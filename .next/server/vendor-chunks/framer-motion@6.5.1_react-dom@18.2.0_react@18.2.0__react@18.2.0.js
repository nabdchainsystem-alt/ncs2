"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/framer-motion@6.5.1_react-dom@18.2.0_react@18.2.0__react@18.2.0";
exports.ids = ["vendor-chunks/framer-motion@6.5.1_react-dom@18.2.0_react@18.2.0__react@18.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/framer-motion@6.5.1_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/cjs/index.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/framer-motion@6.5.1_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/cjs/index.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar tslib = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.1.0_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar heyListen = __webpack_require__(/*! hey-listen */ \"(ssr)/./node_modules/.pnpm/hey-listen@1.0.8/node_modules/hey-listen/dist/hey-listen.es.js\");\nvar styleValueTypes = __webpack_require__(/*! style-value-types */ \"(ssr)/./node_modules/.pnpm/style-value-types@5.0.0/node_modules/style-value-types/dist/valueTypes.cjs.js\");\nvar popmotion = __webpack_require__(/*! popmotion */ \"(ssr)/./node_modules/.pnpm/popmotion@11.0.3/node_modules/popmotion/dist/popmotion.cjs.js\");\nvar sync = __webpack_require__(/*! framesync */ \"(ssr)/./node_modules/.pnpm/framesync@6.0.1/node_modules/framesync/dist/framesync.cjs.js\");\nvar dom = __webpack_require__(/*! @motionone/dom */ \"(ssr)/./node_modules/.pnpm/@motionone+dom@10.12.0/node_modules/@motionone/dom/dist/index.es.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/ _interopNamespace(React);\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\nvar sync__default = /*#__PURE__*/ _interopDefaultLegacy(sync);\n/**\n * Browser-safe usage of process\n */ var defaultEnvironment = \"production\";\nvar env = typeof process === \"undefined\" || process.env === undefined ? defaultEnvironment : \"development\" || 0;\nvar createDefinition = function(propNames) {\n    return {\n        isEnabled: function(props) {\n            return propNames.some(function(name) {\n                return !!props[name];\n            });\n        }\n    };\n};\nvar featureDefinitions = {\n    measureLayout: createDefinition([\n        \"layout\",\n        \"layoutId\",\n        \"drag\"\n    ]),\n    animation: createDefinition([\n        \"animate\",\n        \"exit\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"whileFocus\",\n        \"whileDrag\",\n        \"whileInView\"\n    ]),\n    exit: createDefinition([\n        \"exit\"\n    ]),\n    drag: createDefinition([\n        \"drag\",\n        \"dragControls\"\n    ]),\n    focus: createDefinition([\n        \"whileFocus\"\n    ]),\n    hover: createDefinition([\n        \"whileHover\",\n        \"onHoverStart\",\n        \"onHoverEnd\"\n    ]),\n    tap: createDefinition([\n        \"whileTap\",\n        \"onTap\",\n        \"onTapStart\",\n        \"onTapCancel\"\n    ]),\n    pan: createDefinition([\n        \"onPan\",\n        \"onPanStart\",\n        \"onPanSessionStart\",\n        \"onPanEnd\"\n    ]),\n    inView: createDefinition([\n        \"whileInView\",\n        \"onViewportEnter\",\n        \"onViewportLeave\"\n    ])\n};\nfunction loadFeatures(features) {\n    for(var key in features){\n        if (features[key] === null) continue;\n        if (key === \"projectionNodeConstructor\") {\n            featureDefinitions.projectionNodeConstructor = features[key];\n        } else {\n            featureDefinitions[key].Component = features[key];\n        }\n    }\n}\nvar LazyContext = React.createContext({\n    strict: false\n});\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */ function useFeatures(props, visualElement, preloadedFeatures) {\n    var features = [];\n    var lazyContext = React.useContext(LazyContext);\n    if (!visualElement) return null;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */ if (env !== \"production\" && preloadedFeatures && lazyContext.strict) {\n        heyListen.invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    }\n    for(var i = 0; i < numFeatures; i++){\n        var name_1 = featureNames[i];\n        var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component = _a.Component;\n        /**\n         * It might be possible in the future to use this moment to\n         * dynamically request functionality. In initial tests this\n         * was producing a lot of duplication amongst bundles.\n         */ if (isEnabled(props) && Component) {\n            features.push(React__namespace.createElement(Component, tslib.__assign({\n                key: name_1\n            }, props, {\n                visualElement: visualElement\n            })));\n        }\n    }\n    return features;\n}\n/**\n * @public\n */ var MotionConfigContext = React.createContext({\n    transformPagePoint: function(p) {\n        return p;\n    },\n    isStatic: false,\n    reducedMotion: \"never\"\n});\nvar MotionContext = React.createContext({});\nfunction useVisualElementContext() {\n    return React.useContext(MotionContext).visualElement;\n}\n/**\n * @public\n */ var PresenceContext = React.createContext(null);\nvar isBrowser = typeof document !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n// Does this device prefer reduced motion? Returns `null` server-side.\nvar prefersReducedMotion = {\n    current: null\n};\nvar hasDetected = false;\nfunction initPrefersReducedMotion() {\n    hasDetected = true;\n    if (!isBrowser) return;\n    if (window.matchMedia) {\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n        var setReducedMotionPreferences = function() {\n            return prefersReducedMotion.current = motionMediaQuery_1.matches;\n        };\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    } else {\n        prefersReducedMotion.current = false;\n    }\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */ function useReducedMotion() {\n    /**\n     * Lazy initialisation of prefersReducedMotion\n     */ !hasDetected && initPrefersReducedMotion();\n    var _a = tslib.__read(React.useState(prefersReducedMotion.current), 1), shouldReduceMotion = _a[0];\n    /**\n     * TODO See if people miss automatically updating shouldReduceMotion setting\n     */ return shouldReduceMotion;\n}\nfunction useReducedMotionConfig() {\n    var reducedMotionPreference = useReducedMotion();\n    var reducedMotion = React.useContext(MotionConfigContext).reducedMotion;\n    if (reducedMotion === \"never\") {\n        return false;\n    } else if (reducedMotion === \"always\") {\n        return true;\n    } else {\n        return reducedMotionPreference;\n    }\n}\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n    var lazyContext = React.useContext(LazyContext);\n    var parent = useVisualElementContext();\n    var presenceContext = React.useContext(PresenceContext);\n    var shouldReduceMotion = useReducedMotionConfig();\n    var visualElementRef = React.useRef(undefined);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */ if (!createVisualElement) createVisualElement = lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState: visualState,\n            parent: parent,\n            props: props,\n            presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n            blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,\n            shouldReduceMotion: shouldReduceMotion\n        });\n    }\n    var visualElement = visualElementRef.current;\n    useIsomorphicLayoutEffect(function() {\n        visualElement === null || visualElement === void 0 ? void 0 : visualElement.syncRender();\n    });\n    React.useEffect(function() {\n        var _a;\n        (_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n    });\n    useIsomorphicLayoutEffect(function() {\n        return function() {\n            return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount();\n        };\n    }, []);\n    return visualElement;\n}\nfunction isRefObject(ref) {\n    return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */ function useMotionRef(visualState, visualElement, externalRef) {\n    return React.useCallback(function(instance) {\n        var _a;\n        instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n        if (visualElement) {\n            instance ? visualElement.mount(instance) : visualElement.unmount();\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            } else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */ [\n        visualElement\n    ]);\n}\n/**\n * Decides if the supplied variable is an array of variant labels\n */ function isVariantLabels(v) {\n    return Array.isArray(v);\n}\n/**\n * Decides if the supplied variable is variant label\n */ function isVariantLabel(v) {\n    return typeof v === \"string\" || isVariantLabels(v);\n}\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */ function getCurrent(visualElement) {\n    var current = {};\n    visualElement.forEachValue(function(value, key) {\n        return current[key] = value.get();\n    });\n    return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */ function getVelocity$1(visualElement) {\n    var velocity = {};\n    visualElement.forEachValue(function(value, key) {\n        return velocity[key] = value.getVelocity();\n    });\n    return velocity;\n}\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n    var _a;\n    if (currentValues === void 0) {\n        currentValues = {};\n    }\n    if (currentVelocity === void 0) {\n        currentVelocity = {};\n    }\n    /**\n     * If the variant definition is a function, resolve.\n     */ if (typeof definition === \"function\") {\n        definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */ if (typeof definition === \"string\") {\n        definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */ if (typeof definition === \"function\") {\n        definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n    }\n    return definition;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    var props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));\n}\nfunction checkIfControllingVariants(props) {\n    var _a;\n    return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \"function\" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);\n}\nfunction checkIfVariantNode(props) {\n    return Boolean(checkIfControllingVariants(props) || props.variants);\n}\nfunction getCurrentTreeVariants(props, context) {\n    if (checkIfControllingVariants(props)) {\n        var initial = props.initial, animate = props.animate;\n        return {\n            initial: initial === false || isVariantLabel(initial) ? initial : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\nfunction useCreateMotionContext(props) {\n    var _a = getCurrentTreeVariants(props, React.useContext(MotionContext)), initial = _a.initial, animate = _a.animate;\n    return React.useMemo(function() {\n        return {\n            initial: initial,\n            animate: animate\n        };\n    }, [\n        variantLabelsAsDependency(initial),\n        variantLabelsAsDependency(animate)\n    ]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */ function useConstant(init) {\n    var ref = React.useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n/**\n * This should only ever be modified on the client otherwise it'll\n * persist through server requests. If we need instanced states we\n * could lazy-init via root.\n */ var globalProjectionState = {\n    /**\n     * Global flag as to whether the tree has animated since the last time\n     * we resized the window\n     */ hasAnimatedSinceResize: true,\n    /**\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\n     * update will be given a `data-projection-id` attribute.\n     */ hasEverUpdated: false\n};\nvar id$1 = 1;\nfunction useProjectionId() {\n    return useConstant(function() {\n        if (globalProjectionState.hasEverUpdated) {\n            return id$1++;\n        }\n    });\n}\nvar LayoutGroupContext = React.createContext({});\n/**\n * Internal, exported only for usage in Framer\n */ var SwitchLayoutGroupContext = React.createContext({});\nfunction useProjection(projectionId, _a, visualElement, ProjectionNodeConstructor) {\n    var _b;\n    var layoutId = _a.layoutId, layout = _a.layout, drag = _a.drag, dragConstraints = _a.dragConstraints, layoutScroll = _a.layoutScroll;\n    var initialPromotionConfig = React.useContext(SwitchLayoutGroupContext);\n    if (!ProjectionNodeConstructor || !visualElement || (visualElement === null || visualElement === void 0 ? void 0 : visualElement.projection)) {\n        return;\n    }\n    visualElement.projection = new ProjectionNodeConstructor(projectionId, visualElement.getLatestValues(), (_b = visualElement.parent) === null || _b === void 0 ? void 0 : _b.projection);\n    visualElement.projection.setOptions({\n        layoutId: layoutId,\n        layout: layout,\n        alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n        visualElement: visualElement,\n        scheduleRender: function() {\n            return visualElement.scheduleRender();\n        },\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */ animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig: initialPromotionConfig,\n        layoutScroll: layoutScroll\n    });\n}\nvar VisualElementHandler = /** @class */ function(_super) {\n    tslib.__extends(VisualElementHandler, _super);\n    function VisualElementHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Update visual element props as soon as we know this update is going to be commited.\n     */ VisualElementHandler.prototype.getSnapshotBeforeUpdate = function() {\n        this.updateProps();\n        return null;\n    };\n    VisualElementHandler.prototype.componentDidUpdate = function() {};\n    VisualElementHandler.prototype.updateProps = function() {\n        var _a = this.props, visualElement = _a.visualElement, props = _a.props;\n        if (visualElement) visualElement.setProps(props);\n    };\n    VisualElementHandler.prototype.render = function() {\n        return this.props.children;\n    };\n    return VisualElementHandler;\n}(React__default[\"default\"].Component);\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */ function createMotionComponent(_a) {\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, projectionNodeConstructor = _a.projectionNodeConstructor, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        var layoutId = useLayoutId(props);\n        props = tslib.__assign(tslib.__assign({}, props), {\n            layoutId: layoutId\n        });\n        /**\n         * If we're rendering in a static environment, we only visually update the component\n         * as a result of a React-rerender rather than interactions or animations. This\n         * means we don't need to load additional memory structures like VisualElement,\n         * or any gesture/animation features.\n         */ var config = React.useContext(MotionConfigContext);\n        var features = null;\n        var context = useCreateMotionContext(props);\n        /**\n         * Create a unique projection ID for this component. If a new component is added\n         * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\n         * us to measure it as soon as any layout effect flushes pending layout animations.\n         *\n         * Performance note: It'd be better not to have to search the DOM for these elements.\n         * For newly-entering components it could be enough to only correct treeScale, in which\n         * case we could mount in a scale-correction mode. This wouldn't be enough for\n         * shared element transitions however. Perhaps for those we could revert to a root node\n         * that gets forceRendered and layout animations are triggered on its layout effect.\n         */ var projectionId = config.isStatic ? undefined : useProjectionId();\n        /**\n         *\n         */ var visualState = useVisualState(props, config.isStatic);\n        if (!config.isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */ context.visualElement = useVisualElement(Component, visualState, tslib.__assign(tslib.__assign({}, config), props), createVisualElement);\n            useProjection(projectionId, props, context.visualElement, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             */ features = useFeatures(props, context.visualElement, preloadedFeatures);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */ return React__namespace.createElement(VisualElementHandler, {\n            visualElement: context.visualElement,\n            props: tslib.__assign(tslib.__assign({}, config), props)\n        }, features, React__namespace.createElement(MotionContext.Provider, {\n            value: context\n        }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement)));\n    }\n    return React.forwardRef(MotionComponent);\n}\nfunction useLayoutId(_a) {\n    var _b;\n    var layoutId = _a.layoutId;\n    var layoutGroupId = (_b = React.useContext(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;\n    return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion(Component)\n * ```\n *\n * @public\n */ function createMotionProxy(createConfig) {\n    function custom(Component, customMotionComponentConfig) {\n        if (customMotionComponentConfig === void 0) {\n            customMotionComponentConfig = {};\n        }\n        return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n    }\n    if (typeof Proxy === \"undefined\") {\n        return custom;\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */ var componentCache = new Map();\n    return new Proxy(custom, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */ get: function(_target, key) {\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */ if (!componentCache.has(key)) {\n                componentCache.set(key, custom(key));\n            }\n            return componentCache.get(key);\n        }\n    });\n}\n/**\n * We keep these listed seperately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */ var lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\"\n];\nfunction isSVGComponent(Component) {\n    if (/**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */ typeof Component !== \"string\" || /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */ Component.includes(\"-\")) {\n        return false;\n    } else if (/**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */ lowercaseSVGElements.indexOf(Component) > -1 || /**\n         * If it contains a capital letter, it's an SVG component\n         */ /[A-Z]/.test(Component)) {\n        return true;\n    }\n    return false;\n}\nvar scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    Object.assign(scaleCorrectors, correctors);\n}\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */ var transformAxes = [\n    \"\",\n    \"X\",\n    \"Y\",\n    \"Z\"\n];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */ var order = [\n    \"translate\",\n    \"scale\",\n    \"rotate\",\n    \"skew\"\n];\n/**\n * Generate a list of every possible transform key.\n */ var transformProps = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\"\n];\norder.forEach(function(operationKey) {\n    return transformAxes.forEach(function(axesKey) {\n        return transformProps.push(operationKey + axesKey);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */ function sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */ var transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n    return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */ var transformOriginProps = new Set([\n    \"originX\",\n    \"originY\",\n    \"originZ\"\n]);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\nfunction isForcedMotionValue(key, _a) {\n    var layout = _a.layout, layoutId = _a.layoutId;\n    return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== undefined) && (!!scaleCorrectors[key] || key === \"opacity\");\n}\nvar isMotionValue = function(value) {\n    return Boolean(value !== null && typeof value === \"object\" && value.getVelocity);\n};\nvar translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\"\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */ function buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n    var transform = _a.transform, transformKeys = _a.transformKeys;\n    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;\n    // The transform string we're going to build into.\n    var transformString = \"\";\n    // Transform keys into their default order - this will determine the output order.\n    transformKeys.sort(sortTransformProps);\n    // Track whether the defined transform has a defined z so we don't add a\n    // second to enable hardware acceleration\n    var transformHasZ = false;\n    // Loop over each transform and build them into transformString\n    var numTransformKeys = transformKeys.length;\n    for(var i = 0; i < numTransformKeys; i++){\n        var key = transformKeys[i];\n        transformString += \"\".concat(translateAlias[key] || key, \"(\").concat(transform[key], \") \");\n        if (key === \"z\") transformHasZ = true;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += \"translateZ(0)\";\n    } else {\n        transformString = transformString.trim();\n    }\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    } else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n/**\n * Build a transformOrigin style. Uses the same defaults as the browser for\n * undefined origins.\n */ function buildTransformOrigin(_a) {\n    var _b = _a.originX, originX = _b === void 0 ? \"50%\" : _b, _c = _a.originY, originY = _c === void 0 ? \"50%\" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;\n    return \"\".concat(originX, \" \").concat(originY, \" \").concat(originZ);\n}\n/**\n * Returns true if the provided key is a CSS variable\n */ function isCSSVariable$1(key) {\n    return key.startsWith(\"--\");\n}\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */ var getValueAsType = function(value, type) {\n    return type && typeof value === \"number\" ? type.transform(value) : value;\n};\nvar int = tslib.__assign(tslib.__assign({}, styleValueTypes.number), {\n    transform: Math.round\n});\nvar numberValueTypes = {\n    // Border props\n    borderWidth: styleValueTypes.px,\n    borderTopWidth: styleValueTypes.px,\n    borderRightWidth: styleValueTypes.px,\n    borderBottomWidth: styleValueTypes.px,\n    borderLeftWidth: styleValueTypes.px,\n    borderRadius: styleValueTypes.px,\n    radius: styleValueTypes.px,\n    borderTopLeftRadius: styleValueTypes.px,\n    borderTopRightRadius: styleValueTypes.px,\n    borderBottomRightRadius: styleValueTypes.px,\n    borderBottomLeftRadius: styleValueTypes.px,\n    // Positioning props\n    width: styleValueTypes.px,\n    maxWidth: styleValueTypes.px,\n    height: styleValueTypes.px,\n    maxHeight: styleValueTypes.px,\n    size: styleValueTypes.px,\n    top: styleValueTypes.px,\n    right: styleValueTypes.px,\n    bottom: styleValueTypes.px,\n    left: styleValueTypes.px,\n    // Spacing props\n    padding: styleValueTypes.px,\n    paddingTop: styleValueTypes.px,\n    paddingRight: styleValueTypes.px,\n    paddingBottom: styleValueTypes.px,\n    paddingLeft: styleValueTypes.px,\n    margin: styleValueTypes.px,\n    marginTop: styleValueTypes.px,\n    marginRight: styleValueTypes.px,\n    marginBottom: styleValueTypes.px,\n    marginLeft: styleValueTypes.px,\n    // Transform props\n    rotate: styleValueTypes.degrees,\n    rotateX: styleValueTypes.degrees,\n    rotateY: styleValueTypes.degrees,\n    rotateZ: styleValueTypes.degrees,\n    scale: styleValueTypes.scale,\n    scaleX: styleValueTypes.scale,\n    scaleY: styleValueTypes.scale,\n    scaleZ: styleValueTypes.scale,\n    skew: styleValueTypes.degrees,\n    skewX: styleValueTypes.degrees,\n    skewY: styleValueTypes.degrees,\n    distance: styleValueTypes.px,\n    translateX: styleValueTypes.px,\n    translateY: styleValueTypes.px,\n    translateZ: styleValueTypes.px,\n    x: styleValueTypes.px,\n    y: styleValueTypes.px,\n    z: styleValueTypes.px,\n    perspective: styleValueTypes.px,\n    transformPerspective: styleValueTypes.px,\n    opacity: styleValueTypes.alpha,\n    originX: styleValueTypes.progressPercentage,\n    originY: styleValueTypes.progressPercentage,\n    originZ: styleValueTypes.px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: styleValueTypes.alpha,\n    strokeOpacity: styleValueTypes.alpha,\n    numOctaves: int\n};\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n    var _a;\n    var style = state.style, vars = state.vars, transform = state.transform, transformKeys = state.transformKeys, transformOrigin = state.transformOrigin;\n    // Empty the transformKeys array. As we're throwing out refs to its items\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\n    // with a manual incrementation would be better.\n    transformKeys.length = 0;\n    // Track whether we encounter any transform or transformOrigin values.\n    var hasTransform = false;\n    var hasTransformOrigin = false;\n    // Does the calculated transform essentially equal \"none\"?\n    var transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept seperately for further processing.\n     */ for(var key in latestValues){\n        var value = latestValues[key];\n        /**\n         * If this is a CSS variable we don't do any further processing.\n         */ if (isCSSVariable$1(key)) {\n            vars[key] = value;\n            continue;\n        }\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        var valueType = numberValueTypes[key];\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            // If we already know we have a non-default transform, early return\n            if (!transformIsNone) continue;\n            // Otherwise check to see if this is a default transform\n            if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0)) transformIsNone = false;\n        } else if (isTransformOriginProp(key)) {\n            transformOrigin[key] = valueAsType;\n            // If this is a transform origin, flag and enable further transform-origin processing\n            hasTransformOrigin = true;\n        } else {\n            style[key] = valueAsType;\n        }\n    }\n    if (hasTransform) {\n        style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n    } else if (transformTemplate) {\n        style.transform = transformTemplate({}, \"\");\n    } else if (!latestValues.transform && style.transform) {\n        style.transform = \"none\";\n    }\n    if (hasTransformOrigin) {\n        style.transformOrigin = buildTransformOrigin(transformOrigin);\n    }\n}\nvar createHtmlRenderState = function() {\n    return {\n        style: {},\n        transform: {},\n        transformKeys: [],\n        transformOrigin: {},\n        vars: {}\n    };\n};\nfunction copyRawValuesOnly(target, source, props) {\n    for(var key in source){\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n    var transformTemplate = _a.transformTemplate;\n    return React.useMemo(function() {\n        var state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, {\n            enableHardwareAcceleration: !isStatic\n        }, transformTemplate);\n        var vars = state.vars, style = state.style;\n        return tslib.__assign(tslib.__assign({}, vars), style);\n    }, [\n        visualState\n    ]);\n}\nfunction useStyle(props, visualState, isStatic) {\n    var styleProp = props.style || {};\n    var style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */ copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n    if (props.transformValues) {\n        style = props.transformValues(style);\n    }\n    return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    var htmlProps = {};\n    var style = useStyle(props, visualState, isStatic);\n    if (Boolean(props.drag) && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction = props.drag === true ? \"none\" : \"pan-\".concat(props.drag === \"x\" ? \"y\" : \"x\");\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */ var validMotionProps = new Set([\n    \"initial\",\n    \"animate\",\n    \"exit\",\n    \"style\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"transformValues\",\n    \"custom\",\n    \"inherit\",\n    \"layout\",\n    \"layoutId\",\n    \"layoutDependency\",\n    \"onLayoutAnimationStart\",\n    \"onLayoutAnimationComplete\",\n    \"onLayoutMeasure\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"drag\",\n    \"dragControls\",\n    \"dragListener\",\n    \"dragConstraints\",\n    \"dragDirectionLock\",\n    \"dragSnapToOrigin\",\n    \"_dragX\",\n    \"_dragY\",\n    \"dragElastic\",\n    \"dragMomentum\",\n    \"dragPropagation\",\n    \"dragTransition\",\n    \"whileDrag\",\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanEnd\",\n    \"onPanSessionStart\",\n    \"onTap\",\n    \"onTapStart\",\n    \"onTapCancel\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"whileFocus\",\n    \"whileTap\",\n    \"whileHover\",\n    \"whileInView\",\n    \"onViewportEnter\",\n    \"onViewportLeave\",\n    \"viewport\",\n    \"layoutScroll\"\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */ function isValidMotionProp(key) {\n    return validMotionProps.has(key);\n}\nvar shouldForward = function(key) {\n    return !isValidMotionProp(key);\n};\nfunction loadExternalIsValidProp(isValidProp) {\n    if (!isValidProp) return;\n    // Explicitly filter our events\n    shouldForward = function(key) {\n        return key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n    };\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */ try {\n    /**\n     * We attempt to import this package but require won't be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */ loadExternalIsValidProp((__webpack_require__(/*! @emotion/is-prop-valid */ \"(ssr)/./node_modules/.pnpm/@emotion+is-prop-valid@0.8.8/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\")[\"default\"]));\n} catch (_a) {\n// We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    var filteredProps = {};\n    for(var key in props){\n        if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners\n        props[\"draggable\"] && key.startsWith(\"onDrag\")) {\n            filteredProps[key] = props[key];\n        }\n    }\n    return filteredProps;\n}\nfunction calcOrigin$1(origin, offset, size) {\n    return typeof origin === \"string\" ? origin : styleValueTypes.px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */ function calcSVGTransformOrigin(dimensions, originX, originY) {\n    var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n    var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n    return \"\".concat(pxOriginX, \" \").concat(pxOriginY);\n}\nvar dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */ function buildSVGPath(attrs, length, spacing, offset, useDashCase) {\n    if (spacing === void 0) {\n        spacing = 1;\n    }\n    if (offset === void 0) {\n        offset = 0;\n    }\n    if (useDashCase === void 0) {\n        useDashCase = true;\n    }\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    var keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = styleValueTypes.px.transform(-offset);\n    // Build the dash array\n    var pathLength = styleValueTypes.px.transform(length);\n    var pathSpacing = styleValueTypes.px.transform(spacing);\n    attrs[keys.array] = \"\".concat(pathLength, \" \").concat(pathSpacing);\n}\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */ function buildSVGAttrs(state, _a, options, transformTemplate) {\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, // This is object creation, which we try to avoid per-frame.\n    latest = tslib.__rest(_a, [\n        \"attrX\",\n        \"attrY\",\n        \"originX\",\n        \"originY\",\n        \"pathLength\",\n        \"pathSpacing\",\n        \"pathOffset\"\n    ]);\n    buildHTMLStyles(state, latest, options, transformTemplate);\n    state.attrs = state.style;\n    state.style = {};\n    var attrs = state.attrs, style = state.style, dimensions = state.dimensions;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */ if (attrs.transform) {\n        if (dimensions) style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Treat x/y not as shortcuts but as actual attributes\n    if (attrX !== undefined) attrs.x = attrX;\n    if (attrY !== undefined) attrs.y = attrY;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\nvar createSvgRenderState = function() {\n    return tslib.__assign(tslib.__assign({}, createHtmlRenderState()), {\n        attrs: {}\n    });\n};\nfunction useSVGProps(props, visualState) {\n    var visualProps = React.useMemo(function() {\n        var state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, {\n            enableHardwareAcceleration: false\n        }, props.transformTemplate);\n        return tslib.__assign(tslib.__assign({}, state.attrs), {\n            style: tslib.__assign({}, state.style)\n        });\n    }, [\n        visualState\n    ]);\n    if (props.style) {\n        var rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = tslib.__assign(tslib.__assign({}, rawStyles), visualProps.style);\n    }\n    return visualProps;\n}\nfunction createUseRender(forwardMotionProps) {\n    if (forwardMotionProps === void 0) {\n        forwardMotionProps = false;\n    }\n    var useRender = function(Component, props, projectionId, ref, _a, isStatic) {\n        var latestValues = _a.latestValues;\n        var useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;\n        var visualProps = useVisualProps(props, latestValues, isStatic);\n        var filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n        var elementProps = tslib.__assign(tslib.__assign(tslib.__assign({}, filteredProps), visualProps), {\n            ref: ref\n        });\n        if (projectionId) {\n            elementProps[\"data-projection-id\"] = projectionId;\n        }\n        return React.createElement(Component, elementProps);\n    };\n    return useRender;\n}\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */ var camelToDash = function(str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\nfunction renderHTML(element, _a, styleProp, projection) {\n    var style = _a.style, vars = _a.vars;\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for(var key in vars){\n        element.style.setProperty(key, vars[key]);\n    }\n}\n/**\n * A set of attribute names that are always read/written as camel case.\n */ var camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\"\n]);\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for(var key in renderState.attrs){\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\nfunction scrapeMotionValuesFromProps$1(props) {\n    var style = props.style;\n    var newValues = {};\n    for(var key in style){\n        if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\nfunction scrapeMotionValuesFromProps(props) {\n    var newValues = scrapeMotionValuesFromProps$1(props);\n    for(var key in props){\n        if (isMotionValue(props[key])) {\n            var targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\nfunction isAnimationControls(v) {\n    return typeof v === \"object\" && typeof v.start === \"function\";\n}\nvar isKeyframesTarget = function(v) {\n    return Array.isArray(v);\n};\nvar isCustomValue = function(v) {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function(v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */ function resolveMotionValue(value) {\n    var unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\nfunction makeState(_a, props, context, presenceContext) {\n    var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;\n    var state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState()\n    };\n    if (onMount) {\n        state.mount = function(instance) {\n            return onMount(props, instance, state);\n        };\n    }\n    return state;\n}\nvar makeUseVisualState = function(config) {\n    return function(props, isStatic) {\n        var context = React.useContext(MotionContext);\n        var presenceContext = React.useContext(PresenceContext);\n        return isStatic ? makeState(config, props, context, presenceContext) : useConstant(function() {\n            return makeState(config, props, context, presenceContext);\n        });\n    };\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    var values = {};\n    var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n    var motionValues = scrapeMotionValues(props);\n    for(var key in motionValues){\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    var initial = props.initial, animate = props.animate;\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {\n        initial !== null && initial !== void 0 ? initial : initial = context.initial;\n        animate !== null && animate !== void 0 ? animate : animate = context.animate;\n    }\n    var initialAnimationIsBlocked = blockInitialAnimation || initial === false;\n    var variantToSet = initialAnimationIsBlocked ? animate : initial;\n    if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n        var list = Array.isArray(variantToSet) ? variantToSet : [\n            variantToSet\n        ];\n        list.forEach(function(definition) {\n            var resolved = resolveVariantFromProps(props, definition);\n            if (!resolved) return;\n            var transitionEnd = resolved.transitionEnd;\n            resolved.transition;\n            var target = tslib.__rest(resolved, [\n                \"transitionEnd\",\n                \"transition\"\n            ]);\n            for(var key in target){\n                var valueTarget = target[key];\n                if (Array.isArray(valueTarget)) {\n                    /**\n                     * Take final keyframe if the initial animation is blocked because\n                     * we want to initialise at the end of that blocked animation.\n                     */ var index = initialAnimationIsBlocked ? valueTarget.length - 1 : 0;\n                    valueTarget = valueTarget[index];\n                }\n                if (valueTarget !== null) {\n                    values[key] = valueTarget;\n                }\n            }\n            for(var key in transitionEnd)values[key] = transitionEnd[key];\n        });\n    }\n    return values;\n}\nvar svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onMount: function(props, instance, _a) {\n            var renderState = _a.renderState, latestValues = _a.latestValues;\n            try {\n                renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n            } catch (e) {\n                // Most likely trying to measure an unrendered element under Firefox\n                renderState.dimensions = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0\n                };\n            }\n            buildSVGAttrs(renderState, latestValues, {\n                enableHardwareAcceleration: false\n            }, props.transformTemplate);\n            renderSVG(instance, renderState);\n        }\n    })\n};\nvar htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n        createRenderState: createHtmlRenderState\n    })\n};\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement, projectionNodeConstructor) {\n    var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;\n    var baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;\n    return tslib.__assign(tslib.__assign({}, baseConfig), {\n        preloadedFeatures: preloadedFeatures,\n        useRender: createUseRender(forwardMotionProps),\n        createVisualElement: createVisualElement,\n        projectionNodeConstructor: projectionNodeConstructor,\n        Component: Component\n    });\n}\nexports.AnimationType = void 0;\n(function(AnimationType) {\n    AnimationType[\"Animate\"] = \"animate\";\n    AnimationType[\"Hover\"] = \"whileHover\";\n    AnimationType[\"Tap\"] = \"whileTap\";\n    AnimationType[\"Drag\"] = \"whileDrag\";\n    AnimationType[\"Focus\"] = \"whileFocus\";\n    AnimationType[\"InView\"] = \"whileInView\";\n    AnimationType[\"Exit\"] = \"exit\";\n})(exports.AnimationType || (exports.AnimationType = {}));\nfunction addDomEvent(target, eventName, handler, options) {\n    if (options === void 0) {\n        options = {\n            passive: true\n        };\n    }\n    target.addEventListener(eventName, handler, options);\n    return function() {\n        return target.removeEventListener(eventName, handler);\n    };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */ function useDomEvent(ref, eventName, handler, options) {\n    React.useEffect(function() {\n        var element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [\n        ref,\n        eventName,\n        handler,\n        options\n    ]);\n}\n/**\n *\n * @param props\n * @param ref\n * @internal\n */ function useFocusGesture(_a) {\n    var whileFocus = _a.whileFocus, visualElement = _a.visualElement;\n    var onFocus = function() {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Focus, true);\n    };\n    var onBlur = function() {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Focus, false);\n    };\n    useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : undefined);\n    useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : undefined);\n}\nfunction isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n        return !!(event.pointerType === \"mouse\");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */ function filterPrimaryPointer(eventHandler) {\n    return function(event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = {\n    pageX: 0,\n    pageY: 0\n};\nfunction pointFromTouch(e, pointType) {\n    if (pointType === void 0) {\n        pointType = \"page\";\n    }\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var point = primaryTouch || defaultPagePoint;\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"]\n    };\n}\nfunction pointFromMouse(point, pointType) {\n    if (pointType === void 0) {\n        pointType = \"page\";\n    }\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"]\n    };\n}\nfunction extractEventInfo(event, pointType) {\n    if (pointType === void 0) {\n        pointType = \"page\";\n    }\n    return {\n        point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n    };\n}\nvar wrapHandler = function(handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) {\n        shouldFilterPrimaryPointer = false;\n    }\n    var listener = function(event) {\n        return handler(event, extractEventInfo(event));\n    };\n    return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function() {\n    return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function() {\n    return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function() {\n    return isBrowser && window.onmousedown === null;\n};\nvar mouseEventNames = {\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointercancel: \"mousecancel\",\n    pointerover: \"mouseover\",\n    pointerout: \"mouseout\",\n    pointerenter: \"mouseenter\",\n    pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n    pointerdown: \"touchstart\",\n    pointermove: \"touchmove\",\n    pointerup: \"touchend\",\n    pointercancel: \"touchcancel\"\n};\nfunction getPointerEventName(name) {\n    if (supportsPointerEvents()) {\n        return name;\n    } else if (supportsTouchEvents()) {\n        return touchEventNames[name];\n    } else if (supportsMouseEvents()) {\n        return mouseEventNames[name];\n    }\n    return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n    return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction createLock(name) {\n    var lock = null;\n    return function() {\n        var openLock = function() {\n            lock = null;\n        };\n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === \"y\") {\n        lock = globalVerticalLock();\n    } else if (drag === \"x\") {\n        lock = globalHorizontalLock();\n    } else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function() {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        } else {\n            // Release the locks because we don't use them\n            if (openHorizontal_1) openHorizontal_1();\n            if (openVertical_1) openVertical_1();\n        }\n    }\n    return lock;\n}\nfunction isDragActive() {\n    // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock) return true;\n    openGestureLock();\n    return false;\n}\nfunction createHoverEvent(visualElement, isActive, callback) {\n    return function(event, info) {\n        var _a;\n        if (!isMouseEvent(event) || isDragActive()) return;\n        /**\n         * Ensure we trigger animations before firing event callback\n         */ (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Hover, isActive);\n        callback === null || callback === void 0 ? void 0 : callback(event, info);\n    };\n}\nfunction useHoverGesture(_a) {\n    var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement = _a.visualElement;\n    usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover ? createHoverEvent(visualElement, true, onHoverStart) : undefined, {\n        passive: !onHoverStart\n    });\n    usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover ? createHoverEvent(visualElement, false, onHoverEnd) : undefined, {\n        passive: !onHoverEnd\n    });\n}\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */ var isNodeOrChild = function(parent, child) {\n    if (!child) {\n        return false;\n    } else if (parent === child) {\n        return true;\n    } else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\nfunction useUnmountEffect(callback) {\n    return React.useEffect(function() {\n        return function() {\n            return callback();\n        };\n    }, []);\n}\n/**\n * @param handlers -\n * @internal\n */ function useTapGesture(_a) {\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement = _a.visualElement;\n    var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    var isPressing = React.useRef(false);\n    var cancelPointerEndListeners = React.useRef(null);\n    /**\n     * Only set listener to passive if there are no external listeners.\n     */ var eventOptions = {\n        passive: !(onTapStart || onTap || onTapCancel || onPointerDown)\n    };\n    function removePointerEndListener() {\n        var _a;\n        (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        var _a;\n        removePointerEndListener();\n        isPressing.current = false;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Tap, false);\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        if (!checkPointerEnd()) return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */ !isNodeOrChild(visualElement.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n    }\n    function onPointerCancel(event, info) {\n        if (!checkPointerEnd()) return;\n        onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n    }\n    function onPointerDown(event, info) {\n        var _a;\n        removePointerEndListener();\n        if (isPressing.current) return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = popmotion.pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n        /**\n         * Ensure we trigger animations before firing event callback\n         */ (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Tap, true);\n        onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined, eventOptions);\n    useUnmountEffect(removePointerEndListener);\n}\nvar warned = new Set();\nfunction warnOnce(condition, message, element) {\n    if (condition || warned.has(message)) return;\n    console.warn(message);\n    if (element) console.warn(element);\n    warned.add(message);\n}\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */ var observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */ var observers = new WeakMap();\nvar fireObserverCallback = function(entry) {\n    var _a;\n    (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n};\nvar fireAllObserverCallbacks = function(entries) {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n    var root = _a.root, options = tslib.__rest(_a, [\n        \"root\"\n    ]);\n    var lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */ if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    var rootObservers = observers.get(lookupRoot);\n    var key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */ if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, tslib.__assign({\n            root: root\n        }, options));\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    var rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return function() {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\nfunction useViewport(_a) {\n    var visualElement = _a.visualElement, whileInView = _a.whileInView, onViewportEnter = _a.onViewportEnter, onViewportLeave = _a.onViewportLeave, _b = _a.viewport, viewport = _b === void 0 ? {} : _b;\n    var state = React.useRef({\n        hasEnteredView: false,\n        isInView: false\n    });\n    var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n    if (viewport.once && state.current.hasEnteredView) shouldObserve = false;\n    var useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n    useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nvar thresholdNames = {\n    some: 0,\n    all: 1\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _a) {\n    var root = _a.root, rootMargin = _a.margin, _b = _a.amount, amount = _b === void 0 ? \"some\" : _b, once = _a.once;\n    React.useEffect(function() {\n        if (!shouldObserve) return;\n        var options = {\n            root: root === null || root === void 0 ? void 0 : root.current,\n            rootMargin: rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n        };\n        var intersectionCallback = function(entry) {\n            var _a;\n            var isIntersecting = entry.isIntersecting;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */ if (state.isInView === isIntersecting) return;\n            state.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */ if (once && !isIntersecting && state.hasEnteredView) {\n                return;\n            } else if (isIntersecting) {\n                state.hasEnteredView = true;\n            }\n            (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.InView, isIntersecting);\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */ var props = visualElement.getProps();\n            var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n            callback === null || callback === void 0 ? void 0 : callback(entry);\n        };\n        return observeIntersection(visualElement.getInstance(), options, intersectionCallback);\n    }, [\n        shouldObserve,\n        root,\n        rootMargin,\n        amount\n    ]);\n}\n/**\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\n * on mount. This way, the page will be in the state the author expects users\n * to see it in for everyone.\n */ function useMissingIntersectionObserver(shouldObserve, state, visualElement, _a) {\n    var _b = _a.fallback, fallback = _b === void 0 ? true : _b;\n    React.useEffect(function() {\n        if (!shouldObserve || !fallback) return;\n        if (env !== \"production\") {\n            warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n        }\n        /**\n         * Fire this in an rAF because, at this point, the animation state\n         * won't have flushed for the first time and there's certain logic in\n         * there that behaves differently on the initial animation.\n         *\n         * This hook should be quite rarely called so setting this in an rAF\n         * is preferred to changing the behaviour of the animation state.\n         */ requestAnimationFrame(function() {\n            var _a;\n            state.hasEnteredView = true;\n            var onViewportEnter = visualElement.getProps().onViewportEnter;\n            onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);\n            (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.InView, true);\n        });\n    }, [\n        shouldObserve\n    ]);\n}\nvar makeRenderlessComponent = function(hook) {\n    return function(props) {\n        hook(props);\n        return null;\n    };\n};\nvar gestureAnimations = {\n    inView: makeRenderlessComponent(useViewport),\n    tap: makeRenderlessComponent(useTapGesture),\n    focus: makeRenderlessComponent(useFocusGesture),\n    hover: makeRenderlessComponent(useHoverGesture)\n};\nvar counter = 0;\nvar incrementId = function() {\n    return counter++;\n};\nvar useId = function() {\n    return useConstant(incrementId);\n};\n/**\n * Ideally we'd use the following code to support React 18 optionally.\n * But this fairly fails in Webpack (otherwise treeshaking wouldn't work at all).\n * Need to come up with a different way of figuring this out.\n */ // export const useId = (React as any).useId\n//     ? (React as any).useId\n//     : () => useConstant(incrementId)\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */ function usePresence() {\n    var context = React.useContext(PresenceContext);\n    if (context === null) return [\n        true,\n        null\n    ];\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    // Replace with useId when released in React\n    var id = useId();\n    React.useEffect(function() {\n        return register(id);\n    }, []);\n    var safeToRemove = function() {\n        return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);\n    };\n    return !isPresent && onExitComplete ? [\n        false,\n        safeToRemove\n    ] : [\n        true\n    ];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */ function useIsPresent() {\n    return isPresent(React.useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev)) return false;\n    var prevLength = prev.length;\n    if (prevLength !== next.length) return false;\n    for(var i = 0; i < prevLength; i++){\n        if (prev[i] !== next[i]) return false;\n    }\n    return true;\n}\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */ var secondsToMilliseconds = function(seconds) {\n    return seconds * 1000;\n};\nvar easingLookup = {\n    linear: popmotion.linear,\n    easeIn: popmotion.easeIn,\n    easeInOut: popmotion.easeInOut,\n    easeOut: popmotion.easeOut,\n    circIn: popmotion.circIn,\n    circInOut: popmotion.circInOut,\n    circOut: popmotion.circOut,\n    backIn: popmotion.backIn,\n    backInOut: popmotion.backInOut,\n    backOut: popmotion.backOut,\n    anticipate: popmotion.anticipate,\n    bounceIn: popmotion.bounceIn,\n    bounceInOut: popmotion.bounceInOut,\n    bounceOut: popmotion.bounceOut\n};\nvar easingDefinitionToFunction = function(definition) {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        heyListen.invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n        var _a = tslib.__read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\n        return popmotion.cubicBezier(x1, y1, x2, y2);\n    } else if (typeof definition === \"string\") {\n        // Else lookup from table\n        heyListen.invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\".concat(definition, \"'\"));\n        return easingLookup[definition];\n    }\n    return definition;\n};\nvar isEasingArray = function(ease) {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */ var isAnimatable = function(key, value) {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\") return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value)) return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n    styleValueTypes.complex.test(value) && // And it contains numbers and/or colors\n    !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\nvar underDampedSpring = function() {\n    return {\n        type: \"spring\",\n        stiffness: 500,\n        damping: 25,\n        restSpeed: 10\n    };\n};\nvar criticallyDampedSpring = function(to) {\n    return {\n        type: \"spring\",\n        stiffness: 550,\n        damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n        restSpeed: 10\n    };\n};\nvar linearTween = function() {\n    return {\n        type: \"keyframes\",\n        ease: \"linear\",\n        duration: 0.3\n    };\n};\nvar keyframes = function(values) {\n    return {\n        type: \"keyframes\",\n        duration: 0.8,\n        values: values\n    };\n};\nvar defaultTransitions = {\n    x: underDampedSpring,\n    y: underDampedSpring,\n    z: underDampedSpring,\n    rotate: underDampedSpring,\n    rotateX: underDampedSpring,\n    rotateY: underDampedSpring,\n    rotateZ: underDampedSpring,\n    scaleX: criticallyDampedSpring,\n    scaleY: criticallyDampedSpring,\n    scale: criticallyDampedSpring,\n    opacity: linearTween,\n    backgroundColor: linearTween,\n    color: linearTween,\n    default: criticallyDampedSpring\n};\nvar getDefaultTransition = function(valueKey, to) {\n    var transitionFactory;\n    if (isKeyframesTarget(to)) {\n        transitionFactory = keyframes;\n    } else {\n        transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n    }\n    return tslib.__assign({\n        to: to\n    }, transitionFactory(to));\n};\n/**\n * A map of default value types for common values\n */ var defaultValueTypes = tslib.__assign(tslib.__assign({}, numberValueTypes), {\n    // Color props\n    color: styleValueTypes.color,\n    backgroundColor: styleValueTypes.color,\n    outlineColor: styleValueTypes.color,\n    fill: styleValueTypes.color,\n    stroke: styleValueTypes.color,\n    // Border props\n    borderColor: styleValueTypes.color,\n    borderTopColor: styleValueTypes.color,\n    borderRightColor: styleValueTypes.color,\n    borderBottomColor: styleValueTypes.color,\n    borderLeftColor: styleValueTypes.color,\n    filter: styleValueTypes.filter,\n    WebkitFilter: styleValueTypes.filter\n});\n/**\n * Gets the default ValueType for the provided value key\n */ var getDefaultValueType = function(key) {\n    return defaultValueTypes[key];\n};\nfunction getAnimatableNone(key, value) {\n    var _a;\n    var defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== styleValueTypes.filter) defaultValueType = styleValueTypes.complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\nvar instantAnimationState = {\n    current: false\n};\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */ function isTransitionDefined(_a) {\n    _a.when;\n    _a.delay;\n    _a.delayChildren;\n    _a.staggerChildren;\n    _a.staggerDirection;\n    _a.repeat;\n    _a.repeatType;\n    _a.repeatDelay;\n    _a.from;\n    var transition = tslib.__rest(_a, [\n        \"when\",\n        \"delay\",\n        \"delayChildren\",\n        \"staggerChildren\",\n        \"staggerDirection\",\n        \"repeat\",\n        \"repeatType\",\n        \"repeatDelay\",\n        \"from\"\n    ]);\n    return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */ function convertTransitionToAnimationOptions(_a) {\n    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = tslib.__rest(_a, [\n        \"ease\",\n        \"times\",\n        \"yoyo\",\n        \"flip\",\n        \"loop\"\n    ]);\n    var options = tslib.__assign({}, transition);\n    if (times) options[\"offset\"] = times;\n    /**\n     * Convert any existing durations from seconds to milliseconds\n     */ if (transition.duration) options[\"duration\"] = secondsToMilliseconds(transition.duration);\n    if (transition.repeatDelay) options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n    /**\n     * Map easing names to Popmotion's easing functions\n     */ if (ease) {\n        options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n    }\n    /**\n     * Support legacy transition API\n     */ if (transition.type === \"tween\") options.type = \"keyframes\";\n    /**\n     * TODO: These options are officially removed from the API.\n     */ if (yoyo || loop || flip) {\n        heyListen.warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n        legacyRepeatWarning = true;\n        if (yoyo) {\n            options.repeatType = \"reverse\";\n        } else if (loop) {\n            options.repeatType = \"loop\";\n        } else if (flip) {\n            options.repeatType = \"mirror\";\n        }\n        options.repeat = loop || yoyo || flip || transition.repeat;\n    }\n    /**\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n     * It'd be good to introduce a similar thing here.\n     */ if (transition.type !== \"spring\") options.type = \"keyframes\";\n    return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */ function getDelayFromTransition(transition, key) {\n    var _a, _b;\n    var valueTransition = getValueTransition(transition, key) || {};\n    return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n    if (Array.isArray(options.to) && options.to[0] === null) {\n        options.to = tslib.__spreadArray([], tslib.__read(options.to), false);\n        options.to[0] = options.from;\n    }\n    return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n    var _a;\n    if (Array.isArray(options.to)) {\n        (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;\n    }\n    hydrateKeyframes(options);\n    /**\n     * Get a default transition if none is determined to be defined.\n     */ if (!isTransitionDefined(transition)) {\n        transition = tslib.__assign(tslib.__assign({}, transition), getDefaultTransition(key, options.to));\n    }\n    return tslib.__assign(tslib.__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */ function getAnimation(key, value, target, transition, onComplete) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key);\n    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n    var isTargetAnimatable = isAnimatable(key, target);\n    if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n        /**\n         * If we're trying to animate from \"none\", try and get an animatable version\n         * of the target. This could be improved to work both ways.\n         */ origin = getAnimatableNone(key, target);\n    } else if (isZero(origin) && typeof target === \"string\") {\n        origin = getZeroUnit(target);\n    } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n        target = getZeroUnit(origin);\n    }\n    var isOriginAnimatable = isAnimatable(key, origin);\n    heyListen.warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \".concat(key, ' from \"').concat(origin, '\" to \"').concat(target, '\". ').concat(origin, \" is not an animatable value - to enable this animation set \").concat(origin, \" to a value animatable to \").concat(target, \" via the `style` property.\"));\n    function start() {\n        var options = {\n            from: origin,\n            to: target,\n            velocity: value.getVelocity(),\n            onComplete: onComplete,\n            onUpdate: function(v) {\n                return value.set(v);\n            }\n        };\n        return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? popmotion.inertia(tslib.__assign(tslib.__assign({}, options), valueTransition)) : popmotion.animate(tslib.__assign(tslib.__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), {\n            onUpdate: function(v) {\n                var _a;\n                options.onUpdate(v);\n                (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n            },\n            onComplete: function() {\n                var _a;\n                options.onComplete();\n                (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n            }\n        }));\n    }\n    function set() {\n        var _a, _b;\n        var finalTarget = resolveFinalValueInKeyframes(target);\n        value.set(finalTarget);\n        onComplete();\n        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, finalTarget);\n        (_b = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b === void 0 ? void 0 : _b.call(valueTransition);\n        return {\n            stop: function() {}\n        };\n    }\n    return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\nfunction isZero(value) {\n    return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\nfunction getZeroUnit(potentialUnitType) {\n    return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n */ function startAnimation(key, value, target, transition) {\n    if (transition === void 0) {\n        transition = {};\n    }\n    if (instantAnimationState.current) {\n        transition = {\n            type: false\n        };\n    }\n    return value.start(function(onComplete) {\n        var delayTimer;\n        var controls;\n        var animation = getAnimation(key, value, target, transition, onComplete);\n        var delay = getDelayFromTransition(transition, key);\n        var start = function() {\n            return controls = animation();\n        };\n        if (delay) {\n            delayTimer = window.setTimeout(start, secondsToMilliseconds(delay));\n        } else {\n            start();\n        }\n        return function() {\n            clearTimeout(delayTimer);\n            controls === null || controls === void 0 ? void 0 : controls.stop();\n        };\n    });\n}\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */ var isNumericalString = function(v) {\n    return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */ var isZeroValueString = function(v) {\n    return /^0[^.\\s]+$/.test(v);\n};\nfunction addUniqueItem(arr, item) {\n    arr.indexOf(item) === -1 && arr.push(item);\n}\nfunction removeItem(arr, item) {\n    var index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem(_a, fromIndex, toIndex) {\n    var _b = tslib.__read(_a), arr = _b.slice(0);\n    var startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        var endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        var _c = tslib.__read(arr.splice(fromIndex, 1), 1), item = _c[0];\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\nvar SubscriptionManager = /** @class */ function() {\n    function SubscriptionManager() {\n        this.subscriptions = [];\n    }\n    SubscriptionManager.prototype.add = function(handler) {\n        var _this = this;\n        addUniqueItem(this.subscriptions, handler);\n        return function() {\n            return removeItem(_this.subscriptions, handler);\n        };\n    };\n    SubscriptionManager.prototype.notify = function(a, b, c) {\n        var numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions) return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */ this.subscriptions[0](a, b, c);\n        } else {\n            for(var i = 0; i < numSubscriptions; i++){\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */ var handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    };\n    SubscriptionManager.prototype.getSize = function() {\n        return this.subscriptions.length;\n    };\n    SubscriptionManager.prototype.clear = function() {\n        this.subscriptions.length = 0;\n    };\n    return SubscriptionManager;\n}();\nvar isFloat = function(value) {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */ var MotionValue = /** @class */ function() {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */ function MotionValue(init) {\n        var _this = this;\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */ this.version = \"6.5.1\";\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */ this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */ this.lastUpdated = 0;\n        /**\n         * Functions to notify when the `MotionValue` updates.\n         *\n         * @internal\n         */ this.updateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the velocity updates.\n         *\n         * @internal\n         */ this.velocityUpdateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n         *\n         * @internal\n         */ this.renderSubscribers = new SubscriptionManager();\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */ this.canTrackVelocity = false;\n        this.updateAndNotify = function(v, render) {\n            if (render === void 0) {\n                render = true;\n            }\n            _this.prev = _this.current;\n            _this.current = v;\n            // Update timestamp\n            var _a = sync.getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\n            if (_this.lastUpdated !== timestamp) {\n                _this.timeDelta = delta;\n                _this.lastUpdated = timestamp;\n                sync__default[\"default\"].postRender(_this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (_this.prev !== _this.current) {\n                _this.updateSubscribers.notify(_this.current);\n            }\n            // Update velocity subscribers\n            if (_this.velocityUpdateSubscribers.getSize()) {\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n            // Update render subscribers\n            if (render) {\n                _this.renderSubscribers.notify(_this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */ this.scheduleVelocityCheck = function() {\n            return sync__default[\"default\"].postRender(_this.velocityCheck);\n        };\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */ this.velocityCheck = function(_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @privateRemarks\n     *\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n     *\n     * ```jsx\n     * useOnChange(x, () => {})\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @public\n     */ MotionValue.prototype.onChange = function(subscription) {\n        return this.updateSubscribers.add(subscription);\n    };\n    MotionValue.prototype.clearListeners = function() {\n        this.updateSubscribers.clear();\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` requests a render.\n     *\n     * @param subscriber - A function that's provided the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @internal\n     */ MotionValue.prototype.onRenderRequest = function(subscription) {\n        // Render immediately\n        subscription(this.get());\n        return this.renderSubscribers.add(subscription);\n    };\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */ MotionValue.prototype.attach = function(passiveEffect) {\n        this.passiveEffect = passiveEffect;\n    };\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */ MotionValue.prototype.set = function(v, render) {\n        if (render === void 0) {\n            render = true;\n        }\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        } else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    };\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */ MotionValue.prototype.get = function() {\n        return this.current;\n    };\n    /**\n     * @public\n     */ MotionValue.prototype.getPrevious = function() {\n        return this.prev;\n    };\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */ MotionValue.prototype.getVelocity = function() {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity ? popmotion.velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n    };\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */ MotionValue.prototype.start = function(animation) {\n        var _this = this;\n        this.stop();\n        return new Promise(function(resolve) {\n            _this.hasAnimated = true;\n            _this.stopAnimation = animation(resolve);\n        }).then(function() {\n            return _this.clearAnimation();\n        });\n    };\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */ MotionValue.prototype.stop = function() {\n        if (this.stopAnimation) this.stopAnimation();\n        this.clearAnimation();\n    };\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */ MotionValue.prototype.isAnimating = function() {\n        return !!this.stopAnimation;\n    };\n    MotionValue.prototype.clearAnimation = function() {\n        this.stopAnimation = null;\n    };\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */ MotionValue.prototype.destroy = function() {\n        this.updateSubscribers.clear();\n        this.renderSubscribers.clear();\n        this.stop();\n    };\n    return MotionValue;\n}();\nfunction motionValue(init) {\n    return new MotionValue(init);\n}\n/**\n * Tests a provided value against a ValueType\n */ var testValueType = function(v) {\n    return function(type) {\n        return type.test(v);\n    };\n};\n/**\n * ValueType for \"auto\"\n */ var auto = {\n    test: function(v) {\n        return v === \"auto\";\n    },\n    parse: function(v) {\n        return v;\n    }\n};\n/**\n * A list of value types commonly used for dimensions\n */ var dimensionValueTypes = [\n    styleValueTypes.number,\n    styleValueTypes.px,\n    styleValueTypes.percent,\n    styleValueTypes.degrees,\n    styleValueTypes.vw,\n    styleValueTypes.vh,\n    auto\n];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */ var findDimensionValueType = function(v) {\n    return dimensionValueTypes.find(testValueType(v));\n};\n/**\n * A list of all ValueTypes\n */ var valueTypes = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(dimensionValueTypes), false), [\n    styleValueTypes.color,\n    styleValueTypes.complex\n], false);\n/**\n * Tests a value against the list of ValueTypes\n */ var findValueType = function(v) {\n    return valueTypes.find(testValueType(v));\n};\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */ function setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    } else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n    var _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;\n    _a.transition;\n    var target = tslib.__rest(_a, [\n        \"transitionEnd\",\n        \"transition\"\n    ]);\n    target = tslib.__assign(tslib.__assign({}, target), transitionEnd);\n    for(var key in target){\n        var value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    var reversedLabels = tslib.__spreadArray([], tslib.__read(variantLabels), false).reverse();\n    reversedLabels.forEach(function(key) {\n        var _a;\n        var variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {\n            setVariants(child, variantLabels);\n        });\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    } else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [\n            definition\n        ]);\n    } else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b, _c;\n    var _d;\n    var newValueKeys = Object.keys(target).filter(function(key) {\n        return !visualElement.hasValue(key);\n    });\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues) return;\n    for(var i = 0; i < numNewValues; i++){\n        var key = newValueKeys[i];\n        var targetValue = target[key];\n        var value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */ if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */ if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */ if (value === undefined || value === null) continue;\n        if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        } else if (!findValueType(value) && styleValueTypes.complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value));\n        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;\n        visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition) return;\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    var _a, _b;\n    var origin = {};\n    for(var key in target){\n        origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n    }\n    return origin;\n}\nfunction animateVisualElement(visualElement, definition, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    visualElement.notifyAnimationStart(definition);\n    var animation;\n    if (Array.isArray(definition)) {\n        var animations = definition.map(function(variant) {\n            return animateVariant(visualElement, variant, options);\n        });\n        animation = Promise.all(animations);\n    } else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    } else {\n        var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(function() {\n        return visualElement.notifyAnimationComplete(definition);\n    });\n}\nfunction animateVariant(visualElement, variant, options) {\n    var _a;\n    if (options === void 0) {\n        options = {};\n    }\n    var resolved = resolveVariant(visualElement, variant, options.custom);\n    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */ var getAnimation = resolved ? function() {\n        return animateTarget(visualElement, resolved, options);\n    } : function() {\n        return Promise.resolve();\n    };\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */ var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function(forwardDelay) {\n        if (forwardDelay === void 0) {\n            forwardDelay = 0;\n        }\n        var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\n        return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n    } : function() {\n        return Promise.resolve();\n    };\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */ var when = transition.when;\n    if (when) {\n        var _c = tslib.__read(when === \"beforeChildren\" ? [\n            getAnimation,\n            getChildAnimations\n        ] : [\n            getChildAnimations,\n            getAnimation\n        ], 2), first = _c[0], last = _c[1];\n        return first().then(last);\n    } else {\n        return Promise.all([\n            getAnimation(),\n            getChildAnimations(options.delay)\n        ]);\n    }\n}\n/**\n * @internal\n */ function animateTarget(visualElement, definition, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\n    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = tslib.__rest(_e, [\n        \"transition\",\n        \"transitionEnd\"\n    ]);\n    if (transitionOverride) transition = transitionOverride;\n    var animations = [];\n    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n    for(var key in target){\n        var value = visualElement.getValue(key);\n        var valueTarget = target[key];\n        if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n            continue;\n        }\n        var valueTransition = tslib.__assign({\n            delay: delay\n        }, transition);\n        /**\n         * Make animation instant if this is a transform prop and we should reduce motion.\n         */ if (visualElement.shouldReduceMotion && isTransformProp(key)) {\n            valueTransition = tslib.__assign(tslib.__assign({}, valueTransition), {\n                type: false,\n                delay: 0\n            });\n        }\n        var animation = startAnimation(key, value, valueTarget, valueTransition);\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(function() {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n    if (delayChildren === void 0) {\n        delayChildren = 0;\n    }\n    if (staggerChildren === void 0) {\n        staggerChildren = 0;\n    }\n    if (staggerDirection === void 0) {\n        staggerDirection = 1;\n    }\n    var animations = [];\n    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1 ? function(i) {\n        if (i === void 0) {\n            i = 0;\n        }\n        return i * staggerChildren;\n    } : function(i) {\n        if (i === void 0) {\n            i = 0;\n        }\n        return maxStaggerDuration - i * staggerChildren;\n    };\n    Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function(child, i) {\n        animations.push(animateVariant(child, variant, tslib.__assign(tslib.__assign({}, options), {\n            delay: delayChildren + generateStaggerDuration(i)\n        })).then(function() {\n            return child.notifyAnimationComplete(variant);\n        }));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.forEachValue(function(value) {\n        return value.stop();\n    });\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */ function shouldBlockAnimation(_a, key) {\n    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\n    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nvar variantPriorityOrder = [\n    exports.AnimationType.Animate,\n    exports.AnimationType.InView,\n    exports.AnimationType.Focus,\n    exports.AnimationType.Hover,\n    exports.AnimationType.Tap,\n    exports.AnimationType.Drag,\n    exports.AnimationType.Exit\n];\nvar reversePriorityOrder = tslib.__spreadArray([], tslib.__read(variantPriorityOrder), false).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return function(animations) {\n        return Promise.all(animations.map(function(_a) {\n            var animation = _a.animation, options = _a.options;\n            return animateVisualElement(visualElement, animation, options);\n        }));\n    };\n}\nfunction createAnimationState(visualElement) {\n    var animate = animateList(visualElement);\n    var state = createState();\n    var allAnimatedKeys = {};\n    var isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */ var buildResolvedTypeValues = function(acc, definition) {\n        var resolved = resolveVariant(visualElement, definition);\n        if (resolved) {\n            resolved.transition;\n            var transitionEnd = resolved.transitionEnd, target = tslib.__rest(resolved, [\n                \"transition\",\n                \"transitionEnd\"\n            ]);\n            acc = tslib.__assign(tslib.__assign(tslib.__assign({}, acc), target), transitionEnd);\n        }\n        return acc;\n    };\n    function isAnimated(key) {\n        return allAnimatedKeys[key] !== undefined;\n    }\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */ function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */ function animateChanges(options, changedActiveType) {\n        var _a;\n        var props = visualElement.getProps();\n        var context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */ var animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */ var removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */ var encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */ var removedVariantIndex = Infinity;\n        var _loop_1 = function(i) {\n            var type = reversePriorityOrder[i];\n            var typeState = state[type];\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n            var propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */ var activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false) removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */ var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */ if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */ typeState.protectedKeys = tslib.__assign({}, encounteredKeys);\n            // Check if we can skip analysing this prop early\n            if (// If it isn't active and hasn't *just* been set as inactive\n            !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type\n            !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n            isAnimationControls(prop) || typeof prop === \"boolean\") {\n                return \"continue\";\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */ var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            var shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active\n            type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)\n            i > removedVariantIndex && propIsVariant;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */ var definitionList = Array.isArray(prop) ? prop : [\n                prop\n            ];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */ var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n            if (activeDelta === false) resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */ var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\n            var allKeys = tslib.__assign(tslib.__assign({}, prevResolvedValues), resolvedValues);\n            var markToAnimate = function(key) {\n                shouldAnimateType = true;\n                removedKeys.delete(key);\n                typeState.needsAnimating[key] = true;\n            };\n            for(var key in allKeys){\n                var next = resolvedValues[key];\n                var prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key)) continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */ if (next !== prev) {\n                    /**\n                     * If both values are keyframes, we need to shallow compare them to\n                     * detect whether any value has changed. If it has, we animate it.\n                     */ if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                        if (!shallowCompare(next, prev) || variantDidChange) {\n                            markToAnimate(key);\n                        } else {\n                            /**\n                             * If it hasn't changed, we want to ensure it doesn't animate by\n                             * adding it to the list of protected keys.\n                             */ typeState.protectedKeys[key] = true;\n                        }\n                    } else if (next !== undefined) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    } else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                } else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */ markToAnimate(key);\n                } else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */ typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */ typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */ if (typeState.isActive) {\n                encounteredKeys = tslib.__assign(tslib.__assign({}, encounteredKeys), resolvedValues);\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             * TODO: Test as this should probably still handle animations triggered\n             * by removed values?\n             */ if (shouldAnimateType && !isInherited) {\n                animations.push.apply(animations, tslib.__spreadArray([], tslib.__read(definitionList.map(function(animation) {\n                    return {\n                        animation: animation,\n                        options: tslib.__assign({\n                            type: type\n                        }, options)\n                    };\n                })), false));\n            }\n        };\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */ for(var i = 0; i < numAnimationTypes; i++){\n            _loop_1(i);\n        }\n        allAnimatedKeys = tslib.__assign({}, encounteredKeys);\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */ if (removedKeys.size) {\n            var fallbackAnimation_1 = {};\n            removedKeys.forEach(function(key) {\n                var fallbackTarget = visualElement.getBaseTarget(key);\n                if (fallbackTarget !== undefined) {\n                    fallbackAnimation_1[key] = fallbackTarget;\n                }\n            });\n            animations.push({\n                animation: fallbackAnimation_1\n            });\n        }\n        var shouldAnimate = Boolean(animations.length);\n        if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */ function setActive(type, isActive, options) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive) return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {\n            var _a;\n            return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n        });\n        state[type].isActive = isActive;\n        var animations = animateChanges(options, type);\n        for(var key in state){\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        isAnimated: isAnimated,\n        animateChanges: animateChanges,\n        setActive: setActive,\n        setAnimateFunction: setAnimateFunction,\n        getState: function() {\n            return state;\n        }\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    } else if (isVariantLabels(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive) {\n    if (isActive === void 0) {\n        isActive = false;\n    }\n    return {\n        isActive: isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {}\n    };\n}\nfunction createState() {\n    var _a;\n    return _a = {}, _a[exports.AnimationType.Animate] = createTypeState(true), _a[exports.AnimationType.InView] = createTypeState(), _a[exports.AnimationType.Hover] = createTypeState(), _a[exports.AnimationType.Tap] = createTypeState(), _a[exports.AnimationType.Drag] = createTypeState(), _a[exports.AnimationType.Focus] = createTypeState(), _a[exports.AnimationType.Exit] = createTypeState(), _a;\n}\nvar animations = {\n    animation: makeRenderlessComponent(function(_a) {\n        var visualElement = _a.visualElement, animate = _a.animate;\n        /**\n         * We dynamically generate the AnimationState manager as it contains a reference\n         * to the underlying animation library. We only want to load that if we load this,\n         * so people can optionally code split it out using the `m` component.\n         */ visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n        /**\n         * Subscribe any provided AnimationControls to the component's VisualElement\n         */ if (isAnimationControls(animate)) {\n            React.useEffect(function() {\n                return animate.subscribe(visualElement);\n            }, [\n                animate\n            ]);\n        }\n    }),\n    exit: makeRenderlessComponent(function(props) {\n        var custom = props.custom, visualElement = props.visualElement;\n        var _a = tslib.__read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];\n        var presenceContext = React.useContext(PresenceContext);\n        React.useEffect(function() {\n            var _a, _b;\n            visualElement.isPresent = isPresent;\n            var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Exit, !isPresent, {\n                custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom\n            });\n            !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));\n        }, [\n            isPresent\n        ]);\n    })\n};\n/**\n * @internal\n */ var PanSession = /** @class */ function() {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n        /**\n         * @internal\n         */ this.startEvent = null;\n        /**\n         * @internal\n         */ this.lastMoveEvent = null;\n        /**\n         * @internal\n         */ this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */ this.handlers = {};\n        this.updatePoint = function() {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = popmotion.distance(info.offset, {\n                x: 0,\n                y: 0\n            }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold) return;\n            var point = info.point;\n            var timestamp = sync.getFrameData().timestamp;\n            _this.history.push(tslib.__assign(tslib.__assign({}, point), {\n                timestamp: timestamp\n            }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function(event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync__default[\"default\"].update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function(event, info) {\n            _this.end();\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            if (_this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1) return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = sync.getFrameData().timestamp;\n        this.history = [\n            tslib.__assign(tslib.__assign({}, point), {\n                timestamp: timestamp\n            })\n        ];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = popmotion.pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function(handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function() {\n        this.removeListeners && this.removeListeners();\n        sync.cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}();\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? {\n        point: transformPagePoint(info.point)\n    } : info;\n}\nfunction subtractPoint(a, b) {\n    return {\n        x: a.x - b.x,\n        y: a.y - b.y\n    };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1)\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while(i >= 0){\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) {\n        target = 0;\n    }\n    if (maxDistance === void 0) {\n        maxDistance = 0.01;\n    }\n    return popmotion.distance(value, target) < maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin) {\n    if (origin === void 0) {\n        origin = 0.5;\n    }\n    delta.origin = origin;\n    delta.originPoint = popmotion.mix(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    if (isNear(delta.scale, 1, 0.0001) || isNaN(delta.scale)) delta.scale = 1;\n    delta.translate = popmotion.mix(target.min, target.max, delta.origin) - delta.originPoint;\n    if (isNear(delta.translate) || isNaN(delta.translate)) delta.translate = 0;\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);\n    calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n    calcRelativeAxis(target.x, relative.x, parent.x);\n    calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n    target.min = layout.min - parent.min;\n    target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */ function applyConstraints(point, _a, elastic) {\n    var min = _a.min, max = _a.max;\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(min, point, elastic.min) : Math.max(point, min);\n    } else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */ function calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */ function calcRelativeConstraints(layoutBox, _a) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */ function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    var _a;\n    var min = constraintsAxis.min - layoutAxis.min;\n    var max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n        _a = tslib.__read([\n            max,\n            min\n        ], 2), min = _a[0], max = _a[1];\n    }\n    return {\n        min: min,\n        max: max\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */ function calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */ function calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = calcLength(source);\n    var targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = popmotion.progress(target.min, target.max - sourceLength, source.min);\n    } else if (sourceLength > targetLength) {\n        origin = popmotion.progress(source.min, source.max - targetLength, target.min);\n    }\n    return popmotion.clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */ function rebaseAxisConstraints(layout, constraints) {\n    var relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */ function resolveDragElastic(dragElastic) {\n    if (dragElastic === void 0) {\n        dragElastic = defaultElastic;\n    }\n    if (dragElastic === false) {\n        dragElastic = 0;\n    } else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel)\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    var _a;\n    return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\nvar createAxisDelta = function() {\n    return {\n        translate: 0,\n        scale: 1,\n        origin: 0,\n        originPoint: 0\n    };\n};\nvar createDelta = function() {\n    return {\n        x: createAxisDelta(),\n        y: createAxisDelta()\n    };\n};\nvar createAxis = function() {\n    return {\n        min: 0,\n        max: 0\n    };\n};\nvar createBox = function() {\n    return {\n        x: createAxis(),\n        y: createAxis()\n    };\n};\nfunction eachAxis(callback) {\n    return [\n        callback(\"x\"),\n        callback(\"y\")\n    ];\n}\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */ function convertBoundingBoxToBox(_a) {\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n    return {\n        x: {\n            min: left,\n            max: right\n        },\n        y: {\n            min: top,\n            max: bottom\n        }\n    };\n}\nfunction convertBoxToBoundingBox(_a) {\n    var x = _a.x, y = _a.y;\n    return {\n        top: y.min,\n        right: x.max,\n        bottom: y.max,\n        left: x.min\n    };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */ function transformBoxPoints(point, transformPoint) {\n    if (!transformPoint) return point;\n    var topLeft = transformPoint({\n        x: point.left,\n        y: point.top\n    });\n    var bottomRight = transformPoint({\n        x: point.right,\n        y: point.bottom\n    });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x\n    };\n}\nfunction isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale(_a) {\n    var scale = _a.scale, scaleX = _a.scaleX, scaleY = _a.scaleY;\n    return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);\n}\nfunction hasTransform(values) {\n    return hasScale(values) || hasTranslate(values.x) || hasTranslate(values.y) || values.z || values.rotate || values.rotateX || values.rotateY;\n}\nfunction hasTranslate(value) {\n    return value && value !== \"0%\";\n}\n/**\n * Scales a point based on a factor and an originPoint\n */ function scalePoint(point, scale, originPoint) {\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */ function applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */ function applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n    if (translate === void 0) {\n        translate = 0;\n    }\n    if (scale === void 0) {\n        scale = 1;\n    }\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */ function applyBoxDelta(box, _a) {\n    var x = _a.x, y = _a.y;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */ function applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {\n    var _a, _b;\n    if (isSharedTransition === void 0) {\n        isSharedTransition = false;\n    }\n    var treeLength = treePath.length;\n    if (!treeLength) return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    var node;\n    var delta;\n    for(var i = 0; i < treeLength; i++){\n        node = treePath[i];\n        delta = node.projectionDelta;\n        if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === \"contents\") continue;\n        if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.x,\n                y: -node.scroll.y\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */ function transformAxis(axis, transforms, _a) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    var originPoint = popmotion.mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */ var xKeys$1 = [\n    \"x\",\n    \"scaleX\",\n    \"originX\"\n];\nvar yKeys$1 = [\n    \"y\",\n    \"scaleY\",\n    \"originY\"\n];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */ function transformBox(box, transform) {\n    transformAxis(box.x, transform, xKeys$1);\n    transformAxis(box.y, transform, yKeys$1);\n}\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    var viewportBox = measureViewportBox(element, transformPagePoint);\n    var scroll = rootProjectionNode.scroll;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.x);\n        translateAxis(viewportBox.y, scroll.y);\n    }\n    return viewportBox;\n}\nvar elementDragControls = new WeakMap();\n/**\n *\n */ // let latestPointerEvent: AnyPointerEvent\nvar VisualElementDragControls = /** @class */ function() {\n    function VisualElementDragControls(visualElement) {\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = {\n            x: 0,\n            y: 0\n        };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */ this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */ this.elastic = createBox();\n        this.visualElement = visualElement;\n    }\n    VisualElementDragControls.prototype.start = function(originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c;\n        /**\n         * Don't start dragging if this component is exiting\n         */ if (this.visualElement.isPresent === false) return;\n        var onSessionStart = function(event) {\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopAnimation();\n            if (snapToCursor) {\n                _this.snapToCursor(extractEventInfo(event, \"page\").point);\n            }\n        };\n        var onStart = function(event, info) {\n            var _a;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _b = _this.getProps(), drag = _b.drag, dragPropagation = _b.dragPropagation, onDragStart = _b.onDragStart;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock) _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!_this.openGlobalLock) return;\n            }\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            _this.resolveConstraints();\n            if (_this.visualElement.projection) {\n                _this.visualElement.projection.isAnimationBlocked = true;\n                _this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */ eachAxis(function(axis) {\n                var _a, _b;\n                var current = _this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */ if (styleValueTypes.percent.test(current)) {\n                    var measuredAxis = (_b = (_a = _this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.actual[axis];\n                    if (measuredAxis) {\n                        var length_1 = calcLength(measuredAxis);\n                        current = length_1 * (parseFloat(current) / 100);\n                    }\n                }\n                _this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);\n            (_a = _this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Drag, true);\n        };\n        var onMove = function(event, info) {\n            // latestPointerEvent = event\n            var _a = _this.getProps(), dragPropagation = _a.dragPropagation, dragDirectionLock = _a.dragDirectionLock, onDirectionLock = _a.onDirectionLock, onDrag = _a.onDrag;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock) return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(_this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis(\"x\", info.point, offset);\n            _this.updateAxis(\"y\", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */ _this.visualElement.syncRender();\n            /**\n             * This must fire after the syncRender call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */ onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);\n        };\n        var onSessionEnd = function(event, info) {\n            return _this.stop(event, info);\n        };\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onSessionEnd: onSessionEnd\n        }, {\n            transformPagePoint: this.visualElement.getTransformPagePoint()\n        });\n    };\n    VisualElementDragControls.prototype.stop = function(event, info) {\n        var isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging) return;\n        var velocity = info.velocity;\n        this.startAnimation(velocity);\n        var onDragEnd = this.getProps().onDragEnd;\n        onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n    };\n    VisualElementDragControls.prototype.cancel = function() {\n        var _a, _b;\n        this.isDragging = false;\n        if (this.visualElement.projection) {\n            this.visualElement.projection.isAnimationBlocked = false;\n        }\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = undefined;\n        var dragPropagation = this.getProps().dragPropagation;\n        if (!dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(exports.AnimationType.Drag, false);\n    };\n    VisualElementDragControls.prototype.updateAxis = function(axis, _point, offset) {\n        var drag = this.getProps().drag;\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;\n        var axisValue = this.getAxisMotionValue(axis);\n        var next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    };\n    VisualElementDragControls.prototype.resolveConstraints = function() {\n        var _this = this;\n        var _a = this.getProps(), dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n        var layout = (this.visualElement.projection || {}).layout;\n        var prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        } else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.actual, dragConstraints);\n            } else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */ if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {\n            eachAxis(function(axis) {\n                if (_this.getAxisMotionValue(axis)) {\n                    _this.constraints[axis] = rebaseAxisConstraints(layout.actual[axis], _this.constraints[axis]);\n                }\n            });\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function() {\n        var _a = this.getProps(), constraints = _a.dragConstraints, onMeasureDragConstraints = _a.onMeasureDragConstraints;\n        if (!constraints || !isRefObject(constraints)) return false;\n        var constraintsElement = constraints.current;\n        heyListen.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        var projection = this.visualElement.projection;\n        // TODO\n        if (!projection || !projection.layout) return false;\n        var constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        var measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */ if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.startAnimation = function(velocity) {\n        var _this = this;\n        var _a = this.getProps(), drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition, dragSnapToOrigin = _a.dragSnapToOrigin, onDragTransitionEnd = _a.onDragTransitionEnd;\n        var constraints = this.constraints || {};\n        var momentumAnimations = eachAxis(function(axis) {\n            var _a;\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n            if (dragSnapToOrigin) transition = {\n                min: 0,\n                max: 0\n            };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */ var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = tslib.__assign(tslib.__assign({\n                type: \"inertia\",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness: bounceStiffness,\n                bounceDamping: bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10\n            }, dragTransition), transition);\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    };\n    VisualElementDragControls.prototype.startAxisValueAnimation = function(axis, transition) {\n        var axisValue = this.getAxisMotionValue(axis);\n        return startAnimation(axis, axisValue, 0, transition);\n    };\n    VisualElementDragControls.prototype.stopAnimation = function() {\n        var _this = this;\n        eachAxis(function(axis) {\n            return _this.getAxisMotionValue(axis).stop();\n        });\n    };\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */ VisualElementDragControls.prototype.getAxisMotionValue = function(axis) {\n        var _a, _b;\n        var dragKey = \"_drag\" + axis.toUpperCase();\n        var externalMotionValue = this.visualElement.getProps()[dragKey];\n        return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function(point) {\n        var _this = this;\n        eachAxis(function(axis) {\n            var drag = _this.getProps().drag;\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, _this.currentDirection)) return;\n            var projection = _this.visualElement.projection;\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                var _a = projection.layout.actual[axis], min = _a.min, max = _a.max;\n                axisValue.set(point[axis] - popmotion.mix(min, max, 0.5));\n            }\n        });\n    };\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */ VisualElementDragControls.prototype.scalePositionWithinConstraints = function() {\n        var _this = this;\n        var _a;\n        var _b = this.getProps(), drag = _b.drag, dragConstraints = _b.dragConstraints;\n        var projection = this.visualElement.projection;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */ this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */ var boxProgress = {\n            x: 0,\n            y: 0\n        };\n        eachAxis(function(axis) {\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n                var latest = axisValue.get();\n                boxProgress[axis] = calcOrigin({\n                    min: latest,\n                    max: latest\n                }, _this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */ var transformTemplate = this.visualElement.getProps().transformTemplate;\n        this.visualElement.getInstance().style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n        (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */ eachAxis(function(axis) {\n            if (!shouldDrag(axis, drag, null)) return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */ var axisValue = _this.getAxisMotionValue(axis);\n            var _a = _this.constraints[axis], min = _a.min, max = _a.max;\n            axisValue.set(popmotion.mix(min, max, boxProgress[axis]));\n        });\n    };\n    VisualElementDragControls.prototype.addListeners = function() {\n        var _this = this;\n        var _a;\n        elementDragControls.set(this.visualElement, this);\n        var element = this.visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */ var stopPointerListener = addPointerEvent(element, \"pointerdown\", function(event) {\n            var _a = _this.getProps(), drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        var measureDragConstraints = function() {\n            var dragConstraints = _this.getProps().dragConstraints;\n            if (isRefObject(dragConstraints)) {\n                _this.constraints = _this.resolveRefConstraints();\n            }\n        };\n        var projection = this.visualElement.projection;\n        var stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n        if (projection && !projection.layout) {\n            (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n            projection.updateLayout();\n        }\n        measureDragConstraints();\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */ var stopResizeListener = addDomEvent(window, \"resize\", function() {\n            return _this.scalePositionWithinConstraints();\n        });\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */ projection.addEventListener(\"didUpdate\", function(_a) {\n            var delta = _a.delta, hasLayoutChanged = _a.hasLayoutChanged;\n            if (_this.isDragging && hasLayoutChanged) {\n                eachAxis(function(axis) {\n                    var motionValue = _this.getAxisMotionValue(axis);\n                    if (!motionValue) return;\n                    _this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                _this.visualElement.syncRender();\n            }\n        });\n        return function() {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n        };\n    };\n    VisualElementDragControls.prototype.getProps = function() {\n        var props = this.visualElement.getProps();\n        var _a = props.drag, drag = _a === void 0 ? false : _a, _b = props.dragDirectionLock, dragDirectionLock = _b === void 0 ? false : _b, _c = props.dragPropagation, dragPropagation = _c === void 0 ? false : _c, _d = props.dragConstraints, dragConstraints = _d === void 0 ? false : _d, _e = props.dragElastic, dragElastic = _e === void 0 ? defaultElastic : _e, _f = props.dragMomentum, dragMomentum = _f === void 0 ? true : _f;\n        return tslib.__assign(tslib.__assign({}, props), {\n            drag: drag,\n            dragDirectionLock: dragDirectionLock,\n            dragPropagation: dragPropagation,\n            dragConstraints: dragConstraints,\n            dragElastic: dragElastic,\n            dragMomentum: dragMomentum\n        });\n    };\n    return VisualElementDragControls;\n}();\nfunction shouldDrag(direction, drag, currentDirection) {\n    return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */ function getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) {\n        lockThreshold = 10;\n    }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    } else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */ function useDrag(props) {\n    var groupDragControls = props.dragControls, visualElement = props.visualElement;\n    var dragControls = useConstant(function() {\n        return new VisualElementDragControls(visualElement);\n    });\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    React.useEffect(function() {\n        return groupDragControls && groupDragControls.subscribe(dragControls);\n    }, [\n        dragControls,\n        groupDragControls\n    ]);\n    // Apply the event listeners to the element\n    React.useEffect(function() {\n        return dragControls.addListeners();\n    }, [\n        dragControls\n    ]);\n}\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @privateRemarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */ function usePanGesture(_a) {\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement = _a.visualElement;\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n    var panSession = React.useRef(null);\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n    var handlers = {\n        onSessionStart: onPanSessionStart,\n        onStart: onPanStart,\n        onMove: onPan,\n        onEnd: function(event, info) {\n            panSession.current = null;\n            onPanEnd && onPanEnd(event, info);\n        }\n    };\n    React.useEffect(function() {\n        if (panSession.current !== null) {\n            panSession.current.updateHandlers(handlers);\n        }\n    });\n    function onPointerDown(event) {\n        panSession.current = new PanSession(event, handlers, {\n            transformPagePoint: transformPagePoint\n        });\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n    useUnmountEffect(function() {\n        return panSession.current && panSession.current.end();\n    });\n}\nvar drag = {\n    pan: makeRenderlessComponent(usePanGesture),\n    drag: makeRenderlessComponent(useDrag)\n};\nvar names = [\n    \"LayoutMeasure\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutUpdate\",\n    \"ViewportBoxUpdate\",\n    \"Update\",\n    \"Render\",\n    \"AnimationComplete\",\n    \"LayoutAnimationComplete\",\n    \"AnimationStart\",\n    \"LayoutAnimationStart\",\n    \"SetAxisTarget\",\n    \"Unmount\"\n];\nfunction createLifecycles() {\n    var managers = names.map(function() {\n        return new SubscriptionManager();\n    });\n    var propSubscriptions = {};\n    var lifecycles = {\n        clearAllListeners: function() {\n            return managers.forEach(function(manager) {\n                return manager.clear();\n            });\n        },\n        updatePropListeners: function(props) {\n            names.forEach(function(name) {\n                var _a;\n                var on = \"on\" + name;\n                var propListener = props[on];\n                // Unsubscribe existing subscription\n                (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n                // Add new subscription\n                if (propListener) {\n                    propSubscriptions[name] = lifecycles[on](propListener);\n                }\n            });\n        }\n    };\n    managers.forEach(function(manager, i) {\n        lifecycles[\"on\" + names[i]] = function(handler) {\n            return manager.add(handler);\n        };\n        lifecycles[\"notify\" + names[i]] = function() {\n            var args = [];\n            for(var _i = 0; _i < arguments.length; _i++){\n                args[_i] = arguments[_i];\n            }\n            return manager.notify.apply(manager, tslib.__spreadArray([], tslib.__read(args), false));\n        };\n    });\n    return lifecycles;\n}\nfunction updateMotionValuesFromProps(element, next, prev) {\n    var _a;\n    for(var key in next){\n        var nextValue = next[key];\n        var prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */ element.addValue(key, nextValue);\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */ if (true) {\n                warnOnce(nextValue.version === \"6.5.1\", \"Attempting to mix Framer Motion versions \".concat(nextValue.version, \" with 6.5.1 may not work as expected.\"));\n            }\n        } else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping to a new motion value, create a new motion value\n             * from that\n             */ element.addValue(key, motionValue(nextValue));\n        } else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */ if (element.hasValue(key)) {\n                var existingValue = element.getValue(key);\n                // TODO: Only update values that aren't being animated or even looked at\n                !existingValue.hasAnimated && existingValue.set(nextValue);\n            } else {\n                element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n            }\n        }\n    }\n    // Handle removed values\n    for(var key in prev){\n        if (next[key] === undefined) element.removeValue(key);\n    }\n    return next;\n}\nvar visualElement = function(_a) {\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n    return function(_a, options) {\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState, shouldReduceMotion = _a.shouldReduceMotion;\n        if (options === void 0) {\n            options = {};\n        }\n        var isMounted = false;\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\n        /**\n         * The instance of the render-specific node that will be hydrated by the\n         * exposed React ref. So for example, this visual element can host a\n         * HTMLElement, plain object, or Three.js object. The functions provided\n         * in VisualElementConfig allow us to interface with this instance.\n         */ var instance;\n        /**\n         * Manages the subscriptions for a visual element's lifecycle, for instance\n         * onRender\n         */ var lifecycles = createLifecycles();\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */ var values = new Map();\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */ var valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */ var prevMotionValues = {};\n        /**\n         * When values are removed from all animation props we need to search\n         * for a fallback value to animate to. These values are tracked in baseTarget.\n         */ var baseTarget = tslib.__assign({}, latestValues);\n        // Internal methods ========================\n        /**\n         * On mount, this will be hydrated with a callback to disconnect\n         * this visual element from its parent on unmount.\n         */ var removeFromVariantTree;\n        /**\n         * Render the element with the latest styles outside of the React\n         * render lifecycle\n         */ function render() {\n            if (!instance || !isMounted) return;\n            triggerBuild();\n            renderInstance(instance, renderState, props.style, element.projection);\n        }\n        function triggerBuild() {\n            build(element, renderState, latestValues, options, props);\n        }\n        function update() {\n            lifecycles.notifyUpdate(latestValues);\n        }\n        /**\n         *\n         */ function bindToMotionValue(key, value) {\n            var removeOnChange = value.onChange(function(latestValue) {\n                latestValues[key] = latestValue;\n                props.onUpdate && sync__default[\"default\"].update(update, false, true);\n            });\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n            valueSubscriptions.set(key, function() {\n                removeOnChange();\n                removeOnRenderRequest();\n            });\n        }\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */ var initialMotionValues = scrapeMotionValuesFromProps(props);\n        for(var key in initialMotionValues){\n            var value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */ var isControllingVariants = checkIfControllingVariants(props);\n        var isVariantNode = checkIfVariantNode(props);\n        var element = tslib.__assign(tslib.__assign({\n            treeType: treeType,\n            /**\n             * This is a mirror of the internal instance prop, which keeps\n             * VisualElement type-compatible with React's RefObject.\n             */ current: null,\n            /**\n             * The depth of this visual element within the visual element tree.\n             */ depth: parent ? parent.depth + 1 : 0,\n            parent: parent,\n            children: new Set(),\n            /**\n             *\n             */ presenceId: presenceId,\n            shouldReduceMotion: shouldReduceMotion,\n            /**\n             * If this component is part of the variant tree, it should track\n             * any children that are also part of the tree. This is essentially\n             * a shadow tree to simplify logic around how to stagger over children.\n             */ variantChildren: isVariantNode ? new Set() : undefined,\n            /**\n             * Whether this instance is visible. This can be changed imperatively\n             * by the projection tree, is analogous to CSS's visibility in that\n             * hidden elements should take up layout, and needs enacting by the configured\n             * render function.\n             */ isVisible: undefined,\n            /**\n             * Normally, if a component is controlled by a parent's variants, it can\n             * rely on that ancestor to trigger animations further down the tree.\n             * However, if a component is created after its parent is mounted, the parent\n             * won't trigger that mount animation so the child needs to.\n             *\n             * TODO: This might be better replaced with a method isParentMounted\n             */ manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n            /**\n             * This can be set by AnimatePresence to force components that mount\n             * at the same time as it to mount as if they have initial={false} set.\n             */ blockInitialAnimation: blockInitialAnimation,\n            /**\n             * Determine whether this component has mounted yet. This is mostly used\n             * by variant children to determine whether they need to trigger their\n             * own animations on mount.\n             */ isMounted: function() {\n                return Boolean(instance);\n            },\n            mount: function(newInstance) {\n                isMounted = true;\n                instance = element.current = newInstance;\n                if (element.projection) {\n                    element.projection.mount(newInstance);\n                }\n                if (isVariantNode && parent && !isControllingVariants) {\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n                }\n                values.forEach(function(value, key) {\n                    return bindToMotionValue(key, value);\n                });\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n                element.setProps(props);\n            },\n            /**\n             *\n             */ unmount: function() {\n                var _a;\n                (_a = element.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n                sync.cancelSync.update(update);\n                sync.cancelSync.render(render);\n                valueSubscriptions.forEach(function(remove) {\n                    return remove();\n                });\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n                lifecycles.clearAllListeners();\n                instance = undefined;\n                isMounted = false;\n            },\n            /**\n             * Add a child visual element to our set of children.\n             */ addVariantChild: function(child) {\n                var _a;\n                var closestVariantNode = element.getClosestVariantNode();\n                if (closestVariantNode) {\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n                    return function() {\n                        return closestVariantNode.variantChildren.delete(child);\n                    };\n                }\n            },\n            sortNodePosition: function(other) {\n                /**\n                 * If these nodes aren't even of the same type we can't compare their depth.\n                 */ if (!sortNodePosition || treeType !== other.treeType) return 0;\n                return sortNodePosition(element.getInstance(), other.getInstance());\n            },\n            /**\n             * Returns the closest variant node in the tree starting from\n             * this visual element.\n             */ getClosestVariantNode: function() {\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n            },\n            /**\n             * Expose the latest layoutId prop.\n             */ getLayoutId: function() {\n                return props.layoutId;\n            },\n            /**\n             * Returns the current instance.\n             */ getInstance: function() {\n                return instance;\n            },\n            /**\n             * Get/set the latest static values.\n             */ getStaticValue: function(key) {\n                return latestValues[key];\n            },\n            setStaticValue: function(key, value) {\n                return latestValues[key] = value;\n            },\n            /**\n             * Returns the latest motion value state. Currently only used to take\n             * a snapshot of the visual element - perhaps this can return the whole\n             * visual state\n             */ getLatestValues: function() {\n                return latestValues;\n            },\n            /**\n             * Set the visiblity of the visual element. If it's changed, schedule\n             * a render to reflect these changes.\n             */ setVisibility: function(visibility) {\n                if (element.isVisible === visibility) return;\n                element.isVisible = visibility;\n                element.scheduleRender();\n            },\n            /**\n             * Make a target animatable by Popmotion. For instance, if we're\n             * trying to animate width from 100px to 100vw we need to measure 100vw\n             * in pixels to determine what we really need to animate to. This is also\n             * pluggable to support Framer's custom value types like Color,\n             * and CSS variables.\n             */ makeTargetAnimatable: function(target, canMutate) {\n                if (canMutate === void 0) {\n                    canMutate = true;\n                }\n                return makeTargetAnimatable(element, target, props, canMutate);\n            },\n            /**\n             * Measure the current viewport box with or without transforms.\n             * Only measures axis-aligned boxes, rotate and skew must be manually\n             * removed with a re-render to work.\n             */ measureViewportBox: function() {\n                return measureViewportBox(instance, props);\n            },\n            // Motion values ========================\n            /**\n             * Add a motion value and bind it to this visual element.\n             */ addValue: function(key, value) {\n                // Remove existing value if it exists\n                if (element.hasValue(key)) element.removeValue(key);\n                values.set(key, value);\n                latestValues[key] = value.get();\n                bindToMotionValue(key, value);\n            },\n            /**\n             * Remove a motion value and unbind any active subscriptions.\n             */ removeValue: function(key) {\n                var _a;\n                values.delete(key);\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n                valueSubscriptions.delete(key);\n                delete latestValues[key];\n                removeValueFromRenderState(key, renderState);\n            },\n            /**\n             * Check whether we have a motion value for this key\n             */ hasValue: function(key) {\n                return values.has(key);\n            },\n            /**\n             * Get a motion value for this key. If called with a default\n             * value, we'll create one if none exists.\n             */ getValue: function(key, defaultValue) {\n                var value = values.get(key);\n                if (value === undefined && defaultValue !== undefined) {\n                    value = motionValue(defaultValue);\n                    element.addValue(key, value);\n                }\n                return value;\n            },\n            /**\n             * Iterate over our motion values.\n             */ forEachValue: function(callback) {\n                return values.forEach(callback);\n            },\n            /**\n             * If we're trying to animate to a previously unencountered value,\n             * we need to check for it in our state and as a last resort read it\n             * directly from the instance (which might have performance implications).\n             */ readValue: function(key) {\n                var _a;\n                return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n            },\n            /**\n             * Set the base target to later animate back to. This is currently\n             * only hydrated on creation and when we first read a value.\n             */ setBaseTarget: function(key, value) {\n                baseTarget[key] = value;\n            },\n            /**\n             * Find the base target for a value thats been removed from all animation\n             * props.\n             */ getBaseTarget: function(key) {\n                if (getBaseTarget) {\n                    var target = getBaseTarget(props, key);\n                    if (target !== undefined && !isMotionValue(target)) return target;\n                }\n                return baseTarget[key];\n            }\n        }, lifecycles), {\n            /**\n             * Build the renderer state based on the latest visual state.\n             */ build: function() {\n                triggerBuild();\n                return renderState;\n            },\n            /**\n             * Schedule a render on the next animation frame.\n             */ scheduleRender: function() {\n                sync__default[\"default\"].render(render, false, true);\n            },\n            /**\n             * Synchronously fire render. It's prefered that we batch renders but\n             * in many circumstances, like layout measurement, we need to run this\n             * synchronously. However in those instances other measures should be taken\n             * to batch reads/writes.\n             */ syncRender: render,\n            /**\n             * Update the provided props. Ensure any newly-added motion values are\n             * added to our map, old ones removed, and listeners updated.\n             */ setProps: function(newProps) {\n                if (newProps.transformTemplate || props.transformTemplate) {\n                    element.scheduleRender();\n                }\n                props = newProps;\n                lifecycles.updatePropListeners(newProps);\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n            },\n            getProps: function() {\n                return props;\n            },\n            // Variants ==============================\n            /**\n             * Returns the variant definition with a given name.\n             */ getVariant: function(name) {\n                var _a;\n                return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];\n            },\n            /**\n             * Returns the defined default transition on this component.\n             */ getDefaultTransition: function() {\n                return props.transition;\n            },\n            getTransformPagePoint: function() {\n                return props.transformPagePoint;\n            },\n            /**\n             * Used by child variant nodes to get the closest ancestor variant props.\n             */ getVariantContext: function(startAtParent) {\n                if (startAtParent === void 0) {\n                    startAtParent = false;\n                }\n                if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n                if (!isControllingVariants) {\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n                    if (props.initial !== undefined) {\n                        context_1.initial = props.initial;\n                    }\n                    return context_1;\n                }\n                var context = {};\n                for(var i = 0; i < numVariantProps; i++){\n                    var name_1 = variantProps[i];\n                    var prop = props[name_1];\n                    if (isVariantLabel(prop) || prop === false) {\n                        context[name_1] = prop;\n                    }\n                }\n                return context;\n            }\n        });\n        return element;\n    };\n};\nvar variantProps = tslib.__spreadArray([\n    \"initial\"\n], tslib.__read(variantPriorityOrder), false);\nvar numVariantProps = variantProps.length;\nfunction isCSSVariable(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */ var cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match) return [\n        , \n    ];\n    var _a = tslib.__read(match, 3), token = _a[1], fallback = _a[2];\n    return [\n        token,\n        fallback\n    ];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) {\n        depth = 1;\n    }\n    heyListen.invariant(depth <= maxDepth, 'Max CSS variable fallback depth detected in property \"'.concat(current, '\". This may indicate a circular fallback dependency.'));\n    var _a = tslib.__read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token) return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    } else if (isCSSVariable(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    } else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */ function resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var _b;\n    var target = tslib.__rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof Element)) return {\n        target: target,\n        transitionEnd: transitionEnd\n    };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = tslib.__assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function(value) {\n        var current = value.get();\n        if (!isCSSVariable(current)) return;\n        var resolved = getVariableValue(current, element);\n        if (resolved) value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for(var key in target){\n        var current = target[key];\n        if (!isCSSVariable(current)) continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved) continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd) (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;\n    }\n    return {\n        target: target,\n        transitionEnd: transitionEnd\n    };\n}\nvar positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\"\n]);\nvar isPositionalKey = function(key) {\n    return positionalKeys.has(key);\n};\nvar hasPositionalKey = function(target) {\n    return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function(value, to) {\n    // Looks odd but setting it twice doesn't render, it'll just\n    // set both prev and current to the latest value\n    value.set(to, false);\n    value.set(to);\n};\nvar isNumOrPxType = function(v) {\n    return v === styleValueTypes.number || v === styleValueTypes.px;\n};\nvar BoundingBoxDimension;\n(function(BoundingBoxDimension) {\n    BoundingBoxDimension[\"width\"] = \"width\";\n    BoundingBoxDimension[\"height\"] = \"height\";\n    BoundingBoxDimension[\"left\"] = \"left\";\n    BoundingBoxDimension[\"right\"] = \"right\";\n    BoundingBoxDimension[\"top\"] = \"top\";\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function(matrix, pos) {\n    return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function(pos2, pos3) {\n    return function(_bbox, _a) {\n        var transform = _a.transform;\n        if (transform === \"none\" || !transform) return 0;\n        var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n        if (matrix3d) {\n            return getPosFromMatrix(matrix3d[1], pos3);\n        } else {\n            var matrix = transform.match(/^matrix\\((.+)\\)$/);\n            if (matrix) {\n                return getPosFromMatrix(matrix[1], pos2);\n            } else {\n                return 0;\n            }\n        }\n    };\n};\nvar transformKeys = new Set([\n    \"x\",\n    \"y\",\n    \"z\"\n]);\nvar nonTranslationalTransformKeys = transformProps.filter(function(key) {\n    return !transformKeys.has(key);\n});\nfunction removeNonTranslationalTransform(visualElement) {\n    var removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(function(key) {\n        var value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([\n                key,\n                value.get()\n            ]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length) visualElement.syncRender();\n    return removedTransforms;\n}\nvar positionalValues = {\n    // Dimensions\n    width: function(_a, _b) {\n        var x = _a.x;\n        var _c = _b.paddingLeft, paddingLeft = _c === void 0 ? \"0\" : _c, _d = _b.paddingRight, paddingRight = _d === void 0 ? \"0\" : _d;\n        return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n    },\n    height: function(_a, _b) {\n        var y = _a.y;\n        var _c = _b.paddingTop, paddingTop = _c === void 0 ? \"0\" : _c, _d = _b.paddingBottom, paddingBottom = _d === void 0 ? \"0\" : _d;\n        return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n    },\n    top: function(_bbox, _a) {\n        var top = _a.top;\n        return parseFloat(top);\n    },\n    left: function(_bbox, _a) {\n        var left = _a.left;\n        return parseFloat(left);\n    },\n    bottom: function(_a, _b) {\n        var y = _a.y;\n        var top = _b.top;\n        return parseFloat(top) + (y.max - y.min);\n    },\n    right: function(_a, _b) {\n        var x = _a.x;\n        var left = _b.left;\n        return parseFloat(left) + (x.max - x.min);\n    },\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = function(target, visualElement, changedKeys) {\n    var originBbox = visualElement.measureViewportBox();\n    var element = visualElement.getInstance();\n    var elementComputedStyle = getComputedStyle(element);\n    var display = elementComputedStyle.display;\n    var origin = {};\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    /**\n     * Record origins before we render and update styles\n     */ changedKeys.forEach(function(key) {\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n    });\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.syncRender();\n    var targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach(function(key) {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        var value = visualElement.getValue(key);\n        setAndResetVelocity(value, origin[key]);\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nvar checkAndConvertChangedValueTypes = function(visualElement, target, origin, transitionEnd) {\n    if (origin === void 0) {\n        origin = {};\n    }\n    if (transitionEnd === void 0) {\n        transitionEnd = {};\n    }\n    target = tslib.__assign({}, target);\n    transitionEnd = tslib.__assign({}, transitionEnd);\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    var removedTransformValues = [];\n    var hasAttemptedToRemoveTransformValues = false;\n    var changedValueTypeKeys = [];\n    targetPositionalKeys.forEach(function(key) {\n        var value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key)) return;\n        var from = origin[key];\n        var fromType = findDimensionValueType(from);\n        var to = target[key];\n        var toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            var numKeyframes = to.length;\n            var fromIndex = to[0] === null ? 1 : 0;\n            from = to[fromIndex];\n            fromType = findDimensionValueType(from);\n            for(var i = fromIndex; i < numKeyframes; i++){\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    heyListen.invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n                } else {\n                    heyListen.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        } else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                var current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                } else if (Array.isArray(to) && toType === styleValueTypes.px) {\n                    target[key] = to.map(parseFloat);\n                }\n            } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                } else {\n                    target[key] = fromType.transform(to);\n                }\n            } else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n                setAndResetVelocity(value, to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        var scrollY_1 = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(function(_a) {\n                var _b = tslib.__read(_a, 2), key = _b[0], value = _b[1];\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.syncRender();\n        // Restore scroll position\n        if (scrollY_1 !== null) window.scrollTo({\n            top: scrollY_1\n        });\n        return {\n            target: convertedTarget,\n            transitionEnd: transitionEnd\n        };\n    } else {\n        return {\n            target: target,\n            transitionEnd: transitionEnd\n        };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */ function unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n        target: target,\n        transitionEnd: transitionEnd\n    };\n}\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */ var parseDomVariant = function(visualElement, target, origin, transitionEnd) {\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\nfunction getComputedStyle$1(element) {\n    return window.getComputedStyle(element);\n}\nvar htmlConfig = {\n    treeType: \"dom\",\n    readValueFromInstance: function(domElement, key) {\n        if (isTransformProp(key)) {\n            var defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        } else {\n            var computedStyle = getComputedStyle$1(domElement);\n            return (isCSSVariable$1(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n        }\n    },\n    sortNodePosition: function(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */ return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget: function(props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox: function(element, _a) {\n        var transformPagePoint = _a.transformPagePoint;\n        return measureViewportBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */ resetTransform: function(element, domElement, props) {\n        var transformTemplate = props.transformTemplate;\n        domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform: function(instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromRenderState: function(key, _a) {\n        var vars = _a.vars, style = _a.style;\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */ makeTargetAnimatable: function(element, _a, _b, isMounted) {\n        var transformValues = _b.transformValues;\n        if (isMounted === void 0) {\n            isMounted = true;\n        }\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\n            \"transition\",\n            \"transitionEnd\"\n        ]);\n        var origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */ if (transformValues) {\n            if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n            if (target) target = transformValues(target);\n            if (origin) origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            var parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return tslib.__assign({\n            transition: transition,\n            transitionEnd: transitionEnd\n        }, target);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n    build: function(element, renderState, latestValues, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n        }\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n    },\n    render: renderHTML\n};\nvar htmlVisualElement = visualElement(htmlConfig);\nvar svgVisualElement = visualElement(tslib.__assign(tslib.__assign({}, htmlConfig), {\n    getBaseTarget: function(props, key) {\n        return props[key];\n    },\n    readValueFromInstance: function(domElement, key) {\n        var _a;\n        if (isTransformProp(key)) {\n            return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return domElement.getAttribute(key);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    build: function(_element, renderState, latestValues, options, props) {\n        buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);\n    },\n    render: renderSVG\n}));\nvar createDomVisualElement = function(Component, options) {\n    return isSVGComponent(Component) ? svgVisualElement(options, {\n        enableHardwareAcceleration: false\n    }) : htmlVisualElement(options, {\n        enableHardwareAcceleration: true\n    });\n};\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min) return 0;\n    return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */ var correctBorderRadius = {\n    correct: function(latest, node) {\n        if (!node.target) return latest;\n        /**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */ if (typeof latest === \"string\") {\n            if (styleValueTypes.px.test(latest)) {\n                latest = parseFloat(latest);\n            } else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */ var x = pixelsToPercent(latest, node.target.x);\n        var y = pixelsToPercent(latest, node.target.y);\n        return \"\".concat(x, \"% \").concat(y, \"%\");\n    }\n};\nvar varToken = \"_$css\";\nvar correctBoxShadow = {\n    correct: function(latest, _a) {\n        var treeScale = _a.treeScale, projectionDelta = _a.projectionDelta;\n        var original = latest;\n        /**\n         * We need to first strip and store CSS variables from the string.\n         */ var containsCSSVariables = latest.includes(\"var(\");\n        var cssVariables = [];\n        if (containsCSSVariables) {\n            latest = latest.replace(cssVariableRegex, function(match) {\n                cssVariables.push(match);\n                return varToken;\n            });\n        }\n        var shadow = styleValueTypes.complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5) return original;\n        var template = styleValueTypes.complex.createTransformer(latest);\n        var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        var xScale = projectionDelta.x.scale * treeScale.x;\n        var yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */ var averageScale = popmotion.mix(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n        var output = template(shadow);\n        if (containsCSSVariables) {\n            var i_1 = 0;\n            output = output.replace(varToken, function() {\n                var cssVariable = cssVariables[i_1];\n                i_1++;\n                return cssVariable;\n            });\n        }\n        return output;\n    }\n};\nvar MeasureLayoutWithContext = /** @class */ function(_super) {\n    tslib.__extends(MeasureLayoutWithContext, _super);\n    function MeasureLayoutWithContext() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */ MeasureLayoutWithContext.prototype.componentDidMount = function() {\n        var _this = this;\n        var _a = this.props, visualElement = _a.visualElement, layoutGroup = _a.layoutGroup, switchLayoutGroup = _a.switchLayoutGroup, layoutId = _a.layoutId;\n        var projection = visualElement.projection;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.add(projection);\n            if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener(\"animationComplete\", function() {\n                _this.safeToRemove();\n            });\n            projection.setOptions(tslib.__assign(tslib.__assign({}, projection.options), {\n                onExitComplete: function() {\n                    return _this.safeToRemove();\n                }\n            }));\n        }\n        globalProjectionState.hasEverUpdated = true;\n    };\n    MeasureLayoutWithContext.prototype.getSnapshotBeforeUpdate = function(prevProps) {\n        var _this = this;\n        var _a = this.props, layoutDependency = _a.layoutDependency, visualElement = _a.visualElement, drag = _a.drag, isPresent = _a.isPresent;\n        var projection = visualElement.projection;\n        if (!projection) return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */ projection.isPresent = isPresent;\n        if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {\n            projection.willUpdate();\n        } else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            } else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */ sync__default[\"default\"].postRender(function() {\n                    var _a;\n                    if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n                        _this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    };\n    MeasureLayoutWithContext.prototype.componentDidUpdate = function() {\n        var projection = this.props.visualElement.projection;\n        if (projection) {\n            projection.root.didUpdate();\n            if (!projection.currentAnimation && projection.isLead()) {\n                this.safeToRemove();\n            }\n        }\n    };\n    MeasureLayoutWithContext.prototype.componentWillUnmount = function() {\n        var _a = this.props, visualElement = _a.visualElement, layoutGroup = _a.layoutGroup, promoteContext = _a.switchLayoutGroup;\n        var projection = visualElement.projection;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.remove(projection);\n            if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister) promoteContext.deregister(projection);\n        }\n    };\n    MeasureLayoutWithContext.prototype.safeToRemove = function() {\n        var safeToRemove = this.props.safeToRemove;\n        safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n    };\n    MeasureLayoutWithContext.prototype.render = function() {\n        return null;\n    };\n    return MeasureLayoutWithContext;\n}(React__default[\"default\"].Component);\nfunction MeasureLayout(props) {\n    var _a = tslib.__read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];\n    var layoutGroup = React.useContext(LayoutGroupContext);\n    return React__default[\"default\"].createElement(MeasureLayoutWithContext, tslib.__assign({}, props, {\n        layoutGroup: layoutGroup,\n        switchLayoutGroup: React.useContext(SwitchLayoutGroupContext),\n        isPresent: isPresent,\n        safeToRemove: safeToRemove\n    }));\n}\nvar defaultScaleCorrectors = {\n    borderRadius: tslib.__assign(tslib.__assign({}, correctBorderRadius), {\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\"\n        ]\n    }),\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow\n};\nvar layoutFeatures = {\n    measureLayout: MeasureLayout\n};\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */ function animate(from, to, transition) {\n    if (transition === void 0) {\n        transition = {};\n    }\n    var value = isMotionValue(from) ? from : motionValue(from);\n    startAnimation(\"\", value, to, transition);\n    return {\n        stop: function() {\n            return value.stop();\n        },\n        isAnimating: function() {\n            return value.isAnimating();\n        }\n    };\n}\nvar borders = [\n    \"TopLeft\",\n    \"TopRight\",\n    \"BottomLeft\",\n    \"BottomRight\"\n];\nvar numBorders = borders.length;\nvar asNumber = function(value) {\n    return typeof value === \"string\" ? parseFloat(value) : value;\n};\nvar isPx = function(value) {\n    return typeof value === \"number\" || styleValueTypes.px.test(value);\n};\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    var _a, _b, _c, _d;\n    if (shouldCrossfadeOpacity) {\n        target.opacity = popmotion.mix(0, // (follow?.opacity as number) ?? 0,\n        // TODO Reinstate this if only child\n        (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));\n        target.opacityExit = popmotion.mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));\n    } else if (isOnlyMember) {\n        target.opacity = popmotion.mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */ for(var i = 0; i < numBorders; i++){\n        var borderLabel = \"border\".concat(borders[i], \"Radius\");\n        var followRadius = getRadius(follow, borderLabel);\n        var leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined) continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(popmotion.mix(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (styleValueTypes.percent.test(leadRadius) || styleValueTypes.percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        } else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */ if (follow.rotate || lead.rotate) {\n        target.rotate = popmotion.mix(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nvar easeCrossfadeIn = compress(0, 0.5, popmotion.circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, popmotion.linear);\nfunction compress(min, max, easing) {\n    return function(p) {\n        // Could replace ifs with clamp\n        if (p < min) return 0;\n        if (p > max) return 1;\n        return easing(popmotion.progress(min, max, p));\n    };\n}\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */ function copyAxisInto(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */ function copyBoxInto(box, originBox) {\n    copyAxisInto(box.x, originBox.x);\n    copyAxisInto(box.y, originBox.y);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */ function removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */ function removeAxisDelta(axis, translate, scale, origin, boxScale, originAxis, sourceAxis) {\n    if (translate === void 0) {\n        translate = 0;\n    }\n    if (scale === void 0) {\n        scale = 1;\n    }\n    if (origin === void 0) {\n        origin = 0.5;\n    }\n    if (originAxis === void 0) {\n        originAxis = axis;\n    }\n    if (sourceAxis === void 0) {\n        sourceAxis = axis;\n    }\n    if (styleValueTypes.percent.test(translate)) {\n        translate = parseFloat(translate);\n        var relativeProgress = popmotion.mix(sourceAxis.min, sourceAxis.max, translate / 100);\n        translate = relativeProgress - sourceAxis.min;\n    }\n    if (typeof translate !== \"number\") return;\n    var originPoint = popmotion.mix(originAxis.min, originAxis.max, origin);\n    if (axis === originAxis) originPoint -= translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */ function removeAxisTransforms(axis, transforms, _a, origin, sourceAxis) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */ var xKeys = [\n    \"x\",\n    \"scaleX\",\n    \"originX\"\n];\nvar yKeys = [\n    \"y\",\n    \"scaleY\",\n    \"originY\"\n];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */ function removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, xKeys, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);\n    removeAxisTransforms(box.y, transforms, yKeys, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);\n}\nfunction isAxisDeltaZero(delta) {\n    return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction boxEquals(a, b) {\n    return a.x.min === b.x.min && a.x.max === b.x.max && a.y.min === b.y.min && a.y.max === b.y.max;\n}\nvar NodeStack = /** @class */ function() {\n    function NodeStack() {\n        this.members = [];\n    }\n    NodeStack.prototype.add = function(node) {\n        addUniqueItem(this.members, node);\n        node.scheduleRender();\n    };\n    NodeStack.prototype.remove = function(node) {\n        removeItem(this.members, node);\n        if (node === this.prevLead) {\n            this.prevLead = undefined;\n        }\n        if (node === this.lead) {\n            var prevLead = this.members[this.members.length - 1];\n            if (prevLead) {\n                this.promote(prevLead);\n            }\n        }\n    };\n    NodeStack.prototype.relegate = function(node) {\n        var indexOfNode = this.members.findIndex(function(member) {\n            return node === member;\n        });\n        if (indexOfNode === 0) return false;\n        /**\n         * Find the next projection node that is present\n         */ var prevLead;\n        for(var i = indexOfNode; i >= 0; i--){\n            var member = this.members[i];\n            if (member.isPresent !== false) {\n                prevLead = member;\n                break;\n            }\n        }\n        if (prevLead) {\n            this.promote(prevLead);\n            return true;\n        } else {\n            return false;\n        }\n    };\n    NodeStack.prototype.promote = function(node, preserveFollowOpacity) {\n        var _a;\n        var prevLead = this.lead;\n        if (node === prevLead) return;\n        this.prevLead = prevLead;\n        this.lead = node;\n        node.show();\n        if (prevLead) {\n            prevLead.instance && prevLead.scheduleRender();\n            node.scheduleRender();\n            node.resumeFrom = prevLead;\n            if (preserveFollowOpacity) {\n                node.resumeFrom.preserveOpacity = true;\n            }\n            if (prevLead.snapshot) {\n                node.snapshot = prevLead.snapshot;\n                node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;\n                node.snapshot.isShared = true;\n            }\n            if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {\n                node.isLayoutDirty = true;\n            }\n            var crossfade = node.options.crossfade;\n            if (crossfade === false) {\n                prevLead.hide();\n            }\n        /**\n             * TODO:\n             *   - Test border radius when previous node was deleted\n             *   - boxShadow mixing\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\n             * ---\n             *   - Crossfade opacity of root nodes\n             *   - layoutId changes after animation\n             *   - layoutId changes mid animation\n             */ }\n    };\n    NodeStack.prototype.exitAnimationComplete = function() {\n        this.members.forEach(function(node) {\n            var _a, _b, _c, _d, _e;\n            (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n            (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);\n        });\n    };\n    NodeStack.prototype.scheduleRender = function() {\n        this.members.forEach(function(node) {\n            node.instance && node.scheduleRender(false);\n        });\n    };\n    /**\n     * Clear any leads that have been removed this render to prevent them from being\n     * used in future animations and to prevent memory leaks\n     */ NodeStack.prototype.removeLeadSnapshot = function() {\n        if (this.lead && this.lead.snapshot) {\n            this.lead.snapshot = undefined;\n        }\n    };\n    return NodeStack;\n}();\nvar identityProjection = \"translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)\";\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */ var xTranslate = delta.x.translate / treeScale.x;\n    var yTranslate = delta.y.translate / treeScale.y;\n    var transform = \"translate3d(\".concat(xTranslate, \"px, \").concat(yTranslate, \"px, 0) \");\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */ transform += \"scale(\".concat(1 / treeScale.x, \", \").concat(1 / treeScale.y, \") \");\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate) transform += \"rotate(\".concat(rotate, \"deg) \");\n        if (rotateX) transform += \"rotateX(\".concat(rotateX, \"deg) \");\n        if (rotateY) transform += \"rotateY(\".concat(rotateY, \"deg) \");\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */ var elementScaleX = delta.x.scale * treeScale.x;\n    var elementScaleY = delta.y.scale * treeScale.y;\n    transform += \"scale(\".concat(elementScaleX, \", \").concat(elementScaleY, \")\");\n    return transform === identityProjection ? \"none\" : transform;\n}\nvar compareByDepth = function(a, b) {\n    return a.depth - b.depth;\n};\nvar FlatTree = /** @class */ function() {\n    function FlatTree() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    FlatTree.prototype.add = function(child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.remove = function(child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.forEach = function(callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    };\n    return FlatTree;\n}();\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */ var animationTarget = 1000;\nfunction createProjectionNode(_a) {\n    var attachResizeListener = _a.attachResizeListener, defaultParent = _a.defaultParent, measureScroll = _a.measureScroll, checkIsScrollRoot = _a.checkIsScrollRoot, resetTransform = _a.resetTransform;\n    return /** @class */ function() {\n        function ProjectionNode(id, latestValues, parent) {\n            var _this = this;\n            if (latestValues === void 0) {\n                latestValues = {};\n            }\n            if (parent === void 0) {\n                parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent();\n            }\n            /**\n             * A Set containing all this component's children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */ this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */ this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */ this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can't always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */ this.isLayoutDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */ this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */ this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */ this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */ this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */ this.shouldResetTransform = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to actually\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */ this.treeScale = {\n                x: 1,\n                y: 1\n            };\n            /**\n             *\n             */ this.eventHandlers = new Map();\n            // Note: Currently only running on root node\n            this.potentialNodes = new Map();\n            this.checkUpdateFailed = function() {\n                if (_this.isUpdating) {\n                    _this.isUpdating = false;\n                    _this.clearAllSnapshots();\n                }\n            };\n            this.updateProjection = function() {\n                _this.nodes.forEach(resolveTargetDelta);\n                _this.nodes.forEach(calcProjection);\n            };\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */ // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.id = id;\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(parent.path), false), [\n                parent\n            ], false) : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            id && this.root.registerPotentialNode(id, this);\n            for(var i = 0; i < this.path.length; i++){\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this) this.nodes = new FlatTree();\n        }\n        ProjectionNode.prototype.addEventListener = function(name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        };\n        ProjectionNode.prototype.notifyListeners = function(name) {\n            var args = [];\n            for(var _i = 1; _i < arguments.length; _i++){\n                args[_i - 1] = arguments[_i];\n            }\n            var subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, tslib.__spreadArray([], tslib.__read(args), false));\n        };\n        ProjectionNode.prototype.hasListeners = function(name) {\n            return this.eventHandlers.has(name);\n        };\n        ProjectionNode.prototype.registerPotentialNode = function(id, node) {\n            this.potentialNodes.set(id, node);\n        };\n        /**\n         * Lifecycles\n         */ ProjectionNode.prototype.mount = function(instance, isLayoutDirty) {\n            var _this = this;\n            var _a;\n            if (isLayoutDirty === void 0) {\n                isLayoutDirty = false;\n            }\n            if (this.instance) return;\n            this.isSVG = instance instanceof SVGElement && instance.tagName !== \"svg\";\n            this.instance = instance;\n            var _b = this.options, layoutId = _b.layoutId, layout = _b.layout, visualElement = _b.visualElement;\n            if (visualElement && !visualElement.getInstance()) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);\n            this.id && this.root.potentialNodes.delete(this.id);\n            if (isLayoutDirty && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                var unblockTimeout_1;\n                var resizeUnblockUpdate_1 = function() {\n                    return _this.root.updateBlockedByResize = false;\n                };\n                attachResizeListener(instance, function() {\n                    _this.root.updateBlockedByResize = true;\n                    clearTimeout(unblockTimeout_1);\n                    unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        _this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false && visualElement && (layoutId || layout)) {\n                this.addEventListener(\"didUpdate\", function(_a) {\n                    var _b, _c, _d, _e, _f;\n                    var delta = _a.delta, hasLayoutChanged = _a.hasLayoutChanged, hasRelativeTargetChanged = _a.hasRelativeTargetChanged, newLayout = _a.layout;\n                    if (_this.isTreeAnimationBlocked()) {\n                        _this.target = undefined;\n                        _this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    var layoutTransition = (_c = (_b = _this.options.transition) !== null && _b !== void 0 ? _b : visualElement.getDefaultTransition()) !== null && _c !== void 0 ? _c : defaultLayoutTransition;\n                    var _g = visualElement.getProps(), onLayoutAnimationStart = _g.onLayoutAnimationStart, onLayoutAnimationComplete = _g.onLayoutAnimationComplete;\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */ var targetChanged = !_this.targetLayout || !boxEquals(_this.targetLayout, newLayout) || hasRelativeTargetChanged;\n                    /**\n                     * If the layout hasn't seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */ var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n                    if (((_d = _this.resumeFrom) === null || _d === void 0 ? void 0 : _d.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !_this.currentAnimation)) {\n                        if (_this.resumeFrom) {\n                            _this.resumingFrom = _this.resumeFrom;\n                            _this.resumingFrom.resumingFrom = undefined;\n                        }\n                        _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                        var animationOptions = tslib.__assign(tslib.__assign({}, getValueTransition(layoutTransition, \"layout\")), {\n                            onPlay: onLayoutAnimationStart,\n                            onComplete: onLayoutAnimationComplete\n                        });\n                        if (visualElement.shouldReduceMotion) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        _this.startAnimation(animationOptions);\n                    } else {\n                        /**\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */ if (!hasLayoutChanged && _this.animationProgress === 0) {\n                            _this.finishAnimation();\n                        }\n                        _this.isLead() && ((_f = (_e = _this.options).onExitComplete) === null || _f === void 0 ? void 0 : _f.call(_e));\n                    }\n                    _this.targetLayout = newLayout;\n                });\n            }\n        };\n        ProjectionNode.prototype.unmount = function() {\n            var _a, _b;\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);\n            (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);\n            this.instance = undefined;\n            sync.cancelSync.preRender(this.updateProjection);\n        };\n        // only on the root\n        ProjectionNode.prototype.blockUpdate = function() {\n            this.updateManuallyBlocked = true;\n        };\n        ProjectionNode.prototype.unblockUpdate = function() {\n            this.updateManuallyBlocked = false;\n        };\n        ProjectionNode.prototype.isUpdateBlocked = function() {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        };\n        ProjectionNode.prototype.isTreeAnimationBlocked = function() {\n            var _a;\n            return this.isAnimationBlocked || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) || false;\n        };\n        // Note: currently only running on root node\n        ProjectionNode.prototype.startUpdate = function() {\n            var _a;\n            if (this.isUpdateBlocked()) return;\n            this.isUpdating = true;\n            (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);\n        };\n        ProjectionNode.prototype.willUpdate = function(shouldNotifyListeners) {\n            var _a, _b, _c;\n            if (shouldNotifyListeners === void 0) {\n                shouldNotifyListeners = true;\n            }\n            if (this.root.isUpdateBlocked()) {\n                (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n                return;\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty) return;\n            this.isLayoutDirty = true;\n            for(var i = 0; i < this.path.length; i++){\n                var node = this.path[i];\n                node.shouldResetTransform = true;\n                /**\n                 * TODO: Check we haven't updated the scroll\n                 * since the last didUpdate\n                 */ node.updateScroll();\n            }\n            var _d = this.options, layoutId = _d.layoutId, layout = _d.layout;\n            if (layoutId === undefined && !layout) return;\n            var transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;\n            this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n        };\n        // Note: Currently only running on root node\n        ProjectionNode.prototype.didUpdate = function() {\n            var updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            if (!this.isUpdating) return;\n            this.isUpdating = false;\n            /**\n             * Search for and mount newly-added projection elements.\n             *\n             * TODO: Every time a new component is rendered we could search up the tree for\n             * the closest mounted node and query from there rather than document.\n             */ if (this.potentialNodes.size) {\n                this.potentialNodes.forEach(mountNodeEarly);\n                this.potentialNodes.clear();\n            }\n            /**\n             * Write\n             */ this.nodes.forEach(resetTransformStyle);\n            /**\n             * Read ==================\n             */ // Update layout measurements of updated children\n            this.nodes.forEach(updateLayout);\n            /**\n             * Write\n             */ // Notify listeners that the layout is updated\n            this.nodes.forEach(notifyLayoutUpdate);\n            this.clearAllSnapshots();\n            // Flush any scheduled updates\n            sync.flushSync.update();\n            sync.flushSync.preRender();\n            sync.flushSync.render();\n        };\n        ProjectionNode.prototype.clearAllSnapshots = function() {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        };\n        ProjectionNode.prototype.scheduleUpdateProjection = function() {\n            sync__default[\"default\"].preRender(this.updateProjection, false, true);\n        };\n        ProjectionNode.prototype.scheduleCheckAfterUnmount = function() {\n            var _this = this;\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */ sync__default[\"default\"].postRender(function() {\n                if (_this.isLayoutDirty) {\n                    _this.root.didUpdate();\n                } else {\n                    _this.root.checkUpdateFailed();\n                }\n            });\n        };\n        /**\n         * Update measurements\n         */ ProjectionNode.prototype.updateSnapshot = function() {\n            if (this.snapshot || !this.instance) return;\n            var measured = this.measure();\n            var layout = this.removeTransform(this.removeElementScroll(measured));\n            roundBox(layout);\n            this.snapshot = {\n                measured: measured,\n                layout: layout,\n                latestValues: {}\n            };\n        };\n        ProjectionNode.prototype.updateLayout = function() {\n            var _a;\n            if (!this.instance) return;\n            // TODO: Incorporate into a forwarded scroll offset\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead's\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */ if (this.resumeFrom && !this.resumeFrom.instance) {\n                for(var i = 0; i < this.path.length; i++){\n                    var node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            var measured = this.measure();\n            roundBox(measured);\n            var prevLayout = this.layout;\n            this.layout = {\n                measured: measured,\n                actual: this.removeElementScroll(measured)\n            };\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners(\"measure\", this.layout.actual);\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);\n        };\n        ProjectionNode.prototype.updateScroll = function() {\n            if (this.options.layoutScroll && this.instance) {\n                this.isScrollRoot = checkIsScrollRoot(this.instance);\n                this.scroll = measureScroll(this.instance);\n            }\n        };\n        ProjectionNode.prototype.resetTransform = function() {\n            var _a;\n            if (!resetTransform) return;\n            var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;\n            var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n            var transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n            var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        };\n        ProjectionNode.prototype.measure = function() {\n            var visualElement = this.options.visualElement;\n            if (!visualElement) return createBox();\n            var box = visualElement.measureViewportBox();\n            // Remove viewport scroll to give page-relative coordinates\n            var scroll = this.root.scroll;\n            if (scroll) {\n                translateAxis(box.x, scroll.x);\n                translateAxis(box.y, scroll.y);\n            }\n            return box;\n        };\n        ProjectionNode.prototype.removeElementScroll = function(box) {\n            var boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */ for(var i = 0; i < this.path.length; i++){\n                var node = this.path[i];\n                var scroll_1 = node.scroll, options = node.options, isScrollRoot = node.isScrollRoot;\n                if (node !== this.root && scroll_1 && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */ if (isScrollRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                        var rootScroll = this.root.scroll;\n                        /**\n                         * Undo the application of page scroll that was originally added\n                         * to the measured bounding box.\n                         */ if (rootScroll) {\n                            translateAxis(boxWithoutScroll.x, -rootScroll.x);\n                            translateAxis(boxWithoutScroll.y, -rootScroll.y);\n                        }\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll_1.x);\n                    translateAxis(boxWithoutScroll.y, scroll_1.y);\n                }\n            }\n            return boxWithoutScroll;\n        };\n        ProjectionNode.prototype.applyTransform = function(box, transformOnly) {\n            if (transformOnly === void 0) {\n                transformOnly = false;\n            }\n            var withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for(var i = 0; i < this.path.length; i++){\n                var node = this.path[i];\n                if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.x,\n                        y: -node.scroll.y\n                    });\n                }\n                if (!hasTransform(node.latestValues)) continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        };\n        ProjectionNode.prototype.removeTransform = function(box) {\n            var _a;\n            var boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for(var i = 0; i < this.path.length; i++){\n                var node = this.path[i];\n                if (!node.instance) continue;\n                if (!hasTransform(node.latestValues)) continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                var sourceBox = createBox();\n                var nodeBox = node.measure();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layout, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        };\n        /**\n         *\n         */ ProjectionNode.prototype.setTargetDelta = function(delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n        };\n        ProjectionNode.prototype.setOptions = function(options) {\n            var _a;\n            this.options = tslib.__assign(tslib.__assign(tslib.__assign({}, this.options), options), {\n                crossfade: (_a = options.crossfade) !== null && _a !== void 0 ? _a : true\n            });\n        };\n        ProjectionNode.prototype.clearMeasurements = function() {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        };\n        /**\n         * Frame calculations\n         */ ProjectionNode.prototype.resolveTargetDelta = function() {\n            var _a;\n            var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;\n            /**\n             * If we have no layout, we can't perform projection, so early return\n             */ if (!this.layout || !(layout || layoutId)) return;\n            /**\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */ // TODO If this is unsuccessful this currently happens every frame\n            if (!this.targetDelta && !this.relativeTarget) {\n                // TODO: This is a semi-repetition of further down this function, make DRY\n                this.relativeParent = this.getClosestProjectingParent();\n                if (this.relativeParent && this.relativeParent.layout) {\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn't valid\n             * for this frame.\n             */ if (!this.relativeTarget && !this.targetDelta) return;\n            /**\n             * Lazy-init target data structure\n             */ if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\n             */ if (this.relativeTarget && this.relativeTargetOrigin && ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n            /**\n                 * If we've only got a targetDelta, resolve it into a target\n                 */ } else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.actual);\n                } else {\n                    copyBoxInto(this.target, this.layout.actual);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            } else {\n                /**\n                 * If no target, use own layout as target\n                 */ copyBoxInto(this.target, this.layout.actual);\n            }\n            /**\n             * If we've been told to attempt to resolve a relative target, do so.\n             */ if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                this.relativeParent = this.getClosestProjectingParent();\n                if (this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target) {\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n            }\n        };\n        ProjectionNode.prototype.getClosestProjectingParent = function() {\n            if (!this.parent || hasTransform(this.parent.latestValues)) return undefined;\n            if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {\n                return this.parent;\n            } else {\n                return this.parent.getClosestProjectingParent();\n            }\n        };\n        ProjectionNode.prototype.calcProjection = function() {\n            var _a;\n            var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;\n            /**\n             * If this section of the tree isn't animating we can\n             * delete our target sources for the following frame.\n             */ this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId)) return;\n            var lead = this.getLead();\n            /**\n             * Reset the corrected box with the latest values from box, as we're then going\n             * to perform mutative operations on it.\n             */ copyBoxInto(this.layoutCorrected, this.layout.actual);\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */ applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);\n            var target = lead.target;\n            if (!target) return;\n            if (!this.projectionDelta) {\n                this.projectionDelta = createDelta();\n                this.projectionDeltaWithTransform = createDelta();\n            }\n            var prevTreeScaleX = this.treeScale.x;\n            var prevTreeScaleY = this.treeScale.y;\n            var prevProjectionTransform = this.projectionTransform;\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */ calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);\n            if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners(\"projectionUpdate\", target);\n            }\n        };\n        ProjectionNode.prototype.hide = function() {\n            this.isVisible = false;\n        // TODO: Schedule render\n        };\n        ProjectionNode.prototype.show = function() {\n            this.isVisible = true;\n        // TODO: Schedule render\n        };\n        ProjectionNode.prototype.scheduleRender = function(notifyAll) {\n            var _a, _b, _c;\n            if (notifyAll === void 0) {\n                notifyAll = true;\n            }\n            (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n            notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        };\n        ProjectionNode.prototype.setAnimationOrigin = function(delta, hasOnlyRelativeTargetChanged) {\n            var _this = this;\n            var _a;\n            if (hasOnlyRelativeTargetChanged === void 0) {\n                hasOnlyRelativeTargetChanged = false;\n            }\n            var snapshot = this.snapshot;\n            var snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};\n            var mixedValues = tslib.__assign({}, this.latestValues);\n            var targetDelta = createDelta();\n            this.relativeTarget = this.relativeTargetOrigin = undefined;\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            var relativeLayout = createBox();\n            var isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;\n            var isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;\n            var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            this.mixTargetDelta = function(latest) {\n                var _a;\n                var progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                _this.setTargetDelta(targetDelta);\n                if (_this.relativeTarget && _this.relativeTargetOrigin && _this.layout && ((_a = _this.relativeParent) === null || _a === void 0 ? void 0 : _a.layout)) {\n                    calcRelativePosition(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);\n                    mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress);\n                }\n                if (isSharedLayoutAnimation) {\n                    _this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, _this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                _this.root.scheduleUpdateProjection();\n                _this.scheduleRender();\n                _this.animationProgress = progress;\n            };\n            this.mixTargetDelta(0);\n        };\n        ProjectionNode.prototype.startAnimation = function(options) {\n            var _this = this;\n            var _a, _b;\n            this.notifyListeners(\"animationStart\");\n            (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n            if (this.resumingFrom) {\n                (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();\n            }\n            if (this.pendingAnimation) {\n                sync.cancelSync.update(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */ this.pendingAnimation = sync__default[\"default\"].update(function() {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                _this.currentAnimation = animate(0, animationTarget, tslib.__assign(tslib.__assign({}, options), {\n                    onUpdate: function(latest) {\n                        var _a;\n                        _this.mixTargetDelta(latest);\n                        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, latest);\n                    },\n                    onComplete: function() {\n                        var _a;\n                        (_a = options.onComplete) === null || _a === void 0 ? void 0 : _a.call(options);\n                        _this.completeAnimation();\n                    }\n                }));\n                if (_this.resumingFrom) {\n                    _this.resumingFrom.currentAnimation = _this.currentAnimation;\n                }\n                _this.pendingAnimation = undefined;\n            });\n        };\n        ProjectionNode.prototype.completeAnimation = function() {\n            var _a;\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();\n            this.resumingFrom = this.currentAnimation = this.animationValues = undefined;\n            this.notifyListeners(\"animationComplete\");\n        };\n        ProjectionNode.prototype.finishAnimation = function() {\n            var _a;\n            if (this.currentAnimation) {\n                (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        };\n        ProjectionNode.prototype.applyTransformsToTarget = function() {\n            var _a = this.getLead(), targetWithTransforms = _a.targetWithTransforms, target = _a.target, layout = _a.layout, latestValues = _a.latestValues;\n            if (!targetWithTransforms || !target || !layout) return;\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */ transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its actual layout\n             * into the desired bounding box.\n             */ calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        };\n        ProjectionNode.prototype.registerSharedNode = function(layoutId, node) {\n            var _a, _b, _c;\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            var stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            node.promote({\n                transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,\n                preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)\n            });\n        };\n        ProjectionNode.prototype.isLead = function() {\n            var stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        };\n        ProjectionNode.prototype.getLead = function() {\n            var _a;\n            var layoutId = this.options.layoutId;\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n        };\n        ProjectionNode.prototype.getPrevLead = function() {\n            var _a;\n            var layoutId = this.options.layoutId;\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\n        };\n        ProjectionNode.prototype.getStack = function() {\n            var layoutId = this.options.layoutId;\n            if (layoutId) return this.root.sharedNodes.get(layoutId);\n        };\n        ProjectionNode.prototype.promote = function(_a) {\n            var _b = _a === void 0 ? {} : _a, needsReset = _b.needsReset, transition = _b.transition, preserveFollowOpacity = _b.preserveFollowOpacity;\n            var stack = this.getStack();\n            if (stack) stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition) this.setOptions({\n                transition: transition\n            });\n        };\n        ProjectionNode.prototype.relegate = function() {\n            var stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            } else {\n                return false;\n            }\n        };\n        ProjectionNode.prototype.resetRotation = function() {\n            var visualElement = this.options.visualElement;\n            if (!visualElement) return;\n            // If there's no detected rotation values, we can early return without a forced render.\n            var hasRotate = false;\n            // Keep a record of all the values we've reset\n            var resetValues = {};\n            // Check the rotate value of all axes and reset to 0\n            for(var i = 0; i < transformAxes.length; i++){\n                var axis = transformAxes[i];\n                var key = \"rotate\" + axis;\n                // If this rotation doesn't exist as a motion value, then we don't\n                // need to reset it\n                if (!visualElement.getStaticValue(key)) {\n                    continue;\n                }\n                hasRotate = true;\n                // Record the rotation and then temporarily set it to 0\n                resetValues[key] = visualElement.getStaticValue(key);\n                visualElement.setStaticValue(key, 0);\n            }\n            // If there's no rotation values, we don't need to do any more.\n            if (!hasRotate) return;\n            // Force a render of this element to apply the transform with all rotations\n            // set to 0.\n            visualElement === null || visualElement === void 0 ? void 0 : visualElement.syncRender();\n            // Put back all the values we reset\n            for(var key in resetValues){\n                visualElement.setStaticValue(key, resetValues[key]);\n            }\n            // Schedule a render for the next frame. This ensures we won't visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        };\n        ProjectionNode.prototype.getProjectionStyles = function(styleProp) {\n            var _a, _b, _c, _d, _e, _f;\n            if (styleProp === void 0) {\n                styleProp = {};\n            }\n            // TODO: Return lifecycle-persistent object\n            var styles = {};\n            if (!this.instance || this.isSVG) return styles;\n            if (!this.isVisible) {\n                return {\n                    visibility: \"hidden\"\n                };\n            } else {\n                styles.visibility = \"\";\n            }\n            var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n            if (this.needsReset) {\n                this.needsReset = false;\n                styles.opacity = \"\";\n                styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n                styles.transform = transformTemplate ? transformTemplate(this.latestValues, \"\") : \"none\";\n                return styles;\n            }\n            var lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                var emptyStyles = {};\n                if (this.options.layoutId) {\n                    emptyStyles.opacity = (_b = this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1;\n                    emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    emptyStyles.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n                    this.hasProjected = false;\n                }\n                return emptyStyles;\n            }\n            var valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\n            }\n            var _g = this.projectionDelta, x = _g.x, y = _g.y;\n            styles.transformOrigin = \"\".concat(x.origin * 100, \"% \").concat(y.origin * 100, \"% 0\");\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */ styles.opacity = lead === this ? (_d = (_c = valuesToRender.opacity) !== null && _c !== void 0 ? _c : this.latestValues.opacity) !== null && _d !== void 0 ? _d : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;\n            } else {\n                /**\n                 * Or we're not animating at all, set the lead component to its actual\n                 * opacity and other components to hidden.\n                 */ styles.opacity = lead === this ? (_e = valuesToRender.opacity) !== null && _e !== void 0 ? _e : \"\" : (_f = valuesToRender.opacityExit) !== null && _f !== void 0 ? _f : 0;\n            }\n            /**\n             * Apply scale correction\n             */ for(var key in scaleCorrectors){\n                if (valuesToRender[key] === undefined) continue;\n                var _h = scaleCorrectors[key], correct = _h.correct, applyTo = _h.applyTo;\n                var corrected = correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    var num = applyTo.length;\n                    for(var i = 0; i < num; i++){\n                        styles[applyTo[i]] = corrected;\n                    }\n                } else {\n                    styles[key] = corrected;\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn't block\n             * pointer events on the lead.\n             */ if (this.options.layoutId) {\n                styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || \"\" : \"none\";\n            }\n            return styles;\n        };\n        ProjectionNode.prototype.clearSnapshot = function() {\n            this.resumeFrom = this.snapshot = undefined;\n        };\n        // Only run on root\n        ProjectionNode.prototype.resetTree = function() {\n            this.root.nodes.forEach(function(node) {\n                var _a;\n                return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n            });\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        };\n        return ProjectionNode;\n    }();\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    var _a, _b, _c, _d;\n    var snapshot = (_b = (_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) !== null && _b !== void 0 ? _b : node.snapshot;\n    if (node.isLead() && node.layout && snapshot && node.hasListeners(\"didUpdate\")) {\n        var _e = node.layout, layout_1 = _e.actual, measuredLayout = _e.measured;\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\n        // animations for instance if layout=\"size\" and an element has only changed position\n        if (node.options.animationType === \"size\") {\n            eachAxis(function(axis) {\n                var axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];\n                var length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout_1[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        } else if (node.options.animationType === \"position\") {\n            eachAxis(function(axis) {\n                var axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];\n                var length = calcLength(layout_1[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        var layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout_1, snapshot.layout);\n        var visualDelta = createDelta();\n        if (snapshot.isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measured);\n        } else {\n            calcBoxDelta(visualDelta, layout_1, snapshot.layout);\n        }\n        var hasLayoutChanged = !isDeltaZero(layoutDelta);\n        var hasRelativeTargetChanged = false;\n        if (!node.resumeFrom) {\n            node.relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */ if (node.relativeParent && !node.relativeParent.resumeFrom) {\n                var _f = node.relativeParent, parentSnapshot = _f.snapshot, parentLayout = _f.layout;\n                if (parentSnapshot && parentLayout) {\n                    var relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layout, parentSnapshot.layout);\n                    var relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout_1, parentLayout.actual);\n                    if (!boxEquals(relativeSnapshot, relativeLayout)) {\n                        hasRelativeTargetChanged = true;\n                    }\n                }\n            }\n        }\n        node.notifyListeners(\"didUpdate\", {\n            layout: layout_1,\n            snapshot: snapshot,\n            delta: visualDelta,\n            layoutDelta: layoutDelta,\n            hasLayoutChanged: hasLayoutChanged,\n            hasRelativeTargetChanged: hasRelativeTargetChanged\n        });\n    } else if (node.isLead()) {\n        (_d = (_c = node.options).onExitComplete) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */ node.options.transition = undefined;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction resetTransformStyle(node) {\n    var visualElement = node.options.visualElement;\n    if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notifyBeforeLayoutMeasure();\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetRotation(node) {\n    node.resetRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = popmotion.mix(delta.translate, 0, p);\n    output.scale = popmotion.mix(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = popmotion.mix(from.min, to.min, p);\n    output.max = popmotion.mix(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return node.animationValues && node.animationValues.opacityExit !== undefined;\n}\nvar defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [\n        0.4,\n        0,\n        0.1,\n        1\n    ]\n};\nfunction mountNodeEarly(node, id) {\n    /**\n     * Rather than searching the DOM from document we can search the\n     * path for the deepest mounted ancestor and search from there\n     */ var searchNode = node.root;\n    for(var i = node.path.length - 1; i >= 0; i--){\n        if (Boolean(node.path[i].instance)) {\n            searchNode = node.path[i];\n            break;\n        }\n    }\n    var searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;\n    var element = searchElement.querySelector('[data-projection-id=\"'.concat(id, '\"]'));\n    if (element) node.mount(element, true);\n}\nfunction roundAxis(axis) {\n    axis.min = Math.round(axis.min);\n    axis.max = Math.round(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\nvar DocumentProjectionNode = createProjectionNode({\n    attachResizeListener: function(ref, notify) {\n        return addDomEvent(ref, \"resize\", notify);\n    },\n    measureScroll: function() {\n        return {\n            x: document.documentElement.scrollLeft || document.body.scrollLeft,\n            y: document.documentElement.scrollTop || document.body.scrollTop\n        };\n    },\n    checkIsScrollRoot: function() {\n        return true;\n    }\n});\nvar rootProjectionNode = {\n    current: undefined\n};\nvar HTMLProjectionNode = createProjectionNode({\n    measureScroll: function(instance) {\n        return {\n            x: instance.scrollLeft,\n            y: instance.scrollTop\n        };\n    },\n    defaultParent: function() {\n        if (!rootProjectionNode.current) {\n            var documentNode = new DocumentProjectionNode(0, {});\n            documentNode.mount(window);\n            documentNode.setOptions({\n                layoutScroll: true\n            });\n            rootProjectionNode.current = documentNode;\n        }\n        return rootProjectionNode.current;\n    },\n    resetTransform: function(instance, value) {\n        instance.style.transform = value !== null && value !== void 0 ? value : \"none\";\n    },\n    checkIsScrollRoot: function(instance) {\n        return Boolean(window.getComputedStyle(instance).position === \"fixed\");\n    }\n});\nvar featureBundle = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, animations), gestureAnimations), drag), layoutFeatures);\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */ var motion = /*@__PURE__*/ createMotionProxy(function(Component, config) {\n    return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement, HTMLProjectionNode);\n});\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don't\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from \"framer-motion\"\n *\n * const motion = {\n *   div: createDomMotionComponent('div')\n * }\n * ```\n *\n * @public\n */ function createDomMotionComponent(key) {\n    return createMotionComponent(createDomMotionConfig(key, {\n        forwardMotionProps: false\n    }, featureBundle, createDomVisualElement, HTMLProjectionNode));\n}\n/**\n * @public\n */ var m = createMotionProxy(createDomMotionConfig);\nfunction useIsMounted() {\n    var isMounted = React.useRef(false);\n    useIsomorphicLayoutEffect(function() {\n        isMounted.current = true;\n        return function() {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\nfunction useForceUpdate() {\n    var isMounted = useIsMounted();\n    var _a = tslib.__read(React.useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    var forceRender = React.useCallback(function() {\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [\n        forcedRenderCount\n    ]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */ var deferredForceRender = React.useCallback(function() {\n        return sync__default[\"default\"].postRender(forceRender);\n    }, [\n        forceRender\n    ]);\n    return [\n        deferredForceRender,\n        forcedRenderCount\n    ];\n}\nvar PresenceChild = function(_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useId();\n    var context = React.useMemo(function() {\n        return {\n            id: id,\n            initial: initial,\n            isPresent: isPresent,\n            custom: custom,\n            onExitComplete: function(childId) {\n                var e_1, _a;\n                presenceChildren.set(childId, true);\n                try {\n                    for(var _b = tslib.__values(presenceChildren.values()), _c = _b.next(); !_c.done; _c = _b.next()){\n                        var isComplete = _c.value;\n                        if (!isComplete) return; // can stop searching when any is incomplete\n                    }\n                } catch (e_1_1) {\n                    e_1 = {\n                        error: e_1_1\n                    };\n                } finally{\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    } finally{\n                        if (e_1) throw e_1.error;\n                    }\n                }\n                onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();\n            },\n            register: function(childId) {\n                presenceChildren.set(childId, false);\n                return function() {\n                    return presenceChildren.delete(childId);\n                };\n            }\n        };\n    }, /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */ presenceAffectsLayout ? undefined : [\n        isPresent\n    ]);\n    React.useMemo(function() {\n        presenceChildren.forEach(function(_, key) {\n            return presenceChildren.set(key, false);\n        });\n    }, [\n        isPresent\n    ]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */ React__namespace.useEffect(function() {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [\n        isPresent\n    ]);\n    return React__namespace.createElement(PresenceContext.Provider, {\n        value: context\n    }, children);\n};\nfunction newChildrenMap() {\n    return new Map();\n}\nvar getChildKey = function(child) {\n    return child.key || \"\";\n};\nfunction updateChildLookup(children, allChildren) {\n    children.forEach(function(child) {\n        var key = getChildKey(child);\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    React.Children.forEach(children, function(child) {\n        if (React.isValidElement(child)) filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */ var AnimatePresence = function(_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var _d = tslib.__read(useForceUpdate(), 1), forceRender = _d[0];\n    var forceRenderLayoutGroup = React.useContext(LayoutGroupContext).forceRender;\n    if (forceRenderLayoutGroup) forceRender = forceRenderLayoutGroup;\n    var isMounted = useIsMounted();\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    var childrenToRender = filteredChildren;\n    var exiting = new Set();\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = React.useRef(childrenToRender);\n    // A lookup table to quickly reference components by key\n    var allChildren = React.useRef(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    var isInitialRender = React.useRef(true);\n    useIsomorphicLayoutEffect(function() {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(function() {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exiting.clear();\n    });\n    if (isInitialRender.current) {\n        return React__namespace.createElement(React__namespace.Fragment, null, childrenToRender.map(function(child) {\n            return React__namespace.createElement(PresenceChild, {\n                key: getChildKey(child),\n                isPresent: true,\n                initial: initial ? undefined : false,\n                presenceAffectsLayout: presenceAffectsLayout\n            }, child);\n        }));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = tslib.__spreadArray([], tslib.__read(childrenToRender), false);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for(var i = 0; i < numPresent; i++){\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function(key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1) return;\n        var child = allChildren.get(key);\n        if (!child) return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function() {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function(presentChild) {\n                return presentChild.key === key;\n            });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                if (isMounted.current === false) return;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React__namespace.createElement(PresenceChild, {\n            key: getChildKey(child),\n            isPresent: false,\n            onExitComplete: onExit,\n            custom: custom,\n            presenceAffectsLayout: presenceAffectsLayout\n        }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function(child) {\n        var key = child.key;\n        return exiting.has(key) ? child : React__namespace.createElement(PresenceChild, {\n            key: getChildKey(child),\n            isPresent: true,\n            presenceAffectsLayout: presenceAffectsLayout\n        }, child);\n    });\n    if (env !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return React__namespace.createElement(React__namespace.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function(child) {\n        return React.cloneElement(child);\n    }));\n};\n/**\n * @deprecated\n */ var DeprecatedLayoutGroupContext = React.createContext(null);\nvar notify = function(node) {\n    return !node.isLayoutDirty && node.willUpdate(false);\n};\nfunction nodeGroup() {\n    var nodes = new Set();\n    var subscriptions = new WeakMap();\n    var dirtyAll = function() {\n        return nodes.forEach(notify);\n    };\n    return {\n        add: function(node) {\n            nodes.add(node);\n            subscriptions.set(node, node.addEventListener(\"willUpdate\", dirtyAll));\n        },\n        remove: function(node) {\n            var _a;\n            nodes.delete(node);\n            (_a = subscriptions.get(node)) === null || _a === void 0 ? void 0 : _a();\n            subscriptions.delete(node);\n            dirtyAll();\n        },\n        dirty: dirtyAll\n    };\n}\nvar shouldInheritGroup = function(inherit) {\n    return inherit === true;\n};\nvar shouldInheritId = function(inherit) {\n    return shouldInheritGroup(inherit === true) || inherit === \"id\";\n};\nvar LayoutGroup = function(_a) {\n    var _b, _c;\n    var children = _a.children, id = _a.id, inheritId = _a.inheritId, _d = _a.inherit, inherit = _d === void 0 ? true : _d;\n    // Maintain backwards-compatibility with inheritId until 7.0\n    if (inheritId !== undefined) inherit = inheritId;\n    var layoutGroupContext = React.useContext(LayoutGroupContext);\n    var deprecatedLayoutGroupContext = React.useContext(DeprecatedLayoutGroupContext);\n    var _e = tslib.__read(useForceUpdate(), 2), forceRender = _e[0], key = _e[1];\n    var context = React.useRef(null);\n    var upstreamId = (_b = layoutGroupContext.id) !== null && _b !== void 0 ? _b : deprecatedLayoutGroupContext;\n    if (context.current === null) {\n        if (shouldInheritId(inherit) && upstreamId) {\n            id = id ? upstreamId + \"-\" + id : upstreamId;\n        }\n        context.current = {\n            id: id,\n            group: shouldInheritGroup(inherit) ? (_c = layoutGroupContext === null || layoutGroupContext === void 0 ? void 0 : layoutGroupContext.group) !== null && _c !== void 0 ? _c : nodeGroup() : nodeGroup()\n        };\n    }\n    var memoizedContext = React.useMemo(function() {\n        return tslib.__assign(tslib.__assign({}, context.current), {\n            forceRender: forceRender\n        });\n    }, [\n        key\n    ]);\n    return React__namespace.createElement(LayoutGroupContext.Provider, {\n        value: memoizedContext\n    }, children);\n};\nvar id = 0;\nvar AnimateSharedLayout = function(_a) {\n    var children = _a.children;\n    React__namespace.useEffect(function() {\n        heyListen.warning(false, \"AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations\");\n    }, []);\n    return React__namespace.createElement(LayoutGroup, {\n        id: useConstant(function() {\n            return \"asl-\".concat(id++);\n        })\n    }, children);\n};\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */ function MotionConfig(_a) {\n    var children = _a.children, isValidProp = _a.isValidProp, config = tslib.__rest(_a, [\n        \"children\",\n        \"isValidProp\"\n    ]);\n    isValidProp && loadExternalIsValidProp(isValidProp);\n    /**\n     * Inherit props from any parent MotionConfig components\n     */ config = tslib.__assign(tslib.__assign({}, React.useContext(MotionConfigContext)), config);\n    /**\n     * Don't allow isStatic to change between renders as it affects how many hooks\n     * motion components fire.\n     */ config.isStatic = useConstant(function() {\n        return config.isStatic;\n    });\n    /**\n     * Creating a new config context object will re-render every `motion` component\n     * every time it renders. So we only want to create a new one sparingly.\n     */ var context = React.useMemo(function() {\n        return config;\n    }, [\n        JSON.stringify(config.transition),\n        config.transformPagePoint,\n        config.reducedMotion\n    ]);\n    return React__namespace.createElement(MotionConfigContext.Provider, {\n        value: context\n    }, children);\n}\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimations } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimations}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimations')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */ function LazyMotion(_a) {\n    var children = _a.children, features = _a.features, _b = _a.strict, strict = _b === void 0 ? false : _b;\n    var _c = tslib.__read(React.useState(!isLazyBundle(features)), 2), setIsLoaded = _c[1];\n    var loadedRenderer = React.useRef(undefined);\n    /**\n     * If this is a synchronous load, load features immediately\n     */ if (!isLazyBundle(features)) {\n        var renderer = features.renderer, loadedFeatures = tslib.__rest(features, [\n            \"renderer\"\n        ]);\n        loadedRenderer.current = renderer;\n        loadFeatures(loadedFeatures);\n    }\n    React.useEffect(function() {\n        if (isLazyBundle(features)) {\n            features().then(function(_a) {\n                var renderer = _a.renderer, loadedFeatures = tslib.__rest(_a, [\n                    \"renderer\"\n                ]);\n                loadFeatures(loadedFeatures);\n                loadedRenderer.current = renderer;\n                setIsLoaded(true);\n            });\n        }\n    }, []);\n    return React__namespace.createElement(LazyContext.Provider, {\n        value: {\n            renderer: loadedRenderer.current,\n            strict: strict\n        }\n    }, children);\n}\nfunction isLazyBundle(features) {\n    return typeof features === \"function\";\n}\nvar ReorderContext = React.createContext(null);\nfunction checkReorder(order, value, offset, velocity) {\n    if (!velocity) return order;\n    var index = order.findIndex(function(item) {\n        return item.value === value;\n    });\n    if (index === -1) return order;\n    var nextOffset = velocity > 0 ? 1 : -1;\n    var nextItem = order[index + nextOffset];\n    if (!nextItem) return order;\n    var item = order[index];\n    var nextLayout = nextItem.layout;\n    var nextItemCenter = popmotion.mix(nextLayout.min, nextLayout.max, 0.5);\n    if (nextOffset === 1 && item.layout.max + offset > nextItemCenter || nextOffset === -1 && item.layout.min + offset < nextItemCenter) {\n        return moveItem(order, index, index + nextOffset);\n    }\n    return order;\n}\nfunction ReorderGroup(_a, externalRef) {\n    var children = _a.children, _b = _a.as, as = _b === void 0 ? \"ul\" : _b, _c = _a.axis, axis = _c === void 0 ? \"y\" : _c, onReorder = _a.onReorder, values = _a.values, props = tslib.__rest(_a, [\n        \"children\",\n        \"as\",\n        \"axis\",\n        \"onReorder\",\n        \"values\"\n    ]);\n    var Component = useConstant(function() {\n        return motion(as);\n    });\n    var order = [];\n    var isReordering = React.useRef(false);\n    heyListen.invariant(Boolean(values), \"Reorder.Group must be provided a values prop\");\n    var context = {\n        axis: axis,\n        registerItem: function(value, layout) {\n            /**\n             * Ensure entries can't add themselves more than once\n             */ if (layout && order.findIndex(function(entry) {\n                return value === entry.value;\n            }) === -1) {\n                order.push({\n                    value: value,\n                    layout: layout[axis]\n                });\n                order.sort(compareMin);\n            }\n        },\n        updateOrder: function(id, offset, velocity) {\n            if (isReordering.current) return;\n            var newOrder = checkReorder(order, id, offset, velocity);\n            if (order !== newOrder) {\n                isReordering.current = true;\n                onReorder(newOrder.map(getValue).filter(function(value) {\n                    return values.indexOf(value) !== -1;\n                }));\n            }\n        }\n    };\n    React.useEffect(function() {\n        isReordering.current = false;\n    });\n    return React__namespace.createElement(Component, tslib.__assign({}, props, {\n        ref: externalRef\n    }), React__namespace.createElement(ReorderContext.Provider, {\n        value: context\n    }, children));\n}\nvar Group = React.forwardRef(ReorderGroup);\nfunction getValue(item) {\n    return item.value;\n}\nfunction compareMin(a, b) {\n    return a.layout.min - b.layout.min;\n}\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */ function useMotionValue(initial) {\n    var value = useConstant(function() {\n        return motionValue(initial);\n    });\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */ var isStatic = React.useContext(MotionConfigContext).isStatic;\n    if (isStatic) {\n        var _a = tslib.__read(React.useState(initial), 2), setLatest_1 = _a[1];\n        React.useEffect(function() {\n            return value.onChange(setLatest_1);\n        }, []);\n    }\n    return value;\n}\nvar isCustomValueType = function(v) {\n    return typeof v === \"object\" && v.mix;\n};\nvar getMixer = function(v) {\n    return isCustomValueType(v) ? v.mix : undefined;\n};\nfunction transform() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    var useImmediate = !Array.isArray(args[0]);\n    var argOffset = useImmediate ? 0 : -1;\n    var inputValue = args[0 + argOffset];\n    var inputRange = args[1 + argOffset];\n    var outputRange = args[2 + argOffset];\n    var options = args[3 + argOffset];\n    var interpolator = popmotion.interpolate(inputRange, outputRange, tslib.__assign({\n        mixer: getMixer(outputRange[0])\n    }, options));\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\nfunction useOnChange(value, callback) {\n    useIsomorphicLayoutEffect(function() {\n        if (isMotionValue(value)) return value.onChange(callback);\n    }, [\n        callback\n    ]);\n}\nfunction useMultiOnChange(values, handler) {\n    useIsomorphicLayoutEffect(function() {\n        var subscriptions = values.map(function(value) {\n            return value.onChange(handler);\n        });\n        return function() {\n            return subscriptions.forEach(function(unsubscribe) {\n                return unsubscribe();\n            });\n        };\n    });\n}\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */ var value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */ var updateValue = function() {\n        return value.set(combineValues());\n    };\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */ updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */ useMultiOnChange(values, function() {\n        return sync__default[\"default\"].update(updateValue, false, true);\n    });\n    return value;\n}\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    var transformer = typeof inputRangeOrTransformer === \"function\" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([\n        input\n    ], function(_a) {\n        var _b = tslib.__read(_a, 1), latest = _b[0];\n        return transformer(latest);\n    });\n}\nfunction useListTransform(values, transformer) {\n    var latest = useConstant(function() {\n        return [];\n    });\n    return useCombineMotionValues(values, function() {\n        latest.length = 0;\n        var numValues = values.length;\n        for(var i = 0; i < numValues; i++){\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\nfunction useDefaultMotionValue(value, defaultValue) {\n    if (defaultValue === void 0) {\n        defaultValue = 0;\n    }\n    return isMotionValue(value) ? value : useMotionValue(defaultValue);\n}\nfunction ReorderItem(_a, externalRef) {\n    var children = _a.children, style = _a.style, value = _a.value, _b = _a.as, as = _b === void 0 ? \"li\" : _b, onDrag = _a.onDrag, _c = _a.layout, layout = _c === void 0 ? true : _c, props = tslib.__rest(_a, [\n        \"children\",\n        \"style\",\n        \"value\",\n        \"as\",\n        \"onDrag\",\n        \"layout\"\n    ]);\n    var Component = useConstant(function() {\n        return motion(as);\n    });\n    var context = React.useContext(ReorderContext);\n    var point = {\n        x: useDefaultMotionValue(style === null || style === void 0 ? void 0 : style.x),\n        y: useDefaultMotionValue(style === null || style === void 0 ? void 0 : style.y)\n    };\n    var zIndex = useTransform([\n        point.x,\n        point.y\n    ], function(_a) {\n        var _b = tslib.__read(_a, 2), latestX = _b[0], latestY = _b[1];\n        return latestX || latestY ? 1 : \"unset\";\n    });\n    var measuredLayout = React.useRef(null);\n    heyListen.invariant(Boolean(context), \"Reorder.Item must be a child of Reorder.Group\");\n    var _d = context, axis = _d.axis, registerItem = _d.registerItem, updateOrder = _d.updateOrder;\n    React.useEffect(function() {\n        registerItem(value, measuredLayout.current);\n    }, [\n        context\n    ]);\n    return React__namespace.createElement(Component, tslib.__assign({\n        drag: axis\n    }, props, {\n        dragSnapToOrigin: true,\n        style: tslib.__assign(tslib.__assign({}, style), {\n            x: point.x,\n            y: point.y,\n            zIndex: zIndex\n        }),\n        layout: layout,\n        onDrag: function(event, gesturePoint) {\n            var velocity = gesturePoint.velocity;\n            velocity[axis] && updateOrder(value, point[axis].get(), velocity[axis]);\n            onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, gesturePoint);\n        },\n        onLayoutMeasure: function(measured) {\n            measuredLayout.current = measured;\n        },\n        ref: externalRef\n    }), children);\n}\nvar Item = React.forwardRef(ReorderItem);\nvar Reorder = {\n    Group: Group,\n    Item: Item\n};\n/**\n * @public\n */ var domAnimation = tslib.__assign(tslib.__assign({\n    renderer: createDomVisualElement\n}, animations), gestureAnimations);\n/**\n * @public\n */ var domMax = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, domAnimation), drag), layoutFeatures), {\n    projectionNodeConstructor: HTMLProjectionNode\n});\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */ function useMotionTemplate(fragments) {\n    var values = [];\n    for(var _i = 1; _i < arguments.length; _i++){\n        values[_i - 1] = arguments[_i];\n    }\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */ var numFragments = fragments.length;\n    function buildValue() {\n        var output = \"\";\n        for(var i = 0; i < numFragments; i++){\n            output += fragments[i];\n            var value = values[i];\n            if (value) output += values[i].get();\n        }\n        return output;\n    }\n    return useCombineMotionValues(values, buildValue);\n}\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */ function useSpring(source, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    var activeSpringAnimation = React.useRef(null);\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    React.useMemo(function() {\n        return value.attach(function(v, set) {\n            /**\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n             * at that level, but this will work for now\n             */ if (isStatic) return set(v);\n            if (activeSpringAnimation.current) {\n                activeSpringAnimation.current.stop();\n            }\n            activeSpringAnimation.current = popmotion.animate(tslib.__assign(tslib.__assign({\n                from: value.get(),\n                to: v,\n                velocity: value.getVelocity()\n            }, config), {\n                onUpdate: set\n            }));\n            return value.get();\n        });\n    }, [\n        JSON.stringify(config)\n    ]);\n    useOnChange(source, function(v) {\n        return value.set(parseFloat(v));\n    });\n    return value;\n}\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */ function useVelocity(value) {\n    var velocity = useMotionValue(value.getVelocity());\n    React.useEffect(function() {\n        return value.velocityUpdateSubscribers.add(function(newVelocity) {\n            velocity.set(newVelocity);\n        });\n    }, [\n        value\n    ]);\n    return velocity;\n}\nvar createScrollMotionValues = function() {\n    return {\n        scrollX: motionValue(0),\n        scrollY: motionValue(0),\n        scrollXProgress: motionValue(0),\n        scrollYProgress: motionValue(0)\n    };\n};\nfunction useScroll(_a) {\n    if (_a === void 0) {\n        _a = {};\n    }\n    var container = _a.container, target = _a.target, options = tslib.__rest(_a, [\n        \"container\",\n        \"target\"\n    ]);\n    var values = useConstant(createScrollMotionValues);\n    useIsomorphicLayoutEffect(function() {\n        return dom.scroll(function(_a) {\n            var x = _a.x, y = _a.y;\n            values.scrollX.set(x.current);\n            values.scrollXProgress.set(x.progress);\n            values.scrollY.set(y.current);\n            values.scrollYProgress.set(y.progress);\n        }, tslib.__assign(tslib.__assign({}, options), {\n            container: (container === null || container === void 0 ? void 0 : container.current) || undefined,\n            target: (target === null || target === void 0 ? void 0 : target.current) || undefined\n        }));\n    }, []);\n    return values;\n}\nfunction useElementScroll(ref) {\n    warnOnce(false, \"useElementScroll is deprecated. Convert to useScroll({ container: ref }).\");\n    return useScroll({\n        container: ref\n    });\n}\nfunction useViewportScroll() {\n    warnOnce(false, \"useViewportScroll is deprecated. Convert to useScroll().\");\n    return useScroll();\n}\nvar getCurrentTime = typeof performance !== \"undefined\" ? function() {\n    return performance.now();\n} : function() {\n    return Date.now();\n};\nfunction useAnimationFrame(callback) {\n    var initialTimestamp = useConstant(getCurrentTime);\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    React.useEffect(function() {\n        if (isStatic) return;\n        var provideTimeSinceStart = function(_a) {\n            var timestamp = _a.timestamp;\n            callback(timestamp - initialTimestamp);\n        };\n        sync__default[\"default\"].update(provideTimeSinceStart, true);\n        return function() {\n            return sync.cancelSync.update(provideTimeSinceStart);\n        };\n    }, [\n        callback\n    ]);\n}\nfunction useTime() {\n    var time = useMotionValue(0);\n    useAnimationFrame(function(t) {\n        return time.set(t);\n    });\n    return time;\n}\n/**\n * @public\n */ function animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */ var hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */ var pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */ var subscribers = new Set();\n    var controls = {\n        subscribe: function(visualElement) {\n            subscribers.add(visualElement);\n            return function() {\n                return void subscribers.delete(visualElement);\n            };\n        },\n        start: function(definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */ if (hasMounted) {\n                var animations_1 = [];\n                subscribers.forEach(function(visualElement) {\n                    animations_1.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride: transitionOverride\n                    }));\n                });\n                return Promise.all(animations_1);\n            } else {\n                return new Promise(function(resolve) {\n                    pendingAnimations.push({\n                        animation: [\n                            definition,\n                            transitionOverride\n                        ],\n                        resolve: resolve\n                    });\n                });\n            }\n        },\n        set: function(definition) {\n            heyListen.invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach(function(visualElement) {\n                setValues(visualElement, definition);\n            });\n        },\n        stop: function() {\n            subscribers.forEach(function(visualElement) {\n                stopAnimation(visualElement);\n            });\n        },\n        mount: function() {\n            hasMounted = true;\n            pendingAnimations.forEach(function(_a) {\n                var animation = _a.animation, resolve = _a.resolve;\n                controls.start.apply(controls, tslib.__spreadArray([], tslib.__read(animation), false)).then(resolve);\n            });\n            return function() {\n                hasMounted = false;\n                controls.stop();\n            };\n        }\n    };\n    return controls;\n}\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */ function useAnimationControls() {\n    var controls = useConstant(animationControls);\n    React.useEffect(controls.mount, []);\n    return controls;\n}\nvar useAnimation = useAnimationControls;\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */ function useCycle() {\n    var items = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        items[_i] = arguments[_i];\n    }\n    var index = React.useRef(0);\n    var _a = tslib.__read(React.useState(items[index.current]), 2), item = _a[0], setItem = _a[1];\n    var runCycle = React.useCallback(function(next) {\n        index.current = typeof next !== \"number\" ? popmotion.wrap(0, items.length, index.current + 1) : next;\n        setItem(items[index.current]);\n    }, tslib.__spreadArray([\n        items.length\n    ], tslib.__read(items), false));\n    return [\n        item,\n        runCycle\n    ];\n}\nfunction useInView(ref, _a) {\n    var _b = _a === void 0 ? {} : _a, root = _b.root, margin = _b.margin, amount = _b.amount, _c = _b.once, once = _c === void 0 ? false : _c;\n    var _d = tslib.__read(React.useState(false), 2), isInView = _d[0], setInView = _d[1];\n    React.useEffect(function() {\n        var _a;\n        if (!ref.current || once && isInView) return;\n        var onEnter = function() {\n            setInView(true);\n            return once ? undefined : function() {\n                return setInView(false);\n            };\n        };\n        var options = {\n            root: (_a = root === null || root === void 0 ? void 0 : root.current) !== null && _a !== void 0 ? _a : undefined,\n            margin: margin,\n            amount: amount === \"some\" ? \"any\" : amount\n        };\n        return dom.inView(ref.current, onEnter, options);\n    }, [\n        root,\n        ref,\n        margin,\n        once\n    ]);\n    return isInView;\n}\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */ var DragControls = /** @class */ function() {\n    function DragControls() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */ DragControls.prototype.subscribe = function(controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        return function() {\n            return _this.componentControls.delete(controls);\n        };\n    };\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */ DragControls.prototype.start = function(event, options) {\n        this.componentControls.forEach(function(controls) {\n            controls.start(event.nativeEvent || event, options);\n        });\n    };\n    return DragControls;\n}();\nvar createDragControls = function() {\n    return new DragControls();\n};\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */ function useDragControls() {\n    return useConstant(createDragControls);\n}\nfunction useInstantLayoutTransition() {\n    return startTransition;\n}\nfunction startTransition(cb) {\n    if (!rootProjectionNode.current) return;\n    rootProjectionNode.current.isUpdating = false;\n    rootProjectionNode.current.blockUpdate();\n    cb === null || cb === void 0 ? void 0 : cb();\n}\nfunction useInstantTransition() {\n    var _a = tslib.__read(useForceUpdate(), 2), forceUpdate = _a[0], forcedRenderCount = _a[1];\n    var startInstantLayoutTransition = useInstantLayoutTransition();\n    React.useEffect(function() {\n        /**\n         * Unblock after two animation frames, otherwise this will unblock too soon.\n         */ sync__default[\"default\"].postRender(function() {\n            return sync__default[\"default\"].postRender(function() {\n                return instantAnimationState.current = false;\n            });\n        });\n    }, [\n        forcedRenderCount\n    ]);\n    return function(callback) {\n        startInstantLayoutTransition(function() {\n            instantAnimationState.current = true;\n            forceUpdate();\n            callback();\n        });\n    };\n}\nfunction useResetProjection() {\n    var reset = React__namespace.useCallback(function() {\n        var root = rootProjectionNode.current;\n        if (!root) return;\n        root.resetTree();\n    }, []);\n    return reset;\n}\nvar createObject = function() {\n    return {};\n};\nvar stateVisualElement = visualElement({\n    build: function() {},\n    measureViewportBox: createBox,\n    resetTransform: function() {},\n    restoreTransform: function() {},\n    removeValueFromRenderState: function() {},\n    render: function() {},\n    scrapeMotionValuesFromProps: createObject,\n    readValueFromInstance: function(_state, key, options) {\n        return options.initialState[key] || 0;\n    },\n    makeTargetAnimatable: function(element, _a) {\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\n            \"transition\",\n            \"transitionEnd\"\n        ]);\n        var origin = getOrigin(target, transition || {}, element);\n        checkTargetForNewValues(element, target, origin);\n        return tslib.__assign({\n            transition: transition,\n            transitionEnd: transitionEnd\n        }, target);\n    }\n});\nvar useVisualState = makeUseVisualState({\n    scrapeMotionValuesFromProps: createObject,\n    createRenderState: createObject\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n */ function useAnimatedState(initialState) {\n    var _a = tslib.__read(React.useState(initialState), 2), animationState = _a[0], setAnimationState = _a[1];\n    var visualState = useVisualState({}, false);\n    var element = useConstant(function() {\n        return stateVisualElement({\n            props: {},\n            visualState: visualState\n        }, {\n            initialState: initialState\n        });\n    });\n    React.useEffect(function() {\n        element.mount({});\n        return element.unmount;\n    }, [\n        element\n    ]);\n    React.useEffect(function() {\n        element.setProps({\n            onUpdate: function(v) {\n                setAnimationState(tslib.__assign({}, v));\n            }\n        });\n    }, [\n        setAnimationState,\n        element\n    ]);\n    var startAnimation = useConstant(function() {\n        return function(animationDefinition) {\n            return animateVisualElement(element, animationDefinition);\n        };\n    });\n    return [\n        animationState,\n        startAnimation\n    ];\n}\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nvar maxScale = 100000;\nvar invertScale = function(scale) {\n    return scale > 0.001 ? 1 / scale : maxScale;\n};\nvar hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @deprecated\n */ function useInvertedScale(scale) {\n    var parentScaleX = useMotionValue(1);\n    var parentScaleY = useMotionValue(1);\n    var visualElement = useVisualElementContext();\n    heyListen.invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n    heyListen.warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n    hasWarned = true;\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    } else if (visualElement) {\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\n    }\n    var scaleX = useTransform(parentScaleX, invertScale);\n    var scaleY = useTransform(parentScaleY, invertScale);\n    return {\n        scaleX: scaleX,\n        scaleY: scaleY\n    };\n}\nexports.AnimatePresence = AnimatePresence;\nexports.AnimateSharedLayout = AnimateSharedLayout;\nexports.DeprecatedLayoutGroupContext = DeprecatedLayoutGroupContext;\nexports.DragControls = DragControls;\nexports.FlatTree = FlatTree;\nexports.LayoutGroup = LayoutGroup;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyMotion = LazyMotion;\nexports.MotionConfig = MotionConfig;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionContext = MotionContext;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.Reorder = Reorder;\nexports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;\nexports.addPointerEvent = addPointerEvent;\nexports.addScaleCorrector = addScaleCorrector;\nexports.animate = animate;\nexports.animateVisualElement = animateVisualElement;\nexports.animationControls = animationControls;\nexports.animations = animations;\nexports.calcLength = calcLength;\nexports.checkTargetForNewValues = checkTargetForNewValues;\nexports.createBox = createBox;\nexports.createDomMotionComponent = createDomMotionComponent;\nexports.createMotionComponent = createMotionComponent;\nexports.domAnimation = domAnimation;\nexports.domMax = domMax;\nexports.filterProps = filterProps;\nexports.isBrowser = isBrowser;\nexports.isDragActive = isDragActive;\nexports.isMotionValue = isMotionValue;\nexports.isValidMotionProp = isValidMotionProp;\nexports.m = m;\nexports.makeUseVisualState = makeUseVisualState;\nexports.motion = motion;\nexports.motionValue = motionValue;\nexports.resolveMotionValue = resolveMotionValue;\nexports.transform = transform;\nexports.useAnimation = useAnimation;\nexports.useAnimationControls = useAnimationControls;\nexports.useAnimationFrame = useAnimationFrame;\nexports.useCycle = useCycle;\nexports.useDeprecatedAnimatedState = useAnimatedState;\nexports.useDeprecatedInvertedScale = useInvertedScale;\nexports.useDomEvent = useDomEvent;\nexports.useDragControls = useDragControls;\nexports.useElementScroll = useElementScroll;\nexports.useForceUpdate = useForceUpdate;\nexports.useInView = useInView;\nexports.useInstantLayoutTransition = useInstantLayoutTransition;\nexports.useInstantTransition = useInstantTransition;\nexports.useIsPresent = useIsPresent;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.useMotionTemplate = useMotionTemplate;\nexports.useMotionValue = useMotionValue;\nexports.usePresence = usePresence;\nexports.useReducedMotion = useReducedMotion;\nexports.useReducedMotionConfig = useReducedMotionConfig;\nexports.useResetProjection = useResetProjection;\nexports.useScroll = useScroll;\nexports.useSpring = useSpring;\nexports.useTime = useTime;\nexports.useTransform = useTransform;\nexports.useUnmountEffect = useUnmountEffect;\nexports.useVelocity = useVelocity;\nexports.useViewportScroll = useViewportScroll;\nexports.useVisualElementContext = useVisualElementContext;\nexports.visualElement = visualElement;\nexports.wrapHandler = wrapHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZnJhbWVyLW1vdGlvbkA2LjUuMV9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMF9fcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlFLFlBQVlGLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlHLGtCQUFrQkgsbUJBQU9BLENBQUM7QUFDOUIsSUFBSUksWUFBWUosbUJBQU9BLENBQUM7QUFDeEIsSUFBSUssT0FBT0wsbUJBQU9BLENBQUM7QUFDbkIsSUFBSU0sTUFBTU4sbUJBQU9BLENBQUM7QUFFbEIsU0FBU08sc0JBQXVCQyxDQUFDO0lBQUksT0FBT0EsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBYUEsSUFBSUEsSUFBSTtRQUFFLFdBQVdBO0lBQUU7QUFBRztBQUVqSCxTQUFTQyxrQkFBa0JELENBQUM7SUFDeEIsSUFBSUEsS0FBS0EsRUFBRUUsVUFBVSxFQUFFLE9BQU9GO0lBQzlCLElBQUlHLElBQUloQixPQUFPaUIsTUFBTSxDQUFDO0lBQ3RCLElBQUlKLEdBQUc7UUFDSGIsT0FBT2tCLElBQUksQ0FBQ0wsR0FBR00sT0FBTyxDQUFDLFNBQVVDLENBQUM7WUFDOUIsSUFBSUEsTUFBTSxXQUFXO2dCQUNqQixJQUFJQyxJQUFJckIsT0FBT3NCLHdCQUF3QixDQUFDVCxHQUFHTztnQkFDM0NwQixPQUFPQyxjQUFjLENBQUNlLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDcENHLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1YsQ0FBQyxDQUFDTyxFQUFFO29CQUFFO2dCQUNwQztZQUNKO1FBQ0o7SUFDSjtJ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QUcyZ0Q7QUFDcEIzZ0QsaUJBQWlCLEdBQUdrZ0Q7QUFDcEJsZ0QsZUFBZSxHQUFHc2hEO0FBQ2xCdGhELG9CQUFvQixHQUFHOCtDO0FBQ3ZCOStDLHdCQUF3QixHQUFHMmdCO0FBQzNCM2dCLG1CQUFtQixHQUFHb2dEO0FBQ3RCcGdELHlCQUF5QixHQUFHOGdEO0FBQzVCOWdELCtCQUErQixHQUFHNEU7QUFDbEM1RSxxQkFBcUIsR0FBRzJEO0FBQ3hCM0QsbUJBQW1CLEdBQUdnZSIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGVyaWFsLXRhaWx3aW5kLWRhc2hib2FyZC1uZXh0anMtcHJvLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZyYW1lci1tb3Rpb25ANi41LjFfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjBfX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2Nqcy9pbmRleC5qcz83N2U0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgaGV5TGlzdGVuID0gcmVxdWlyZSgnaGV5LWxpc3RlbicpO1xudmFyIHN0eWxlVmFsdWVUeXBlcyA9IHJlcXVpcmUoJ3N0eWxlLXZhbHVlLXR5cGVzJyk7XG52YXIgcG9wbW90aW9uID0gcmVxdWlyZSgncG9wbW90aW9uJyk7XG52YXIgc3luYyA9IHJlcXVpcmUoJ2ZyYW1lc3luYycpO1xudmFyIGRvbSA9IHJlcXVpcmUoJ0Btb3Rpb25vbmUvZG9tJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xudmFyIFJlYWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShSZWFjdCk7XG52YXIgc3luY19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koc3luYyk7XG5cbi8qKlxuICogQnJvd3Nlci1zYWZlIHVzYWdlIG9mIHByb2Nlc3NcbiAqL1xudmFyIGRlZmF1bHRFbnZpcm9ubWVudCA9IFwicHJvZHVjdGlvblwiO1xudmFyIGVudiA9IHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52ID09PSB1bmRlZmluZWRcbiAgICA/IGRlZmF1bHRFbnZpcm9ubWVudFxuICAgIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgZGVmYXVsdEVudmlyb25tZW50O1xuXG52YXIgY3JlYXRlRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChwcm9wTmFtZXMpIHsgcmV0dXJuICh7XG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIHByb3BOYW1lcy5zb21lKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhIXByb3BzW25hbWVdOyB9KTsgfSxcbn0pOyB9O1xudmFyIGZlYXR1cmVEZWZpbml0aW9ucyA9IHtcbiAgICBtZWFzdXJlTGF5b3V0OiBjcmVhdGVEZWZpbml0aW9uKFtcImxheW91dFwiLCBcImxheW91dElkXCIsIFwiZHJhZ1wiXSksXG4gICAgYW5pbWF0aW9uOiBjcmVhdGVEZWZpbml0aW9uKFtcbiAgICAgICAgXCJhbmltYXRlXCIsXG4gICAgICAgIFwiZXhpdFwiLFxuICAgICAgICBcInZhcmlhbnRzXCIsXG4gICAgICAgIFwid2hpbGVIb3ZlclwiLFxuICAgICAgICBcIndoaWxlVGFwXCIsXG4gICAgICAgIFwid2hpbGVGb2N1c1wiLFxuICAgICAgICBcIndoaWxlRHJhZ1wiLFxuICAgICAgICBcIndoaWxlSW5WaWV3XCIsXG4gICAgXSksXG4gICAgZXhpdDogY3JlYXRlRGVmaW5pdGlvbihbXCJleGl0XCJdKSxcbiAgICBkcmFnOiBjcmVhdGVEZWZpbml0aW9uKFtcImRyYWdcIiwgXCJkcmFnQ29udHJvbHNcIl0pLFxuICAgIGZvY3VzOiBjcmVhdGVEZWZpbml0aW9uKFtcIndoaWxlRm9jdXNcIl0pLFxuICAgIGhvdmVyOiBjcmVhdGVEZWZpbml0aW9uKFtcIndoaWxlSG92ZXJcIiwgXCJvbkhvdmVyU3RhcnRcIiwgXCJvbkhvdmVyRW5kXCJdKSxcbiAgICB0YXA6IGNyZWF0ZURlZmluaXRpb24oW1wid2hpbGVUYXBcIiwgXCJvblRhcFwiLCBcIm9uVGFwU3RhcnRcIiwgXCJvblRhcENhbmNlbFwiXSksXG4gICAgcGFuOiBjcmVhdGVEZWZpbml0aW9uKFtcbiAgICAgICAgXCJvblBhblwiLFxuICAgICAgICBcIm9uUGFuU3RhcnRcIixcbiAgICAgICAgXCJvblBhblNlc3Npb25TdGFydFwiLFxuICAgICAgICBcIm9uUGFuRW5kXCIsXG4gICAgXSksXG4gICAgaW5WaWV3OiBjcmVhdGVEZWZpbml0aW9uKFtcbiAgICAgICAgXCJ3aGlsZUluVmlld1wiLFxuICAgICAgICBcIm9uVmlld3BvcnRFbnRlclwiLFxuICAgICAgICBcIm9uVmlld3BvcnRMZWF2ZVwiLFxuICAgIF0pLFxufTtcbmZ1bmN0aW9uIGxvYWRGZWF0dXJlcyhmZWF0dXJlcykge1xuICAgIGZvciAodmFyIGtleSBpbiBmZWF0dXJlcykge1xuICAgICAgICBpZiAoZmVhdHVyZXNba2V5XSA9PT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoa2V5ID09PSBcInByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgZmVhdHVyZURlZmluaXRpb25zLnByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IgPSBmZWF0dXJlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmVhdHVyZURlZmluaXRpb25zW2tleV0uQ29tcG9uZW50ID0gZmVhdHVyZXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIExhenlDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7IHN0cmljdDogZmFsc2UgfSk7XG5cbnZhciBmZWF0dXJlTmFtZXMgPSBPYmplY3Qua2V5cyhmZWF0dXJlRGVmaW5pdGlvbnMpO1xudmFyIG51bUZlYXR1cmVzID0gZmVhdHVyZU5hbWVzLmxlbmd0aDtcbi8qKlxuICogTG9hZCBmZWF0dXJlcyB2aWEgcmVuZGVybGVzcyBjb21wb25lbnRzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBNb3Rpb25Qcm9wcy5cbiAqL1xuZnVuY3Rpb24gdXNlRmVhdHVyZXMocHJvcHMsIHZpc3VhbEVsZW1lbnQsIHByZWxvYWRlZEZlYXR1cmVzKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgdmFyIGxhenlDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChMYXp5Q29udGV4dCk7XG4gICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSBpbiBkZXZlbG9wbWVudCBtb2RlLCBjaGVjayB0byBtYWtlIHN1cmUgd2UncmUgbm90IHJlbmRlcmluZyBhIG1vdGlvbiBjb21wb25lbnRcbiAgICAgKiBhcyBhIGNoaWxkIG9mIExhenlNb3Rpb24sIGFzIHRoaXMgd2lsbCBicmVhayB0aGUgZmlsZS1zaXplIGJlbmVmaXRzIG9mIHVzaW5nIGl0LlxuICAgICAqL1xuICAgIGlmIChlbnYgIT09IFwicHJvZHVjdGlvblwiICYmIHByZWxvYWRlZEZlYXR1cmVzICYmIGxhenlDb250ZXh0LnN0cmljdCkge1xuICAgICAgICBoZXlMaXN0ZW4uaW52YXJpYW50KGZhbHNlLCBcIllvdSBoYXZlIHJlbmRlcmVkIGEgYG1vdGlvbmAgY29tcG9uZW50IHdpdGhpbiBhIGBMYXp5TW90aW9uYCBjb21wb25lbnQuIFRoaXMgd2lsbCBicmVhayB0cmVlIHNoYWtpbmcuIEltcG9ydCBhbmQgcmVuZGVyIGEgYG1gIGNvbXBvbmVudCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1GZWF0dXJlczsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lXzEgPSBmZWF0dXJlTmFtZXNbaV07XG4gICAgICAgIHZhciBfYSA9IGZlYXR1cmVEZWZpbml0aW9uc1tuYW1lXzFdLCBpc0VuYWJsZWQgPSBfYS5pc0VuYWJsZWQsIENvbXBvbmVudCA9IF9hLkNvbXBvbmVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0IG1pZ2h0IGJlIHBvc3NpYmxlIGluIHRoZSBmdXR1cmUgdG8gdXNlIHRoaXMgbW9tZW50IHRvXG4gICAgICAgICAqIGR5bmFtaWNhbGx5IHJlcXVlc3QgZnVuY3Rpb25hbGl0eS4gSW4gaW5pdGlhbCB0ZXN0cyB0aGlzXG4gICAgICAgICAqIHdhcyBwcm9kdWNpbmcgYSBsb3Qgb2YgZHVwbGljYXRpb24gYW1vbmdzdCBidW5kbGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzRW5hYmxlZChwcm9wcykgJiYgQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHRzbGliLl9fYXNzaWduKHsga2V5OiBuYW1lXzEgfSwgcHJvcHMsIHsgdmlzdWFsRWxlbWVudDogdmlzdWFsRWxlbWVudCB9KSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbnZhciBNb3Rpb25Db25maWdDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gICAgdHJhbnNmb3JtUGFnZVBvaW50OiBmdW5jdGlvbiAocCkgeyByZXR1cm4gcDsgfSxcbiAgICBpc1N0YXRpYzogZmFsc2UsXG4gICAgcmVkdWNlZE1vdGlvbjogXCJuZXZlclwiLFxufSk7XG5cbnZhciBNb3Rpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG5mdW5jdGlvbiB1c2VWaXN1YWxFbGVtZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db250ZXh0KS52aXN1YWxFbGVtZW50O1xufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFByZXNlbmNlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gaXNCcm93c2VyID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuXG4vLyBEb2VzIHRoaXMgZGV2aWNlIHByZWZlciByZWR1Y2VkIG1vdGlvbj8gUmV0dXJucyBgbnVsbGAgc2VydmVyLXNpZGUuXG52YXIgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSB7IGN1cnJlbnQ6IG51bGwgfTtcbnZhciBoYXNEZXRlY3RlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCkge1xuICAgIGhhc0RldGVjdGVkID0gdHJ1ZTtcbiAgICBpZiAoIWlzQnJvd3NlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICB2YXIgbW90aW9uTWVkaWFRdWVyeV8xID0gd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIik7XG4gICAgICAgIHZhciBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPSBtb3Rpb25NZWRpYVF1ZXJ5XzEubWF0Y2hlcyk7XG4gICAgICAgIH07XG4gICAgICAgIG1vdGlvbk1lZGlhUXVlcnlfMS5hZGRMaXN0ZW5lcihzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMpO1xuICAgICAgICBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEEgaG9vayB0aGF0IHJldHVybnMgYHRydWVgIGlmIHdlIHNob3VsZCBiZSB1c2luZyByZWR1Y2VkIG1vdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBkZXZpY2UncyBSZWR1Y2VkIE1vdGlvbiBzZXR0aW5nLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IGNoYW5nZXMgdG8geW91ciBVSSBiYXNlZCBvbiBSZWR1Y2VkIE1vdGlvbi4gRm9yIGluc3RhbmNlLCByZXBsYWNpbmcgbW90aW9uLXNpY2tuZXNzIGluZHVjaW5nXG4gKiBgeGAvYHlgIGFuaW1hdGlvbnMgd2l0aCBgb3BhY2l0eWAsIGRpc2FibGluZyB0aGUgYXV0b3BsYXkgb2YgYmFja2dyb3VuZCB2aWRlb3MsIG9yIHR1cm5pbmcgb2ZmIHBhcmFsbGF4IG1vdGlvbi5cbiAqXG4gKiBJdCB3aWxsIGFjdGl2ZWx5IHJlc3BvbmQgdG8gY2hhbmdlcyBhbmQgcmUtcmVuZGVyIHlvdXIgY29tcG9uZW50cyB3aXRoIHRoZSBsYXRlc3Qgc2V0dGluZy5cbiAqXG4gKiBgYGBqc3hcbiAqIGV4cG9ydCBmdW5jdGlvbiBTaWRlYmFyKHsgaXNPcGVuIH0pIHtcbiAqICAgY29uc3Qgc2hvdWxkUmVkdWNlTW90aW9uID0gdXNlUmVkdWNlZE1vdGlvbigpXG4gKiAgIGNvbnN0IGNsb3NlZFggPSBzaG91bGRSZWR1Y2VNb3Rpb24gPyAwIDogXCItMTAwJVwiXG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxtb3Rpb24uZGl2IGFuaW1hdGU9e3tcbiAqICAgICAgIG9wYWNpdHk6IGlzT3BlbiA/IDEgOiAwLFxuICogICAgICAgeDogaXNPcGVuID8gMCA6IGNsb3NlZFhcbiAqICAgICB9fSAvPlxuICogICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJuIGJvb2xlYW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVJlZHVjZWRNb3Rpb24oKSB7XG4gICAgLyoqXG4gICAgICogTGF6eSBpbml0aWFsaXNhdGlvbiBvZiBwcmVmZXJzUmVkdWNlZE1vdGlvblxuICAgICAqL1xuICAgICFoYXNEZXRlY3RlZCAmJiBpbml0UHJlZmVyc1JlZHVjZWRNb3Rpb24oKTtcbiAgICB2YXIgX2EgPSB0c2xpYi5fX3JlYWQoUmVhY3QudXNlU3RhdGUocHJlZmVyc1JlZHVjZWRNb3Rpb24uY3VycmVudCksIDEpLCBzaG91bGRSZWR1Y2VNb3Rpb24gPSBfYVswXTtcbiAgICAvKipcbiAgICAgKiBUT0RPIFNlZSBpZiBwZW9wbGUgbWlzcyBhdXRvbWF0aWNhbGx5IHVwZGF0aW5nIHNob3VsZFJlZHVjZU1vdGlvbiBzZXR0aW5nXG4gICAgICovXG4gICAgcmV0dXJuIHNob3VsZFJlZHVjZU1vdGlvbjtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZWRNb3Rpb25Db25maWcoKSB7XG4gICAgdmFyIHJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlID0gdXNlUmVkdWNlZE1vdGlvbigpO1xuICAgIHZhciByZWR1Y2VkTW90aW9uID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KS5yZWR1Y2VkTW90aW9uO1xuICAgIGlmIChyZWR1Y2VkTW90aW9uID09PSBcIm5ldmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWR1Y2VkTW90aW9uID09PSBcImFsd2F5c1wiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXNlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHZpc3VhbFN0YXRlLCBwcm9wcywgY3JlYXRlVmlzdWFsRWxlbWVudCkge1xuICAgIHZhciBsYXp5Q29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTGF6eUNvbnRleHQpO1xuICAgIHZhciBwYXJlbnQgPSB1c2VWaXN1YWxFbGVtZW50Q29udGV4dCgpO1xuICAgIHZhciBwcmVzZW5jZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgdmFyIHNob3VsZFJlZHVjZU1vdGlvbiA9IHVzZVJlZHVjZWRNb3Rpb25Db25maWcoKTtcbiAgICB2YXIgdmlzdWFsRWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZih1bmRlZmluZWQpO1xuICAgIC8qKlxuICAgICAqIElmIHdlIGhhdmVuJ3QgcHJlbG9hZGVkIGEgcmVuZGVyZXIsIGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIG9uZSBsYXp5LWxvYWRlZFxuICAgICAqL1xuICAgIGlmICghY3JlYXRlVmlzdWFsRWxlbWVudClcbiAgICAgICAgY3JlYXRlVmlzdWFsRWxlbWVudCA9IGxhenlDb250ZXh0LnJlbmRlcmVyO1xuICAgIGlmICghdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50ICYmIGNyZWF0ZVZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50ID0gY3JlYXRlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgICAgICAgIHZpc3VhbFN0YXRlOiB2aXN1YWxTdGF0ZSxcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgcHJlc2VuY2VJZDogcHJlc2VuY2VDb250ZXh0ID09PSBudWxsIHx8IHByZXNlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VuY2VDb250ZXh0LmlkLFxuICAgICAgICAgICAgYmxvY2tJbml0aWFsQW5pbWF0aW9uOiAocHJlc2VuY2VDb250ZXh0ID09PSBudWxsIHx8IHByZXNlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VuY2VDb250ZXh0LmluaXRpYWwpID09PSBmYWxzZSxcbiAgICAgICAgICAgIHNob3VsZFJlZHVjZU1vdGlvbjogc2hvdWxkUmVkdWNlTW90aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgfSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbmltYXRlQ2hhbmdlcygpO1xuICAgIH0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50Lm5vdGlmeVVubW91bnQoKTsgfTsgfSwgW10pO1xuICAgIHJldHVybiB2aXN1YWxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1JlZk9iamVjdChyZWYpIHtcbiAgICByZXR1cm4gKHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZiwgXCJjdXJyZW50XCIpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVmIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBoeWRyYXRlcyB0aGUgcHJvdmlkZWRcbiAqIGV4dGVybmFsIHJlZiBhbmQgVmlzdWFsRWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gdXNlTW90aW9uUmVmKHZpc3VhbFN0YXRlLCB2aXN1YWxFbGVtZW50LCBleHRlcm5hbFJlZikge1xuICAgIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpbnN0YW5jZSAmJiAoKF9hID0gdmlzdWFsU3RhdGUubW91bnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHZpc3VhbFN0YXRlLCBpbnN0YW5jZSkpO1xuICAgICAgICBpZiAodmlzdWFsRWxlbWVudCkge1xuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICA/IHZpc3VhbEVsZW1lbnQubW91bnQoaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgOiB2aXN1YWxFbGVtZW50LnVubW91bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0ZXJuYWxSZWYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZXJuYWxSZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsUmVmKGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmT2JqZWN0KGV4dGVybmFsUmVmKSkge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFxuICAgIC8qKlxuICAgICAqIE9ubHkgcGFzcyBhIG5ldyByZWYgY2FsbGJhY2sgdG8gUmVhY3QgaWYgd2UndmUgcmVjZWl2ZWQgYSB2aXN1YWwgZWxlbWVudFxuICAgICAqIGZhY3RvcnkuIE90aGVyd2lzZSB3ZSdsbCBiZSBtb3VudGluZy9yZW1vdW50aW5nIGV2ZXJ5IHRpbWUgZXh0ZXJuYWxSZWZcbiAgICAgKiBvciBvdGhlciBkZXBlbmRlbmNpZXMgY2hhbmdlLlxuICAgICAqL1xuICAgIFt2aXN1YWxFbGVtZW50XSk7XG59XG5cbi8qKlxuICogRGVjaWRlcyBpZiB0aGUgc3VwcGxpZWQgdmFyaWFibGUgaXMgYW4gYXJyYXkgb2YgdmFyaWFudCBsYWJlbHNcbiAqL1xuZnVuY3Rpb24gaXNWYXJpYW50TGFiZWxzKHYpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTtcbn1cbi8qKlxuICogRGVjaWRlcyBpZiB0aGUgc3VwcGxpZWQgdmFyaWFibGUgaXMgdmFyaWFudCBsYWJlbFxuICovXG5mdW5jdGlvbiBpc1ZhcmlhbnRMYWJlbCh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiIHx8IGlzVmFyaWFudExhYmVscyh2KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbGF0ZXN0IHN0YXRlIG9mIGV2ZXJ5IE1vdGlvblZhbHVlIG9uIGEgVmlzdWFsRWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50KHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgY3VycmVudCA9IHt9O1xuICAgIHZpc3VhbEVsZW1lbnQuZm9yRWFjaFZhbHVlKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IHJldHVybiAoY3VycmVudFtrZXldID0gdmFsdWUuZ2V0KCkpOyB9KTtcbiAgICByZXR1cm4gY3VycmVudDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbGF0ZXN0IHZlbG9jaXR5IG9mIGV2ZXJ5IE1vdGlvblZhbHVlIG9uIGEgVmlzdWFsRWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRWZWxvY2l0eSQxKHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgdmVsb2NpdHkgPSB7fTtcbiAgICB2aXN1YWxFbGVtZW50LmZvckVhY2hWYWx1ZShmdW5jdGlvbiAodmFsdWUsIGtleSkgeyByZXR1cm4gKHZlbG9jaXR5W2tleV0gPSB2YWx1ZS5nZXRWZWxvY2l0eSgpKTsgfSk7XG4gICAgcmV0dXJuIHZlbG9jaXR5O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24sIGN1c3RvbSwgY3VycmVudFZhbHVlcywgY3VycmVudFZlbG9jaXR5KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChjdXJyZW50VmFsdWVzID09PSB2b2lkIDApIHsgY3VycmVudFZhbHVlcyA9IHt9OyB9XG4gICAgaWYgKGN1cnJlbnRWZWxvY2l0eSA9PT0gdm9pZCAwKSB7IGN1cnJlbnRWZWxvY2l0eSA9IHt9OyB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHZhcmlhbnQgZGVmaW5pdGlvbiBpcyBhIGZ1bmN0aW9uLCByZXNvbHZlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uKGN1c3RvbSAhPT0gbnVsbCAmJiBjdXN0b20gIT09IHZvaWQgMCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgY3VycmVudFZhbHVlcywgY3VycmVudFZlbG9jaXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHZhcmlhbnQgZGVmaW5pdGlvbiBpcyBhIHZhcmlhbnQgbGFiZWwsIG9yXG4gICAgICogdGhlIGZ1bmN0aW9uIHJldHVybmVkIGEgdmFyaWFudCBsYWJlbCwgcmVzb2x2ZS5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IChfYSA9IHByb3BzLnZhcmlhbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbZGVmaW5pdGlvbl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UndmUgcmVzb2x2ZWQgYm90aCBmdW5jdGlvbnMgYW5kIHZhcmlhbnQgbGFiZWxzLFxuICAgICAqIGJ1dCB0aGUgcmVzb2x2ZWQgdmFyaWFudCBsYWJlbCBtaWdodCBpdHNlbGYgaGF2ZSBiZWVuIGEgZnVuY3Rpb24uXG4gICAgICogSWYgc28sIHJlc29sdmUuIFRoaXMgY2FuIG9ubHkgaGF2ZSByZXR1cm5lZCBhIHZhbGlkIHRhcmdldCBvYmplY3QuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24oY3VzdG9tICE9PSBudWxsICYmIGN1c3RvbSAhPT0gdm9pZCAwID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBjdXJyZW50VmFsdWVzLCBjdXJyZW50VmVsb2NpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIGN1c3RvbSkge1xuICAgIHZhciBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICByZXR1cm4gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24sIGN1c3RvbSAhPT0gbnVsbCAmJiBjdXN0b20gIT09IHZvaWQgMCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgZ2V0Q3VycmVudCh2aXN1YWxFbGVtZW50KSwgZ2V0VmVsb2NpdHkkMSh2aXN1YWxFbGVtZW50KSk7XG59XG5mdW5jdGlvbiBjaGVja0lmQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHR5cGVvZiAoKF9hID0gcHJvcHMuYW5pbWF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0KSA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLmluaXRpYWwpIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLmFuaW1hdGUpIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLndoaWxlSG92ZXIpIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLndoaWxlRHJhZykgfHxcbiAgICAgICAgaXNWYXJpYW50TGFiZWwocHJvcHMud2hpbGVUYXApIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLndoaWxlRm9jdXMpIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLmV4aXQpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZWYXJpYW50Tm9kZShwcm9wcykge1xuICAgIHJldHVybiBCb29sZWFuKGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSB8fCBwcm9wcy52YXJpYW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmVlVmFyaWFudHMocHJvcHMsIGNvbnRleHQpIHtcbiAgICBpZiAoY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpKSB7XG4gICAgICAgIHZhciBpbml0aWFsID0gcHJvcHMuaW5pdGlhbCwgYW5pbWF0ZSA9IHByb3BzLmFuaW1hdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbml0aWFsOiBpbml0aWFsID09PSBmYWxzZSB8fCBpc1ZhcmlhbnRMYWJlbChpbml0aWFsKVxuICAgICAgICAgICAgICAgID8gaW5pdGlhbFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZTogaXNWYXJpYW50TGFiZWwoYW5pbWF0ZSkgPyBhbmltYXRlIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UgPyBjb250ZXh0IDoge307XG59XG5cbmZ1bmN0aW9uIHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMpIHtcbiAgICB2YXIgX2EgPSBnZXRDdXJyZW50VHJlZVZhcmlhbnRzKHByb3BzLCBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpKSwgaW5pdGlhbCA9IF9hLmluaXRpYWwsIGFuaW1hdGUgPSBfYS5hbmltYXRlO1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IGluaXRpYWw6IGluaXRpYWwsIGFuaW1hdGU6IGFuaW1hdGUgfSk7IH0sIFt2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGluaXRpYWwpLCB2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGFuaW1hdGUpXSk7XG59XG5mdW5jdGlvbiB2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KHByb3ApIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwcm9wKSA/IHByb3Auam9pbihcIiBcIikgOiBwcm9wO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25zdGFudCB2YWx1ZSBvdmVyIHRoZSBsaWZlY3ljbGUgb2YgYSBjb21wb25lbnQuXG4gKlxuICogRXZlbiBpZiBgdXNlTWVtb2AgaXMgcHJvdmlkZWQgYW4gZW1wdHkgYXJyYXkgYXMgaXRzIGZpbmFsIGFyZ3VtZW50LCBpdCBkb2Vzbid0IG9mZmVyXG4gKiBhIGd1YXJhbnRlZSB0aGF0IGl0IHdvbid0IHJlLXJ1biBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBsYXRlciBvbi4gQnkgdXNpbmcgYHVzZUNvbnN0YW50YFxuICogeW91IGNhbiBlbnN1cmUgdGhhdCBpbml0aWFsaXNlcnMgZG9uJ3QgZXhlY3V0ZSB0d2ljZSBvciBtb3JlLlxuICovXG5mdW5jdGlvbiB1c2VDb25zdGFudChpbml0KSB7XG4gICAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBpbml0KCk7XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cblxuLyoqXG4gKiBUaGlzIHNob3VsZCBvbmx5IGV2ZXIgYmUgbW9kaWZpZWQgb24gdGhlIGNsaWVudCBvdGhlcndpc2UgaXQnbGxcbiAqIHBlcnNpc3QgdGhyb3VnaCBzZXJ2ZXIgcmVxdWVzdHMuIElmIHdlIG5lZWQgaW5zdGFuY2VkIHN0YXRlcyB3ZVxuICogY291bGQgbGF6eS1pbml0IHZpYSByb290LlxuICovXG52YXIgZ2xvYmFsUHJvamVjdGlvblN0YXRlID0ge1xuICAgIC8qKlxuICAgICAqIEdsb2JhbCBmbGFnIGFzIHRvIHdoZXRoZXIgdGhlIHRyZWUgaGFzIGFuaW1hdGVkIHNpbmNlIHRoZSBsYXN0IHRpbWVcbiAgICAgKiB3ZSByZXNpemVkIHRoZSB3aW5kb3dcbiAgICAgKi9cbiAgICBoYXNBbmltYXRlZFNpbmNlUmVzaXplOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFdlIHNldCB0aGlzIHRvIHRydWUgb25jZSwgb24gdGhlIGZpcnN0IHVwZGF0ZS4gQW55IG5vZGVzIGFkZGVkIHRvIHRoZSB0cmVlIGJleW9uZCB0aGF0XG4gICAgICogdXBkYXRlIHdpbGwgYmUgZ2l2ZW4gYSBgZGF0YS1wcm9qZWN0aW9uLWlkYCBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgaGFzRXZlclVwZGF0ZWQ6IGZhbHNlLFxufTtcblxudmFyIGlkJDEgPSAxO1xuZnVuY3Rpb24gdXNlUHJvamVjdGlvbklkKCkge1xuICAgIHJldHVybiB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzRXZlclVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCQxKys7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxudmFyIExheW91dEdyb3VwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuXG4vKipcbiAqIEludGVybmFsLCBleHBvcnRlZCBvbmx5IGZvciB1c2FnZSBpbiBGcmFtZXJcbiAqL1xudmFyIFN3aXRjaExheW91dEdyb3VwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuXG5mdW5jdGlvbiB1c2VQcm9qZWN0aW9uKHByb2plY3Rpb25JZCwgX2EsIHZpc3VhbEVsZW1lbnQsIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIGxheW91dElkID0gX2EubGF5b3V0SWQsIGxheW91dCA9IF9hLmxheW91dCwgZHJhZyA9IF9hLmRyYWcsIGRyYWdDb25zdHJhaW50cyA9IF9hLmRyYWdDb25zdHJhaW50cywgbGF5b3V0U2Nyb2xsID0gX2EubGF5b3V0U2Nyb2xsO1xuICAgIHZhciBpbml0aWFsUHJvbW90aW9uQ29uZmlnID0gUmVhY3QudXNlQ29udGV4dChTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIGlmICghUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciB8fFxuICAgICAgICAhdmlzdWFsRWxlbWVudCB8fFxuICAgICAgICAodmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LnByb2plY3Rpb24pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uID0gbmV3IFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IocHJvamVjdGlvbklkLCB2aXN1YWxFbGVtZW50LmdldExhdGVzdFZhbHVlcygpLCAoX2IgPSB2aXN1YWxFbGVtZW50LnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnByb2plY3Rpb24pO1xuICAgIHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi5zZXRPcHRpb25zKHtcbiAgICAgICAgbGF5b3V0SWQ6IGxheW91dElkLFxuICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgYWx3YXlzTWVhc3VyZUxheW91dDogQm9vbGVhbihkcmFnKSB8fCAoZHJhZ0NvbnN0cmFpbnRzICYmIGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykpLFxuICAgICAgICB2aXN1YWxFbGVtZW50OiB2aXN1YWxFbGVtZW50LFxuICAgICAgICBzY2hlZHVsZVJlbmRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmlzdWFsRWxlbWVudC5zY2hlZHVsZVJlbmRlcigpOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETzogVXBkYXRlIG9wdGlvbnMgaW4gYW4gZWZmZWN0LiBUaGlzIGNvdWxkIGJlIHRyaWNreSBhcyBpdCdsbCBiZSB0b28gbGF0ZVxuICAgICAgICAgKiB0byB1cGRhdGUgYnkgdGhlIHRpbWUgbGF5b3V0IGFuaW1hdGlvbnMgcnVuLlxuICAgICAgICAgKiBXZSBhbHNvIG5lZWQgdG8gZml4IHRoaXMgc2FmZVRvUmVtb3ZlIGJ5IGxpbmtpbmcgaXQgdXAgdG8gdGhlIG9uZSByZXR1cm5lZCBieSB1c2VQcmVzZW5jZSxcbiAgICAgICAgICogZW5zdXJpbmcgaXQgZ2V0cyBjYWxsZWQgaWYgdGhlcmUncyBubyBwb3RlbnRpYWwgbGF5b3V0IGFuaW1hdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRpb25UeXBlOiB0eXBlb2YgbGF5b3V0ID09PSBcInN0cmluZ1wiID8gbGF5b3V0IDogXCJib3RoXCIsXG4gICAgICAgIGluaXRpYWxQcm9tb3Rpb25Db25maWc6IGluaXRpYWxQcm9tb3Rpb25Db25maWcsXG4gICAgICAgIGxheW91dFNjcm9sbDogbGF5b3V0U2Nyb2xsLFxuICAgIH0pO1xufVxuXG52YXIgVmlzdWFsRWxlbWVudEhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFZpc3VhbEVsZW1lbnRIYW5kbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZpc3VhbEVsZW1lbnRIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB2aXN1YWwgZWxlbWVudCBwcm9wcyBhcyBzb29uIGFzIHdlIGtub3cgdGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0ZWQuXG4gICAgICovXG4gICAgVmlzdWFsRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVByb3BzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBWaXN1YWxFbGVtZW50SGFuZGxlci5wcm90b3R5cGUudXBkYXRlUHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50LCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICBpZiAodmlzdWFsRWxlbWVudClcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0UHJvcHMocHJvcHMpO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfTtcbiAgICByZXR1cm4gVmlzdWFsRWxlbWVudEhhbmRsZXI7XG59KFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5Db21wb25lbnQpKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBgbW90aW9uYCBjb21wb25lbnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgQ29tcG9uZW50IGFyZ3VtZW50LCB3aGljaCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIChpZSBcImRpdlwiXG4gKiBmb3IgYG1vdGlvbi5kaXZgKSwgb3IgYW4gYWN0dWFsIFJlYWN0IGNvbXBvbmVudC5cbiAqXG4gKiBBbG9uZ3NpZGUgdGhpcyBpcyBhIGNvbmZpZyBvcHRpb24gd2hpY2ggcHJvdmlkZXMgYSB3YXkgb2YgcmVuZGVyaW5nIHRoZSBwcm92aWRlZFxuICogY29tcG9uZW50IFwib2ZmbGluZVwiLCBvciBvdXRzaWRlIHRoZSBSZWFjdCByZW5kZXIgY3ljbGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vdGlvbkNvbXBvbmVudChfYSkge1xuICAgIHZhciBwcmVsb2FkZWRGZWF0dXJlcyA9IF9hLnByZWxvYWRlZEZlYXR1cmVzLCBjcmVhdGVWaXN1YWxFbGVtZW50ID0gX2EuY3JlYXRlVmlzdWFsRWxlbWVudCwgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciA9IF9hLnByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsIHVzZVJlbmRlciA9IF9hLnVzZVJlbmRlciwgdXNlVmlzdWFsU3RhdGUgPSBfYS51c2VWaXN1YWxTdGF0ZSwgQ29tcG9uZW50ID0gX2EuQ29tcG9uZW50O1xuICAgIHByZWxvYWRlZEZlYXR1cmVzICYmIGxvYWRGZWF0dXJlcyhwcmVsb2FkZWRGZWF0dXJlcyk7XG4gICAgZnVuY3Rpb24gTW90aW9uQ29tcG9uZW50KHByb3BzLCBleHRlcm5hbFJlZikge1xuICAgICAgICB2YXIgbGF5b3V0SWQgPSB1c2VMYXlvdXRJZChwcm9wcyk7XG4gICAgICAgIHByb3BzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHByb3BzKSwgeyBsYXlvdXRJZDogbGF5b3V0SWQgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSByZW5kZXJpbmcgaW4gYSBzdGF0aWMgZW52aXJvbm1lbnQsIHdlIG9ubHkgdmlzdWFsbHkgdXBkYXRlIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogYXMgYSByZXN1bHQgb2YgYSBSZWFjdC1yZXJlbmRlciByYXRoZXIgdGhhbiBpbnRlcmFjdGlvbnMgb3IgYW5pbWF0aW9ucy4gVGhpc1xuICAgICAgICAgKiBtZWFucyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgYWRkaXRpb25hbCBtZW1vcnkgc3RydWN0dXJlcyBsaWtlIFZpc3VhbEVsZW1lbnQsXG4gICAgICAgICAqIG9yIGFueSBnZXN0dXJlL2FuaW1hdGlvbiBmZWF0dXJlcy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjb25maWcgPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpO1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSBudWxsO1xuICAgICAgICB2YXIgY29udGV4dCA9IHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgdW5pcXVlIHByb2plY3Rpb24gSUQgZm9yIHRoaXMgY29tcG9uZW50LiBJZiBhIG5ldyBjb21wb25lbnQgaXMgYWRkZWRcbiAgICAgICAgICogZHVyaW5nIGEgbGF5b3V0IGFuaW1hdGlvbiB3ZSdsbCB1c2UgdGhpcyB0byBxdWVyeSB0aGUgRE9NIGFuZCBoeWRyYXRlIGl0cyByZWYgZWFybHksIGFsbG93aW5nXG4gICAgICAgICAqIHVzIHRvIG1lYXN1cmUgaXQgYXMgc29vbiBhcyBhbnkgbGF5b3V0IGVmZmVjdCBmbHVzaGVzIHBlbmRpbmcgbGF5b3V0IGFuaW1hdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBlcmZvcm1hbmNlIG5vdGU6IEl0J2QgYmUgYmV0dGVyIG5vdCB0byBoYXZlIHRvIHNlYXJjaCB0aGUgRE9NIGZvciB0aGVzZSBlbGVtZW50cy5cbiAgICAgICAgICogRm9yIG5ld2x5LWVudGVyaW5nIGNvbXBvbmVudHMgaXQgY291bGQgYmUgZW5vdWdoIHRvIG9ubHkgY29ycmVjdCB0cmVlU2NhbGUsIGluIHdoaWNoXG4gICAgICAgICAqIGNhc2Ugd2UgY291bGQgbW91bnQgaW4gYSBzY2FsZS1jb3JyZWN0aW9uIG1vZGUuIFRoaXMgd291bGRuJ3QgYmUgZW5vdWdoIGZvclxuICAgICAgICAgKiBzaGFyZWQgZWxlbWVudCB0cmFuc2l0aW9ucyBob3dldmVyLiBQZXJoYXBzIGZvciB0aG9zZSB3ZSBjb3VsZCByZXZlcnQgdG8gYSByb290IG5vZGVcbiAgICAgICAgICogdGhhdCBnZXRzIGZvcmNlUmVuZGVyZWQgYW5kIGxheW91dCBhbmltYXRpb25zIGFyZSB0cmlnZ2VyZWQgb24gaXRzIGxheW91dCBlZmZlY3QuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcHJvamVjdGlvbklkID0gY29uZmlnLmlzU3RhdGljID8gdW5kZWZpbmVkIDogdXNlUHJvamVjdGlvbklkKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHZpc3VhbFN0YXRlID0gdXNlVmlzdWFsU3RhdGUocHJvcHMsIGNvbmZpZy5pc1N0YXRpYyk7XG4gICAgICAgIGlmICghY29uZmlnLmlzU3RhdGljICYmIGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgYSBWaXN1YWxFbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudC4gQSBWaXN1YWxFbGVtZW50IHByb3ZpZGVzIGEgY29tbW9uXG4gICAgICAgICAgICAgKiBpbnRlcmZhY2UgdG8gcmVuZGVyZXItc3BlY2lmaWMgQVBJcyAoaWUgRE9NL1RocmVlLmpzIGV0YykgYXMgd2VsbCBhc1xuICAgICAgICAgICAgICogcHJvdmlkaW5nIGEgd2F5IG9mIHJlbmRlcmluZyB0byB0aGVzZSBBUElzIG91dHNpZGUgb2YgdGhlIFJlYWN0IHJlbmRlciBsb29wXG4gICAgICAgICAgICAgKiBmb3IgbW9yZSBwZXJmb3JtYW50IGFuaW1hdGlvbnMgYW5kIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb250ZXh0LnZpc3VhbEVsZW1lbnQgPSB1c2VWaXN1YWxFbGVtZW50KENvbXBvbmVudCwgdmlzdWFsU3RhdGUsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjb25maWcpLCBwcm9wcyksIGNyZWF0ZVZpc3VhbEVsZW1lbnQpO1xuICAgICAgICAgICAgdXNlUHJvamVjdGlvbihwcm9qZWN0aW9uSWQsIHByb3BzLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQsIHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IgfHxcbiAgICAgICAgICAgICAgICBmZWF0dXJlRGVmaW5pdGlvbnMucHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExvYWQgTW90aW9uIGdlc3R1cmUgYW5kIGFuaW1hdGlvbiBmZWF0dXJlcy4gVGhlc2UgYXJlIHJlbmRlcmVkIGFzIHJlbmRlcmxlc3NcbiAgICAgICAgICAgICAqIGNvbXBvbmVudHMgc28gZWFjaCBmZWF0dXJlIGNhbiBvcHRpb25hbGx5IG1ha2UgdXNlIG9mIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmZWF0dXJlcyA9IHVzZUZlYXR1cmVzKHByb3BzLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQsIHByZWxvYWRlZEZlYXR1cmVzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vdW50IG9yZGVyIGFuZCBoaWVyYXJjaHkgaXMgc3BlY2lmaWMgdG8gZW5zdXJlIG91ciBlbGVtZW50IHJlZlxuICAgICAgICAgKiBpcyBoeWRyYXRlZCBieSB0aGUgdGltZSBmZWF0dXJlcyBmaXJlIHRoZWlyIGVmZmVjdHMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChWaXN1YWxFbGVtZW50SGFuZGxlciwgeyB2aXN1YWxFbGVtZW50OiBjb250ZXh0LnZpc3VhbEVsZW1lbnQsIHByb3BzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgY29uZmlnKSwgcHJvcHMpIH0sXG4gICAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChNb3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIHVzZVJlbmRlcihDb21wb25lbnQsIHByb3BzLCBwcm9qZWN0aW9uSWQsIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgY29udGV4dC52aXN1YWxFbGVtZW50LCBleHRlcm5hbFJlZiksIHZpc3VhbFN0YXRlLCBjb25maWcuaXNTdGF0aWMsIGNvbnRleHQudmlzdWFsRWxlbWVudCkpKSk7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5mb3J3YXJkUmVmKE1vdGlvbkNvbXBvbmVudCk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRJZChfYSkge1xuICAgIHZhciBfYjtcbiAgICB2YXIgbGF5b3V0SWQgPSBfYS5sYXlvdXRJZDtcbiAgICB2YXIgbGF5b3V0R3JvdXBJZCA9IChfYiA9IFJlYWN0LnVzZUNvbnRleHQoTGF5b3V0R3JvdXBDb250ZXh0KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkO1xuICAgIHJldHVybiBsYXlvdXRHcm91cElkICYmIGxheW91dElkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBsYXlvdXRHcm91cElkICsgXCItXCIgKyBsYXlvdXRJZFxuICAgICAgICA6IGxheW91dElkO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW55IFJlYWN0IGNvbXBvbmVudCBpbnRvIGEgYG1vdGlvbmAgY29tcG9uZW50LiBUaGUgcHJvdmlkZWQgY29tcG9uZW50XG4gKiAqKm11c3QqKiB1c2UgYFJlYWN0LmZvcndhcmRSZWZgIHRvIHRoZSB1bmRlcmx5aW5nIERPTSBjb21wb25lbnQgeW91IHdhbnQgdG8gYW5pbWF0ZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGNvbnN0IENvbXBvbmVudCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAqICAgcmV0dXJuIDxkaXYgcmVmPXtyZWZ9IC8+XG4gKiB9KVxuICpcbiAqIGNvbnN0IE1vdGlvbkNvbXBvbmVudCA9IG1vdGlvbihDb21wb25lbnQpXG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vdGlvblByb3h5KGNyZWF0ZUNvbmZpZykge1xuICAgIGZ1bmN0aW9uIGN1c3RvbShDb21wb25lbnQsIGN1c3RvbU1vdGlvbkNvbXBvbmVudENvbmZpZykge1xuICAgICAgICBpZiAoY3VzdG9tTW90aW9uQ29tcG9uZW50Q29uZmlnID09PSB2b2lkIDApIHsgY3VzdG9tTW90aW9uQ29tcG9uZW50Q29uZmlnID0ge307IH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1vdGlvbkNvbXBvbmVudChjcmVhdGVDb25maWcoQ29tcG9uZW50LCBjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGNhY2hlIG9mIGdlbmVyYXRlZCBgbW90aW9uYCBjb21wb25lbnRzLCBlLmcgYG1vdGlvbi5kaXZgLCBgbW90aW9uLmlucHV0YCBldGMuXG4gICAgICogUmF0aGVyIHRoYW4gZ2VuZXJhdGluZyB0aGVtIGFuZXcgZXZlcnkgcmVuZGVyLlxuICAgICAqL1xuICAgIHZhciBjb21wb25lbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gbmV3IFByb3h5KGN1c3RvbSwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gYG1vdGlvbmAgaXMgcmVmZXJlbmNlZCB3aXRoIGEgcHJvcDogYG1vdGlvbi5kaXZgLCBgbW90aW9uLmlucHV0YCBldGMuXG4gICAgICAgICAqIFRoZSBwcm9wIG5hbWUgaXMgcGFzc2VkIHRocm91Z2ggYXMgYGtleWAgYW5kIHdlIGNhbiB1c2UgdGhhdCB0byBnZW5lcmF0ZSBhIGBtb3Rpb25gXG4gICAgICAgICAqIERPTSBjb21wb25lbnQgd2l0aCB0aGF0IG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChfdGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBlbGVtZW50IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGNvbXBvbmVudCBjYWNoZSwgY3JlYXRlIGl0IGFuZCBjYWNoZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFjb21wb25lbnRDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudENhY2hlLnNldChrZXksIGN1c3RvbShrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRDYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBXZSBrZWVwIHRoZXNlIGxpc3RlZCBzZXBlcmF0ZWx5IGFzIHdlIHVzZSB0aGUgbG93ZXJjYXNlIHRhZyBuYW1lcyBhcyBwYXJ0XG4gKiBvZiB0aGUgcnVudGltZSBidW5kbGUgdG8gZGV0ZWN0IFNWRyBjb21wb25lbnRzXG4gKi9cbnZhciBsb3dlcmNhc2VTVkdFbGVtZW50cyA9IFtcbiAgICBcImFuaW1hdGVcIixcbiAgICBcImNpcmNsZVwiLFxuICAgIFwiZGVmc1wiLFxuICAgIFwiZGVzY1wiLFxuICAgIFwiZWxsaXBzZVwiLFxuICAgIFwiZ1wiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcImxpbmVcIixcbiAgICBcImZpbHRlclwiLFxuICAgIFwibWFya2VyXCIsXG4gICAgXCJtYXNrXCIsXG4gICAgXCJtZXRhZGF0YVwiLFxuICAgIFwicGF0aFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwicG9seWdvblwiLFxuICAgIFwicG9seWxpbmVcIixcbiAgICBcInJlY3RcIixcbiAgICBcInN0b3BcIixcbiAgICBcInN2Z1wiLFxuICAgIFwic3dpdGNoXCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcInRleHRcIixcbiAgICBcInRzcGFuXCIsXG4gICAgXCJ1c2VcIixcbiAgICBcInZpZXdcIixcbl07XG5cbmZ1bmN0aW9uIGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIGlmIChcbiAgICAvKipcbiAgICAgKiBJZiBpdCdzIG5vdCBhIHN0cmluZywgaXQncyBhIGN1c3RvbSBSZWFjdCBjb21wb25lbnQuIEN1cnJlbnRseSB3ZSBvbmx5IHN1cHBvcnRcbiAgICAgKiBIVE1MIGN1c3RvbSBSZWFjdCBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIHR5cGVvZiBDb21wb25lbnQgIT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGl0IGNvbnRhaW5zIGEgZGFzaCwgdGhlIGVsZW1lbnQgaXMgYSBjdXN0b20gSFRNTCB3ZWJjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBDb21wb25lbnQuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXG4gICAgLyoqXG4gICAgICogSWYgaXQncyBpbiBvdXIgbGlzdCBvZiBsb3dlcmNhc2UgU1ZHIHRhZ3MsIGl0J3MgYW4gU1ZHIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGxvd2VyY2FzZVNWR0VsZW1lbnRzLmluZGV4T2YoQ29tcG9uZW50KSA+IC0xIHx8XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBpdCBjb250YWlucyBhIGNhcGl0YWwgbGV0dGVyLCBpdCdzIGFuIFNWRyBjb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIC9bQS1aXS8udGVzdChDb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBzY2FsZUNvcnJlY3RvcnMgPSB7fTtcbmZ1bmN0aW9uIGFkZFNjYWxlQ29ycmVjdG9yKGNvcnJlY3RvcnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHNjYWxlQ29ycmVjdG9ycywgY29ycmVjdG9ycyk7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGFsbCB0cmFuc2Zvcm1hYmxlIGF4ZXMuIFdlJ2xsIHVzZSB0aGlzIGxpc3QgdG8gZ2VuZXJhdGVkIGEgdmVyc2lvblxuICogb2YgZWFjaCBheGVzIGZvciBlYWNoIHRyYW5zZm9ybS5cbiAqL1xudmFyIHRyYW5zZm9ybUF4ZXMgPSBbXCJcIiwgXCJYXCIsIFwiWVwiLCBcIlpcIl07XG4vKipcbiAqIEFuIG9yZGVyZWQgYXJyYXkgb2YgZWFjaCB0cmFuc2Zvcm1hYmxlIHZhbHVlLiBCeSBkZWZhdWx0LCB0cmFuc2Zvcm0gdmFsdWVzXG4gKiB3aWxsIGJlIHNvcnRlZCB0byB0aGlzIG9yZGVyLlxuICovXG52YXIgb3JkZXIgPSBbXCJ0cmFuc2xhdGVcIiwgXCJzY2FsZVwiLCBcInJvdGF0ZVwiLCBcInNrZXdcIl07XG4vKipcbiAqIEdlbmVyYXRlIGEgbGlzdCBvZiBldmVyeSBwb3NzaWJsZSB0cmFuc2Zvcm0ga2V5LlxuICovXG52YXIgdHJhbnNmb3JtUHJvcHMgPSBbXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLCBcInhcIiwgXCJ5XCIsIFwielwiXTtcbm9yZGVyLmZvckVhY2goZnVuY3Rpb24gKG9wZXJhdGlvbktleSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1BeGVzLmZvckVhY2goZnVuY3Rpb24gKGF4ZXNLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb3BzLnB1c2gob3BlcmF0aW9uS2V5ICsgYXhlc0tleSk7XG4gICAgfSk7XG59KTtcbi8qKlxuICogQSBmdW5jdGlvbiB0byB1c2Ugd2l0aCBBcnJheS5zb3J0IHRvIHNvcnQgdHJhbnNmb3JtIGtleXMgYnkgdGhlaXIgZGVmYXVsdCBvcmRlci5cbiAqL1xuZnVuY3Rpb24gc29ydFRyYW5zZm9ybVByb3BzKGEsIGIpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUHJvcHMuaW5kZXhPZihhKSAtIHRyYW5zZm9ybVByb3BzLmluZGV4T2YoYik7XG59XG4vKipcbiAqIEEgcXVpY2sgbG9va3VwIGZvciB0cmFuc2Zvcm0gcHJvcHMuXG4gKi9cbnZhciB0cmFuc2Zvcm1Qcm9wU2V0ID0gbmV3IFNldCh0cmFuc2Zvcm1Qcm9wcyk7XG5mdW5jdGlvbiBpc1RyYW5zZm9ybVByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVByb3BTZXQuaGFzKGtleSk7XG59XG4vKipcbiAqIEEgcXVpY2sgbG9va3VwIGZvciB0cmFuc2Zvcm0gb3JpZ2luIHByb3BzXG4gKi9cbnZhciB0cmFuc2Zvcm1PcmlnaW5Qcm9wcyA9IG5ldyBTZXQoW1wib3JpZ2luWFwiLCBcIm9yaWdpbllcIiwgXCJvcmlnaW5aXCJdKTtcbmZ1bmN0aW9uIGlzVHJhbnNmb3JtT3JpZ2luUHJvcChrZXkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtT3JpZ2luUHJvcHMuaGFzKGtleSk7XG59XG5cbmZ1bmN0aW9uIGlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBfYSkge1xuICAgIHZhciBsYXlvdXQgPSBfYS5sYXlvdXQsIGxheW91dElkID0gX2EubGF5b3V0SWQ7XG4gICAgcmV0dXJuIChpc1RyYW5zZm9ybVByb3Aoa2V5KSB8fFxuICAgICAgICBpc1RyYW5zZm9ybU9yaWdpblByb3Aoa2V5KSB8fFxuICAgICAgICAoKGxheW91dCB8fCBsYXlvdXRJZCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKCEhc2NhbGVDb3JyZWN0b3JzW2tleV0gfHwga2V5ID09PSBcIm9wYWNpdHlcIikpKTtcbn1cblxudmFyIGlzTW90aW9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUuZ2V0VmVsb2NpdHkpO1xufTtcblxudmFyIHRyYW5zbGF0ZUFsaWFzID0ge1xuICAgIHg6IFwidHJhbnNsYXRlWFwiLFxuICAgIHk6IFwidHJhbnNsYXRlWVwiLFxuICAgIHo6IFwidHJhbnNsYXRlWlwiLFxuICAgIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBcInBlcnNwZWN0aXZlXCIsXG59O1xuLyoqXG4gKiBCdWlsZCBhIENTUyB0cmFuc2Zvcm0gc3R5bGUgZnJvbSBpbmRpdmlkdWFsIHgveS9zY2FsZSBldGMgcHJvcGVydGllcy5cbiAqXG4gKiBUaGlzIG91dHB1dHMgd2l0aCBhIGRlZmF1bHQgb3JkZXIgb2YgdHJhbnNmb3Jtcy9zY2FsZXMvcm90YXRpb25zLCB0aGlzIGNhbiBiZSBjdXN0b21pc2VkIGJ5XG4gKiBwcm92aWRpbmcgYSB0cmFuc2Zvcm1UZW1wbGF0ZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYnVpbGRUcmFuc2Zvcm0oX2EsIF9iLCB0cmFuc2Zvcm1Jc0RlZmF1bHQsIHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgdmFyIHRyYW5zZm9ybSA9IF9hLnRyYW5zZm9ybSwgdHJhbnNmb3JtS2V5cyA9IF9hLnRyYW5zZm9ybUtleXM7XG4gICAgdmFyIF9jID0gX2IuZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24sIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgX2QgPSBfYi5hbGxvd1RyYW5zZm9ybU5vbmUsIGFsbG93VHJhbnNmb3JtTm9uZSA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2Q7XG4gICAgLy8gVGhlIHRyYW5zZm9ybSBzdHJpbmcgd2UncmUgZ29pbmcgdG8gYnVpbGQgaW50by5cbiAgICB2YXIgdHJhbnNmb3JtU3RyaW5nID0gXCJcIjtcbiAgICAvLyBUcmFuc2Zvcm0ga2V5cyBpbnRvIHRoZWlyIGRlZmF1bHQgb3JkZXIgLSB0aGlzIHdpbGwgZGV0ZXJtaW5lIHRoZSBvdXRwdXQgb3JkZXIuXG4gICAgdHJhbnNmb3JtS2V5cy5zb3J0KHNvcnRUcmFuc2Zvcm1Qcm9wcyk7XG4gICAgLy8gVHJhY2sgd2hldGhlciB0aGUgZGVmaW5lZCB0cmFuc2Zvcm0gaGFzIGEgZGVmaW5lZCB6IHNvIHdlIGRvbid0IGFkZCBhXG4gICAgLy8gc2Vjb25kIHRvIGVuYWJsZSBoYXJkd2FyZSBhY2NlbGVyYXRpb25cbiAgICB2YXIgdHJhbnNmb3JtSGFzWiA9IGZhbHNlO1xuICAgIC8vIExvb3Agb3ZlciBlYWNoIHRyYW5zZm9ybSBhbmQgYnVpbGQgdGhlbSBpbnRvIHRyYW5zZm9ybVN0cmluZ1xuICAgIHZhciBudW1UcmFuc2Zvcm1LZXlzID0gdHJhbnNmb3JtS2V5cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UcmFuc2Zvcm1LZXlzOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHRyYW5zZm9ybUtleXNbaV07XG4gICAgICAgIHRyYW5zZm9ybVN0cmluZyArPSBcIlwiLmNvbmNhdCh0cmFuc2xhdGVBbGlhc1trZXldIHx8IGtleSwgXCIoXCIpLmNvbmNhdCh0cmFuc2Zvcm1ba2V5XSwgXCIpIFwiKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJ6XCIpXG4gICAgICAgICAgICB0cmFuc2Zvcm1IYXNaID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0cmFuc2Zvcm1IYXNaICYmIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uKSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmluZyArPSBcInRyYW5zbGF0ZVooMClcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmluZyA9IHRyYW5zZm9ybVN0cmluZy50cmltKCk7XG4gICAgfVxuICAgIC8vIElmIHdlIGhhdmUgYSBjdXN0b20gYHRyYW5zZm9ybWAgdGVtcGxhdGUsIHBhc3Mgb3VyIHRyYW5zZm9ybSB2YWx1ZXMgYW5kXG4gICAgLy8gZ2VuZXJhdGVkIHRyYW5zZm9ybVN0cmluZyB0byB0aGF0IGJlZm9yZSByZXR1cm5pbmdcbiAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nID0gdHJhbnNmb3JtVGVtcGxhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm1Jc0RlZmF1bHQgPyBcIlwiIDogdHJhbnNmb3JtU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWxsb3dUcmFuc2Zvcm1Ob25lICYmIHRyYW5zZm9ybUlzRGVmYXVsdCkge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybVN0cmluZztcbn1cbi8qKlxuICogQnVpbGQgYSB0cmFuc2Zvcm1PcmlnaW4gc3R5bGUuIFVzZXMgdGhlIHNhbWUgZGVmYXVsdHMgYXMgdGhlIGJyb3dzZXIgZm9yXG4gKiB1bmRlZmluZWQgb3JpZ2lucy5cbiAqL1xuZnVuY3Rpb24gYnVpbGRUcmFuc2Zvcm1PcmlnaW4oX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5vcmlnaW5YLCBvcmlnaW5YID0gX2IgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfYiwgX2MgPSBfYS5vcmlnaW5ZLCBvcmlnaW5ZID0gX2MgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfYywgX2QgPSBfYS5vcmlnaW5aLCBvcmlnaW5aID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZDtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQob3JpZ2luWCwgXCIgXCIpLmNvbmNhdChvcmlnaW5ZLCBcIiBcIikuY29uY2F0KG9yaWdpblopO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQga2V5IGlzIGEgQ1NTIHZhcmlhYmxlXG4gKi9cbmZ1bmN0aW9uIGlzQ1NTVmFyaWFibGUkMShrZXkpIHtcbiAgICByZXR1cm4ga2V5LnN0YXJ0c1dpdGgoXCItLVwiKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlZCBhIHZhbHVlIGFuZCBhIFZhbHVlVHlwZSwgcmV0dXJucyB0aGUgdmFsdWUgYXMgdGhhdCB2YWx1ZSB0eXBlLlxuICovXG52YXIgZ2V0VmFsdWVBc1R5cGUgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB0eXBlLnRyYW5zZm9ybSh2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbn07XG5cbnZhciBpbnQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgc3R5bGVWYWx1ZVR5cGVzLm51bWJlciksIHsgdHJhbnNmb3JtOiBNYXRoLnJvdW5kIH0pO1xuXG52YXIgbnVtYmVyVmFsdWVUeXBlcyA9IHtcbiAgICAvLyBCb3JkZXIgcHJvcHNcbiAgICBib3JkZXJXaWR0aDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGJvcmRlclRvcFdpZHRoOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgYm9yZGVyUmlnaHRXaWR0aDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGJvcmRlckJvdHRvbVdpZHRoOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgYm9yZGVyTGVmdFdpZHRoOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgYm9yZGVyUmFkaXVzOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgcmFkaXVzOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgYm9yZGVyVG9wTGVmdFJhZGl1czogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgLy8gUG9zaXRpb25pbmcgcHJvcHNcbiAgICB3aWR0aDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIG1heFdpZHRoOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgaGVpZ2h0OiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgbWF4SGVpZ2h0OiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgc2l6ZTogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHRvcDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHJpZ2h0OiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgYm90dG9tOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgbGVmdDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIC8vIFNwYWNpbmcgcHJvcHNcbiAgICBwYWRkaW5nOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgcGFkZGluZ1RvcDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHBhZGRpbmdSaWdodDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHBhZGRpbmdCb3R0b206IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBwYWRkaW5nTGVmdDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIG1hcmdpbjogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIG1hcmdpblRvcDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIG1hcmdpblJpZ2h0OiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgbWFyZ2luQm90dG9tOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgbWFyZ2luTGVmdDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIC8vIFRyYW5zZm9ybSBwcm9wc1xuICAgIHJvdGF0ZTogc3R5bGVWYWx1ZVR5cGVzLmRlZ3JlZXMsXG4gICAgcm90YXRlWDogc3R5bGVWYWx1ZVR5cGVzLmRlZ3JlZXMsXG4gICAgcm90YXRlWTogc3R5bGVWYWx1ZVR5cGVzLmRlZ3JlZXMsXG4gICAgcm90YXRlWjogc3R5bGVWYWx1ZVR5cGVzLmRlZ3JlZXMsXG4gICAgc2NhbGU6IHN0eWxlVmFsdWVUeXBlcy5zY2FsZSxcbiAgICBzY2FsZVg6IHN0eWxlVmFsdWVUeXBlcy5zY2FsZSxcbiAgICBzY2FsZVk6IHN0eWxlVmFsdWVUeXBlcy5zY2FsZSxcbiAgICBzY2FsZVo6IHN0eWxlVmFsdWVUeXBlcy5zY2FsZSxcbiAgICBza2V3OiBzdHlsZVZhbHVlVHlwZXMuZGVncmVlcyxcbiAgICBza2V3WDogc3R5bGVWYWx1ZVR5cGVzLmRlZ3JlZXMsXG4gICAgc2tld1k6IHN0eWxlVmFsdWVUeXBlcy5kZWdyZWVzLFxuICAgIGRpc3RhbmNlOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgdHJhbnNsYXRlWDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHRyYW5zbGF0ZVk6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICB0cmFuc2xhdGVaOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgeDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHk6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICB6OiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgcGVyc3BlY3RpdmU6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIG9wYWNpdHk6IHN0eWxlVmFsdWVUeXBlcy5hbHBoYSxcbiAgICBvcmlnaW5YOiBzdHlsZVZhbHVlVHlwZXMucHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgIG9yaWdpblk6IHN0eWxlVmFsdWVUeXBlcy5wcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgb3JpZ2luWjogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIC8vIE1pc2NcbiAgICB6SW5kZXg6IGludCxcbiAgICAvLyBTVkdcbiAgICBmaWxsT3BhY2l0eTogc3R5bGVWYWx1ZVR5cGVzLmFscGhhLFxuICAgIHN0cm9rZU9wYWNpdHk6IHN0eWxlVmFsdWVUeXBlcy5hbHBoYSxcbiAgICBudW1PY3RhdmVzOiBpbnQsXG59O1xuXG5mdW5jdGlvbiBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGUsIHZhcnMgPSBzdGF0ZS52YXJzLCB0cmFuc2Zvcm0gPSBzdGF0ZS50cmFuc2Zvcm0sIHRyYW5zZm9ybUtleXMgPSBzdGF0ZS50cmFuc2Zvcm1LZXlzLCB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW47XG4gICAgLy8gRW1wdHkgdGhlIHRyYW5zZm9ybUtleXMgYXJyYXkuIEFzIHdlJ3JlIHRocm93aW5nIG91dCByZWZzIHRvIGl0cyBpdGVtc1xuICAgIC8vIHRoaXMgbWlnaHQgbm90IGJlIGFzIGNoZWFwIGFzIHN1c3BlY3RlZC4gTWF5YmUgdXNpbmcgdGhlIGFycmF5IGFzIGEgYnVmZmVyXG4gICAgLy8gd2l0aCBhIG1hbnVhbCBpbmNyZW1lbnRhdGlvbiB3b3VsZCBiZSBiZXR0ZXIuXG4gICAgdHJhbnNmb3JtS2V5cy5sZW5ndGggPSAwO1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgd2UgZW5jb3VudGVyIGFueSB0cmFuc2Zvcm0gb3IgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcy5cbiAgICB2YXIgaGFzVHJhbnNmb3JtID0gZmFsc2U7XG4gICAgdmFyIGhhc1RyYW5zZm9ybU9yaWdpbiA9IGZhbHNlO1xuICAgIC8vIERvZXMgdGhlIGNhbGN1bGF0ZWQgdHJhbnNmb3JtIGVzc2VudGlhbGx5IGVxdWFsIFwibm9uZVwiP1xuICAgIHZhciB0cmFuc2Zvcm1Jc05vbmUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIExvb3Agb3ZlciBhbGwgb3VyIGxhdGVzdCBhbmltYXRlZCB2YWx1ZXMgYW5kIGRlY2lkZSB3aGV0aGVyIHRvIGhhbmRsZSB0aGVtXG4gICAgICogYXMgYSBzdHlsZSBvciBDU1MgdmFyaWFibGUuXG4gICAgICpcbiAgICAgKiBUcmFuc2Zvcm1zIGFuZCB0cmFuc2Zvcm0gb3JpZ2lucyBhcmUga2VwdCBzZXBlcmF0ZWx5IGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuXG4gICAgICovXG4gICAgZm9yICh2YXIga2V5IGluIGxhdGVzdFZhbHVlcykge1xuICAgICAgICB2YXIgdmFsdWUgPSBsYXRlc3RWYWx1ZXNba2V5XTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoaXMgaXMgYSBDU1MgdmFyaWFibGUgd2UgZG9uJ3QgZG8gYW55IGZ1cnRoZXIgcHJvY2Vzc2luZy5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc0NTU1ZhcmlhYmxlJDEoa2V5KSkge1xuICAgICAgICAgICAgdmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBpdHMgZGVmYXVsdCB2YWx1ZSB0eXBlLCBpZSAwIC0+IFwiMHB4XCJcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IG51bWJlclZhbHVlVHlwZXNba2V5XTtcbiAgICAgICAgdmFyIHZhbHVlQXNUeXBlID0gZ2V0VmFsdWVBc1R5cGUodmFsdWUsIHZhbHVlVHlwZSk7XG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVByb3Aoa2V5KSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRyYW5zZm9ybSwgZmxhZyB0byBlbmFibGUgZnVydGhlciB0cmFuc2Zvcm0gcHJvY2Vzc2luZ1xuICAgICAgICAgICAgaGFzVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybVtrZXldID0gdmFsdWVBc1R5cGU7XG4gICAgICAgICAgICB0cmFuc2Zvcm1LZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkga25vdyB3ZSBoYXZlIGEgbm9uLWRlZmF1bHQgdHJhbnNmb3JtLCBlYXJseSByZXR1cm5cbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtSXNOb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIGEgZGVmYXVsdCB0cmFuc2Zvcm1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gKChfYSA9IHZhbHVlVHlwZS5kZWZhdWx0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSlcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Jc05vbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1RyYW5zZm9ybU9yaWdpblByb3Aoa2V5KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB0cmFuc2Zvcm0gb3JpZ2luLCBmbGFnIGFuZCBlbmFibGUgZnVydGhlciB0cmFuc2Zvcm0tb3JpZ2luIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGhhc1RyYW5zZm9ybU9yaWdpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZVtrZXldID0gdmFsdWVBc1R5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1RyYW5zZm9ybSkge1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBidWlsZFRyYW5zZm9ybShzdGF0ZSwgb3B0aW9ucywgdHJhbnNmb3JtSXNOb25lLCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlKHt9LCBcIlwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWxhdGVzdFZhbHVlcy50cmFuc2Zvcm0gJiYgc3R5bGUudHJhbnNmb3JtKSB7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IFwibm9uZVwiO1xuICAgIH1cbiAgICBpZiAoaGFzVHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGJ1aWxkVHJhbnNmb3JtT3JpZ2luKHRyYW5zZm9ybU9yaWdpbik7XG4gICAgfVxufVxuXG52YXIgY3JlYXRlSHRtbFJlbmRlclN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICBzdHlsZToge30sXG4gICAgdHJhbnNmb3JtOiB7fSxcbiAgICB0cmFuc2Zvcm1LZXlzOiBbXSxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IHt9LFxuICAgIHZhcnM6IHt9LFxufSk7IH07XG5cbmZ1bmN0aW9uIGNvcHlSYXdWYWx1ZXNPbmx5KHRhcmdldCwgc291cmNlLCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKCFpc01vdGlvblZhbHVlKHNvdXJjZVtrZXldKSAmJiAhaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIHByb3BzKSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHVzZUluaXRpYWxNb3Rpb25WYWx1ZXMoX2EsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykge1xuICAgIHZhciB0cmFuc2Zvcm1UZW1wbGF0ZSA9IF9hLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gY3JlYXRlSHRtbFJlbmRlclN0YXRlKCk7XG4gICAgICAgIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgdmlzdWFsU3RhdGUsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246ICFpc1N0YXRpYyB9LCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgICAgIHZhciB2YXJzID0gc3RhdGUudmFycywgc3R5bGUgPSBzdGF0ZS5zdHlsZTtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB2YXJzKSwgc3R5bGUpO1xuICAgIH0sIFt2aXN1YWxTdGF0ZV0pO1xufVxuZnVuY3Rpb24gdXNlU3R5bGUocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykge1xuICAgIHZhciBzdHlsZVByb3AgPSBwcm9wcy5zdHlsZSB8fCB7fTtcbiAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICAvKipcbiAgICAgKiBDb3B5IG5vbi1Nb3Rpb24gVmFsdWVzIHN0cmFpZ2h0IGludG8gc3R5bGVcbiAgICAgKi9cbiAgICBjb3B5UmF3VmFsdWVzT25seShzdHlsZSwgc3R5bGVQcm9wLCBwcm9wcyk7XG4gICAgT2JqZWN0LmFzc2lnbihzdHlsZSwgdXNlSW5pdGlhbE1vdGlvblZhbHVlcyhwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSk7XG4gICAgaWYgKHByb3BzLnRyYW5zZm9ybVZhbHVlcykge1xuICAgICAgICBzdHlsZSA9IHByb3BzLnRyYW5zZm9ybVZhbHVlcyhzdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbn1cbmZ1bmN0aW9uIHVzZUhUTUxQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSB7XG4gICAgLy8gVGhlIGBhbnlgIGlzbid0IGlkZWFsIGJ1dCBpdCBpcyB0aGUgdHlwZSBvZiBjcmVhdGVFbGVtZW50IHByb3BzIGFyZ3VtZW50XG4gICAgdmFyIGh0bWxQcm9wcyA9IHt9O1xuICAgIHZhciBzdHlsZSA9IHVzZVN0eWxlKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpO1xuICAgIGlmIChCb29sZWFuKHByb3BzLmRyYWcpICYmIHByb3BzLmRyYWdMaXN0ZW5lciAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgZ2hvc3QgZWxlbWVudCB3aGVuIGEgdXNlciBkcmFnc1xuICAgICAgICBodG1sUHJvcHMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIERpc2FibGUgdGV4dCBzZWxlY3Rpb25cbiAgICAgICAgc3R5bGUudXNlclNlbGVjdCA9XG4gICAgICAgICAgICBzdHlsZS5XZWJraXRVc2VyU2VsZWN0ID1cbiAgICAgICAgICAgICAgICBzdHlsZS5XZWJraXRUb3VjaENhbGxvdXQgPVxuICAgICAgICAgICAgICAgICAgICBcIm5vbmVcIjtcbiAgICAgICAgLy8gRGlzYWJsZSBzY3JvbGxpbmcgb24gdGhlIGRyYWdnYWJsZSBkaXJlY3Rpb25cbiAgICAgICAgc3R5bGUudG91Y2hBY3Rpb24gPVxuICAgICAgICAgICAgcHJvcHMuZHJhZyA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgID8gXCJub25lXCJcbiAgICAgICAgICAgICAgICA6IFwicGFuLVwiLmNvbmNhdChwcm9wcy5kcmFnID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCIpO1xuICAgIH1cbiAgICBodG1sUHJvcHMuc3R5bGUgPSBzdHlsZTtcbiAgICByZXR1cm4gaHRtbFByb3BzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBhbGwgdmFsaWQgTW90aW9uUHJvcHMuXG4gKlxuICogQHByaXZhdGVSZW1hcmtzXG4gKiBUaGlzIGRvZXNuJ3QgdGhyb3cgaWYgYSBgTW90aW9uUHJvcGAgbmFtZSBpcyBtaXNzaW5nIC0gaXQgc2hvdWxkLlxuICovXG52YXIgdmFsaWRNb3Rpb25Qcm9wcyA9IG5ldyBTZXQoW1xuICAgIFwiaW5pdGlhbFwiLFxuICAgIFwiYW5pbWF0ZVwiLFxuICAgIFwiZXhpdFwiLFxuICAgIFwic3R5bGVcIixcbiAgICBcInZhcmlhbnRzXCIsXG4gICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgXCJ0cmFuc2Zvcm1UZW1wbGF0ZVwiLFxuICAgIFwidHJhbnNmb3JtVmFsdWVzXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImluaGVyaXRcIixcbiAgICBcImxheW91dFwiLFxuICAgIFwibGF5b3V0SWRcIixcbiAgICBcImxheW91dERlcGVuZGVuY3lcIixcbiAgICBcIm9uTGF5b3V0QW5pbWF0aW9uU3RhcnRcIixcbiAgICBcIm9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGVcIixcbiAgICBcIm9uTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwib25CZWZvcmVMYXlvdXRNZWFzdXJlXCIsXG4gICAgXCJvbkFuaW1hdGlvblN0YXJ0XCIsXG4gICAgXCJvbkFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gICAgXCJvblVwZGF0ZVwiLFxuICAgIFwib25EcmFnU3RhcnRcIixcbiAgICBcIm9uRHJhZ1wiLFxuICAgIFwib25EcmFnRW5kXCIsXG4gICAgXCJvbk1lYXN1cmVEcmFnQ29uc3RyYWludHNcIixcbiAgICBcIm9uRGlyZWN0aW9uTG9ja1wiLFxuICAgIFwib25EcmFnVHJhbnNpdGlvbkVuZFwiLFxuICAgIFwiZHJhZ1wiLFxuICAgIFwiZHJhZ0NvbnRyb2xzXCIsXG4gICAgXCJkcmFnTGlzdGVuZXJcIixcbiAgICBcImRyYWdDb25zdHJhaW50c1wiLFxuICAgIFwiZHJhZ0RpcmVjdGlvbkxvY2tcIixcbiAgICBcImRyYWdTbmFwVG9PcmlnaW5cIixcbiAgICBcIl9kcmFnWFwiLFxuICAgIFwiX2RyYWdZXCIsXG4gICAgXCJkcmFnRWxhc3RpY1wiLFxuICAgIFwiZHJhZ01vbWVudHVtXCIsXG4gICAgXCJkcmFnUHJvcGFnYXRpb25cIixcbiAgICBcImRyYWdUcmFuc2l0aW9uXCIsXG4gICAgXCJ3aGlsZURyYWdcIixcbiAgICBcIm9uUGFuXCIsXG4gICAgXCJvblBhblN0YXJ0XCIsXG4gICAgXCJvblBhbkVuZFwiLFxuICAgIFwib25QYW5TZXNzaW9uU3RhcnRcIixcbiAgICBcIm9uVGFwXCIsXG4gICAgXCJvblRhcFN0YXJ0XCIsXG4gICAgXCJvblRhcENhbmNlbFwiLFxuICAgIFwib25Ib3ZlclN0YXJ0XCIsXG4gICAgXCJvbkhvdmVyRW5kXCIsXG4gICAgXCJ3aGlsZUZvY3VzXCIsXG4gICAgXCJ3aGlsZVRhcFwiLFxuICAgIFwid2hpbGVIb3ZlclwiLFxuICAgIFwid2hpbGVJblZpZXdcIixcbiAgICBcIm9uVmlld3BvcnRFbnRlclwiLFxuICAgIFwib25WaWV3cG9ydExlYXZlXCIsXG4gICAgXCJ2aWV3cG9ydFwiLFxuICAgIFwibGF5b3V0U2Nyb2xsXCIsXG5dKTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHByb3AgbmFtZSBpcyBhIHZhbGlkIGBNb3Rpb25Qcm9wYCBrZXkuXG4gKlxuICogQHBhcmFtIGtleSAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaXMga2V5IGlzIGEgdmFsaWQgYE1vdGlvblByb3BgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZE1vdGlvblByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHZhbGlkTW90aW9uUHJvcHMuaGFzKGtleSk7XG59XG5cbnZhciBzaG91bGRGb3J3YXJkID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSk7IH07XG5mdW5jdGlvbiBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcChpc1ZhbGlkUHJvcCkge1xuICAgIGlmICghaXNWYWxpZFByb3ApXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBFeHBsaWNpdGx5IGZpbHRlciBvdXIgZXZlbnRzXG4gICAgc2hvdWxkRm9yd2FyZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKFwib25cIikgPyAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KSA6IGlzVmFsaWRQcm9wKGtleSk7XG4gICAgfTtcbn1cbi8qKlxuICogRW1vdGlvbiBhbmQgU3R5bGVkIENvbXBvbmVudHMgYm90aCBhbGxvdyB1c2VycyB0byBwYXNzIHRocm91Z2ggYXJiaXRyYXJ5IHByb3BzIHRvIHRoZWlyIGNvbXBvbmVudHNcbiAqIHRvIGR5bmFtaWNhbGx5IGdlbmVyYXRlIENTUy4gVGhleSBib3RoIHVzZSB0aGUgYEBlbW90aW9uL2lzLXByb3AtdmFsaWRgIHBhY2thZ2UgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gKiBvZiB0aGVzZSBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlLlxuICpcbiAqIEhvd2V2ZXIsIHdoZW4gc3R5bGluZyBhIE1vdGlvbiBjb21wb25lbnQgYHN0eWxlZChtb3Rpb24uZGl2KWAsIGJvdGggcGFja2FnZXMgcGFzcyB0aHJvdWdoICphbGwqIHByb3BzXG4gKiBhcyBpdCdzIHNlZW4gYXMgYW4gYXJiaXRyYXJ5IGNvbXBvbmVudCByYXRoZXIgdGhhbiBhIERPTSBub2RlLiBNb3Rpb24gb25seSBhbGxvd3MgYXJiaXRyYXJ5IHByb3BzXG4gKiBwYXNzZWQgdGhyb3VnaCB0aGUgYGN1c3RvbWAgcHJvcCBzbyBpdCBkb2Vzbid0ICpuZWVkKiB0aGUgcGF5bG9hZCBvciBjb21wdXRhdGlvbmFsIG92ZXJoZWFkIG9mXG4gKiBgQGVtb3Rpb24vaXMtcHJvcC12YWxpZGAsIGhvd2V2ZXIgdG8gZml4IHRoaXMgcHJvYmxlbSB3ZSBuZWVkIHRvIHVzZSBpdC5cbiAqXG4gKiBCeSBtYWtpbmcgaXQgYW4gb3B0aW9uYWxEZXBlbmRlbmN5IHdlIGNhbiBvZmZlciB0aGlzIGZ1bmN0aW9uYWxpdHkgb25seSBpbiB0aGUgc2l0dWF0aW9ucyB3aGVyZSBpdCdzXG4gKiBhY3R1YWxseSByZXF1aXJlZC5cbiAqL1xudHJ5IHtcbiAgICAvKipcbiAgICAgKiBXZSBhdHRlbXB0IHRvIGltcG9ydCB0aGlzIHBhY2thZ2UgYnV0IHJlcXVpcmUgd29uJ3QgYmUgZGVmaW5lZCBpbiBlc20gZW52aXJvbm1lbnRzLCBpbiB0aGF0IGNhc2VcbiAgICAgKiBpc1Byb3BWYWxpZCB3aWxsIGhhdmUgdG8gYmUgcHJvdmlkZWQgdmlhIGBNb3Rpb25Db250ZXh0YC4gSW4gYSA2LjAuMCB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSByZW1vdmVkXG4gICAgICogaW4gZmF2b3VyIG9mIGV4cGxpY2l0IGluamVjdGlvbi5cbiAgICAgKi9cbiAgICBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcChyZXF1aXJlKFwiQGVtb3Rpb24vaXMtcHJvcC12YWxpZFwiKS5kZWZhdWx0KTtcbn1cbmNhdGNoIChfYSkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gYWN0dWFsbHkgZG8gYW55dGhpbmcgaGVyZSAtIHRoZSBmYWxsYmFjayBpcyB0aGUgZXhpc3RpbmcgYGlzUHJvcFZhbGlkYC5cbn1cbmZ1bmN0aW9uIGZpbHRlclByb3BzKHByb3BzLCBpc0RvbSwgZm9yd2FyZE1vdGlvblByb3BzKSB7XG4gICAgdmFyIGZpbHRlcmVkUHJvcHMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKHNob3VsZEZvcndhcmQoa2V5KSB8fFxuICAgICAgICAgICAgKGZvcndhcmRNb3Rpb25Qcm9wcyA9PT0gdHJ1ZSAmJiBpc1ZhbGlkTW90aW9uUHJvcChrZXkpKSB8fFxuICAgICAgICAgICAgKCFpc0RvbSAmJiAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KSkgfHxcbiAgICAgICAgICAgIC8vIElmIHRyeWluZyB0byB1c2UgbmF0aXZlIEhUTUwgZHJhZyBldmVudHMsIGZvcndhcmQgZHJhZyBsaXN0ZW5lcnNcbiAgICAgICAgICAgIChwcm9wc1tcImRyYWdnYWJsZVwiXSAmJiBrZXkuc3RhcnRzV2l0aChcIm9uRHJhZ1wiKSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkUHJvcHM7XG59XG5cbmZ1bmN0aW9uIGNhbGNPcmlnaW4kMShvcmlnaW4sIG9mZnNldCwgc2l6ZSkge1xuICAgIHJldHVybiB0eXBlb2Ygb3JpZ2luID09PSBcInN0cmluZ1wiXG4gICAgICAgID8gb3JpZ2luXG4gICAgICAgIDogc3R5bGVWYWx1ZVR5cGVzLnB4LnRyYW5zZm9ybShvZmZzZXQgKyBzaXplICogb3JpZ2luKTtcbn1cbi8qKlxuICogVGhlIFNWRyB0cmFuc2Zvcm0gb3JpZ2luIGRlZmF1bHRzIGFyZSBkaWZmZXJlbnQgdG8gQ1NTIGFuZCBpcyBsZXNzIGludHVpdGl2ZSxcbiAqIHNvIHdlIHVzZSB0aGUgbWVhc3VyZWQgZGltZW5zaW9ucyBvZiB0aGUgU1ZHIHRvIHJlY29uY2lsZSB0aGVzZS5cbiAqL1xuZnVuY3Rpb24gY2FsY1NWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgdmFyIHB4T3JpZ2luWCA9IGNhbGNPcmlnaW4kMShvcmlnaW5YLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMud2lkdGgpO1xuICAgIHZhciBweE9yaWdpblkgPSBjYWxjT3JpZ2luJDEob3JpZ2luWSwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLmhlaWdodCk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHB4T3JpZ2luWCwgXCIgXCIpLmNvbmNhdChweE9yaWdpblkpO1xufVxuXG52YXIgZGFzaEtleXMgPSB7XG4gICAgb2Zmc2V0OiBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gICAgYXJyYXk6IFwic3Ryb2tlLWRhc2hhcnJheVwiLFxufTtcbnZhciBjYW1lbEtleXMgPSB7XG4gICAgb2Zmc2V0OiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgICBhcnJheTogXCJzdHJva2VEYXNoYXJyYXlcIixcbn07XG4vKipcbiAqIEJ1aWxkIFNWRyBwYXRoIHByb3BlcnRpZXMuIFVzZXMgdGhlIHBhdGgncyBtZWFzdXJlZCBsZW5ndGggdG8gY29udmVydFxuICogb3VyIGN1c3RvbSBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZyBhbmQgcGF0aE9mZnNldCBpbnRvIHN0cm9rZS1kYXNob2Zmc2V0XG4gKiBhbmQgc3Ryb2tlLWRhc2hhcnJheSBhdHRyaWJ1dGVzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbXV0YXRpdmUgdG8gcmVkdWNlIHBlci1mcmFtZSBHQy5cbiAqL1xuZnVuY3Rpb24gYnVpbGRTVkdQYXRoKGF0dHJzLCBsZW5ndGgsIHNwYWNpbmcsIG9mZnNldCwgdXNlRGFzaENhc2UpIHtcbiAgICBpZiAoc3BhY2luZyA9PT0gdm9pZCAwKSB7IHNwYWNpbmcgPSAxOyB9XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICBpZiAodXNlRGFzaENhc2UgPT09IHZvaWQgMCkgeyB1c2VEYXNoQ2FzZSA9IHRydWU7IH1cbiAgICAvLyBOb3JtYWxpc2UgcGF0aCBsZW5ndGggYnkgc2V0dGluZyBTVkcgYXR0cmlidXRlIHBhdGhMZW5ndGggdG8gMVxuICAgIGF0dHJzLnBhdGhMZW5ndGggPSAxO1xuICAgIC8vIFdlIHVzZSBkYXNoIGNhc2Ugd2hlbiBzZXR0aW5nIGF0dHJpYnV0ZXMgZGlyZWN0bHkgdG8gdGhlIERPTSBub2RlIGFuZCBjYW1lbCBjYXNlXG4gICAgLy8gd2hlbiBkZWZpbmluZyBwcm9wcyBvbiBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICB2YXIga2V5cyA9IHVzZURhc2hDYXNlID8gZGFzaEtleXMgOiBjYW1lbEtleXM7XG4gICAgLy8gQnVpbGQgdGhlIGRhc2ggb2Zmc2V0XG4gICAgYXR0cnNba2V5cy5vZmZzZXRdID0gc3R5bGVWYWx1ZVR5cGVzLnB4LnRyYW5zZm9ybSgtb2Zmc2V0KTtcbiAgICAvLyBCdWlsZCB0aGUgZGFzaCBhcnJheVxuICAgIHZhciBwYXRoTGVuZ3RoID0gc3R5bGVWYWx1ZVR5cGVzLnB4LnRyYW5zZm9ybShsZW5ndGgpO1xuICAgIHZhciBwYXRoU3BhY2luZyA9IHN0eWxlVmFsdWVUeXBlcy5weC50cmFuc2Zvcm0oc3BhY2luZyk7XG4gICAgYXR0cnNba2V5cy5hcnJheV0gPSBcIlwiLmNvbmNhdChwYXRoTGVuZ3RoLCBcIiBcIikuY29uY2F0KHBhdGhTcGFjaW5nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBTVkcgdmlzdWFsIGF0dHJidXRlcywgbGlrZSBjeCBhbmQgc3R5bGUudHJhbnNmb3JtXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU1ZHQXR0cnMoc3RhdGUsIF9hLCBvcHRpb25zLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIHZhciBhdHRyWCA9IF9hLmF0dHJYLCBhdHRyWSA9IF9hLmF0dHJZLCBvcmlnaW5YID0gX2Eub3JpZ2luWCwgb3JpZ2luWSA9IF9hLm9yaWdpblksIHBhdGhMZW5ndGggPSBfYS5wYXRoTGVuZ3RoLCBfYiA9IF9hLnBhdGhTcGFjaW5nLCBwYXRoU3BhY2luZyA9IF9iID09PSB2b2lkIDAgPyAxIDogX2IsIF9jID0gX2EucGF0aE9mZnNldCwgcGF0aE9mZnNldCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIFxuICAgIC8vIFRoaXMgaXMgb2JqZWN0IGNyZWF0aW9uLCB3aGljaCB3ZSB0cnkgdG8gYXZvaWQgcGVyLWZyYW1lLlxuICAgIGxhdGVzdCA9IHRzbGliLl9fcmVzdChfYSwgW1wiYXR0clhcIiwgXCJhdHRyWVwiLCBcIm9yaWdpblhcIiwgXCJvcmlnaW5ZXCIsIFwicGF0aExlbmd0aFwiLCBcInBhdGhTcGFjaW5nXCIsIFwicGF0aE9mZnNldFwiXSk7XG4gICAgYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3QsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICBzdGF0ZS5hdHRycyA9IHN0YXRlLnN0eWxlO1xuICAgIHN0YXRlLnN0eWxlID0ge307XG4gICAgdmFyIGF0dHJzID0gc3RhdGUuYXR0cnMsIHN0eWxlID0gc3RhdGUuc3R5bGUsIGRpbWVuc2lvbnMgPSBzdGF0ZS5kaW1lbnNpb25zO1xuICAgIC8qKlxuICAgICAqIEhvd2V2ZXIsIHdlIGFwcGx5IHRyYW5zZm9ybXMgYXMgQ1NTIHRyYW5zZm9ybXMuIFNvIGlmIHdlIGRldGVjdCBhIHRyYW5zZm9ybSB3ZSB0YWtlIGl0IGZyb20gYXR0cnNcbiAgICAgKiBhbmQgY29weSBpdCBpbnRvIHN0eWxlLlxuICAgICAqL1xuICAgIGlmIChhdHRycy50cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMpXG4gICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBhdHRycy50cmFuc2Zvcm07XG4gICAgICAgIGRlbGV0ZSBhdHRycy50cmFuc2Zvcm07XG4gICAgfVxuICAgIC8vIFBhcnNlIHRyYW5zZm9ybU9yaWdpblxuICAgIGlmIChkaW1lbnNpb25zICYmXG4gICAgICAgIChvcmlnaW5YICE9PSB1bmRlZmluZWQgfHwgb3JpZ2luWSAhPT0gdW5kZWZpbmVkIHx8IHN0eWxlLnRyYW5zZm9ybSkpIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2FsY1NWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YICE9PSB1bmRlZmluZWQgPyBvcmlnaW5YIDogMC41LCBvcmlnaW5ZICE9PSB1bmRlZmluZWQgPyBvcmlnaW5ZIDogMC41KTtcbiAgICB9XG4gICAgLy8gVHJlYXQgeC95IG5vdCBhcyBzaG9ydGN1dHMgYnV0IGFzIGFjdHVhbCBhdHRyaWJ1dGVzXG4gICAgaWYgKGF0dHJYICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGF0dHJzLnggPSBhdHRyWDtcbiAgICBpZiAoYXR0clkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYXR0cnMueSA9IGF0dHJZO1xuICAgIC8vIEJ1aWxkIFNWRyBwYXRoIGlmIG9uZSBoYXMgYmVlbiBkZWZpbmVkXG4gICAgaWYgKHBhdGhMZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWlsZFNWR1BhdGgoYXR0cnMsIHBhdGhMZW5ndGgsIHBhdGhTcGFjaW5nLCBwYXRoT2Zmc2V0LCBmYWxzZSk7XG4gICAgfVxufVxuXG52YXIgY3JlYXRlU3ZnUmVuZGVyU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSgpKSwgeyBhdHRyczoge30gfSkpOyB9O1xuXG5mdW5jdGlvbiB1c2VTVkdQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUpIHtcbiAgICB2YXIgdmlzdWFsUHJvcHMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gY3JlYXRlU3ZnUmVuZGVyU3RhdGUoKTtcbiAgICAgICAgYnVpbGRTVkdBdHRycyhzdGF0ZSwgdmlzdWFsU3RhdGUsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IGZhbHNlIH0sIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBzdGF0ZS5hdHRycyksIHsgc3R5bGU6IHRzbGliLl9fYXNzaWduKHt9LCBzdGF0ZS5zdHlsZSkgfSk7XG4gICAgfSwgW3Zpc3VhbFN0YXRlXSk7XG4gICAgaWYgKHByb3BzLnN0eWxlKSB7XG4gICAgICAgIHZhciByYXdTdHlsZXMgPSB7fTtcbiAgICAgICAgY29weVJhd1ZhbHVlc09ubHkocmF3U3R5bGVzLCBwcm9wcy5zdHlsZSwgcHJvcHMpO1xuICAgICAgICB2aXN1YWxQcm9wcy5zdHlsZSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCByYXdTdHlsZXMpLCB2aXN1YWxQcm9wcy5zdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiB2aXN1YWxQcm9wcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXNlUmVuZGVyKGZvcndhcmRNb3Rpb25Qcm9wcykge1xuICAgIGlmIChmb3J3YXJkTW90aW9uUHJvcHMgPT09IHZvaWQgMCkgeyBmb3J3YXJkTW90aW9uUHJvcHMgPSBmYWxzZTsgfVxuICAgIHZhciB1c2VSZW5kZXIgPSBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcywgcHJvamVjdGlvbklkLCByZWYsIF9hLCBpc1N0YXRpYykge1xuICAgICAgICB2YXIgbGF0ZXN0VmFsdWVzID0gX2EubGF0ZXN0VmFsdWVzO1xuICAgICAgICB2YXIgdXNlVmlzdWFsUHJvcHMgPSBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpXG4gICAgICAgICAgICA/IHVzZVNWR1Byb3BzXG4gICAgICAgICAgICA6IHVzZUhUTUxQcm9wcztcbiAgICAgICAgdmFyIHZpc3VhbFByb3BzID0gdXNlVmlzdWFsUHJvcHMocHJvcHMsIGxhdGVzdFZhbHVlcywgaXNTdGF0aWMpO1xuICAgICAgICB2YXIgZmlsdGVyZWRQcm9wcyA9IGZpbHRlclByb3BzKHByb3BzLCB0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiLCBmb3J3YXJkTW90aW9uUHJvcHMpO1xuICAgICAgICB2YXIgZWxlbWVudFByb3BzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGZpbHRlcmVkUHJvcHMpLCB2aXN1YWxQcm9wcyksIHsgcmVmOiByZWYgfSk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRQcm9wc1tcImRhdGEtcHJvamVjdGlvbi1pZFwiXSA9IHByb2plY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnRQcm9wcyk7XG4gICAgfTtcbiAgICByZXR1cm4gdXNlUmVuZGVyO1xufVxuXG52YXIgQ0FNRUxfQ0FTRV9QQVRURVJOID0gLyhbYS16XSkoW0EtWl0pL2c7XG52YXIgUkVQTEFDRV9URU1QTEFURSA9IFwiJDEtJDJcIjtcbi8qKlxuICogQ29udmVydCBjYW1lbENhc2UgdG8gZGFzaC1jYXNlIHByb3BlcnRpZXMuXG4gKi9cbnZhciBjYW1lbFRvRGFzaCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoQ0FNRUxfQ0FTRV9QQVRURVJOLCBSRVBMQUNFX1RFTVBMQVRFKS50b0xvd2VyQ2FzZSgpO1xufTtcblxuZnVuY3Rpb24gcmVuZGVySFRNTChlbGVtZW50LCBfYSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHN0eWxlID0gX2Euc3R5bGUsIHZhcnMgPSBfYS52YXJzO1xuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUsIHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5nZXRQcm9qZWN0aW9uU3R5bGVzKHN0eWxlUHJvcCkpO1xuICAgIC8vIExvb3Agb3ZlciBhbnkgQ1NTIHZhcmlhYmxlcyBhbmQgYXNzaWduIHRob3NlLlxuICAgIGZvciAodmFyIGtleSBpbiB2YXJzKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YXJzW2tleV0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHNldCBvZiBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBhcmUgYWx3YXlzIHJlYWQvd3JpdHRlbiBhcyBjYW1lbCBjYXNlLlxuICovXG52YXIgY2FtZWxDYXNlQXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICAgIFwiYmFzZUZyZXF1ZW5jeVwiLFxuICAgIFwiZGlmZnVzZUNvbnN0YW50XCIsXG4gICAgXCJrZXJuZWxNYXRyaXhcIixcbiAgICBcImtlcm5lbFVuaXRMZW5ndGhcIixcbiAgICBcImtleVNwbGluZXNcIixcbiAgICBcImtleVRpbWVzXCIsXG4gICAgXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxuICAgIFwibWFya2VySGVpZ2h0XCIsXG4gICAgXCJtYXJrZXJXaWR0aFwiLFxuICAgIFwibnVtT2N0YXZlc1wiLFxuICAgIFwidGFyZ2V0WFwiLFxuICAgIFwidGFyZ2V0WVwiLFxuICAgIFwic3VyZmFjZVNjYWxlXCIsXG4gICAgXCJzcGVjdWxhckNvbnN0YW50XCIsXG4gICAgXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgXCJzdGREZXZpYXRpb25cIixcbiAgICBcInRhYmxlVmFsdWVzXCIsXG4gICAgXCJ2aWV3Qm94XCIsXG4gICAgXCJncmFkaWVudFRyYW5zZm9ybVwiLFxuICAgIFwicGF0aExlbmd0aFwiLFxuXSk7XG5cbmZ1bmN0aW9uIHJlbmRlclNWRyhlbGVtZW50LCByZW5kZXJTdGF0ZSwgX3N0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICAgIHJlbmRlckhUTUwoZWxlbWVudCwgcmVuZGVyU3RhdGUsIHVuZGVmaW5lZCwgcHJvamVjdGlvbik7XG4gICAgZm9yICh2YXIga2V5IGluIHJlbmRlclN0YXRlLmF0dHJzKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCFjYW1lbENhc2VBdHRyaWJ1dGVzLmhhcyhrZXkpID8gY2FtZWxUb0Rhc2goa2V5KSA6IGtleSwgcmVuZGVyU3RhdGUuYXR0cnNba2V5XSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMShwcm9wcykge1xuICAgIHZhciBzdHlsZSA9IHByb3BzLnN0eWxlO1xuICAgIHZhciBuZXdWYWx1ZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3R5bGUpIHtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUoc3R5bGVba2V5XSkgfHwgaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIHByb3BzKSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2tleV0gPSBzdHlsZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZXM7XG59XG5cbmZ1bmN0aW9uIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcykge1xuICAgIHZhciBuZXdWYWx1ZXMgPSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMShwcm9wcyk7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKHByb3BzW2tleV0pKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0S2V5ID0ga2V5ID09PSBcInhcIiB8fCBrZXkgPT09IFwieVwiID8gXCJhdHRyXCIgKyBrZXkudG9VcHBlckNhc2UoKSA6IGtleTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1t0YXJnZXRLZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWVzO1xufVxuXG5mdW5jdGlvbiBpc0FuaW1hdGlvbkNvbnRyb2xzKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHYuc3RhcnQgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxudmFyIGlzS2V5ZnJhbWVzVGFyZ2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTtcbn07XG5cbnZhciBpc0N1c3RvbVZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2ICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYubWl4ICYmIHYudG9WYWx1ZSk7XG59O1xudmFyIHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMgPSBmdW5jdGlvbiAodikge1xuICAgIC8vIFRPRE8gbWF5YmUgdGhyb3cgaWYgdi5sZW5ndGggLSAxIGlzIHBsYWNlaG9sZGVyIHRva2VuP1xuICAgIHJldHVybiBpc0tleWZyYW1lc1RhcmdldCh2KSA/IHZbdi5sZW5ndGggLSAxXSB8fCAwIDogdjtcbn07XG5cbi8qKlxuICogSWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGEgTW90aW9uVmFsdWUsIHRoaXMgcmV0dXJucyB0aGUgYWN0dWFsIHZhbHVlLCBvdGhlcndpc2UganVzdCB0aGUgdmFsdWUgaXRzZWxmXG4gKlxuICogVE9ETzogUmVtb3ZlIGFuZCBtb3ZlIHRvIGxpYnJhcnlcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZU1vdGlvblZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHVud3JhcHBlZFZhbHVlID0gaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlO1xuICAgIHJldHVybiBpc0N1c3RvbVZhbHVlKHVud3JhcHBlZFZhbHVlKVxuICAgICAgICA/IHVud3JhcHBlZFZhbHVlLnRvVmFsdWUoKVxuICAgICAgICA6IHVud3JhcHBlZFZhbHVlO1xufVxuXG5mdW5jdGlvbiBtYWtlU3RhdGUoX2EsIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpIHtcbiAgICB2YXIgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzID0gX2Euc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLCBjcmVhdGVSZW5kZXJTdGF0ZSA9IF9hLmNyZWF0ZVJlbmRlclN0YXRlLCBvbk1vdW50ID0gX2Eub25Nb3VudDtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGxhdGVzdFZhbHVlczogbWFrZUxhdGVzdFZhbHVlcyhwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0LCBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMpLFxuICAgICAgICByZW5kZXJTdGF0ZTogY3JlYXRlUmVuZGVyU3RhdGUoKSxcbiAgICB9O1xuICAgIGlmIChvbk1vdW50KSB7XG4gICAgICAgIHN0YXRlLm1vdW50ID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7IHJldHVybiBvbk1vdW50KHByb3BzLCBpbnN0YW5jZSwgc3RhdGUpOyB9O1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG52YXIgbWFrZVVzZVZpc3VhbFN0YXRlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcHMsIGlzU3RhdGljKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db250ZXh0KTtcbiAgICAgICAgdmFyIHByZXNlbmNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGlzU3RhdGljXG4gICAgICAgICAgICA/IG1ha2VTdGF0ZShjb25maWcsIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpXG4gICAgICAgICAgICA6IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVN0YXRlKGNvbmZpZywgcHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xufTtcbmZ1bmN0aW9uIG1ha2VMYXRlc3RWYWx1ZXMocHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCwgc2NyYXBlTW90aW9uVmFsdWVzKSB7XG4gICAgdmFyIHZhbHVlcyA9IHt9O1xuICAgIHZhciBibG9ja0luaXRpYWxBbmltYXRpb24gPSAocHJlc2VuY2VDb250ZXh0ID09PSBudWxsIHx8IHByZXNlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VuY2VDb250ZXh0LmluaXRpYWwpID09PSBmYWxzZTtcbiAgICB2YXIgbW90aW9uVmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzKHByb3BzKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbW90aW9uVmFsdWVzKSB7XG4gICAgICAgIHZhbHVlc1trZXldID0gcmVzb2x2ZU1vdGlvblZhbHVlKG1vdGlvblZhbHVlc1trZXldKTtcbiAgICB9XG4gICAgdmFyIGluaXRpYWwgPSBwcm9wcy5pbml0aWFsLCBhbmltYXRlID0gcHJvcHMuYW5pbWF0ZTtcbiAgICB2YXIgaXNDb250cm9sbGluZ1ZhcmlhbnRzID0gY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpO1xuICAgIHZhciBpc1ZhcmlhbnROb2RlID0gY2hlY2tJZlZhcmlhbnROb2RlKHByb3BzKTtcbiAgICBpZiAoY29udGV4dCAmJlxuICAgICAgICBpc1ZhcmlhbnROb2RlICYmXG4gICAgICAgICFpc0NvbnRyb2xsaW5nVmFyaWFudHMgJiZcbiAgICAgICAgcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgaW5pdGlhbCAhPT0gbnVsbCAmJiBpbml0aWFsICE9PSB2b2lkIDAgPyBpbml0aWFsIDogKGluaXRpYWwgPSBjb250ZXh0LmluaXRpYWwpO1xuICAgICAgICBhbmltYXRlICE9PSBudWxsICYmIGFuaW1hdGUgIT09IHZvaWQgMCA/IGFuaW1hdGUgOiAoYW5pbWF0ZSA9IGNvbnRleHQuYW5pbWF0ZSk7XG4gICAgfVxuICAgIHZhciBpbml0aWFsQW5pbWF0aW9uSXNCbG9ja2VkID0gYmxvY2tJbml0aWFsQW5pbWF0aW9uIHx8IGluaXRpYWwgPT09IGZhbHNlO1xuICAgIHZhciB2YXJpYW50VG9TZXQgPSBpbml0aWFsQW5pbWF0aW9uSXNCbG9ja2VkID8gYW5pbWF0ZSA6IGluaXRpYWw7XG4gICAgaWYgKHZhcmlhbnRUb1NldCAmJlxuICAgICAgICB0eXBlb2YgdmFyaWFudFRvU2V0ICE9PSBcImJvb2xlYW5cIiAmJlxuICAgICAgICAhaXNBbmltYXRpb25Db250cm9scyh2YXJpYW50VG9TZXQpKSB7XG4gICAgICAgIHZhciBsaXN0ID0gQXJyYXkuaXNBcnJheSh2YXJpYW50VG9TZXQpID8gdmFyaWFudFRvU2V0IDogW3ZhcmlhbnRUb1NldF07XG4gICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbkVuZCA9IHJlc29sdmVkLnRyYW5zaXRpb25FbmQ7IHJlc29sdmVkLnRyYW5zaXRpb247IHZhciB0YXJnZXQgPSB0c2xpYi5fX3Jlc3QocmVzb2x2ZWQsIFtcInRyYW5zaXRpb25FbmRcIiwgXCJ0cmFuc2l0aW9uXCJdKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVUYXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRha2UgZmluYWwga2V5ZnJhbWUgaWYgdGhlIGluaXRpYWwgYW5pbWF0aW9uIGlzIGJsb2NrZWQgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgKiB3ZSB3YW50IHRvIGluaXRpYWxpc2UgYXQgdGhlIGVuZCBvZiB0aGF0IGJsb2NrZWQgYW5pbWF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5pdGlhbEFuaW1hdGlvbklzQmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVRhcmdldC5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlVGFyZ2V0ID0gdmFsdWVUYXJnZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZVRhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdHJhbnNpdGlvbkVuZClcbiAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHRyYW5zaXRpb25FbmRba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5cbnZhciBzdmdNb3Rpb25Db25maWcgPSB7XG4gICAgdXNlVmlzdWFsU3RhdGU6IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLFxuICAgICAgICBjcmVhdGVSZW5kZXJTdGF0ZTogY3JlYXRlU3ZnUmVuZGVyU3RhdGUsXG4gICAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIChwcm9wcywgaW5zdGFuY2UsIF9hKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSBfYS5yZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzID0gX2EubGF0ZXN0VmFsdWVzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5kaW1lbnNpb25zID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluc3RhbmNlLmdldEJCb3ggPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5zdGFuY2UuZ2V0QkJveCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGluc3RhbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3N0IGxpa2VseSB0cnlpbmcgdG8gbWVhc3VyZSBhbiB1bnJlbmRlcmVkIGVsZW1lbnQgdW5kZXIgRmlyZWZveFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1aWxkU1ZHQXR0cnMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZmFsc2UgfSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgICAgICAgcmVuZGVyU1ZHKGluc3RhbmNlLCByZW5kZXJTdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgfSksXG59O1xuXG52YXIgaHRtbE1vdGlvbkNvbmZpZyA9IHtcbiAgICB1c2VWaXN1YWxTdGF0ZTogbWFrZVVzZVZpc3VhbFN0YXRlKHtcbiAgICAgICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMSxcbiAgICAgICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSxcbiAgICB9KSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURvbU1vdGlvbkNvbmZpZyhDb21wb25lbnQsIF9hLCBwcmVsb2FkZWRGZWF0dXJlcywgY3JlYXRlVmlzdWFsRWxlbWVudCwgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcikge1xuICAgIHZhciBfYiA9IF9hLmZvcndhcmRNb3Rpb25Qcm9wcywgZm9yd2FyZE1vdGlvblByb3BzID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgdmFyIGJhc2VDb25maWcgPSBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpXG4gICAgICAgID8gc3ZnTW90aW9uQ29uZmlnXG4gICAgICAgIDogaHRtbE1vdGlvbkNvbmZpZztcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGJhc2VDb25maWcpLCB7IHByZWxvYWRlZEZlYXR1cmVzOiBwcmVsb2FkZWRGZWF0dXJlcywgdXNlUmVuZGVyOiBjcmVhdGVVc2VSZW5kZXIoZm9yd2FyZE1vdGlvblByb3BzKSwgY3JlYXRlVmlzdWFsRWxlbWVudDogY3JlYXRlVmlzdWFsRWxlbWVudCwgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvcjogcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciwgQ29tcG9uZW50OiBDb21wb25lbnQgfSk7XG59XG5cbmV4cG9ydHMuQW5pbWF0aW9uVHlwZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoQW5pbWF0aW9uVHlwZSkge1xuICAgIEFuaW1hdGlvblR5cGVbXCJBbmltYXRlXCJdID0gXCJhbmltYXRlXCI7XG4gICAgQW5pbWF0aW9uVHlwZVtcIkhvdmVyXCJdID0gXCJ3aGlsZUhvdmVyXCI7XG4gICAgQW5pbWF0aW9uVHlwZVtcIlRhcFwiXSA9IFwid2hpbGVUYXBcIjtcbiAgICBBbmltYXRpb25UeXBlW1wiRHJhZ1wiXSA9IFwid2hpbGVEcmFnXCI7XG4gICAgQW5pbWF0aW9uVHlwZVtcIkZvY3VzXCJdID0gXCJ3aGlsZUZvY3VzXCI7XG4gICAgQW5pbWF0aW9uVHlwZVtcIkluVmlld1wiXSA9IFwid2hpbGVJblZpZXdcIjtcbiAgICBBbmltYXRpb25UeXBlW1wiRXhpdFwiXSA9IFwiZXhpdFwiO1xufSkoZXhwb3J0cy5BbmltYXRpb25UeXBlIHx8IChleHBvcnRzLkFuaW1hdGlvblR5cGUgPSB7fSkpO1xuXG5mdW5jdGlvbiBhZGREb21FdmVudCh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9OyB9XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbn1cbi8qKlxuICogQXR0YWNoZXMgYW4gZXZlbnQgbGlzdGVuZXIgZGlyZWN0bHkgdG8gdGhlIHByb3ZpZGVkIERPTSBlbGVtZW50LlxuICpcbiAqIEJ5cGFzc2luZyBSZWFjdCdzIGV2ZW50IHN5c3RlbSBjYW4gYmUgZGVzaXJhYmxlLCBmb3IgaW5zdGFuY2Ugd2hlbiBhdHRhY2hpbmcgbm9uLXBhc3NpdmVcbiAqIGV2ZW50IGhhbmRsZXJzLlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgcmVmID0gdXNlUmVmKG51bGwpXG4gKlxuICogdXNlRG9tRXZlbnQocmVmLCAnd2hlZWwnLCBvbldoZWVsLCB7IHBhc3NpdmU6IGZhbHNlIH0pXG4gKlxuICogcmV0dXJuIDxkaXYgcmVmPXtyZWZ9IC8+XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcmVmIC0gUmVhY3QuUmVmT2JqZWN0IHRoYXQncyBiZWVuIHByb3ZpZGVkIHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIGJpbmQgdGhlIGxpc3RlbmVyIHRvLlxuICogQHBhcmFtIGV2ZW50TmFtZSAtIE5hbWUgb2YgdGhlIGV2ZW50IHlvdSB3YW50IGxpc3RlbiBmb3IuXG4gKiBAcGFyYW0gaGFuZGxlciAtIEZ1bmN0aW9uIHRvIGZpcmUgd2hlbiByZWNlaXZpbmcgdGhlIGV2ZW50LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gYEV2ZW50LmFkZEV2ZW50TGlzdGVuZXJgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlRG9tRXZlbnQocmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoaGFuZGxlciAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkRG9tRXZlbnQoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9uc10pO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEBwYXJhbSByZWZcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VGb2N1c0dlc3R1cmUoX2EpIHtcbiAgICB2YXIgd2hpbGVGb2N1cyA9IF9hLndoaWxlRm9jdXMsIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50O1xuICAgIHZhciBvbkZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoZXhwb3J0cy5BbmltYXRpb25UeXBlLkZvY3VzLCB0cnVlKTtcbiAgICB9O1xuICAgIHZhciBvbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShleHBvcnRzLkFuaW1hdGlvblR5cGUuRm9jdXMsIGZhbHNlKTtcbiAgICB9O1xuICAgIHVzZURvbUV2ZW50KHZpc3VhbEVsZW1lbnQsIFwiZm9jdXNcIiwgd2hpbGVGb2N1cyA/IG9uRm9jdXMgOiB1bmRlZmluZWQpO1xuICAgIHVzZURvbUV2ZW50KHZpc3VhbEVsZW1lbnQsIFwiYmx1clwiLCB3aGlsZUZvY3VzID8gb25CbHVyIDogdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KGV2ZW50KSB7XG4gICAgLy8gUG9pbnRlckV2ZW50IGluaGVyaXRzIGZyb20gTW91c2VFdmVudCBzbyB3ZSBjYW4ndCB1c2UgYSBzdHJhaWdodCBpbnN0YW5jZW9mIGNoZWNrLlxuICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGV2ZW50IGluc3RhbmNlb2YgUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIHJldHVybiAhIShldmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudDtcbn1cbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuICAgIHZhciBoYXNUb3VjaGVzID0gISFldmVudC50b3VjaGVzO1xuICAgIHJldHVybiBoYXNUb3VjaGVzO1xufVxuXG4vKipcbiAqIEZpbHRlcnMgb3V0IGV2ZW50cyBub3QgYXR0YWNoZWQgdG8gdGhlIHByaW1hcnkgcG9pbnRlciAoY3VycmVudGx5IGxlZnQgbW91c2UgYnV0dG9uKVxuICogQHBhcmFtIGV2ZW50SGFuZGxlclxuICovXG5mdW5jdGlvbiBmaWx0ZXJQcmltYXJ5UG9pbnRlcihldmVudEhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBpc01vdXNlRXZlbnQgPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQ7XG4gICAgICAgIHZhciBpc1ByaW1hcnlQb2ludGVyID0gIWlzTW91c2VFdmVudCB8fFxuICAgICAgICAgICAgKGlzTW91c2VFdmVudCAmJiBldmVudC5idXR0b24gPT09IDApO1xuICAgICAgICBpZiAoaXNQcmltYXJ5UG9pbnRlcikge1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG59XG52YXIgZGVmYXVsdFBhZ2VQb2ludCA9IHsgcGFnZVg6IDAsIHBhZ2VZOiAwIH07XG5mdW5jdGlvbiBwb2ludEZyb21Ub3VjaChlLCBwb2ludFR5cGUpIHtcbiAgICBpZiAocG9pbnRUeXBlID09PSB2b2lkIDApIHsgcG9pbnRUeXBlID0gXCJwYWdlXCI7IH1cbiAgICB2YXIgcHJpbWFyeVRvdWNoID0gZS50b3VjaGVzWzBdIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdmFyIHBvaW50ID0gcHJpbWFyeVRvdWNoIHx8IGRlZmF1bHRQYWdlUG9pbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9pbnRbcG9pbnRUeXBlICsgXCJYXCJdLFxuICAgICAgICB5OiBwb2ludFtwb2ludFR5cGUgKyBcIllcIl0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBvaW50RnJvbU1vdXNlKHBvaW50LCBwb2ludFR5cGUpIHtcbiAgICBpZiAocG9pbnRUeXBlID09PSB2b2lkIDApIHsgcG9pbnRUeXBlID0gXCJwYWdlXCI7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb2ludFtwb2ludFR5cGUgKyBcIlhcIl0sXG4gICAgICAgIHk6IHBvaW50W3BvaW50VHlwZSArIFwiWVwiXSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50SW5mbyhldmVudCwgcG9pbnRUeXBlKSB7XG4gICAgaWYgKHBvaW50VHlwZSA9PT0gdm9pZCAwKSB7IHBvaW50VHlwZSA9IFwicGFnZVwiOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IGlzVG91Y2hFdmVudChldmVudClcbiAgICAgICAgICAgID8gcG9pbnRGcm9tVG91Y2goZXZlbnQsIHBvaW50VHlwZSlcbiAgICAgICAgICAgIDogcG9pbnRGcm9tTW91c2UoZXZlbnQsIHBvaW50VHlwZSksXG4gICAgfTtcbn1cbnZhciB3cmFwSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBzaG91bGRGaWx0ZXJQcmltYXJ5UG9pbnRlcikge1xuICAgIGlmIChzaG91bGRGaWx0ZXJQcmltYXJ5UG9pbnRlciA9PT0gdm9pZCAwKSB7IHNob3VsZEZpbHRlclByaW1hcnlQb2ludGVyID0gZmFsc2U7IH1cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIoZXZlbnQsIGV4dHJhY3RFdmVudEluZm8oZXZlbnQpKTtcbiAgICB9O1xuICAgIHJldHVybiBzaG91bGRGaWx0ZXJQcmltYXJ5UG9pbnRlclxuICAgICAgICA/IGZpbHRlclByaW1hcnlQb2ludGVyKGxpc3RlbmVyKVxuICAgICAgICA6IGxpc3RlbmVyO1xufTtcblxuLy8gV2UgY2hlY2sgZm9yIGV2ZW50IHN1cHBvcnQgdmlhIGZ1bmN0aW9ucyBpbiBjYXNlIHRoZXkndmUgYmVlbiBtb2NrZWQgYnkgYSB0ZXN0aW5nIHN1aXRlLlxudmFyIHN1cHBvcnRzUG9pbnRlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNCcm93c2VyICYmIHdpbmRvdy5vbnBvaW50ZXJkb3duID09PSBudWxsO1xufTtcbnZhciBzdXBwb3J0c1RvdWNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc0Jyb3dzZXIgJiYgd2luZG93Lm9udG91Y2hzdGFydCA9PT0gbnVsbDtcbn07XG52YXIgc3VwcG9ydHNNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNCcm93c2VyICYmIHdpbmRvdy5vbm1vdXNlZG93biA9PT0gbnVsbDtcbn07XG5cbnZhciBtb3VzZUV2ZW50TmFtZXMgPSB7XG4gICAgcG9pbnRlcmRvd246IFwibW91c2Vkb3duXCIsXG4gICAgcG9pbnRlcm1vdmU6IFwibW91c2Vtb3ZlXCIsXG4gICAgcG9pbnRlcnVwOiBcIm1vdXNldXBcIixcbiAgICBwb2ludGVyY2FuY2VsOiBcIm1vdXNlY2FuY2VsXCIsXG4gICAgcG9pbnRlcm92ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgcG9pbnRlcm91dDogXCJtb3VzZW91dFwiLFxuICAgIHBvaW50ZXJlbnRlcjogXCJtb3VzZWVudGVyXCIsXG4gICAgcG9pbnRlcmxlYXZlOiBcIm1vdXNlbGVhdmVcIixcbn07XG52YXIgdG91Y2hFdmVudE5hbWVzID0ge1xuICAgIHBvaW50ZXJkb3duOiBcInRvdWNoc3RhcnRcIixcbiAgICBwb2ludGVybW92ZTogXCJ0b3VjaG1vdmVcIixcbiAgICBwb2ludGVydXA6IFwidG91Y2hlbmRcIixcbiAgICBwb2ludGVyY2FuY2VsOiBcInRvdWNoY2FuY2VsXCIsXG59O1xuZnVuY3Rpb24gZ2V0UG9pbnRlckV2ZW50TmFtZShuYW1lKSB7XG4gICAgaWYgKHN1cHBvcnRzUG9pbnRlckV2ZW50cygpKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdXBwb3J0c1RvdWNoRXZlbnRzKCkpIHtcbiAgICAgICAgcmV0dXJuIHRvdWNoRXZlbnROYW1lc1tuYW1lXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3VwcG9ydHNNb3VzZUV2ZW50cygpKSB7XG4gICAgICAgIHJldHVybiBtb3VzZUV2ZW50TmFtZXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gYWRkUG9pbnRlckV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFkZERvbUV2ZW50KHRhcmdldCwgZ2V0UG9pbnRlckV2ZW50TmFtZShldmVudE5hbWUpLCB3cmFwSGFuZGxlcihoYW5kbGVyLCBldmVudE5hbWUgPT09IFwicG9pbnRlcmRvd25cIiksIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdXNlUG9pbnRlckV2ZW50KHJlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHVzZURvbUV2ZW50KHJlZiwgZ2V0UG9pbnRlckV2ZW50TmFtZShldmVudE5hbWUpLCBoYW5kbGVyICYmIHdyYXBIYW5kbGVyKGhhbmRsZXIsIGV2ZW50TmFtZSA9PT0gXCJwb2ludGVyZG93blwiKSwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2sobmFtZSkge1xuICAgIHZhciBsb2NrID0gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3BlbkxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2NrID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxvY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvY2sgPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG9wZW5Mb2NrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxudmFyIGdsb2JhbEhvcml6b250YWxMb2NrID0gY3JlYXRlTG9jayhcImRyYWdIb3Jpem9udGFsXCIpO1xudmFyIGdsb2JhbFZlcnRpY2FsTG9jayA9IGNyZWF0ZUxvY2soXCJkcmFnVmVydGljYWxcIik7XG5mdW5jdGlvbiBnZXRHbG9iYWxMb2NrKGRyYWcpIHtcbiAgICB2YXIgbG9jayA9IGZhbHNlO1xuICAgIGlmIChkcmFnID09PSBcInlcIikge1xuICAgICAgICBsb2NrID0gZ2xvYmFsVmVydGljYWxMb2NrKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYWcgPT09IFwieFwiKSB7XG4gICAgICAgIGxvY2sgPSBnbG9iYWxIb3Jpem9udGFsTG9jaygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9wZW5Ib3Jpem9udGFsXzEgPSBnbG9iYWxIb3Jpem9udGFsTG9jaygpO1xuICAgICAgICB2YXIgb3BlblZlcnRpY2FsXzEgPSBnbG9iYWxWZXJ0aWNhbExvY2soKTtcbiAgICAgICAgaWYgKG9wZW5Ib3Jpem9udGFsXzEgJiYgb3BlblZlcnRpY2FsXzEpIHtcbiAgICAgICAgICAgIGxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb3Blbkhvcml6b250YWxfMSgpO1xuICAgICAgICAgICAgICAgIG9wZW5WZXJ0aWNhbF8xKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVsZWFzZSB0aGUgbG9ja3MgYmVjYXVzZSB3ZSBkb24ndCB1c2UgdGhlbVxuICAgICAgICAgICAgaWYgKG9wZW5Ib3Jpem9udGFsXzEpXG4gICAgICAgICAgICAgICAgb3Blbkhvcml6b250YWxfMSgpO1xuICAgICAgICAgICAgaWYgKG9wZW5WZXJ0aWNhbF8xKVxuICAgICAgICAgICAgICAgIG9wZW5WZXJ0aWNhbF8xKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2s7XG59XG5mdW5jdGlvbiBpc0RyYWdBY3RpdmUoKSB7XG4gICAgLy8gQ2hlY2sgdGhlIGdlc3R1cmUgbG9jayAtIGlmIHdlIGdldCBpdCwgaXQgbWVhbnMgbm8gZHJhZyBnZXN0dXJlIGlzIGFjdGl2ZVxuICAgIC8vIGFuZCB3ZSBjYW4gc2FmZWx5IGZpcmUgdGhlIHRhcCBnZXN0dXJlLlxuICAgIHZhciBvcGVuR2VzdHVyZUxvY2sgPSBnZXRHbG9iYWxMb2NrKHRydWUpO1xuICAgIGlmICghb3Blbkdlc3R1cmVMb2NrKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBvcGVuR2VzdHVyZUxvY2soKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudCwgaXNBY3RpdmUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghaXNNb3VzZUV2ZW50KGV2ZW50KSB8fCBpc0RyYWdBY3RpdmUoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuc3VyZSB3ZSB0cmlnZ2VyIGFuaW1hdGlvbnMgYmVmb3JlIGZpcmluZyBldmVudCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShleHBvcnRzLkFuaW1hdGlvblR5cGUuSG92ZXIsIGlzQWN0aXZlKTtcbiAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGV2ZW50LCBpbmZvKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlSG92ZXJHZXN0dXJlKF9hKSB7XG4gICAgdmFyIG9uSG92ZXJTdGFydCA9IF9hLm9uSG92ZXJTdGFydCwgb25Ib3ZlckVuZCA9IF9hLm9uSG92ZXJFbmQsIHdoaWxlSG92ZXIgPSBfYS53aGlsZUhvdmVyLCB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudDtcbiAgICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudCwgXCJwb2ludGVyZW50ZXJcIiwgb25Ib3ZlclN0YXJ0IHx8IHdoaWxlSG92ZXJcbiAgICAgICAgPyBjcmVhdGVIb3ZlckV2ZW50KHZpc3VhbEVsZW1lbnQsIHRydWUsIG9uSG92ZXJTdGFydClcbiAgICAgICAgOiB1bmRlZmluZWQsIHsgcGFzc2l2ZTogIW9uSG92ZXJTdGFydCB9KTtcbiAgICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudCwgXCJwb2ludGVybGVhdmVcIiwgb25Ib3ZlckVuZCB8fCB3aGlsZUhvdmVyXG4gICAgICAgID8gY3JlYXRlSG92ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBmYWxzZSwgb25Ib3ZlckVuZClcbiAgICAgICAgOiB1bmRlZmluZWQsIHsgcGFzc2l2ZTogIW9uSG92ZXJFbmQgfSk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgdXAgdGhlIHRyZWUgdG8gY2hlY2sgd2hldGhlciB0aGUgcHJvdmlkZWQgY2hpbGQgbm9kZVxuICogaXMgdGhlIHBhcmVudCBvciBhIGRlc2NlbmRhbnQgb2YgaXQuXG4gKlxuICogQHBhcmFtIHBhcmVudCAtIEVsZW1lbnQgdG8gZmluZFxuICogQHBhcmFtIGNoaWxkIC0gRWxlbWVudCB0byB0ZXN0IGFnYWluc3QgcGFyZW50XG4gKi9cbnZhciBpc05vZGVPckNoaWxkID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50ID09PSBjaGlsZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpc05vZGVPckNoaWxkKHBhcmVudCwgY2hpbGQucGFyZW50RWxlbWVudCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gdXNlVW5tb3VudEVmZmVjdChjYWxsYmFjaykge1xuICAgIHJldHVybiBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soKTsgfTsgfSwgW10pO1xufVxuXG4vKipcbiAqIEBwYXJhbSBoYW5kbGVycyAtXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlVGFwR2VzdHVyZShfYSkge1xuICAgIHZhciBvblRhcCA9IF9hLm9uVGFwLCBvblRhcFN0YXJ0ID0gX2Eub25UYXBTdGFydCwgb25UYXBDYW5jZWwgPSBfYS5vblRhcENhbmNlbCwgd2hpbGVUYXAgPSBfYS53aGlsZVRhcCwgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQ7XG4gICAgdmFyIGhhc1ByZXNzTGlzdGVuZXJzID0gb25UYXAgfHwgb25UYXBTdGFydCB8fCBvblRhcENhbmNlbCB8fCB3aGlsZVRhcDtcbiAgICB2YXIgaXNQcmVzc2luZyA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgdmFyIGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgLyoqXG4gICAgICogT25seSBzZXQgbGlzdGVuZXIgdG8gcGFzc2l2ZSBpZiB0aGVyZSBhcmUgbm8gZXh0ZXJuYWwgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIHZhciBldmVudE9wdGlvbnMgPSB7XG4gICAgICAgIHBhc3NpdmU6ICEob25UYXBTdGFydCB8fCBvblRhcCB8fCBvblRhcENhbmNlbCB8fCBvblBvaW50ZXJEb3duKSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMpO1xuICAgICAgICBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1BvaW50ZXJFbmQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmVtb3ZlUG9pbnRlckVuZExpc3RlbmVyKCk7XG4gICAgICAgIGlzUHJlc3NpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5UYXAsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuICFpc0RyYWdBY3RpdmUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyVXAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgaWYgKCFjaGVja1BvaW50ZXJFbmQoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIG9ubHkgY291bnQgdGhpcyBhcyBhIHRhcCBnZXN0dXJlIGlmIHRoZSBldmVudC50YXJnZXQgaXMgdGhlIHNhbWVcbiAgICAgICAgICogYXMsIG9yIGEgY2hpbGQgb2YsIHRoaXMgY29tcG9uZW50J3MgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgIWlzTm9kZU9yQ2hpbGQodmlzdWFsRWxlbWVudC5nZXRJbnN0YW5jZSgpLCBldmVudC50YXJnZXQpXG4gICAgICAgICAgICA/IG9uVGFwQ2FuY2VsID09PSBudWxsIHx8IG9uVGFwQ2FuY2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblRhcENhbmNlbChldmVudCwgaW5mbylcbiAgICAgICAgICAgIDogb25UYXAgPT09IG51bGwgfHwgb25UYXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVGFwKGV2ZW50LCBpbmZvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyQ2FuY2VsKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgIGlmICghY2hlY2tQb2ludGVyRW5kKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG9uVGFwQ2FuY2VsID09PSBudWxsIHx8IG9uVGFwQ2FuY2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblRhcENhbmNlbChldmVudCwgaW5mbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQsIGluZm8pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKTtcbiAgICAgICAgaWYgKGlzUHJlc3NpbmcuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaXNQcmVzc2luZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50ID0gcG9wbW90aW9uLnBpcGUoYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVydXBcIiwgb25Qb2ludGVyVXAsIGV2ZW50T3B0aW9ucyksIGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcmNhbmNlbFwiLCBvblBvaW50ZXJDYW5jZWwsIGV2ZW50T3B0aW9ucykpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5zdXJlIHdlIHRyaWdnZXIgYW5pbWF0aW9ucyBiZWZvcmUgZmlyaW5nIGV2ZW50IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5UYXAsIHRydWUpO1xuICAgICAgICBvblRhcFN0YXJ0ID09PSBudWxsIHx8IG9uVGFwU3RhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVGFwU3RhcnQoZXZlbnQsIGluZm8pO1xuICAgIH1cbiAgICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudCwgXCJwb2ludGVyZG93blwiLCBoYXNQcmVzc0xpc3RlbmVycyA/IG9uUG9pbnRlckRvd24gOiB1bmRlZmluZWQsIGV2ZW50T3B0aW9ucyk7XG4gICAgdXNlVW5tb3VudEVmZmVjdChyZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIpO1xufVxuXG52YXIgd2FybmVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gd2Fybk9uY2UoY29uZGl0aW9uLCBtZXNzYWdlLCBlbGVtZW50KSB7XG4gICAgaWYgKGNvbmRpdGlvbiB8fCB3YXJuZWQuaGFzKG1lc3NhZ2UpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIGlmIChlbGVtZW50KVxuICAgICAgICBjb25zb2xlLndhcm4oZWxlbWVudCk7XG4gICAgd2FybmVkLmFkZChtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBNYXAgYW4gSW50ZXJzZWN0aW9uSGFuZGxlciBjYWxsYmFjayB0byBhbiBlbGVtZW50LiBXZSBvbmx5IGV2ZXIgbWFrZSBvbmUgaGFuZGxlciBmb3Igb25lXG4gKiBlbGVtZW50LCBzbyBldmVuIHRob3VnaCB0aGVzZSBoYW5kbGVycyBtaWdodCBhbGwgYmUgdHJpZ2dlcmVkIGJ5IGRpZmZlcmVudFxuICogb2JzZXJ2ZXJzLCB3ZSBjYW4ga2VlcCB0aGVtIGluIHRoZSBzYW1lIG1hcC5cbiAqL1xudmFyIG9ic2VydmVyQ2FsbGJhY2tzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogTXVsdGlwbGUgb2JzZXJ2ZXJzIGNhbiBiZSBjcmVhdGVkIGZvciBtdWx0aXBsZSBlbGVtZW50L2RvY3VtZW50IHJvb3RzLiBFYWNoIHdpdGhcbiAqIGRpZmZlcmVudCBzZXR0aW5ncy4gU28gaGVyZSB3ZSBzdG9yZSBkaWN0aW9uYXJpZXMgb2Ygb2JzZXJ2ZXJzIHRvIGVhY2ggcm9vdCxcbiAqIHVzaW5nIHNlcmlhbGlzZWQgc2V0dGluZ3MgKHRocmVzaG9sZC9tYXJnaW4pIGFzIGxvb2t1cCBrZXlzLlxuICovXG52YXIgb2JzZXJ2ZXJzID0gbmV3IFdlYWtNYXAoKTtcbnZhciBmaXJlT2JzZXJ2ZXJDYWxsYmFjayA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBvYnNlcnZlckNhbGxiYWNrcy5nZXQoZW50cnkudGFyZ2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKGVudHJ5KTtcbn07XG52YXIgZmlyZUFsbE9ic2VydmVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICBlbnRyaWVzLmZvckVhY2goZmlyZU9ic2VydmVyQ2FsbGJhY2spO1xufTtcbmZ1bmN0aW9uIGluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcihfYSkge1xuICAgIHZhciByb290ID0gX2Eucm9vdCwgb3B0aW9ucyA9IHRzbGliLl9fcmVzdChfYSwgW1wicm9vdFwiXSk7XG4gICAgdmFyIGxvb2t1cFJvb3QgPSByb290IHx8IGRvY3VtZW50O1xuICAgIC8qKlxuICAgICAqIElmIHdlIGRvbid0IGhhdmUgYW4gb2JzZXJ2ZXIgbG9va3VwIG1hcCBmb3IgdGhpcyByb290LCBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIGlmICghb2JzZXJ2ZXJzLmhhcyhsb29rdXBSb290KSkge1xuICAgICAgICBvYnNlcnZlcnMuc2V0KGxvb2t1cFJvb3QsIHt9KTtcbiAgICB9XG4gICAgdmFyIHJvb3RPYnNlcnZlcnMgPSBvYnNlcnZlcnMuZ2V0KGxvb2t1cFJvb3QpO1xuICAgIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGFuIG9ic2VydmVyIGZvciB0aGlzIGNvbWJpbmF0aW9uIG9mIHJvb3QgYW5kIHNldHRpbmdzLFxuICAgICAqIGNyZWF0ZSBvbmUuXG4gICAgICovXG4gICAgaWYgKCFyb290T2JzZXJ2ZXJzW2tleV0pIHtcbiAgICAgICAgcm9vdE9ic2VydmVyc1trZXldID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcywgdHNsaWIuX19hc3NpZ24oeyByb290OiByb290IH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3RPYnNlcnZlcnNba2V5XTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVJbnRlcnNlY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgcm9vdEludGVyZXNlY3Rpb25PYnNlcnZlciA9IGluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcihvcHRpb25zKTtcbiAgICBvYnNlcnZlckNhbGxiYWNrcy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvYnNlcnZlckNhbGxiYWNrcy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0KF9hKSB7XG4gICAgdmFyIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50LCB3aGlsZUluVmlldyA9IF9hLndoaWxlSW5WaWV3LCBvblZpZXdwb3J0RW50ZXIgPSBfYS5vblZpZXdwb3J0RW50ZXIsIG9uVmlld3BvcnRMZWF2ZSA9IF9hLm9uVmlld3BvcnRMZWF2ZSwgX2IgPSBfYS52aWV3cG9ydCwgdmlld3BvcnQgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYjtcbiAgICB2YXIgc3RhdGUgPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBoYXNFbnRlcmVkVmlldzogZmFsc2UsXG4gICAgICAgIGlzSW5WaWV3OiBmYWxzZSxcbiAgICB9KTtcbiAgICB2YXIgc2hvdWxkT2JzZXJ2ZSA9IEJvb2xlYW4od2hpbGVJblZpZXcgfHwgb25WaWV3cG9ydEVudGVyIHx8IG9uVmlld3BvcnRMZWF2ZSk7XG4gICAgaWYgKHZpZXdwb3J0Lm9uY2UgJiYgc3RhdGUuY3VycmVudC5oYXNFbnRlcmVkVmlldylcbiAgICAgICAgc2hvdWxkT2JzZXJ2ZSA9IGZhbHNlO1xuICAgIHZhciB1c2VPYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICA/IHVzZU1pc3NpbmdJbnRlcnNlY3Rpb25PYnNlcnZlclxuICAgICAgICA6IHVzZUludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIHVzZU9ic2VydmVyKHNob3VsZE9ic2VydmUsIHN0YXRlLmN1cnJlbnQsIHZpc3VhbEVsZW1lbnQsIHZpZXdwb3J0KTtcbn1cbnZhciB0aHJlc2hvbGROYW1lcyA9IHtcbiAgICBzb21lOiAwLFxuICAgIGFsbDogMSxcbn07XG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcihzaG91bGRPYnNlcnZlLCBzdGF0ZSwgdmlzdWFsRWxlbWVudCwgX2EpIHtcbiAgICB2YXIgcm9vdCA9IF9hLnJvb3QsIHJvb3RNYXJnaW4gPSBfYS5tYXJnaW4sIF9iID0gX2EuYW1vdW50LCBhbW91bnQgPSBfYiA9PT0gdm9pZCAwID8gXCJzb21lXCIgOiBfYiwgb25jZSA9IF9hLm9uY2U7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFzaG91bGRPYnNlcnZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3QgPT09IG51bGwgfHwgcm9vdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm9vdC5jdXJyZW50LFxuICAgICAgICAgICAgcm9vdE1hcmdpbjogcm9vdE1hcmdpbixcbiAgICAgICAgICAgIHRocmVzaG9sZDogdHlwZW9mIGFtb3VudCA9PT0gXCJudW1iZXJcIiA/IGFtb3VudCA6IHRocmVzaG9sZE5hbWVzW2Ftb3VudF0sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25DYWxsYmFjayA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gZW50cnkuaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZXJlJ3MgYmVlbiBubyBjaGFuZ2UgaW4gdGhlIHZpZXdwb3J0IHN0YXRlLCBlYXJseSByZXR1cm4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0luVmlldyA9PT0gaXNJbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3RhdGUuaXNJblZpZXcgPSBpc0ludGVyc2VjdGluZztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSGFuZGxlIGhhc0VudGVyZWRWaWV3LiBJZiB0aGlzIGlzIG9ubHkgbWVhbnQgdG8gcnVuIG9uY2UsIGFuZFxuICAgICAgICAgICAgICogZWxlbWVudCBpc24ndCB2aXNpYmxlLCBlYXJseSByZXR1cm4uIE90aGVyd2lzZSBzZXQgaGFzRW50ZXJlZFZpZXcgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG9uY2UgJiYgIWlzSW50ZXJzZWN0aW5nICYmIHN0YXRlLmhhc0VudGVyZWRWaWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5oYXNFbnRlcmVkVmlldyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5JblZpZXcsIGlzSW50ZXJzZWN0aW5nKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXNlIHRoZSBsYXRlc3QgY29tbWl0dGVkIHByb3BzIHJhdGhlciB0aGFuIHRoZSBvbmVzIGluIHNjb3BlXG4gICAgICAgICAgICAgKiB3aGVuIHRoaXMgb2JzZXJ2ZXIgaXMgY3JlYXRlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBpc0ludGVyc2VjdGluZ1xuICAgICAgICAgICAgICAgID8gcHJvcHMub25WaWV3cG9ydEVudGVyXG4gICAgICAgICAgICAgICAgOiBwcm9wcy5vblZpZXdwb3J0TGVhdmU7XG4gICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZW50cnkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZUludGVyc2VjdGlvbih2aXN1YWxFbGVtZW50LmdldEluc3RhbmNlKCksIG9wdGlvbnMsIGludGVyc2VjdGlvbkNhbGxiYWNrKTtcbiAgICB9LCBbc2hvdWxkT2JzZXJ2ZSwgcm9vdCwgcm9vdE1hcmdpbiwgYW1vdW50XSk7XG59XG4vKipcbiAqIElmIEludGVyc2VjdGlvbk9ic2VydmVyIGlzIG1pc3NpbmcsIHdlIGFjdGl2YXRlIGluVmlldyBhbmQgZmlyZSBvblZpZXdwb3J0RW50ZXJcbiAqIG9uIG1vdW50LiBUaGlzIHdheSwgdGhlIHBhZ2Ugd2lsbCBiZSBpbiB0aGUgc3RhdGUgdGhlIGF1dGhvciBleHBlY3RzIHVzZXJzXG4gKiB0byBzZWUgaXQgaW4gZm9yIGV2ZXJ5b25lLlxuICovXG5mdW5jdGlvbiB1c2VNaXNzaW5nSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoc2hvdWxkT2JzZXJ2ZSwgc3RhdGUsIHZpc3VhbEVsZW1lbnQsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EuZmFsbGJhY2ssIGZhbGxiYWNrID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNob3VsZE9ic2VydmUgfHwgIWZhbGxiYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZW52ICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgd2Fybk9uY2UoZmFsc2UsIFwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgbm90IGF2YWlsYWJsZSBvbiB0aGlzIGRldmljZS4gd2hpbGVJblZpZXcgYW5pbWF0aW9ucyB3aWxsIHRyaWdnZXIgb24gbW91bnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlIHRoaXMgaW4gYW4gckFGIGJlY2F1c2UsIGF0IHRoaXMgcG9pbnQsIHRoZSBhbmltYXRpb24gc3RhdGVcbiAgICAgICAgICogd29uJ3QgaGF2ZSBmbHVzaGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmQgdGhlcmUncyBjZXJ0YWluIGxvZ2ljIGluXG4gICAgICAgICAqIHRoZXJlIHRoYXQgYmVoYXZlcyBkaWZmZXJlbnRseSBvbiB0aGUgaW5pdGlhbCBhbmltYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaG9vayBzaG91bGQgYmUgcXVpdGUgcmFyZWx5IGNhbGxlZCBzbyBzZXR0aW5nIHRoaXMgaW4gYW4gckFGXG4gICAgICAgICAqIGlzIHByZWZlcnJlZCB0byBjaGFuZ2luZyB0aGUgYmVoYXZpb3VyIG9mIHRoZSBhbmltYXRpb24gc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgc3RhdGUuaGFzRW50ZXJlZFZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9uVmlld3BvcnRFbnRlciA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS5vblZpZXdwb3J0RW50ZXI7XG4gICAgICAgICAgICBvblZpZXdwb3J0RW50ZXIgPT09IG51bGwgfHwgb25WaWV3cG9ydEVudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblZpZXdwb3J0RW50ZXIobnVsbCk7XG4gICAgICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5JblZpZXcsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9LCBbc2hvdWxkT2JzZXJ2ZV0pO1xufVxuXG52YXIgbWFrZVJlbmRlcmxlc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgaG9vayhwcm9wcyk7XG4gICAgcmV0dXJuIG51bGw7XG59OyB9O1xuXG52YXIgZ2VzdHVyZUFuaW1hdGlvbnMgPSB7XG4gICAgaW5WaWV3OiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VWaWV3cG9ydCksXG4gICAgdGFwOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VUYXBHZXN0dXJlKSxcbiAgICBmb2N1czogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlRm9jdXNHZXN0dXJlKSxcbiAgICBob3ZlcjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlSG92ZXJHZXN0dXJlKSxcbn07XG5cbnZhciBjb3VudGVyID0gMDtcbnZhciBpbmNyZW1lbnRJZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvdW50ZXIrKzsgfTtcbnZhciB1c2VJZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVzZUNvbnN0YW50KGluY3JlbWVudElkKTsgfTtcbi8qKlxuICogSWRlYWxseSB3ZSdkIHVzZSB0aGUgZm9sbG93aW5nIGNvZGUgdG8gc3VwcG9ydCBSZWFjdCAxOCBvcHRpb25hbGx5LlxuICogQnV0IHRoaXMgZmFpcmx5IGZhaWxzIGluIFdlYnBhY2sgKG90aGVyd2lzZSB0cmVlc2hha2luZyB3b3VsZG4ndCB3b3JrIGF0IGFsbCkuXG4gKiBOZWVkIHRvIGNvbWUgdXAgd2l0aCBhIGRpZmZlcmVudCB3YXkgb2YgZmlndXJpbmcgdGhpcyBvdXQuXG4gKi9cbi8vIGV4cG9ydCBjb25zdCB1c2VJZCA9IChSZWFjdCBhcyBhbnkpLnVzZUlkXG4vLyAgICAgPyAoUmVhY3QgYXMgYW55KS51c2VJZFxuLy8gICAgIDogKCkgPT4gdXNlQ29uc3RhbnQoaW5jcmVtZW50SWQpXG5cbi8qKlxuICogV2hlbiBhIGNvbXBvbmVudCBpcyB0aGUgY2hpbGQgb2YgYEFuaW1hdGVQcmVzZW5jZWAsIGl0IGNhbiB1c2UgYHVzZVByZXNlbmNlYFxuICogdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IHdoZXRoZXIgaXQncyBzdGlsbCBwcmVzZW50IGluIHRoZSBSZWFjdCB0cmVlLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgdXNlUHJlc2VuY2UgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgW2lzUHJlc2VudCwgc2FmZVRvUmVtb3ZlXSA9IHVzZVByZXNlbmNlKClcbiAqXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgICAgIWlzUHJlc2VudCAmJiBzZXRUaW1lb3V0KHNhZmVUb1JlbW92ZSwgMTAwMClcbiAqICAgfSwgW2lzUHJlc2VudF0pXG4gKlxuICogICByZXR1cm4gPGRpdiAvPlxuICogfVxuICogYGBgXG4gKlxuICogSWYgYGlzUHJlc2VudGAgaXMgYGZhbHNlYCwgaXQgbWVhbnMgdGhhdCBhIGNvbXBvbmVudCBoYXMgYmVlbiByZW1vdmVkIHRoZSB0cmVlLCBidXRcbiAqIGBBbmltYXRlUHJlc2VuY2VgIHdvbid0IHJlYWxseSByZW1vdmUgaXQgdW50aWwgYHNhZmVUb1JlbW92ZWAgaGFzIGJlZW4gY2FsbGVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlUHJlc2VuY2UoKSB7XG4gICAgdmFyIGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBbdHJ1ZSwgbnVsbF07XG4gICAgdmFyIGlzUHJlc2VudCA9IGNvbnRleHQuaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSA9IGNvbnRleHQub25FeGl0Q29tcGxldGUsIHJlZ2lzdGVyID0gY29udGV4dC5yZWdpc3RlcjtcbiAgICAvLyBJdCdzIHNhZmUgdG8gY2FsbCB0aGUgZm9sbG93aW5nIGhvb2tzIGNvbmRpdGlvbmFsbHkgKGFmdGVyIGFuIGVhcmx5IHJldHVybikgYmVjYXVzZSB0aGUgY29udGV4dCB3aWxsIGFsd2F5c1xuICAgIC8vIGVpdGhlciBiZSBudWxsIG9yIG5vbi1udWxsIGZvciB0aGUgbGlmZXNwYW4gb2YgdGhlIGNvbXBvbmVudC5cbiAgICAvLyBSZXBsYWNlIHdpdGggdXNlSWQgd2hlbiByZWxlYXNlZCBpbiBSZWFjdFxuICAgIHZhciBpZCA9IHVzZUlkKCk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ2lzdGVyKGlkKTsgfSwgW10pO1xuICAgIHZhciBzYWZlVG9SZW1vdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvbkV4aXRDb21wbGV0ZSA9PT0gbnVsbCB8fCBvbkV4aXRDb21wbGV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FeGl0Q29tcGxldGUoaWQpOyB9O1xuICAgIHJldHVybiAhaXNQcmVzZW50ICYmIG9uRXhpdENvbXBsZXRlID8gW2ZhbHNlLCBzYWZlVG9SZW1vdmVdIDogW3RydWVdO1xufVxuLyoqXG4gKiBTaW1pbGFyIHRvIGB1c2VQcmVzZW5jZWAsIGV4Y2VwdCBgdXNlSXNQcmVzZW50YCBzaW1wbHkgcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHByZXNlbnQuXG4gKiBUaGVyZSBpcyBubyBgc2FmZVRvUmVtb3ZlYCBmdW5jdGlvbi5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IHVzZUlzUHJlc2VudCB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBleHBvcnQgY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBpc1ByZXNlbnQgPSB1c2VJc1ByZXNlbnQoKVxuICpcbiAqICAgdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgICAhaXNQcmVzZW50ICYmIGNvbnNvbGUubG9nKFwiSSd2ZSBiZWVuIHJlbW92ZWQhXCIpXG4gKiAgIH0sIFtpc1ByZXNlbnRdKVxuICpcbiAqICAgcmV0dXJuIDxkaXYgLz5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlSXNQcmVzZW50KCkge1xuICAgIHJldHVybiBpc1ByZXNlbnQoUmVhY3QudXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpKTtcbn1cbmZ1bmN0aW9uIGlzUHJlc2VudChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQgPT09IG51bGwgPyB0cnVlIDogY29udGV4dC5pc1ByZXNlbnQ7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJldikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcHJldkxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICAgIGlmIChwcmV2TGVuZ3RoICE9PSBuZXh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmV2W2ldICE9PSBuZXh0W2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xuICpcbiAqIEBwYXJhbSBzZWNvbmRzIC0gVGltZSBpbiBzZWNvbmRzLlxuICogQHJldHVybiBtaWxsaXNlY29uZHMgLSBDb252ZXJ0ZWQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBzZWNvbmRzVG9NaWxsaXNlY29uZHMgPSBmdW5jdGlvbiAoc2Vjb25kcykgeyByZXR1cm4gc2Vjb25kcyAqIDEwMDA7IH07XG5cbnZhciBlYXNpbmdMb29rdXAgPSB7XG4gICAgbGluZWFyOiBwb3Btb3Rpb24ubGluZWFyLFxuICAgIGVhc2VJbjogcG9wbW90aW9uLmVhc2VJbixcbiAgICBlYXNlSW5PdXQ6IHBvcG1vdGlvbi5lYXNlSW5PdXQsXG4gICAgZWFzZU91dDogcG9wbW90aW9uLmVhc2VPdXQsXG4gICAgY2lyY0luOiBwb3Btb3Rpb24uY2lyY0luLFxuICAgIGNpcmNJbk91dDogcG9wbW90aW9uLmNpcmNJbk91dCxcbiAgICBjaXJjT3V0OiBwb3Btb3Rpb24uY2lyY091dCxcbiAgICBiYWNrSW46IHBvcG1vdGlvbi5iYWNrSW4sXG4gICAgYmFja0luT3V0OiBwb3Btb3Rpb24uYmFja0luT3V0LFxuICAgIGJhY2tPdXQ6IHBvcG1vdGlvbi5iYWNrT3V0LFxuICAgIGFudGljaXBhdGU6IHBvcG1vdGlvbi5hbnRpY2lwYXRlLFxuICAgIGJvdW5jZUluOiBwb3Btb3Rpb24uYm91bmNlSW4sXG4gICAgYm91bmNlSW5PdXQ6IHBvcG1vdGlvbi5ib3VuY2VJbk91dCxcbiAgICBib3VuY2VPdXQ6IHBvcG1vdGlvbi5ib3VuY2VPdXQsXG59O1xudmFyIGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uID0gZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgICAgICAvLyBJZiBjdWJpYyBiZXppZXIgZGVmaW5pdGlvbiwgY3JlYXRlIGJlemllciBjdXJ2ZVxuICAgICAgICBoZXlMaXN0ZW4uaW52YXJpYW50KGRlZmluaXRpb24ubGVuZ3RoID09PSA0LCBcIkN1YmljIGJlemllciBhcnJheXMgbXVzdCBjb250YWluIGZvdXIgbnVtZXJpY2FsIHZhbHVlcy5cIik7XG4gICAgICAgIHZhciBfYSA9IHRzbGliLl9fcmVhZChkZWZpbml0aW9uLCA0KSwgeDEgPSBfYVswXSwgeTEgPSBfYVsxXSwgeDIgPSBfYVsyXSwgeTIgPSBfYVszXTtcbiAgICAgICAgcmV0dXJuIHBvcG1vdGlvbi5jdWJpY0Jlemllcih4MSwgeTEsIHgyLCB5Mik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEVsc2UgbG9va3VwIGZyb20gdGFibGVcbiAgICAgICAgaGV5TGlzdGVuLmludmFyaWFudChlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl0gIT09IHVuZGVmaW5lZCwgXCJJbnZhbGlkIGVhc2luZyB0eXBlICdcIi5jb25jYXQoZGVmaW5pdGlvbiwgXCInXCIpKTtcbiAgICAgICAgcmV0dXJuIGVhc2luZ0xvb2t1cFtkZWZpbml0aW9uXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb247XG59O1xudmFyIGlzRWFzaW5nQXJyYXkgPSBmdW5jdGlvbiAoZWFzZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGVhc2UpICYmIHR5cGVvZiBlYXNlWzBdICE9PSBcIm51bWJlclwiO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuaW1hdGFibGUuIEV4YW1wbGVzOlxuICpcbiAqIOKchTogMTAwLCBcIjEwMHB4XCIsIFwiI2ZmZlwiXG4gKiDinYw6IFwiYmxvY2tcIiwgXCJ1cmwoMi5qcGcpXCJcbiAqIEBwYXJhbSB2YWx1ZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgaXNBbmltYXRhYmxlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBJZiB0aGUgbGlzdCBvZiBrZXlzIHRhdCBtaWdodCBiZSBub24tYW5pbWF0YWJsZSBncm93cywgcmVwbGFjZSB3aXRoIFNldFxuICAgIGlmIChrZXkgPT09IFwiekluZGV4XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBJZiBpdCdzIGEgbnVtYmVyIG9yIGEga2V5ZnJhbWVzIGFycmF5LCB3ZSBjYW4gYW5pbWF0ZSBpdC4gV2UgbWlnaHQgYXQgc29tZSBwb2ludFxuICAgIC8vIG5lZWQgdG8gZG8gYSBkZWVwIGlzQW5pbWF0YWJsZSBjaGVjayBvZiBrZXlmcmFtZXMsIG9yIGxldCBQb3Btb3Rpb24gaGFuZGxlIHRoaXMsXG4gICAgLy8gYnV0IGZvciBub3cgbGV0cyBsZWF2ZSBpdCBsaWtlIHRoaXMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIC8vIEl0J3MgYW5pbWF0YWJsZSBpZiB3ZSBoYXZlIGEgc3RyaW5nXG4gICAgICAgIHN0eWxlVmFsdWVUeXBlcy5jb21wbGV4LnRlc3QodmFsdWUpICYmIC8vIEFuZCBpdCBjb250YWlucyBudW1iZXJzIGFuZC9vciBjb2xvcnNcbiAgICAgICAgIXZhbHVlLnN0YXJ0c1dpdGgoXCJ1cmwoXCIpIC8vIFVubGVzcyBpdCBzdGFydHMgd2l0aCBcInVybChcIlxuICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIHVuZGVyRGFtcGVkU3ByaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICB0eXBlOiBcInNwcmluZ1wiLFxuICAgIHN0aWZmbmVzczogNTAwLFxuICAgIGRhbXBpbmc6IDI1LFxuICAgIHJlc3RTcGVlZDogMTAsXG59KTsgfTtcbnZhciBjcml0aWNhbGx5RGFtcGVkU3ByaW5nID0gZnVuY3Rpb24gKHRvKSB7IHJldHVybiAoe1xuICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gICAgc3RpZmZuZXNzOiA1NTAsXG4gICAgZGFtcGluZzogdG8gPT09IDAgPyAyICogTWF0aC5zcXJ0KDU1MCkgOiAzMCxcbiAgICByZXN0U3BlZWQ6IDEwLFxufSk7IH07XG52YXIgbGluZWFyVHdlZW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIHR5cGU6IFwia2V5ZnJhbWVzXCIsXG4gICAgZWFzZTogXCJsaW5lYXJcIixcbiAgICBkdXJhdGlvbjogMC4zLFxufSk7IH07XG52YXIga2V5ZnJhbWVzID0gZnVuY3Rpb24gKHZhbHVlcykgeyByZXR1cm4gKHtcbiAgICB0eXBlOiBcImtleWZyYW1lc1wiLFxuICAgIGR1cmF0aW9uOiAwLjgsXG4gICAgdmFsdWVzOiB2YWx1ZXMsXG59KTsgfTtcbnZhciBkZWZhdWx0VHJhbnNpdGlvbnMgPSB7XG4gICAgeDogdW5kZXJEYW1wZWRTcHJpbmcsXG4gICAgeTogdW5kZXJEYW1wZWRTcHJpbmcsXG4gICAgejogdW5kZXJEYW1wZWRTcHJpbmcsXG4gICAgcm90YXRlOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICByb3RhdGVYOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICByb3RhdGVZOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICByb3RhdGVaOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICBzY2FsZVg6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsXG4gICAgc2NhbGVZOiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nLFxuICAgIHNjYWxlOiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nLFxuICAgIG9wYWNpdHk6IGxpbmVhclR3ZWVuLFxuICAgIGJhY2tncm91bmRDb2xvcjogbGluZWFyVHdlZW4sXG4gICAgY29sb3I6IGxpbmVhclR3ZWVuLFxuICAgIGRlZmF1bHQ6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsXG59O1xudmFyIGdldERlZmF1bHRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHZhbHVlS2V5LCB0bykge1xuICAgIHZhciB0cmFuc2l0aW9uRmFjdG9yeTtcbiAgICBpZiAoaXNLZXlmcmFtZXNUYXJnZXQodG8pKSB7XG4gICAgICAgIHRyYW5zaXRpb25GYWN0b3J5ID0ga2V5ZnJhbWVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJhbnNpdGlvbkZhY3RvcnkgPVxuICAgICAgICAgICAgZGVmYXVsdFRyYW5zaXRpb25zW3ZhbHVlS2V5XSB8fCBkZWZhdWx0VHJhbnNpdGlvbnMuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHsgdG86IHRvIH0sIHRyYW5zaXRpb25GYWN0b3J5KHRvKSk7XG59O1xuXG4vKipcbiAqIEEgbWFwIG9mIGRlZmF1bHQgdmFsdWUgdHlwZXMgZm9yIGNvbW1vbiB2YWx1ZXNcbiAqL1xudmFyIGRlZmF1bHRWYWx1ZVR5cGVzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG51bWJlclZhbHVlVHlwZXMpLCB7IFxuICAgIC8vIENvbG9yIHByb3BzXG4gICAgY29sb3I6IHN0eWxlVmFsdWVUeXBlcy5jb2xvciwgYmFja2dyb3VuZENvbG9yOiBzdHlsZVZhbHVlVHlwZXMuY29sb3IsIG91dGxpbmVDb2xvcjogc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLCBmaWxsOiBzdHlsZVZhbHVlVHlwZXMuY29sb3IsIHN0cm9rZTogc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLCBcbiAgICAvLyBCb3JkZXIgcHJvcHNcbiAgICBib3JkZXJDb2xvcjogc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLCBib3JkZXJUb3BDb2xvcjogc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLCBib3JkZXJSaWdodENvbG9yOiBzdHlsZVZhbHVlVHlwZXMuY29sb3IsIGJvcmRlckJvdHRvbUNvbG9yOiBzdHlsZVZhbHVlVHlwZXMuY29sb3IsIGJvcmRlckxlZnRDb2xvcjogc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLCBmaWx0ZXI6IHN0eWxlVmFsdWVUeXBlcy5maWx0ZXIsIFdlYmtpdEZpbHRlcjogc3R5bGVWYWx1ZVR5cGVzLmZpbHRlciB9KTtcbi8qKlxuICogR2V0cyB0aGUgZGVmYXVsdCBWYWx1ZVR5cGUgZm9yIHRoZSBwcm92aWRlZCB2YWx1ZSBrZXlcbiAqL1xudmFyIGdldERlZmF1bHRWYWx1ZVR5cGUgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZWZhdWx0VmFsdWVUeXBlc1trZXldOyB9O1xuXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlTm9uZShrZXksIHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBkZWZhdWx0VmFsdWVUeXBlID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpO1xuICAgIGlmIChkZWZhdWx0VmFsdWVUeXBlICE9PSBzdHlsZVZhbHVlVHlwZXMuZmlsdGVyKVxuICAgICAgICBkZWZhdWx0VmFsdWVUeXBlID0gc3R5bGVWYWx1ZVR5cGVzLmNvbXBsZXg7XG4gICAgLy8gSWYgdmFsdWUgaXMgbm90IHJlY29nbmlzZWQgYXMgYW5pbWF0YWJsZSwgaWUgXCJub25lXCIsIGNyZWF0ZSBhbiBhbmltYXRhYmxlIHZlcnNpb24gb3JpZ2luIGJhc2VkIG9uIHRoZSB0YXJnZXRcbiAgICByZXR1cm4gKF9hID0gZGVmYXVsdFZhbHVlVHlwZS5nZXRBbmltYXRhYmxlTm9uZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGVmYXVsdFZhbHVlVHlwZSwgdmFsdWUpO1xufVxuXG52YXIgaW5zdGFudEFuaW1hdGlvblN0YXRlID0ge1xuICAgIGN1cnJlbnQ6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBEZWNpZGUgd2hldGhlciBhIHRyYW5zaXRpb24gaXMgZGVmaW5lZCBvbiBhIGdpdmVuIFRyYW5zaXRpb24uXG4gKiBUaGlzIGZpbHRlcnMgb3V0IG9yY2hlc3RyYXRpb24gb3B0aW9ucyBhbmQgcmV0dXJucyB0cnVlXG4gKiBpZiBhbnkgb3B0aW9ucyBhcmUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gaXNUcmFuc2l0aW9uRGVmaW5lZChfYSkge1xuICAgIF9hLndoZW47IF9hLmRlbGF5OyBfYS5kZWxheUNoaWxkcmVuOyBfYS5zdGFnZ2VyQ2hpbGRyZW47IF9hLnN0YWdnZXJEaXJlY3Rpb247IF9hLnJlcGVhdDsgX2EucmVwZWF0VHlwZTsgX2EucmVwZWF0RGVsYXk7IF9hLmZyb207IHZhciB0cmFuc2l0aW9uID0gdHNsaWIuX19yZXN0KF9hLCBbXCJ3aGVuXCIsIFwiZGVsYXlcIiwgXCJkZWxheUNoaWxkcmVuXCIsIFwic3RhZ2dlckNoaWxkcmVuXCIsIFwic3RhZ2dlckRpcmVjdGlvblwiLCBcInJlcGVhdFwiLCBcInJlcGVhdFR5cGVcIiwgXCJyZXBlYXREZWxheVwiLCBcImZyb21cIl0pO1xuICAgIHJldHVybiAhIU9iamVjdC5rZXlzKHRyYW5zaXRpb24pLmxlbmd0aDtcbn1cbnZhciBsZWdhY3lSZXBlYXRXYXJuaW5nID0gZmFsc2U7XG4vKipcbiAqIENvbnZlcnQgRnJhbWVyIE1vdGlvbidzIFRyYW5zaXRpb24gdHlwZSBpbnRvIFBvcG1vdGlvbi1jb21wYXRpYmxlIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUcmFuc2l0aW9uVG9BbmltYXRpb25PcHRpb25zKF9hKSB7XG4gICAgdmFyIGVhc2UgPSBfYS5lYXNlLCB0aW1lcyA9IF9hLnRpbWVzLCB5b3lvID0gX2EueW95bywgZmxpcCA9IF9hLmZsaXAsIGxvb3AgPSBfYS5sb29wLCB0cmFuc2l0aW9uID0gdHNsaWIuX19yZXN0KF9hLCBbXCJlYXNlXCIsIFwidGltZXNcIiwgXCJ5b3lvXCIsIFwiZmxpcFwiLCBcImxvb3BcIl0pO1xuICAgIHZhciBvcHRpb25zID0gdHNsaWIuX19hc3NpZ24oe30sIHRyYW5zaXRpb24pO1xuICAgIGlmICh0aW1lcylcbiAgICAgICAgb3B0aW9uc1tcIm9mZnNldFwiXSA9IHRpbWVzO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW55IGV4aXN0aW5nIGR1cmF0aW9ucyBmcm9tIHNlY29uZHMgdG8gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgaWYgKHRyYW5zaXRpb24uZHVyYXRpb24pXG4gICAgICAgIG9wdGlvbnNbXCJkdXJhdGlvblwiXSA9IHNlY29uZHNUb01pbGxpc2Vjb25kcyh0cmFuc2l0aW9uLmR1cmF0aW9uKTtcbiAgICBpZiAodHJhbnNpdGlvbi5yZXBlYXREZWxheSlcbiAgICAgICAgb3B0aW9ucy5yZXBlYXREZWxheSA9IHNlY29uZHNUb01pbGxpc2Vjb25kcyh0cmFuc2l0aW9uLnJlcGVhdERlbGF5KTtcbiAgICAvKipcbiAgICAgKiBNYXAgZWFzaW5nIG5hbWVzIHRvIFBvcG1vdGlvbidzIGVhc2luZyBmdW5jdGlvbnNcbiAgICAgKi9cbiAgICBpZiAoZWFzZSkge1xuICAgICAgICBvcHRpb25zW1wiZWFzZVwiXSA9IGlzRWFzaW5nQXJyYXkoZWFzZSlcbiAgICAgICAgICAgID8gZWFzZS5tYXAoZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24pXG4gICAgICAgICAgICA6IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKGVhc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXBwb3J0IGxlZ2FjeSB0cmFuc2l0aW9uIEFQSVxuICAgICAqL1xuICAgIGlmICh0cmFuc2l0aW9uLnR5cGUgPT09IFwidHdlZW5cIilcbiAgICAgICAgb3B0aW9ucy50eXBlID0gXCJrZXlmcmFtZXNcIjtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBUaGVzZSBvcHRpb25zIGFyZSBvZmZpY2lhbGx5IHJlbW92ZWQgZnJvbSB0aGUgQVBJLlxuICAgICAqL1xuICAgIGlmICh5b3lvIHx8IGxvb3AgfHwgZmxpcCkge1xuICAgICAgICBoZXlMaXN0ZW4ud2FybmluZyghbGVnYWN5UmVwZWF0V2FybmluZywgXCJ5b3lvLCBsb29wIGFuZCBmbGlwIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIEFQSS4gUmVwbGFjZSB3aXRoIHJlcGVhdCBhbmQgcmVwZWF0VHlwZSBvcHRpb25zLlwiKTtcbiAgICAgICAgbGVnYWN5UmVwZWF0V2FybmluZyA9IHRydWU7XG4gICAgICAgIGlmICh5b3lvKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcInJldmVyc2VcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcImxvb3BcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmbGlwKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcIm1pcnJvclwiO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucmVwZWF0ID0gbG9vcCB8fCB5b3lvIHx8IGZsaXAgfHwgdHJhbnNpdGlvbi5yZXBlYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRPRE86IFBvcG1vdGlvbiA5IGhhcyB0aGUgYWJpbGl0eSB0byBhdXRvbWF0aWNhbGx5IGRldGVjdCB3aGV0aGVyIHRvIHVzZVxuICAgICAqIGEga2V5ZnJhbWVzIG9yIHNwcmluZyBhbmltYXRpb24sIGJ1dCBkb2VzIHNvIGJ5IGRldGVjdGluZyB2ZWxvY2l0eSBhbmQgb3RoZXIgc3ByaW5nIG9wdGlvbnMuXG4gICAgICogSXQnZCBiZSBnb29kIHRvIGludHJvZHVjZSBhIHNpbWlsYXIgdGhpbmcgaGVyZS5cbiAgICAgKi9cbiAgICBpZiAodHJhbnNpdGlvbi50eXBlICE9PSBcInNwcmluZ1wiKVxuICAgICAgICBvcHRpb25zLnR5cGUgPSBcImtleWZyYW1lc1wiO1xuICAgIHJldHVybiBvcHRpb25zO1xufVxuLyoqXG4gKiBHZXQgdGhlIGRlbGF5IGZvciBhIHZhbHVlIGJ5IGNoZWNraW5nIFRyYW5zaXRpb24gd2l0aCBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICovXG5mdW5jdGlvbiBnZXREZWxheUZyb21UcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIHZhbHVlVHJhbnNpdGlvbiA9IGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHx8IHt9O1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB2YWx1ZVRyYW5zaXRpb24uZGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRyYW5zaXRpb24uZGVsYXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG59XG5mdW5jdGlvbiBoeWRyYXRlS2V5ZnJhbWVzKG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnRvKSAmJiBvcHRpb25zLnRvWzBdID09PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMudG8gPSB0c2xpYi5fX3NwcmVhZEFycmF5KFtdLCB0c2xpYi5fX3JlYWQob3B0aW9ucy50byksIGZhbHNlKTtcbiAgICAgICAgb3B0aW9ucy50b1swXSA9IG9wdGlvbnMuZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRQb3Btb3Rpb25BbmltYXRpb25PcHRpb25zKHRyYW5zaXRpb24sIG9wdGlvbnMsIGtleSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnRvKSkge1xuICAgICAgICAoX2EgPSB0cmFuc2l0aW9uLmR1cmF0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodHJhbnNpdGlvbi5kdXJhdGlvbiA9IDAuOCk7XG4gICAgfVxuICAgIGh5ZHJhdGVLZXlmcmFtZXMob3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogR2V0IGEgZGVmYXVsdCB0cmFuc2l0aW9uIGlmIG5vbmUgaXMgZGV0ZXJtaW5lZCB0byBiZSBkZWZpbmVkLlxuICAgICAqL1xuICAgIGlmICghaXNUcmFuc2l0aW9uRGVmaW5lZCh0cmFuc2l0aW9uKSkge1xuICAgICAgICB0cmFuc2l0aW9uID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRyYW5zaXRpb24pLCBnZXREZWZhdWx0VHJhbnNpdGlvbihrZXksIG9wdGlvbnMudG8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgY29udmVydFRyYW5zaXRpb25Ub0FuaW1hdGlvbk9wdGlvbnModHJhbnNpdGlvbikpO1xufVxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiBnZXRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uLCBvbkNvbXBsZXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciB2YWx1ZVRyYW5zaXRpb24gPSBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KTtcbiAgICB2YXIgb3JpZ2luID0gKF9hID0gdmFsdWVUcmFuc2l0aW9uLmZyb20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLmdldCgpO1xuICAgIHZhciBpc1RhcmdldEFuaW1hdGFibGUgPSBpc0FuaW1hdGFibGUoa2V5LCB0YXJnZXQpO1xuICAgIGlmIChvcmlnaW4gPT09IFwibm9uZVwiICYmIGlzVGFyZ2V0QW5pbWF0YWJsZSAmJiB0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSB0cnlpbmcgdG8gYW5pbWF0ZSBmcm9tIFwibm9uZVwiLCB0cnkgYW5kIGdldCBhbiBhbmltYXRhYmxlIHZlcnNpb25cbiAgICAgICAgICogb2YgdGhlIHRhcmdldC4gVGhpcyBjb3VsZCBiZSBpbXByb3ZlZCB0byB3b3JrIGJvdGggd2F5cy5cbiAgICAgICAgICovXG4gICAgICAgIG9yaWdpbiA9IGdldEFuaW1hdGFibGVOb25lKGtleSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNaZXJvKG9yaWdpbikgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvcmlnaW4gPSBnZXRaZXJvVW5pdCh0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmXG4gICAgICAgIGlzWmVybyh0YXJnZXQpICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGFyZ2V0ID0gZ2V0WmVyb1VuaXQob3JpZ2luKTtcbiAgICB9XG4gICAgdmFyIGlzT3JpZ2luQW5pbWF0YWJsZSA9IGlzQW5pbWF0YWJsZShrZXksIG9yaWdpbik7XG4gICAgaGV5TGlzdGVuLndhcm5pbmcoaXNPcmlnaW5BbmltYXRhYmxlID09PSBpc1RhcmdldEFuaW1hdGFibGUsIFwiWW91IGFyZSB0cnlpbmcgdG8gYW5pbWF0ZSBcIi5jb25jYXQoa2V5LCBcIiBmcm9tIFxcXCJcIikuY29uY2F0KG9yaWdpbiwgXCJcXFwiIHRvIFxcXCJcIikuY29uY2F0KHRhcmdldCwgXCJcXFwiLiBcIikuY29uY2F0KG9yaWdpbiwgXCIgaXMgbm90IGFuIGFuaW1hdGFibGUgdmFsdWUgLSB0byBlbmFibGUgdGhpcyBhbmltYXRpb24gc2V0IFwiKS5jb25jYXQob3JpZ2luLCBcIiB0byBhIHZhbHVlIGFuaW1hdGFibGUgdG8gXCIpLmNvbmNhdCh0YXJnZXQsIFwiIHZpYSB0aGUgYHN0eWxlYCBwcm9wZXJ0eS5cIikpO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGZyb206IG9yaWdpbixcbiAgICAgICAgICAgIHRvOiB0YXJnZXQsXG4gICAgICAgICAgICB2ZWxvY2l0eTogdmFsdWUuZ2V0VmVsb2NpdHkoKSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGUsXG4gICAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHZhbHVlLnNldCh2KTsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZhbHVlVHJhbnNpdGlvbi50eXBlID09PSBcImluZXJ0aWFcIiB8fFxuICAgICAgICAgICAgdmFsdWVUcmFuc2l0aW9uLnR5cGUgPT09IFwiZGVjYXlcIlxuICAgICAgICAgICAgPyBwb3Btb3Rpb24uaW5lcnRpYSh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHZhbHVlVHJhbnNpdGlvbikpXG4gICAgICAgICAgICA6IHBvcG1vdGlvbi5hbmltYXRlKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBnZXRQb3Btb3Rpb25BbmltYXRpb25PcHRpb25zKHZhbHVlVHJhbnNpdGlvbiwgb3B0aW9ucywga2V5KSksIHsgb25VcGRhdGU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblVwZGF0ZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdmFsdWVUcmFuc2l0aW9uLm9uVXBkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2YWx1ZVRyYW5zaXRpb24sIHYpO1xuICAgICAgICAgICAgICAgIH0sIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdmFsdWVUcmFuc2l0aW9uLm9uQ29tcGxldGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHZhbHVlVHJhbnNpdGlvbik7XG4gICAgICAgICAgICAgICAgfSB9KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGZpbmFsVGFyZ2V0ID0gcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyh0YXJnZXQpO1xuICAgICAgICB2YWx1ZS5zZXQoZmluYWxUYXJnZXQpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIChfYSA9IHZhbHVlVHJhbnNpdGlvbiA9PT0gbnVsbCB8fCB2YWx1ZVRyYW5zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlVHJhbnNpdGlvbi5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodmFsdWVUcmFuc2l0aW9uLCBmaW5hbFRhcmdldCk7XG4gICAgICAgIChfYiA9IHZhbHVlVHJhbnNpdGlvbiA9PT0gbnVsbCB8fCB2YWx1ZVRyYW5zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh2YWx1ZVRyYW5zaXRpb24pO1xuICAgICAgICByZXR1cm4geyBzdG9wOiBmdW5jdGlvbiAoKSB7IH0gfTtcbiAgICB9XG4gICAgcmV0dXJuICFpc09yaWdpbkFuaW1hdGFibGUgfHxcbiAgICAgICAgIWlzVGFyZ2V0QW5pbWF0YWJsZSB8fFxuICAgICAgICB2YWx1ZVRyYW5zaXRpb24udHlwZSA9PT0gZmFsc2VcbiAgICAgICAgPyBzZXRcbiAgICAgICAgOiBzdGFydDtcbn1cbmZ1bmN0aW9uIGlzWmVybyh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgPT09IDAgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgcGFyc2VGbG9hdCh2YWx1ZSkgPT09IDAgJiZcbiAgICAgICAgICAgIHZhbHVlLmluZGV4T2YoXCIgXCIpID09PSAtMSkpO1xufVxuZnVuY3Rpb24gZ2V0WmVyb1VuaXQocG90ZW50aWFsVW5pdFR5cGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHBvdGVudGlhbFVuaXRUeXBlID09PSBcIm51bWJlclwiXG4gICAgICAgID8gMFxuICAgICAgICA6IGdldEFuaW1hdGFibGVOb25lKFwiXCIsIHBvdGVudGlhbFVuaXRUeXBlKTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbltrZXldIHx8IHRyYW5zaXRpb25bXCJkZWZhdWx0XCJdIHx8IHRyYW5zaXRpb247XG59XG4vKipcbiAqIFN0YXJ0IGFuaW1hdGlvbiBvbiBhIE1vdGlvblZhbHVlLiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGludGVyZmFjZSBiZXR3ZWVuXG4gKiBGcmFtZXIgTW90aW9uIGFuZCBQb3Btb3Rpb25cbiAqL1xuZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uKSB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT09IHZvaWQgMCkgeyB0cmFuc2l0aW9uID0ge307IH1cbiAgICBpZiAoaW5zdGFudEFuaW1hdGlvblN0YXRlLmN1cnJlbnQpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IHsgdHlwZTogZmFsc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnN0YXJ0KGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBkZWxheVRpbWVyO1xuICAgICAgICB2YXIgY29udHJvbHM7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSBnZXRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uLCBvbkNvbXBsZXRlKTtcbiAgICAgICAgdmFyIGRlbGF5ID0gZ2V0RGVsYXlGcm9tVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpO1xuICAgICAgICB2YXIgc3RhcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoY29udHJvbHMgPSBhbmltYXRpb24oKSk7IH07XG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgZGVsYXlUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHN0YXJ0LCBzZWNvbmRzVG9NaWxsaXNlY29uZHMoZGVsYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWxheVRpbWVyKTtcbiAgICAgICAgICAgIGNvbnRyb2xzID09PSBudWxsIHx8IGNvbnRyb2xzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250cm9scy5zdG9wKCk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgYSBudW1lcmljYWwgc3RyaW5nLCBpZSBhIHN0cmluZyB0aGF0IGlzIHB1cmVseSBhIG51bWJlciBlZyBcIjEwMFwiIG9yIFwiLTEwMC4xXCJcbiAqL1xudmFyIGlzTnVtZXJpY2FsU3RyaW5nID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIC9eXFwtP1xcZCpcXC4/XFxkKyQvLnRlc3Qodik7IH07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgemVybyB2YWx1ZSBzdHJpbmcgbGlrZSBcIjBweFwiIG9yIFwiMCVcIlxuICovXG52YXIgaXNaZXJvVmFsdWVTdHJpbmcgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gL14wW14uXFxzXSskLy50ZXN0KHYpOyB9O1xuXG5mdW5jdGlvbiBhZGRVbmlxdWVJdGVtKGFyciwgaXRlbSkge1xuICAgIGFyci5pbmRleE9mKGl0ZW0pID09PSAtMSAmJiBhcnIucHVzaChpdGVtKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0oYXJyLCBpdGVtKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaW5kZXggPiAtMSAmJiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBhcnJheS1tb3ZlXG5mdW5jdGlvbiBtb3ZlSXRlbShfYSwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgdmFyIF9iID0gdHNsaWIuX19yZWFkKF9hKSwgYXJyID0gX2Iuc2xpY2UoMCk7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBmcm9tSW5kZXggPCAwID8gYXJyLmxlbmd0aCArIGZyb21JbmRleCA6IGZyb21JbmRleDtcbiAgICBpZiAoc3RhcnRJbmRleCA+PSAwICYmIHN0YXJ0SW5kZXggPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHRvSW5kZXggPCAwID8gYXJyLmxlbmd0aCArIHRvSW5kZXggOiB0b0luZGV4O1xuICAgICAgICB2YXIgX2MgPSB0c2xpYi5fX3JlYWQoYXJyLnNwbGljZShmcm9tSW5kZXgsIDEpLCAxKSwgaXRlbSA9IF9jWzBdO1xuICAgICAgICBhcnIuc3BsaWNlKGVuZEluZGV4LCAwLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxudmFyIFN1YnNjcmlwdGlvbk1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uTWFuYWdlcigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5zdWJzY3JpcHRpb25zLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZUl0ZW0oX3RoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7IH07XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25NYW5hZ2VyLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICB2YXIgbnVtU3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgIGlmICghbnVtU3Vic2NyaXB0aW9ucylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG51bVN1YnNjcmlwdGlvbnMgPT09IDEpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlcmUncyBvbmx5IGEgc2luZ2xlIGhhbmRsZXIgd2UgY2FuIGp1c3QgY2FsbCBpdCB3aXRob3V0IGludm9raW5nIGEgbG9vcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zWzBdKGEsIGIsIGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TdWJzY3JpcHRpb25zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBoYW5kbGVyIGV4aXN0cyBiZWZvcmUgZmlyaW5nIGFzIGl0J3MgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3Vic2NyaXB0aW9ucyB3ZXJlIG1vZGlmaWVkIGR1cmluZyB0aGlzIGxvb3AgcnVubmluZy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIoYSwgYiwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbk1hbmFnZXI7XG59KCkpO1xuXG52YXIgaXNGbG9hdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufTtcbi8qKlxuICogYE1vdGlvblZhbHVlYCBpcyB1c2VkIHRvIHRyYWNrIHRoZSBzdGF0ZSBhbmQgdmVsb2NpdHkgb2YgbW90aW9uIHZhbHVlcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBNb3Rpb25WYWx1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaW5pdCAtIFRoZSBpbml0aWF0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAqXG4gICAgICogLSAgYHRyYW5zZm9ybWVyYDogQSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gaW5jb21pbmcgdmFsdWVzIHdpdGguXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNb3Rpb25WYWx1ZShpbml0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGJ1aWxkIHN0ZXAgd2l0aCB0aGUgbGF0ZXN0IHZlcnNpb24gbnVtYmVyLlxuICAgICAgICAgKiBXaGVuIE1vdGlvblZhbHVlcyBhcmUgcHJvdmlkZWQgdG8gbW90aW9uIGNvbXBvbmVudHMsIHdhcm4gaWYgdmVyc2lvbnMgYXJlIG1peGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCI2LjUuMVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRHVyYXRpb24sIGluIG1pbGxpc2Vjb25kcywgc2luY2UgbGFzdCB1cGRhdGluZyBmcmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVEZWx0YSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lc3RhbXAgb2YgdGhlIGxhc3QgdGltZSB0aGlzIGBNb3Rpb25WYWx1ZWAgd2FzIHVwZGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGdW5jdGlvbnMgdG8gbm90aWZ5IHdoZW4gdGhlIGBNb3Rpb25WYWx1ZWAgdXBkYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9ucyB0byBub3RpZnkgd2hlbiB0aGUgdmVsb2NpdHkgdXBkYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25zIHRvIG5vdGlmeSB3aGVuIHRoZSBgTW90aW9uVmFsdWVgIHVwZGF0ZXMgYW5kIGByZW5kZXJgIGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJTdWJzY3JpYmVycyA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3Mgd2hldGhlciB0aGlzIHZhbHVlIGNhbiBvdXRwdXQgYSB2ZWxvY2l0eS4gQ3VycmVudGx5IHRoaXMgaXMgb25seSB0cnVlXG4gICAgICAgICAqIGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljYWwsIGJ1dCB3ZSBtaWdodCBiZSBhYmxlIHRvIHdpZGVuIHRoZSBzY29wZSBoZXJlIGFuZCBzdXBwb3J0XG4gICAgICAgICAqIG90aGVyIHZhbHVlIHR5cGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSA9IGZ1bmN0aW9uICh2LCByZW5kZXIpIHtcbiAgICAgICAgICAgIGlmIChyZW5kZXIgPT09IHZvaWQgMCkgeyByZW5kZXIgPSB0cnVlOyB9XG4gICAgICAgICAgICBfdGhpcy5wcmV2ID0gX3RoaXMuY3VycmVudDtcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnQgPSB2O1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRpbWVzdGFtcFxuICAgICAgICAgICAgdmFyIF9hID0gc3luYy5nZXRGcmFtZURhdGEoKSwgZGVsdGEgPSBfYS5kZWx0YSwgdGltZXN0YW1wID0gX2EudGltZXN0YW1wO1xuICAgICAgICAgICAgaWYgKF90aGlzLmxhc3RVcGRhdGVkICE9PSB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50aW1lRGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0VXBkYXRlZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5wb3N0UmVuZGVyKF90aGlzLnNjaGVkdWxlVmVsb2NpdHlDaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdXBkYXRlIHN1YnNjcmliZXJzXG4gICAgICAgICAgICBpZiAoX3RoaXMucHJldiAhPT0gX3RoaXMuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVN1YnNjcmliZXJzLm5vdGlmeShfdGhpcy5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2ZWxvY2l0eSBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgaWYgKF90aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMuZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5ub3RpZnkoX3RoaXMuZ2V0VmVsb2NpdHkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgcmVuZGVyIHN1YnNjcmliZXJzXG4gICAgICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyU3Vic2NyaWJlcnMubm90aWZ5KF90aGlzLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZWR1bGUgYSB2ZWxvY2l0eSBjaGVjayBmb3IgdGhlIG5leHQgZnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYW4gaW5zdGFuY2VkIGFuZCBib3VuZCBmdW5jdGlvbiB0byBwcmV2ZW50IGdlbmVyYXRpbmcgYSBuZXdcbiAgICAgICAgICogZnVuY3Rpb24gb25jZSBwZXIgZnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2hlZHVsZVZlbG9jaXR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5wb3N0UmVuZGVyKF90aGlzLnZlbG9jaXR5Q2hlY2spOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBgcHJldmAgd2l0aCBgY3VycmVudGAgaWYgdGhlIHZhbHVlIGhhc24ndCBiZWVuIHVwZGF0ZWQgdGhpcyBmcmFtZS5cbiAgICAgICAgICogVGhpcyBlbnN1cmVzIHZlbG9jaXR5IGNhbGN1bGF0aW9ucyByZXR1cm4gYDBgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGFuIGluc3RhbmNlZCBhbmQgYm91bmQgZnVuY3Rpb24gdG8gcHJldmVudCBnZW5lcmF0aW5nIGEgbmV3XG4gICAgICAgICAqIGZ1bmN0aW9uIG9uY2UgcGVyIGZyYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVsb2NpdHlDaGVjayA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IF9hLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgIT09IF90aGlzLmxhc3RVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJldiA9IF90aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgX3RoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5ub3RpZnkoX3RoaXMuZ2V0VmVsb2NpdHkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmV2ID0gdGhpcy5jdXJyZW50ID0gaW5pdDtcbiAgICAgICAgdGhpcy5jYW5UcmFja1ZlbG9jaXR5ID0gaXNGbG9hdCh0aGlzLmN1cnJlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGBNb3Rpb25WYWx1ZWAgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgd2lsbCBjYW5jZWwgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIFdoZW4gY2FsbGluZyBgb25DaGFuZ2VgIGluc2lkZSBhIFJlYWN0IGNvbXBvbmVudCwgaXQgc2hvdWxkIGJlIHdyYXBwZWQgd2l0aCB0aGVcbiAgICAgKiBgdXNlRWZmZWN0YCBob29rLiBBcyBpdCByZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLCB0aGlzIHNob3VsZCBiZSByZXR1cm5lZFxuICAgICAqIGZyb20gdGhlIGB1c2VFZmZlY3RgIGZ1bmN0aW9uIHRvIGVuc3VyZSB5b3UgZG9uJ3QgYWRkIGR1cGxpY2F0ZSBzdWJzY3JpYmVycy4uXG4gICAgICpcbiAgICAgKiBgYGBqc3hcbiAgICAgKiBleHBvcnQgY29uc3QgTXlDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICogICBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcbiAgICAgKiAgIGNvbnN0IHkgPSB1c2VNb3Rpb25WYWx1ZSgwKVxuICAgICAqICAgY29uc3Qgb3BhY2l0eSA9IHVzZU1vdGlvblZhbHVlKDEpXG4gICAgICpcbiAgICAgKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICogICAgIGZ1bmN0aW9uIHVwZGF0ZU9wYWNpdHkoKSB7XG4gICAgICogICAgICAgY29uc3QgbWF4WFkgPSBNYXRoLm1heCh4LmdldCgpLCB5LmdldCgpKVxuICAgICAqICAgICAgIGNvbnN0IG5ld09wYWNpdHkgPSB0cmFuc2Zvcm0obWF4WFksIFswLCAxMDBdLCBbMSwgMF0pXG4gICAgICogICAgICAgb3BhY2l0eS5zZXQobmV3T3BhY2l0eSlcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogICAgIGNvbnN0IHVuc3Vic2NyaWJlWCA9IHgub25DaGFuZ2UodXBkYXRlT3BhY2l0eSlcbiAgICAgKiAgICAgY29uc3QgdW5zdWJzY3JpYmVZID0geS5vbkNoYW5nZSh1cGRhdGVPcGFjaXR5KVxuICAgICAqXG4gICAgICogICAgIHJldHVybiAoKSA9PiB7XG4gICAgICogICAgICAgdW5zdWJzY3JpYmVYKClcbiAgICAgKiAgICAgICB1bnN1YnNjcmliZVkoKVxuICAgICAqICAgICB9XG4gICAgICogICB9LCBbXSlcbiAgICAgKlxuICAgICAqICAgcmV0dXJuIDxtb3Rpb24uZGl2IHN0eWxlPXt7IHggfX0gLz5cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVJlbWFya3NcbiAgICAgKlxuICAgICAqIFdlIGNvdWxkIGxvb2sgaW50byBhIGB1c2VPbkNoYW5nZWAgaG9vayBpZiB0aGUgYWJvdmUgbGlmZWN5Y2xlIG1hbmFnZW1lbnQgcHJvdmVzIGNvbmZ1c2luZy5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIHVzZU9uQ2hhbmdlKHgsICgpID0+IHt9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHN1YnNjcmliZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGxhdGVzdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIGNhbmNlbCB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzLmFkZChzdWJzY3JpcHRpb24pO1xuICAgIH07XG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmNsZWFyTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGBNb3Rpb25WYWx1ZWAgcmVxdWVzdHMgYSByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlciAtIEEgZnVuY3Rpb24gdGhhdCdzIHByb3ZpZGVkIHRoZSBsYXRlc3QgdmFsdWUuXG4gICAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgd2lsbCBjYW5jZWwgdGhpcyBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUub25SZW5kZXJSZXF1ZXN0ID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAvLyBSZW5kZXIgaW1tZWRpYXRlbHlcbiAgICAgICAgc3Vic2NyaXB0aW9uKHRoaXMuZ2V0KCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgcGFzc2l2ZSBlZmZlY3QgdG8gdGhlIGBNb3Rpb25WYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHBhc3NpdmVFZmZlY3QpIHtcbiAgICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0ID0gcGFzc2l2ZUVmZmVjdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBgTW90aW9uVmFsdWVgLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIGNvbnN0IHggPSB1c2VNb3Rpb25WYWx1ZSgwKVxuICAgICAqIHguc2V0KDEwKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGxhdGVzdCAtIExhdGVzdCB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHJlbmRlciAtIFdoZXRoZXIgdG8gbm90aWZ5IHJlbmRlciBzdWJzY3JpYmVycy4gRGVmYXVsdHMgdG8gYHRydWVgXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCByZW5kZXIpIHtcbiAgICAgICAgaWYgKHJlbmRlciA9PT0gdm9pZCAwKSB7IHJlbmRlciA9IHRydWU7IH1cbiAgICAgICAgaWYgKCFyZW5kZXIgfHwgIXRoaXMucGFzc2l2ZUVmZmVjdCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBbmROb3RpZnkodiwgcmVuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFzc2l2ZUVmZmVjdCh2LCB0aGlzLnVwZGF0ZUFuZE5vdGlmeSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCBzdGF0ZSBvZiBgTW90aW9uVmFsdWVgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBsYXRlc3Qgc3RhdGUgb2YgYE1vdGlvblZhbHVlYFxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmdldFByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF0ZXN0IHZlbG9jaXR5IG9mIGBNb3Rpb25WYWx1ZWBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGxhdGVzdCB2ZWxvY2l0eSBvZiBgTW90aW9uVmFsdWVgLiBSZXR1cm5zIGAwYCBpZiB0aGUgc3RhdGUgaXMgbm9uLW51bWVyaWNhbC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgaXNGbG9hdCh0aGlzLnByZXYpICYmIGlzRmxvYXQodGhpcy5jdXJyZW50KSwgYnV0IHRoYXQgd291bGQgYmUgd2FzdGVmdWxcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuVHJhY2tWZWxvY2l0eVxuICAgICAgICAgICAgPyAvLyBUaGVzZSBjYXN0cyBjb3VsZCBiZSBhdm9pZGVkIGlmIHBhcnNlRmxvYXQgd291bGQgYmUgdHlwZWQgYmV0dGVyXG4gICAgICAgICAgICAgICAgcG9wbW90aW9uLnZlbG9jaXR5UGVyU2Vjb25kKHBhcnNlRmxvYXQodGhpcy5jdXJyZW50KSAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5wcmV2KSwgdGhpcy50aW1lRGVsdGEpXG4gICAgICAgICAgICA6IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgYW5pbWF0aW9uIHRvIGNvbnRyb2wgdGhpcyBgTW90aW9uVmFsdWVgLiBPbmx5IG9uZVxuICAgICAqIGFuaW1hdGlvbiBjYW4gZHJpdmUgYSBgTW90aW9uVmFsdWVgIGF0IG9uZSB0aW1lLlxuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogdmFsdWUuc3RhcnQoKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiAtIEEgZnVuY3Rpb24gdGhhdCBzdGFydHMgdGhlIHByb3ZpZGVkIGFuaW1hdGlvblxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBfdGhpcy5oYXNBbmltYXRlZCA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5zdG9wQW5pbWF0aW9uID0gYW5pbWF0aW9uKHJlc29sdmUpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsZWFyQW5pbWF0aW9uKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgY3VycmVudGx5IGFjdGl2ZSBhbmltYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BBbmltYXRpb24pXG4gICAgICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5jbGVhckFuaW1hdGlvbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyB2YWx1ZSBpcyBjdXJyZW50bHkgYW5pbWF0aW5nLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5pc0FuaW1hdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zdG9wQW5pbWF0aW9uO1xuICAgIH07XG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmNsZWFyQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24gPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhbmQgY2xlYW4gdXAgc3Vic2NyaWJlcnMgdG8gdGhpcyBgTW90aW9uVmFsdWVgLlxuICAgICAqXG4gICAgICogVGhlIGBNb3Rpb25WYWx1ZWAgaG9va3MgbGlrZSBgdXNlTW90aW9uVmFsdWVgIGFuZCBgdXNlVHJhbnNmb3JtYCBhdXRvbWF0aWNhbGx5XG4gICAgICogaGFuZGxlIHRoZSBsaWZlY3ljbGUgb2YgdGhlIHJldHVybmVkIGBNb3Rpb25WYWx1ZWAsIHNvIHRoaXMgbWV0aG9kIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIHlvdSd2ZSBtYW51YWxseVxuICAgICAqIGNyZWF0ZWQgYSBgTW90aW9uVmFsdWVgIHZpYSB0aGUgYG1vdGlvblZhbHVlYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLnJlbmRlclN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1vdGlvblZhbHVlO1xufSgpKTtcbmZ1bmN0aW9uIG1vdGlvblZhbHVlKGluaXQpIHtcbiAgICByZXR1cm4gbmV3IE1vdGlvblZhbHVlKGluaXQpO1xufVxuXG4vKipcbiAqIFRlc3RzIGEgcHJvdmlkZWQgdmFsdWUgYWdhaW5zdCBhIFZhbHVlVHlwZVxuICovXG52YXIgdGVzdFZhbHVlVHlwZSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS50ZXN0KHYpOyB9OyB9O1xuXG4vKipcbiAqIFZhbHVlVHlwZSBmb3IgXCJhdXRvXCJcbiAqL1xudmFyIGF1dG8gPSB7XG4gICAgdGVzdDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgPT09IFwiYXV0b1wiOyB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdjsgfSxcbn07XG5cbi8qKlxuICogQSBsaXN0IG9mIHZhbHVlIHR5cGVzIGNvbW1vbmx5IHVzZWQgZm9yIGRpbWVuc2lvbnNcbiAqL1xudmFyIGRpbWVuc2lvblZhbHVlVHlwZXMgPSBbc3R5bGVWYWx1ZVR5cGVzLm51bWJlciwgc3R5bGVWYWx1ZVR5cGVzLnB4LCBzdHlsZVZhbHVlVHlwZXMucGVyY2VudCwgc3R5bGVWYWx1ZVR5cGVzLmRlZ3JlZXMsIHN0eWxlVmFsdWVUeXBlcy52dywgc3R5bGVWYWx1ZVR5cGVzLnZoLCBhdXRvXTtcbi8qKlxuICogVGVzdHMgYSBkaW1lbnNpb25hbCB2YWx1ZSBhZ2FpbnN0IHRoZSBsaXN0IG9mIGRpbWVuc2lvbiBWYWx1ZVR5cGVzXG4gKi9cbnZhciBmaW5kRGltZW5zaW9uVmFsdWVUeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gZGltZW5zaW9uVmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpO1xufTtcblxuLyoqXG4gKiBBIGxpc3Qgb2YgYWxsIFZhbHVlVHlwZXNcbiAqL1xudmFyIHZhbHVlVHlwZXMgPSB0c2xpYi5fX3NwcmVhZEFycmF5KHRzbGliLl9fc3ByZWFkQXJyYXkoW10sIHRzbGliLl9fcmVhZChkaW1lbnNpb25WYWx1ZVR5cGVzKSwgZmFsc2UpLCBbc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLCBzdHlsZVZhbHVlVHlwZXMuY29tcGxleF0sIGZhbHNlKTtcbi8qKlxuICogVGVzdHMgYSB2YWx1ZSBhZ2FpbnN0IHRoZSBsaXN0IG9mIFZhbHVlVHlwZXNcbiAqL1xudmFyIGZpbmRWYWx1ZVR5cGUgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpOyB9O1xuXG4vKipcbiAqIFNldCBWaXN1YWxFbGVtZW50J3MgTW90aW9uVmFsdWUsIGNyZWF0aW5nIGEgbmV3IE1vdGlvblZhbHVlIGZvciBpdCBpZlxuICogaXQgZG9lc24ndCBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICAgIGlmICh2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aXN1YWxFbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUodmFsdWUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIHZhciBfYSA9IHJlc29sdmVkID8gdmlzdWFsRWxlbWVudC5tYWtlVGFyZ2V0QW5pbWF0YWJsZShyZXNvbHZlZCwgZmFsc2UpIDoge30sIF9iID0gX2EudHJhbnNpdGlvbkVuZCwgdHJhbnNpdGlvbkVuZCA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iOyBfYS50cmFuc2l0aW9uOyB2YXIgdGFyZ2V0ID0gdHNsaWIuX19yZXN0KF9hLCBbXCJ0cmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvblwiXSk7XG4gICAgdGFyZ2V0ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRhcmdldCksIHRyYW5zaXRpb25FbmQpO1xuICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyh0YXJnZXRba2V5XSk7XG4gICAgICAgIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQsIGtleSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFZhcmlhbnRzKHZpc3VhbEVsZW1lbnQsIHZhcmlhbnRMYWJlbHMpIHtcbiAgICB2YXIgcmV2ZXJzZWRMYWJlbHMgPSB0c2xpYi5fX3NwcmVhZEFycmF5KFtdLCB0c2xpYi5fX3JlYWQodmFyaWFudExhYmVscyksIGZhbHNlKS5yZXZlcnNlKCk7XG4gICAgcmV2ZXJzZWRMYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHZhcmlhbnQgPSB2aXN1YWxFbGVtZW50LmdldFZhcmlhbnQoa2V5KTtcbiAgICAgICAgdmFyaWFudCAmJiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgdmFyaWFudCk7XG4gICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHNldFZhcmlhbnRzKGNoaWxkLCB2YXJpYW50TGFiZWxzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZXModmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBzZXRWYXJpYW50cyh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHNldFZhcmlhbnRzKHZpc3VhbEVsZW1lbnQsIFtkZWZpbml0aW9uXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXModmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICB2YXIgX2Q7XG4gICAgdmFyIG5ld1ZhbHVlS2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICF2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSk7IH0pO1xuICAgIHZhciBudW1OZXdWYWx1ZXMgPSBuZXdWYWx1ZUtleXMubGVuZ3RoO1xuICAgIGlmICghbnVtTmV3VmFsdWVzKVxuICAgICAgICByZXR1cm47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1OZXdWYWx1ZXM7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gbmV3VmFsdWVLZXlzW2ldO1xuICAgICAgICB2YXIgdGFyZ2V0VmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB0YXJnZXQgaXMgYSBzZXJpZXMgb2Yga2V5ZnJhbWVzLCB3ZSBjYW4gdXNlIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgICAgKiBpbiB0aGUgYXJyYXkuIElmIHRoaXMgZmlyc3QgdmFsdWUgaXMgbnVsbCwgd2UnbGwgc3RpbGwgbmVlZCB0byByZWFkIGZyb20gdGhlIERPTS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0YXJnZXRWYWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHRhcmdldCBpc24ndCBrZXlmcmFtZXMsIG9yIHRoZSBmaXJzdCBrZXlmcmFtZSB3YXMgbnVsbCwgd2UgbmVlZCB0b1xuICAgICAgICAgKiBmaXJzdCBjaGVjayBpZiBhbiBvcmlnaW4gdmFsdWUgd2FzIGV4cGxpY2l0bHkgZGVmaW5lZCBpbiB0aGUgdHJhbnNpdGlvbiBhcyBcImZyb21cIixcbiAgICAgICAgICogaWYgbm90IHJlYWQgdGhlIHZhbHVlIGZyb20gdGhlIERPTS4gQXMgYW4gYWJzb2x1dGUgZmFsbGJhY2ssIHRha2UgdGhlIGRlZmluZWQgdGFyZ2V0IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IChfYiA9IChfYSA9IG9yaWdpbltrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2aXN1YWxFbGVtZW50LnJlYWRWYWx1ZShrZXkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0YXJnZXRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdmFsdWUgaXMgc3RpbGwgdW5kZWZpbmVkIG9yIG51bGwsIGlnbm9yZSBpdC4gUHJlZmVyYWJseSB0aGlzIHdvdWxkIHRocm93LFxuICAgICAgICAgKiBidXQgdGhpcyB3YXMgY2F1c2luZyBpc3N1ZXMgaW4gRnJhbWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgKGlzTnVtZXJpY2FsU3RyaW5nKHZhbHVlKSB8fCBpc1plcm9WYWx1ZVN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbnVtYmVyIHJlYWQgYXMgYSBzdHJpbmcsIGllIFwiMFwiIG9yIFwiMjAwXCIsIGNvbnZlcnQgaXQgdG8gYSBudW1iZXJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWZpbmRWYWx1ZVR5cGUodmFsdWUpICYmIHN0eWxlVmFsdWVUeXBlcy5jb21wbGV4LnRlc3QodGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGdldEFuaW1hdGFibGVOb25lKGtleSwgdGFyZ2V0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZSh2YWx1ZSkpO1xuICAgICAgICAoX2MgPSAoX2QgPSBvcmlnaW4pW2tleV0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChfZFtrZXldID0gdmFsdWUpO1xuICAgICAgICB2aXN1YWxFbGVtZW50LnNldEJhc2VUYXJnZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0T3JpZ2luRnJvbVRyYW5zaXRpb24oa2V5LCB0cmFuc2l0aW9uKSB7XG4gICAgaWYgKCF0cmFuc2l0aW9uKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIHZhbHVlVHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSB8fCB0cmFuc2l0aW9uW1wiZGVmYXVsdFwiXSB8fCB0cmFuc2l0aW9uO1xuICAgIHJldHVybiB2YWx1ZVRyYW5zaXRpb24uZnJvbTtcbn1cbmZ1bmN0aW9uIGdldE9yaWdpbih0YXJnZXQsIHRyYW5zaXRpb24sIHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBvcmlnaW4gPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIG9yaWdpbltrZXldID1cbiAgICAgICAgICAgIChfYSA9IGdldE9yaWdpbkZyb21UcmFuc2l0aW9uKGtleSwgdHJhbnNpdGlvbikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldCgpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ2luO1xufVxuXG5mdW5jdGlvbiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2aXN1YWxFbGVtZW50Lm5vdGlmeUFuaW1hdGlvblN0YXJ0KGRlZmluaXRpb24pO1xuICAgIHZhciBhbmltYXRpb247XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBkZWZpbml0aW9uLm1hcChmdW5jdGlvbiAodmFyaWFudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgYW5pbWF0aW9uID0gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlc29sdmVkRGVmaW5pdGlvbiA9IHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucy5jdXN0b20pXG4gICAgICAgICAgICA6IGRlZmluaXRpb247XG4gICAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgcmVzb2x2ZWREZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbi50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZpc3VhbEVsZW1lbnQubm90aWZ5QW5pbWF0aW9uQ29tcGxldGUoZGVmaW5pdGlvbik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucy5jdXN0b20pO1xuICAgIHZhciBfYiA9IChyZXNvbHZlZCB8fCB7fSkudHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IF9iID09PSB2b2lkIDAgPyB2aXN1YWxFbGVtZW50LmdldERlZmF1bHRUcmFuc2l0aW9uKCkgfHwge30gOiBfYjtcbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uT3ZlcnJpZGUpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIGEgdmFyaWFudCwgY3JlYXRlIGEgY2FsbGJhY2sgdGhhdCBydW5zIGl0IGFzIGFuIGFuaW1hdGlvbi5cbiAgICAgKiBPdGhlcndpc2UsIHdlIHJlc29sdmUgYSBQcm9taXNlIGltbWVkaWF0ZWx5IGZvciBhIGNvbXBvc2FibGUgbm8tb3AuXG4gICAgICovXG4gICAgdmFyIGdldEFuaW1hdGlvbiA9IHJlc29sdmVkXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCByZXNvbHZlZCwgb3B0aW9ucyk7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgfTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIGNoaWxkcmVuLCBjcmVhdGUgYSBjYWxsYmFjayB0aGF0IHJ1bnMgYWxsIHRoZWlyIGFuaW1hdGlvbnMuXG4gICAgICogT3RoZXJ3aXNlLCB3ZSByZXNvbHZlIGEgUHJvbWlzZSBpbW1lZGlhdGVseSBmb3IgYSBjb21wb3NhYmxlIG5vLW9wLlxuICAgICAqL1xuICAgIHZhciBnZXRDaGlsZEFuaW1hdGlvbnMgPSAoKF9hID0gdmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplKVxuICAgICAgICA/IGZ1bmN0aW9uIChmb3J3YXJkRGVsYXkpIHtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkRGVsYXkgPT09IHZvaWQgMCkgeyBmb3J3YXJkRGVsYXkgPSAwOyB9XG4gICAgICAgICAgICB2YXIgX2EgPSB0cmFuc2l0aW9uLmRlbGF5Q2hpbGRyZW4sIGRlbGF5Q2hpbGRyZW4gPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hLCBzdGFnZ2VyQ2hpbGRyZW4gPSB0cmFuc2l0aW9uLnN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiA9IHRyYW5zaXRpb24uc3RhZ2dlckRpcmVjdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRlQ2hpbGRyZW4odmlzdWFsRWxlbWVudCwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiArIGZvcndhcmREZWxheSwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0cmFuc2l0aW9uIGV4cGxpY2l0bHkgZGVmaW5lcyBhIFwid2hlblwiIG9wdGlvbiwgd2UgbmVlZCB0byByZXNvbHZlIGVpdGhlclxuICAgICAqIHRoaXMgYW5pbWF0aW9uIG9yIGFsbCBjaGlsZHJlbiBhbmltYXRpb25zIGJlZm9yZSBwbGF5aW5nIHRoZSBvdGhlci5cbiAgICAgKi9cbiAgICB2YXIgd2hlbiA9IHRyYW5zaXRpb24ud2hlbjtcbiAgICBpZiAod2hlbikge1xuICAgICAgICB2YXIgX2MgPSB0c2xpYi5fX3JlYWQod2hlbiA9PT0gXCJiZWZvcmVDaGlsZHJlblwiXG4gICAgICAgICAgICA/IFtnZXRBbmltYXRpb24sIGdldENoaWxkQW5pbWF0aW9uc11cbiAgICAgICAgICAgIDogW2dldENoaWxkQW5pbWF0aW9ucywgZ2V0QW5pbWF0aW9uXSwgMiksIGZpcnN0ID0gX2NbMF0sIGxhc3QgPSBfY1sxXTtcbiAgICAgICAgcmV0dXJuIGZpcnN0KCkudGhlbihsYXN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbZ2V0QW5pbWF0aW9uKCksIGdldENoaWxkQW5pbWF0aW9ucyhvcHRpb25zLmRlbGF5KV0pO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgX2EpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIF9jID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9kID0gX2MuZGVsYXksIGRlbGF5ID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgdHJhbnNpdGlvbk92ZXJyaWRlID0gX2MudHJhbnNpdGlvbk92ZXJyaWRlLCB0eXBlID0gX2MudHlwZTtcbiAgICB2YXIgX2UgPSB2aXN1YWxFbGVtZW50Lm1ha2VUYXJnZXRBbmltYXRhYmxlKGRlZmluaXRpb24pLCBfZiA9IF9lLnRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBfZiA9PT0gdm9pZCAwID8gdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpIDogX2YsIHRyYW5zaXRpb25FbmQgPSBfZS50cmFuc2l0aW9uRW5kLCB0YXJnZXQgPSB0c2xpYi5fX3Jlc3QoX2UsIFtcInRyYW5zaXRpb25cIiwgXCJ0cmFuc2l0aW9uRW5kXCJdKTtcbiAgICBpZiAodHJhbnNpdGlvbk92ZXJyaWRlKVxuICAgICAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbk92ZXJyaWRlO1xuICAgIHZhciBhbmltYXRpb25zID0gW107XG4gICAgdmFyIGFuaW1hdGlvblR5cGVTdGF0ZSA9IHR5cGUgJiYgKChfYiA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRTdGF0ZSgpW3R5cGVdKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgdmFyIHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgIHZhbHVlVGFyZ2V0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChhbmltYXRpb25UeXBlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRCbG9ja0FuaW1hdGlvbihhbmltYXRpb25UeXBlU3RhdGUsIGtleSkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVUcmFuc2l0aW9uID0gdHNsaWIuX19hc3NpZ24oeyBkZWxheTogZGVsYXkgfSwgdHJhbnNpdGlvbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIGFuaW1hdGlvbiBpbnN0YW50IGlmIHRoaXMgaXMgYSB0cmFuc2Zvcm0gcHJvcCBhbmQgd2Ugc2hvdWxkIHJlZHVjZSBtb3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodmlzdWFsRWxlbWVudC5zaG91bGRSZWR1Y2VNb3Rpb24gJiYgaXNUcmFuc2Zvcm1Qcm9wKGtleSkpIHtcbiAgICAgICAgICAgIHZhbHVlVHJhbnNpdGlvbiA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB2YWx1ZVRyYW5zaXRpb24pLCB7IHR5cGU6IGZhbHNlLCBkZWxheTogMCB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5pbWF0aW9uID0gc3RhcnRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdmFsdWVUYXJnZXQsIHZhbHVlVHJhbnNpdGlvbik7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyYW5zaXRpb25FbmQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHRyYW5zaXRpb25FbmQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYW5pbWF0ZUNoaWxkcmVuKHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIGRlbGF5Q2hpbGRyZW4sIHN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmIChkZWxheUNoaWxkcmVuID09PSB2b2lkIDApIHsgZGVsYXlDaGlsZHJlbiA9IDA7IH1cbiAgICBpZiAoc3RhZ2dlckNoaWxkcmVuID09PSB2b2lkIDApIHsgc3RhZ2dlckNoaWxkcmVuID0gMDsgfVxuICAgIGlmIChzdGFnZ2VyRGlyZWN0aW9uID09PSB2b2lkIDApIHsgc3RhZ2dlckRpcmVjdGlvbiA9IDE7IH1cbiAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xuICAgIHZhciBtYXhTdGFnZ2VyRHVyYXRpb24gPSAodmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4uc2l6ZSAtIDEpICogc3RhZ2dlckNoaWxkcmVuO1xuICAgIHZhciBnZW5lcmF0ZVN0YWdnZXJEdXJhdGlvbiA9IHN0YWdnZXJEaXJlY3Rpb24gPT09IDFcbiAgICAgICAgPyBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IHZvaWQgMCkgeyBpID0gMDsgfVxuICAgICAgICAgICAgcmV0dXJuIGkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IHZvaWQgMCkgeyBpID0gMDsgfVxuICAgICAgICAgICAgcmV0dXJuIG1heFN0YWdnZXJEdXJhdGlvbiAtIGkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gICAgICAgIH07XG4gICAgQXJyYXkuZnJvbSh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbilcbiAgICAgICAgLnNvcnQoc29ydEJ5VHJlZU9yZGVyKVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGVWYXJpYW50KGNoaWxkLCB2YXJpYW50LCB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZGVsYXk6IGRlbGF5Q2hpbGRyZW4gKyBnZW5lcmF0ZVN0YWdnZXJEdXJhdGlvbihpKSB9KSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjaGlsZC5ub3RpZnlBbmltYXRpb25Db21wbGV0ZSh2YXJpYW50KTsgfSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zKTtcbn1cbmZ1bmN0aW9uIHN0b3BBbmltYXRpb24odmlzdWFsRWxlbWVudCkge1xuICAgIHZpc3VhbEVsZW1lbnQuZm9yRWFjaFZhbHVlKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUuc3RvcCgpOyB9KTtcbn1cbmZ1bmN0aW9uIHNvcnRCeVRyZWVPcmRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEuc29ydE5vZGVQb3NpdGlvbihiKTtcbn1cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgd2Ugc2hvdWxkIGJsb2NrIHRoaXMgYW5pbWF0aW9uLiBQcmV2aW91c2x5LCB3ZSBhY2hpZXZlZCB0aGlzXG4gKiBqdXN0IGJ5IGNoZWNraW5nIHdoZXRoZXIgdGhlIGtleSB3YXMgbGlzdGVkIGluIHByb3RlY3RlZEtleXMsIGJ1dCB0aGlzXG4gKiBwb3NlZCBwcm9ibGVtcyBpZiBhbiBhbmltYXRpb24gd2FzIHRyaWdnZXJlZCBieSBhZnRlckNoaWxkcmVuIGFuZCBwcm90ZWN0ZWRLZXlzXG4gKiBoYWQgYmVlbiBzZXQgdG8gdHJ1ZSBpbiB0aGUgbWVhbnRpbWUuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZEJsb2NrQW5pbWF0aW9uKF9hLCBrZXkpIHtcbiAgICB2YXIgcHJvdGVjdGVkS2V5cyA9IF9hLnByb3RlY3RlZEtleXMsIG5lZWRzQW5pbWF0aW5nID0gX2EubmVlZHNBbmltYXRpbmc7XG4gICAgdmFyIHNob3VsZEJsb2NrID0gcHJvdGVjdGVkS2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG5lZWRzQW5pbWF0aW5nW2tleV0gIT09IHRydWU7XG4gICAgbmVlZHNBbmltYXRpbmdba2V5XSA9IGZhbHNlO1xuICAgIHJldHVybiBzaG91bGRCbG9jaztcbn1cblxudmFyIHZhcmlhbnRQcmlvcml0eU9yZGVyID0gW1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5BbmltYXRlLFxuICAgIGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5JblZpZXcsXG4gICAgZXhwb3J0cy5BbmltYXRpb25UeXBlLkZvY3VzLFxuICAgIGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5Ib3ZlcixcbiAgICBleHBvcnRzLkFuaW1hdGlvblR5cGUuVGFwLFxuICAgIGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5EcmFnLFxuICAgIGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5FeGl0LFxuXTtcbnZhciByZXZlcnNlUHJpb3JpdHlPcmRlciA9IHRzbGliLl9fc3ByZWFkQXJyYXkoW10sIHRzbGliLl9fcmVhZCh2YXJpYW50UHJpb3JpdHlPcmRlciksIGZhbHNlKS5yZXZlcnNlKCk7XG52YXIgbnVtQW5pbWF0aW9uVHlwZXMgPSB2YXJpYW50UHJpb3JpdHlPcmRlci5sZW5ndGg7XG5mdW5jdGlvbiBhbmltYXRlTGlzdCh2aXN1YWxFbGVtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBfYS5hbmltYXRpb24sIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGVWaXN1YWxFbGVtZW50KHZpc3VhbEVsZW1lbnQsIGFuaW1hdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uU3RhdGUodmlzdWFsRWxlbWVudCkge1xuICAgIHZhciBhbmltYXRlID0gYW5pbWF0ZUxpc3QodmlzdWFsRWxlbWVudCk7XG4gICAgdmFyIHN0YXRlID0gY3JlYXRlU3RhdGUoKTtcbiAgICB2YXIgYWxsQW5pbWF0ZWRLZXlzID0ge307XG4gICAgdmFyIGlzSW5pdGlhbFJlbmRlciA9IHRydWU7XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgdG8gcmVkdWNlIHRoZSBhbmltYXRpb24gZGVmaW5pdGlvbnMgZm9yXG4gICAgICogZWFjaCBhY3RpdmUgYW5pbWF0aW9uIHR5cGUgaW50byBhbiBvYmplY3Qgb2YgcmVzb2x2ZWQgdmFsdWVzIGZvciBpdC5cbiAgICAgKi9cbiAgICB2YXIgYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXMgPSBmdW5jdGlvbiAoYWNjLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHJlc29sdmVkLnRyYW5zaXRpb247IHZhciB0cmFuc2l0aW9uRW5kID0gcmVzb2x2ZWQudHJhbnNpdGlvbkVuZCwgdGFyZ2V0ID0gdHNsaWIuX19yZXN0KHJlc29sdmVkLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gICAgICAgICAgICBhY2MgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgYWNjKSwgdGFyZ2V0KSwgdHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzQW5pbWF0ZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiBhbGxBbmltYXRlZEtleXNba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGp1c3QgYWxsb3dzIHVzIHRvIGluamVjdCBtb2NrZWQgYW5pbWF0aW9uIGZ1bmN0aW9uc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEFuaW1hdGVGdW5jdGlvbihtYWtlQW5pbWF0b3IpIHtcbiAgICAgICAgYW5pbWF0ZSA9IG1ha2VBbmltYXRvcih2aXN1YWxFbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSByZWNlaXZlIG5ldyBwcm9wcywgd2UgbmVlZCB0bzpcbiAgICAgKiAxLiBDcmVhdGUgYSBsaXN0IG9mIHByb3RlY3RlZCBrZXlzIGZvciBlYWNoIHR5cGUuIFRoaXMgaXMgYSBkaXJlY3Rvcnkgb2ZcbiAgICAgKiAgICB2YWx1ZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBcImhhbmRsZWRcIiBieSB0eXBlcyBvZiBhIGhpZ2hlciBwcmlvcml0eVxuICAgICAqICAgIHNvIHRoYXQgd2hlbmV2ZXIgYW4gYW5pbWF0aW9uIGlzIHBsYXllZCBvZiBhIGdpdmVuIHR5cGUsIHRoZXNlIHZhbHVlcyBhcmVcbiAgICAgKiAgICBwcm90ZWN0ZWQgZnJvbSBiZWluZyBhbmltYXRlZC5cbiAgICAgKiAyLiBEZXRlcm1pbmUgaWYgYW4gYW5pbWF0aW9uIHR5cGUgbmVlZHMgYW5pbWF0aW5nLlxuICAgICAqIDMuIERldGVybWluZSBpZiBhbnkgdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gYSB0eXBlIGFuZCBmaWd1cmUgb3V0XG4gICAgICogICAgd2hhdCB0byBhbmltYXRlIHRob3NlIHRvLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFuaW1hdGVDaGFuZ2VzKG9wdGlvbnMsIGNoYW5nZWRBY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHByb3BzID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFyaWFudENvbnRleHQodHJ1ZSkgfHwge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgYW5pbWF0aW9ucyB0aGF0IHdlJ2xsIGJ1aWxkIGludG8gYXMgd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSBhbmltYXRpb25cbiAgICAgICAgICogdHlwZXMuIFRoaXMgd2lsbCBnZXQgZXhlY3V0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcCB0cmFjayBvZiB3aGljaCB2YWx1ZXMgaGF2ZSBiZWVuIHJlbW92ZWQuIFRoZW4sIGFzIHdlIGhpdCBsb3dlciBwcmlvcml0eVxuICAgICAgICAgKiBhbmltYXRpb24gdHlwZXMsIHdlIGNhbiBjaGVjayBpZiB0aGV5IGNvbnRhaW4gcmVtb3ZlZCB2YWx1ZXMgYW5kIGFuaW1hdGUgdG8gdGhhdC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciByZW1vdmVkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZGljdGlvbmFyeSBvZiBhbGwgZW5jb3VudGVyZWQga2V5cy4gVGhpcyBpcyBhbiBvYmplY3QgdG8gbGV0IHVzIGJ1aWxkIGludG8gYW5kXG4gICAgICAgICAqIGNvcHkgaXQgd2l0aG91dCBpdGVyYXRpb24uIEVhY2ggdGltZSB3ZSBoaXQgYW4gYW5pbWF0aW9uIHR5cGUgd2Ugc2V0IGl0cyBwcm90ZWN0ZWRcbiAgICAgICAgICoga2V5cyAtIHRoZSBrZXlzIGl0cyBub3QgYWxsb3dlZCB0byBhbmltYXRlIC0gdG8gdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGVuY291bnRlcmVkS2V5cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSB2YXJpYW50IGhhcyBiZWVuIHJlbW92ZWQgYXQgYSBnaXZlbiBpbmRleCwgYW5kIHRoaXMgY29tcG9uZW50IGlzIGNvbnRyb2xsaW5nXG4gICAgICAgICAqIHZhcmlhbnQgYW5pbWF0aW9ucywgd2Ugd2FudCB0byBlbnN1cmUgbG93ZXItcHJpb3JpdHkgdmFyaWFudHMgYXJlIGZvcmNlZCB0byBhbmltYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlbW92ZWRWYXJpYW50SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSByZXZlcnNlUHJpb3JpdHlPcmRlcltpXTtcbiAgICAgICAgICAgIHZhciB0eXBlU3RhdGUgPSBzdGF0ZVt0eXBlXTtcbiAgICAgICAgICAgIHZhciBwcm9wID0gKF9hID0gcHJvcHNbdHlwZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRleHRbdHlwZV07XG4gICAgICAgICAgICB2YXIgcHJvcElzVmFyaWFudCA9IGlzVmFyaWFudExhYmVsKHByb3ApO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIHR5cGUgaGFzICpqdXN0KiBjaGFuZ2VkIGlzQWN0aXZlIHN0YXR1cywgc2V0IGFjdGl2ZURlbHRhXG4gICAgICAgICAgICAgKiB0byB0aGF0IHN0YXR1cy4gT3RoZXJ3aXNlIHNldCB0byBudWxsLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgYWN0aXZlRGVsdGEgPSB0eXBlID09PSBjaGFuZ2VkQWN0aXZlVHlwZSA/IHR5cGVTdGF0ZS5pc0FjdGl2ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoYWN0aXZlRGVsdGEgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJlbW92ZWRWYXJpYW50SW5kZXggPSBpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIHByb3AgaXMgYW4gaW5oZXJpdGVkIHZhcmlhbnQsIHJhdGhlciB0aGFuIGJlZW4gc2V0IGRpcmVjdGx5IG9uIHRoZVxuICAgICAgICAgICAgICogY29tcG9uZW50IGl0c2VsZiwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYWxsb3cgdGhlIHBhcmVudCB0byB0cmlnZ2VyIGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogQ2FuIHByb2JhYmx5IGNoYW5nZSB0aGlzIHRvIGEgIWlzQ29udHJvbGxpbmdWYXJpYW50cyBjaGVja1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgaXNJbmhlcml0ZWQgPSBwcm9wID09PSBjb250ZXh0W3R5cGVdICYmIHByb3AgIT09IHByb3BzW3R5cGVdICYmIHByb3BJc1ZhcmlhbnQ7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc0luaGVyaXRlZCAmJlxuICAgICAgICAgICAgICAgIGlzSW5pdGlhbFJlbmRlciAmJlxuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQubWFudWFsbHlBbmltYXRlT25Nb3VudCkge1xuICAgICAgICAgICAgICAgIGlzSW5oZXJpdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCBhbGwgZW5jb3VudGVyZWQga2V5cyBzbyBmYXIgYXMgdGhlIHByb3RlY3RlZCBrZXlzIGZvciB0aGlzIHR5cGUuIFRoaXMgd2lsbFxuICAgICAgICAgICAgICogYmUgYW55IGtleSB0aGF0IGhhcyBiZWVuIGFuaW1hdGVkIG9yIG90aGVyd2lzZSBoYW5kbGVkIGJ5IGFjdGl2ZSwgaGlnaGVyLXByaW9ydGl5IHR5cGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0eXBlU3RhdGUucHJvdGVjdGVkS2V5cyA9IHRzbGliLl9fYXNzaWduKHt9LCBlbmNvdW50ZXJlZEtleXMpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIHNraXAgYW5hbHlzaW5nIHRoaXMgcHJvcCBlYXJseVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gSWYgaXQgaXNuJ3QgYWN0aXZlIGFuZCBoYXNuJ3QgKmp1c3QqIGJlZW4gc2V0IGFzIGluYWN0aXZlXG4gICAgICAgICAgICAoIXR5cGVTdGF0ZS5pc0FjdGl2ZSAmJiBhY3RpdmVEZWx0YSA9PT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgYW5kIGRvbid0IGhhdmUgYW55IGRlZmluZWQgcHJvcCBmb3IgdGhpcyBhbmltYXRpb24gdHlwZVxuICAgICAgICAgICAgICAgICghcHJvcCAmJiAhdHlwZVN0YXRlLnByZXZQcm9wKSB8fFxuICAgICAgICAgICAgICAgIC8vIE9yIGlmIHRoZSBwcm9wIGRvZXNuJ3QgZGVmaW5lIGFuIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGlzQW5pbWF0aW9uQ29udHJvbHMocHJvcCkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJvcCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcyB3ZSBnbyBsb29rIHRocm91Z2ggdGhlIHZhbHVlcyBkZWZpbmVkIG9uIHRoaXMgdHlwZSwgaWYgd2UgZGV0ZWN0XG4gICAgICAgICAgICAgKiBhIGNoYW5nZWQgdmFsdWUgb3IgYSB2YWx1ZSB0aGF0IHdhcyByZW1vdmVkIGluIGEgaGlnaGVyIHByaW9yaXR5LCB3ZSBzZXRcbiAgICAgICAgICAgICAqIHRoaXMgdG8gdHJ1ZSBhbmQgYWRkIHRoaXMgcHJvcCB0byB0aGUgYW5pbWF0aW9uIGxpc3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciB2YXJpYW50RGlkQ2hhbmdlID0gY2hlY2tWYXJpYW50c0RpZENoYW5nZSh0eXBlU3RhdGUucHJldlByb3AsIHByb3ApO1xuICAgICAgICAgICAgdmFyIHNob3VsZEFuaW1hdGVUeXBlID0gdmFyaWFudERpZENoYW5nZSB8fFxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG1ha2luZyB0aGlzIHZhcmlhbnQgYWN0aXZlLCB3ZSB3YW50IHRvIGFsd2F5cyBtYWtlIGl0IGFjdGl2ZVxuICAgICAgICAgICAgICAgICh0eXBlID09PSBjaGFuZ2VkQWN0aXZlVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlU3RhdGUuaXNBY3RpdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzSW5oZXJpdGVkICYmXG4gICAgICAgICAgICAgICAgICAgIHByb3BJc1ZhcmlhbnQpIHx8XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhIGhpZ2hlci1wcmlvcml0eSB2YXJpYW50IChpIGlzIGluIHJldmVyc2Ugb3JkZXIpXG4gICAgICAgICAgICAgICAgKGkgPiByZW1vdmVkVmFyaWFudEluZGV4ICYmIHByb3BJc1ZhcmlhbnQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcyBhbmltYXRpb25zIGNhbiBiZSBzZXQgYXMgdmFyaWFudCBsaXN0cywgdmFyaWFudHMgb3IgdGFyZ2V0IG9iamVjdHMsIHdlXG4gICAgICAgICAgICAgKiBjb2VyY2UgZXZlcnl0aGluZyB0byBhbiBhcnJheSBpZiBpdCBpc24ndCBvbmUgYWxyZWFkeVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZGVmaW5pdGlvbkxpc3QgPSBBcnJheS5pc0FycmF5KHByb3ApID8gcHJvcCA6IFtwcm9wXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQnVpbGQgYW4gb2JqZWN0IG9mIGFsbCB0aGUgcmVzb2x2ZWQgdmFsdWVzLiBXZSdsbCB1c2UgdGhpcyBpbiB0aGUgc3Vic2VxdWVudFxuICAgICAgICAgICAgICogYW5pbWF0ZUNoYW5nZXMgY2FsbHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkVmFsdWVzID0gZGVmaW5pdGlvbkxpc3QucmVkdWNlKGJ1aWxkUmVzb2x2ZWRUeXBlVmFsdWVzLCB7fSk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlRGVsdGEgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJlc29sdmVkVmFsdWVzID0ge307XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vdyB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBhbGwgdGhlIGtleXMgaW4gdGhlIHByZXYgcHJvcCBhbmQgdGhpcyBwcm9wLFxuICAgICAgICAgICAgICogYW5kIGRlY2lkZTpcbiAgICAgICAgICAgICAqIDEuIElmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwgYW5kIG5lZWRzIGFuaW1hdGluZ1xuICAgICAgICAgICAgICogMi4gSWYgaXQgaGFzIGJlZW4gcmVtb3ZlZCwgYW5kIG5lZWRzIGFkZGluZyB0byB0aGUgcmVtb3ZlZEtleXMgc2V0XG4gICAgICAgICAgICAgKiAzLiBJZiBpdCBoYXMgYmVlbiByZW1vdmVkIGluIGEgaGlnaGVyIHByaW9yaXR5IHR5cGUgYW5kIG5lZWRzIGFuaW1hdGluZ1xuICAgICAgICAgICAgICogNC4gSWYgaXQgaGFzbid0IGJlZW4gcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSBidXQgaGFzbid0IGNoYW5nZWQsIGFuZFxuICAgICAgICAgICAgICogICAgbmVlZHMgYWRkaW5nIHRvIHRoZSB0eXBlJ3MgcHJvdGVjdGVkS2V5cyBsaXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX2IgPSB0eXBlU3RhdGUucHJldlJlc29sdmVkVmFsdWVzLCBwcmV2UmVzb2x2ZWRWYWx1ZXMgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYjtcbiAgICAgICAgICAgIHZhciBhbGxLZXlzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHByZXZSZXNvbHZlZFZhbHVlcyksIHJlc29sdmVkVmFsdWVzKTtcbiAgICAgICAgICAgIHZhciBtYXJrVG9BbmltYXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHNob3VsZEFuaW1hdGVUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZW1vdmVkS2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0eXBlU3RhdGUubmVlZHNBbmltYXRpbmdba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHJlc29sdmVkVmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgdmFyIHByZXYgPSBwcmV2UmVzb2x2ZWRWYWx1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhpcyB3ZSBjYW4ganVzdCBza2lwIGFoZWFkXG4gICAgICAgICAgICAgICAgaWYgKGVuY291bnRlcmVkS2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIHdlIHByb2JhYmx5IHdhbnQgdG8gYW5pbWF0ZSBpdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldikge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgYm90aCB2YWx1ZXMgYXJlIGtleWZyYW1lcywgd2UgbmVlZCB0byBzaGFsbG93IGNvbXBhcmUgdGhlbSB0b1xuICAgICAgICAgICAgICAgICAgICAgKiBkZXRlY3Qgd2hldGhlciBhbnkgdmFsdWUgaGFzIGNoYW5nZWQuIElmIGl0IGhhcywgd2UgYW5pbWF0ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0tleWZyYW1lc1RhcmdldChuZXh0KSAmJiBpc0tleWZyYW1lc1RhcmdldChwcmV2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KSB8fCB2YXJpYW50RGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya1RvQW5pbWF0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgaXQgaGFzbid0IGNoYW5nZWQsIHdlIHdhbnQgdG8gZW5zdXJlIGl0IGRvZXNuJ3QgYW5pbWF0ZSBieVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGFkZGluZyBpdCB0byB0aGUgbGlzdCBvZiBwcm90ZWN0ZWQga2V5cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlU3RhdGUucHJvdGVjdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5leHQgaXMgZGVmaW5lZCBhbmQgZG9lc24ndCBlcXVhbCBwcmV2LCBpdCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgdW5kZWZpbmVkLCBpdCdzIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiByZW1vdmVkS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgbmV4dCBoYXNuJ3QgY2hhbmdlZCBhbmQgaXQgaXNuJ3QgdW5kZWZpbmVkLCB3ZSB3YW50IHRvIGNoZWNrIGlmIGl0J3NcbiAgICAgICAgICAgICAgICAgICAgICogYmVlbiByZW1vdmVkIGJ5IGEgaGlnaGVyIHByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgaXQgaGFzbid0IGNoYW5nZWQsIHdlIGFkZCBpdCB0byB0aGUgbGlzdCBvZiBwcm90ZWN0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAqIHRvIGVuc3VyZSBpdCBkb2Vzbid0IGdldCBhbmltYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSB0eXBlU3RhdGUgc28gbmV4dCB0aW1lIGFuaW1hdGVDaGFuZ2VzIGlzIGNhbGxlZCB3ZSBjYW4gY29tcGFyZSB0aGVcbiAgICAgICAgICAgICAqIGxhdGVzdCBwcm9wIGFuZCByZXNvbHZlZFZhbHVlcyB0byB0aGVzZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByZXZQcm9wID0gcHJvcDtcbiAgICAgICAgICAgIHR5cGVTdGF0ZS5wcmV2UmVzb2x2ZWRWYWx1ZXMgPSByZXNvbHZlZFZhbHVlcztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVTdGF0ZS5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGVuY291bnRlcmVkS2V5cyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBlbmNvdW50ZXJlZEtleXMpLCByZXNvbHZlZFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsUmVuZGVyICYmIHZpc3VhbEVsZW1lbnQuYmxvY2tJbml0aWFsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZVR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhbiBpbmhlcml0ZWQgcHJvcCB3ZSB3YW50IHRvIGhhcmQtYmxvY2sgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICogVE9ETzogVGVzdCBhcyB0aGlzIHNob3VsZCBwcm9iYWJseSBzdGlsbCBoYW5kbGUgYW5pbWF0aW9ucyB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAqIGJ5IHJlbW92ZWQgdmFsdWVzP1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc2hvdWxkQW5pbWF0ZVR5cGUgJiYgIWlzSW5oZXJpdGVkKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoLmFwcGx5KGFuaW1hdGlvbnMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW10sIHRzbGliLl9fcmVhZChkZWZpbml0aW9uTGlzdC5tYXAoZnVuY3Rpb24gKGFuaW1hdGlvbikgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBhbmltYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRzbGliLl9fYXNzaWduKHsgdHlwZTogdHlwZSB9LCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICB9KTsgfSkpLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBhbmltYXRpb24gdHlwZXMgaW4gcmV2ZXJzZSBwcmlvcml0eSBvcmRlci4gRm9yIGVhY2gsIHdlIHdhbnQgdG9cbiAgICAgICAgICogZGV0ZWN0IHdoaWNoIHZhbHVlcyBpdCdzIGhhbmRsaW5nIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGV5J3ZlIGNoYW5nZWQgKGFuZCB0aGVyZWZvcmVcbiAgICAgICAgICogbmVlZCB0byBiZSBhbmltYXRlZCkuIElmIGFueSB2YWx1ZXMgaGF2ZSBiZWVuIHJlbW92ZWQsIHdlIHdhbnQgdG8gZGV0ZWN0IHRob3NlIGluXG4gICAgICAgICAqIGxvd2VyIHByaW9yaXR5IHByb3BzIGFuZCBmbGFnIGZvciBhbmltYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUFuaW1hdGlvblR5cGVzOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsQW5pbWF0ZWRLZXlzID0gdHNsaWIuX19hc3NpZ24oe30sIGVuY291bnRlcmVkS2V5cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGVyZSBhcmUgc29tZSByZW1vdmVkIHZhbHVlIHRoYXQgaGF2ZW4ndCBiZWVuIGRlYWx0IHdpdGgsXG4gICAgICAgICAqIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGFuaW1hdGlvbiB0aGF0IGZhbGxzIGJhY2sgZWl0aGVyIHRvIHRoZSB2YWx1ZVxuICAgICAgICAgKiBkZWZpbmVkIGluIHRoZSBzdHlsZSBwcm9wLCBvciB0aGUgbGFzdCByZWFkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJlbW92ZWRLZXlzLnNpemUpIHtcbiAgICAgICAgICAgIHZhciBmYWxsYmFja0FuaW1hdGlvbl8xID0ge307XG4gICAgICAgICAgICByZW1vdmVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFsbGJhY2tUYXJnZXQgPSB2aXN1YWxFbGVtZW50LmdldEJhc2VUYXJnZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZmFsbGJhY2tUYXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0FuaW1hdGlvbl8xW2tleV0gPSBmYWxsYmFja1RhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaCh7IGFuaW1hdGlvbjogZmFsbGJhY2tBbmltYXRpb25fMSB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkQW5pbWF0ZSA9IEJvb2xlYW4oYW5pbWF0aW9ucy5sZW5ndGgpO1xuICAgICAgICBpZiAoaXNJbml0aWFsUmVuZGVyICYmXG4gICAgICAgICAgICBwcm9wcy5pbml0aWFsID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgIXZpc3VhbEVsZW1lbnQubWFudWFsbHlBbmltYXRlT25Nb3VudCkge1xuICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlzSW5pdGlhbFJlbmRlciA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2hvdWxkQW5pbWF0ZSA/IGFuaW1hdGUoYW5pbWF0aW9ucykgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHdoZXRoZXIgYSBjZXJ0YWluIGFuaW1hdGlvbiB0eXBlIGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBY3RpdmUodHlwZSwgaXNBY3RpdmUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBJZiB0aGUgYWN0aXZlIHN0YXRlIGhhc24ndCBjaGFuZ2VkLCB3ZSBjYW4gc2FmZWx5IGRvIG5vdGhpbmcgaGVyZVxuICAgICAgICBpZiAoc3RhdGVbdHlwZV0uaXNBY3RpdmUgPT09IGlzQWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAvLyBQcm9wYWdhdGUgYWN0aXZlIGNoYW5nZSB0byBjaGlsZHJlblxuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGNoaWxkLmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlKTsgfSk7XG4gICAgICAgIHN0YXRlW3R5cGVdLmlzQWN0aXZlID0gaXNBY3RpdmU7XG4gICAgICAgIHZhciBhbmltYXRpb25zID0gYW5pbWF0ZUNoYW5nZXMob3B0aW9ucywgdHlwZSk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgc3RhdGVba2V5XS5wcm90ZWN0ZWRLZXlzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlzQW5pbWF0ZWQ6IGlzQW5pbWF0ZWQsXG4gICAgICAgIGFuaW1hdGVDaGFuZ2VzOiBhbmltYXRlQ2hhbmdlcyxcbiAgICAgICAgc2V0QWN0aXZlOiBzZXRBY3RpdmUsXG4gICAgICAgIHNldEFuaW1hdGVGdW5jdGlvbjogc2V0QW5pbWF0ZUZ1bmN0aW9uLFxuICAgICAgICBnZXRTdGF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGU7IH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UocHJldiwgbmV4dCkge1xuICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV4dCAhPT0gcHJldjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNWYXJpYW50TGFiZWxzKG5leHQpKSB7XG4gICAgICAgIHJldHVybiAhc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVTdGF0ZShpc0FjdGl2ZSkge1xuICAgIGlmIChpc0FjdGl2ZSA9PT0gdm9pZCAwKSB7IGlzQWN0aXZlID0gZmFsc2U7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXG4gICAgICAgIHByb3RlY3RlZEtleXM6IHt9LFxuICAgICAgICBuZWVkc0FuaW1hdGluZzoge30sXG4gICAgICAgIHByZXZSZXNvbHZlZFZhbHVlczoge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX2EgPSB7fSxcbiAgICAgICAgX2FbZXhwb3J0cy5BbmltYXRpb25UeXBlLkFuaW1hdGVdID0gY3JlYXRlVHlwZVN0YXRlKHRydWUpLFxuICAgICAgICBfYVtleHBvcnRzLkFuaW1hdGlvblR5cGUuSW5WaWV3XSA9IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgICAgICBfYVtleHBvcnRzLkFuaW1hdGlvblR5cGUuSG92ZXJdID0gY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIF9hW2V4cG9ydHMuQW5pbWF0aW9uVHlwZS5UYXBdID0gY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIF9hW2V4cG9ydHMuQW5pbWF0aW9uVHlwZS5EcmFnXSA9IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgICAgICBfYVtleHBvcnRzLkFuaW1hdGlvblR5cGUuRm9jdXNdID0gY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIF9hW2V4cG9ydHMuQW5pbWF0aW9uVHlwZS5FeGl0XSA9IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgICAgICBfYTtcbn1cblxudmFyIGFuaW1hdGlvbnMgPSB7XG4gICAgYW5pbWF0aW9uOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50LCBhbmltYXRlID0gX2EuYW5pbWF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGR5bmFtaWNhbGx5IGdlbmVyYXRlIHRoZSBBbmltYXRpb25TdGF0ZSBtYW5hZ2VyIGFzIGl0IGNvbnRhaW5zIGEgcmVmZXJlbmNlXG4gICAgICAgICAqIHRvIHRoZSB1bmRlcmx5aW5nIGFuaW1hdGlvbiBsaWJyYXJ5LiBXZSBvbmx5IHdhbnQgdG8gbG9hZCB0aGF0IGlmIHdlIGxvYWQgdGhpcyxcbiAgICAgICAgICogc28gcGVvcGxlIGNhbiBvcHRpb25hbGx5IGNvZGUgc3BsaXQgaXQgb3V0IHVzaW5nIHRoZSBgbWAgY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSB8fCAodmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSA9IGNyZWF0ZUFuaW1hdGlvblN0YXRlKHZpc3VhbEVsZW1lbnQpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnNjcmliZSBhbnkgcHJvdmlkZWQgQW5pbWF0aW9uQ29udHJvbHMgdG8gdGhlIGNvbXBvbmVudCdzIFZpc3VhbEVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc0FuaW1hdGlvbkNvbnRyb2xzKGFuaW1hdGUpKSB7XG4gICAgICAgICAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gYW5pbWF0ZS5zdWJzY3JpYmUodmlzdWFsRWxlbWVudCk7IH0sIFthbmltYXRlXSk7XG4gICAgICAgIH1cbiAgICB9KSxcbiAgICBleGl0OiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgdmFyIGN1c3RvbSA9IHByb3BzLmN1c3RvbSwgdmlzdWFsRWxlbWVudCA9IHByb3BzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIHZhciBfYSA9IHRzbGliLl9fcmVhZCh1c2VQcmVzZW5jZSgpLCAyKSwgaXNQcmVzZW50ID0gX2FbMF0sIHNhZmVUb1JlbW92ZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcHJlc2VuY2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpO1xuICAgICAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuaXNQcmVzZW50ID0gaXNQcmVzZW50O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IChfYSA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoZXhwb3J0cy5BbmltYXRpb25UeXBlLkV4aXQsICFpc1ByZXNlbnQsIHsgY3VzdG9tOiAoX2IgPSBwcmVzZW5jZUNvbnRleHQgPT09IG51bGwgfHwgcHJlc2VuY2VDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVzZW5jZUNvbnRleHQuY3VzdG9tKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjdXN0b20gfSk7XG4gICAgICAgICAgICAhaXNQcmVzZW50ICYmIChhbmltYXRpb24gPT09IG51bGwgfHwgYW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmltYXRpb24udGhlbihzYWZlVG9SZW1vdmUpKTtcbiAgICAgICAgfSwgW2lzUHJlc2VudF0pO1xuICAgIH0pLFxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFBhblNlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFuU2Vzc2lvbihldmVudCwgaGFuZGxlcnMsIF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0cmFuc2Zvcm1QYWdlUG9pbnQgPSBfYi50cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdE1vdmVFdmVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdE1vdmVFdmVudEluZm8gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMudXBkYXRlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIShfdGhpcy5sYXN0TW92ZUV2ZW50ICYmIF90aGlzLmxhc3RNb3ZlRXZlbnRJbmZvKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdldFBhbkluZm8oX3RoaXMubGFzdE1vdmVFdmVudEluZm8sIF90aGlzLmhpc3RvcnkpO1xuICAgICAgICAgICAgdmFyIGlzUGFuU3RhcnRlZCA9IF90aGlzLnN0YXJ0RXZlbnQgIT09IG51bGw7XG4gICAgICAgICAgICAvLyBPbmx5IHN0YXJ0IHBhbm5pbmcgaWYgdGhlIG9mZnNldCBpcyBsYXJnZXIgdGhhbiAzIHBpeGVscy4gSWYgd2UgbWFrZSBpdFxuICAgICAgICAgICAgLy8gYW55IGxhcmdlciB0aGFuIHRoaXMgd2UnbGwgd2FudCB0byByZXNldCB0aGUgcG9pbnRlciBoaXN0b3J5XG4gICAgICAgICAgICAvLyBvbiB0aGUgZmlyc3QgdXBkYXRlIHRvIGF2b2lkIHZpc3VhbCBzbmFwcGluZyB0byB0aGUgY3Vyc29lLlxuICAgICAgICAgICAgdmFyIGlzRGlzdGFuY2VQYXN0VGhyZXNob2xkID0gcG9wbW90aW9uLmRpc3RhbmNlKGluZm8ub2Zmc2V0LCB7IHg6IDAsIHk6IDAgfSkgPj0gMztcbiAgICAgICAgICAgIGlmICghaXNQYW5TdGFydGVkICYmICFpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBpbmZvLnBvaW50O1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IHN5bmMuZ2V0RnJhbWVEYXRhKCkudGltZXN0YW1wO1xuICAgICAgICAgICAgX3RoaXMuaGlzdG9yeS5wdXNoKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBwb2ludCksIHsgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSkpO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuaGFuZGxlcnMsIG9uU3RhcnQgPSBfYS5vblN0YXJ0LCBvbk1vdmUgPSBfYS5vbk1vdmU7XG4gICAgICAgICAgICBpZiAoIWlzUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIG9uU3RhcnQgJiYgb25TdGFydChfdGhpcy5sYXN0TW92ZUV2ZW50LCBpbmZvKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydEV2ZW50ID0gX3RoaXMubGFzdE1vdmVFdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTW92ZSAmJiBvbk1vdmUoX3RoaXMubGFzdE1vdmVFdmVudCwgaW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgICAgIF90aGlzLmxhc3RNb3ZlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIF90aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgX3RoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgU2FmYXJpIGRvZXNuJ3QgdHJpZ2dlciBtb3VzZXVwIGV2ZW50cyB3aGVuIGl0J3MgYWJvdmUgYSBgPHNlbGVjdD5gXG4gICAgICAgICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSAmJiBldmVudC5idXR0b25zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlclVwKGV2ZW50LCBpbmZvKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaHJvdHRsZSBtb3VzZSBtb3ZlIGV2ZW50IHRvIG9uY2UgcGVyIGZyYW1lXG4gICAgICAgICAgICBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS51cGRhdGUoX3RoaXMudXBkYXRlUG9pbnQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICAgICAgX3RoaXMuZW5kKCk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5oYW5kbGVycywgb25FbmQgPSBfYS5vbkVuZCwgb25TZXNzaW9uRW5kID0gX2Eub25TZXNzaW9uRW5kO1xuICAgICAgICAgICAgdmFyIHBhbkluZm8gPSBnZXRQYW5JbmZvKHRyYW5zZm9ybVBvaW50KGluZm8sIF90aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCksIF90aGlzLmhpc3RvcnkpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXJ0RXZlbnQgJiYgb25FbmQpIHtcbiAgICAgICAgICAgICAgICBvbkVuZChldmVudCwgcGFuSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblNlc3Npb25FbmQgJiYgb25TZXNzaW9uRW5kKGV2ZW50LCBwYW5JbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHRvdWNoLCBkb24ndCBzdGFydCBkZXRlY3RpbmcgdGhpcyBnZXN0dXJlXG4gICAgICAgIGlmIChpc1RvdWNoRXZlbnQoZXZlbnQpICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCA9IHRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICAgICAgdmFyIGluZm8gPSBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KTtcbiAgICAgICAgdmFyIGluaXRpYWxJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgICAgICB2YXIgcG9pbnQgPSBpbml0aWFsSW5mby5wb2ludDtcbiAgICAgICAgdmFyIHRpbWVzdGFtcCA9IHN5bmMuZ2V0RnJhbWVEYXRhKCkudGltZXN0YW1wO1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBbdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHBvaW50KSwgeyB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KV07XG4gICAgICAgIHZhciBvblNlc3Npb25TdGFydCA9IGhhbmRsZXJzLm9uU2Vzc2lvblN0YXJ0O1xuICAgICAgICBvblNlc3Npb25TdGFydCAmJlxuICAgICAgICAgICAgb25TZXNzaW9uU3RhcnQoZXZlbnQsIGdldFBhbkluZm8oaW5pdGlhbEluZm8sIHRoaXMuaGlzdG9yeSkpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyA9IHBvcG1vdGlvbi5waXBlKGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcm1vdmVcIiwgdGhpcy5oYW5kbGVQb2ludGVyTW92ZSksIGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcnVwXCIsIHRoaXMuaGFuZGxlUG9pbnRlclVwKSwgYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVyY2FuY2VsXCIsIHRoaXMuaGFuZGxlUG9pbnRlclVwKSk7XG4gICAgfVxuICAgIFBhblNlc3Npb24ucHJvdG90eXBlLnVwZGF0ZUhhbmRsZXJzID0gZnVuY3Rpb24gKGhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICB9O1xuICAgIFBhblNlc3Npb24ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgc3luYy5jYW5jZWxTeW5jLnVwZGF0ZSh0aGlzLnVwZGF0ZVBvaW50KTtcbiAgICB9O1xuICAgIHJldHVybiBQYW5TZXNzaW9uO1xufSgpKTtcbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KGluZm8sIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYWdlUG9pbnQgPyB7IHBvaW50OiB0cmFuc2Zvcm1QYWdlUG9pbnQoaW5mby5wb2ludCkgfSA6IGluZm87XG59XG5mdW5jdGlvbiBzdWJ0cmFjdFBvaW50KGEsIGIpIHtcbiAgICByZXR1cm4geyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9O1xufVxuZnVuY3Rpb24gZ2V0UGFuSW5mbyhfYSwgaGlzdG9yeSkge1xuICAgIHZhciBwb2ludCA9IF9hLnBvaW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgZGVsdGE6IHN1YnRyYWN0UG9pbnQocG9pbnQsIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgICAgIG9mZnNldDogc3VidHJhY3RQb2ludChwb2ludCwgc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgICAgIHZlbG9jaXR5OiBnZXRWZWxvY2l0eShoaXN0b3J5LCAwLjEpLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdGFydERldmljZVBvaW50KGhpc3RvcnkpIHtcbiAgICByZXR1cm4gaGlzdG9yeVswXTtcbn1cbmZ1bmN0aW9uIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gICAgcmV0dXJuIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGhpc3RvcnksIHRpbWVEZWx0YSkge1xuICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICB2YXIgaSA9IGhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICB2YXIgdGltZXN0YW1wZWRQb2ludCA9IG51bGw7XG4gICAgdmFyIGxhc3RQb2ludCA9IGxhc3REZXZpY2VQb2ludChoaXN0b3J5KTtcbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgIHRpbWVzdGFtcGVkUG9pbnQgPSBoaXN0b3J5W2ldO1xuICAgICAgICBpZiAobGFzdFBvaW50LnRpbWVzdGFtcCAtIHRpbWVzdGFtcGVkUG9pbnQudGltZXN0YW1wID5cbiAgICAgICAgICAgIHNlY29uZHNUb01pbGxpc2Vjb25kcyh0aW1lRGVsdGEpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpLS07XG4gICAgfVxuICAgIGlmICghdGltZXN0YW1wZWRQb2ludCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuICAgIHZhciB0aW1lID0gKGxhc3RQb2ludC50aW1lc3RhbXAgLSB0aW1lc3RhbXBlZFBvaW50LnRpbWVzdGFtcCkgLyAxMDAwO1xuICAgIGlmICh0aW1lID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRWZWxvY2l0eSA9IHtcbiAgICAgICAgeDogKGxhc3RQb2ludC54IC0gdGltZXN0YW1wZWRQb2ludC54KSAvIHRpbWUsXG4gICAgICAgIHk6IChsYXN0UG9pbnQueSAtIHRpbWVzdGFtcGVkUG9pbnQueSkgLyB0aW1lLFxuICAgIH07XG4gICAgaWYgKGN1cnJlbnRWZWxvY2l0eS54ID09PSBJbmZpbml0eSkge1xuICAgICAgICBjdXJyZW50VmVsb2NpdHkueCA9IDA7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VmVsb2NpdHkueSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY3VycmVudFZlbG9jaXR5LnkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFZlbG9jaXR5O1xufVxuXG5mdW5jdGlvbiBjYWxjTGVuZ3RoKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcy5tYXggLSBheGlzLm1pbjtcbn1cbmZ1bmN0aW9uIGlzTmVhcih2YWx1ZSwgdGFyZ2V0LCBtYXhEaXN0YW5jZSkge1xuICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSAwOyB9XG4gICAgaWYgKG1heERpc3RhbmNlID09PSB2b2lkIDApIHsgbWF4RGlzdGFuY2UgPSAwLjAxOyB9XG4gICAgcmV0dXJuIHBvcG1vdGlvbi5kaXN0YW5jZSh2YWx1ZSwgdGFyZ2V0KSA8IG1heERpc3RhbmNlO1xufVxuZnVuY3Rpb24gY2FsY0F4aXNEZWx0YShkZWx0YSwgc291cmNlLCB0YXJnZXQsIG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IHZvaWQgMCkgeyBvcmlnaW4gPSAwLjU7IH1cbiAgICBkZWx0YS5vcmlnaW4gPSBvcmlnaW47XG4gICAgZGVsdGEub3JpZ2luUG9pbnQgPSBwb3Btb3Rpb24ubWl4KHNvdXJjZS5taW4sIHNvdXJjZS5tYXgsIGRlbHRhLm9yaWdpbik7XG4gICAgZGVsdGEuc2NhbGUgPSBjYWxjTGVuZ3RoKHRhcmdldCkgLyBjYWxjTGVuZ3RoKHNvdXJjZSk7XG4gICAgaWYgKGlzTmVhcihkZWx0YS5zY2FsZSwgMSwgMC4wMDAxKSB8fCBpc05hTihkZWx0YS5zY2FsZSkpXG4gICAgICAgIGRlbHRhLnNjYWxlID0gMTtcbiAgICBkZWx0YS50cmFuc2xhdGUgPVxuICAgICAgICBwb3Btb3Rpb24ubWl4KHRhcmdldC5taW4sIHRhcmdldC5tYXgsIGRlbHRhLm9yaWdpbikgLSBkZWx0YS5vcmlnaW5Qb2ludDtcbiAgICBpZiAoaXNOZWFyKGRlbHRhLnRyYW5zbGF0ZSkgfHwgaXNOYU4oZGVsdGEudHJhbnNsYXRlKSlcbiAgICAgICAgZGVsdGEudHJhbnNsYXRlID0gMDtcbn1cbmZ1bmN0aW9uIGNhbGNCb3hEZWx0YShkZWx0YSwgc291cmNlLCB0YXJnZXQsIG9yaWdpbikge1xuICAgIGNhbGNBeGlzRGVsdGEoZGVsdGEueCwgc291cmNlLngsIHRhcmdldC54LCBvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW4ub3JpZ2luWCk7XG4gICAgY2FsY0F4aXNEZWx0YShkZWx0YS55LCBzb3VyY2UueSwgdGFyZ2V0LnksIG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbi5vcmlnaW5ZKTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LCByZWxhdGl2ZSwgcGFyZW50KSB7XG4gICAgdGFyZ2V0Lm1pbiA9IHBhcmVudC5taW4gKyByZWxhdGl2ZS5taW47XG4gICAgdGFyZ2V0Lm1heCA9IHRhcmdldC5taW4gKyBjYWxjTGVuZ3RoKHJlbGF0aXZlKTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUJveCh0YXJnZXQsIHJlbGF0aXZlLCBwYXJlbnQpIHtcbiAgICBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldC54LCByZWxhdGl2ZS54LCBwYXJlbnQueCk7XG4gICAgY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQueSwgcmVsYXRpdmUueSwgcGFyZW50LnkpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uKHRhcmdldCwgbGF5b3V0LCBwYXJlbnQpIHtcbiAgICB0YXJnZXQubWluID0gbGF5b3V0Lm1pbiAtIHBhcmVudC5taW47XG4gICAgdGFyZ2V0Lm1heCA9IHRhcmdldC5taW4gKyBjYWxjTGVuZ3RoKGxheW91dCk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVQb3NpdGlvbih0YXJnZXQsIGxheW91dCwgcGFyZW50KSB7XG4gICAgY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uKHRhcmdldC54LCBsYXlvdXQueCwgcGFyZW50LngpO1xuICAgIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQueSwgbGF5b3V0LnksIHBhcmVudC55KTtcbn1cblxuLyoqXG4gKiBBcHBseSBjb25zdHJhaW50cyB0byBhIHBvaW50LiBUaGVzZSBjb25zdHJhaW50cyBhcmUgYm90aCBwaHlzaWNhbCBhbG9uZyBhblxuICogYXhpcywgYW5kIGFuIGVsYXN0aWMgZmFjdG9yIHRoYXQgZGV0ZXJtaW5lcyBob3cgbXVjaCB0byBjb25zdHJhaW4gdGhlIHBvaW50XG4gKiBieSBpZiBpdCBkb2VzIGxpZSBvdXRzaWRlIHRoZSBkZWZpbmVkIHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q29uc3RyYWludHMocG9pbnQsIF9hLCBlbGFzdGljKSB7XG4gICAgdmFyIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4O1xuICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiBwb2ludCA8IG1pbikge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWluIHBvaW50IGRlZmluZWQsIGFuZCB0aGlzIGlzIG91dHNpZGUgb2YgdGhhdCwgY29uc3RyYWluXG4gICAgICAgIHBvaW50ID0gZWxhc3RpYyA/IHBvcG1vdGlvbi5taXgobWluLCBwb2ludCwgZWxhc3RpYy5taW4pIDogTWF0aC5tYXgocG9pbnQsIG1pbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIHBvaW50ID4gbWF4KSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXggcG9pbnQgZGVmaW5lZCwgYW5kIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGF0LCBjb25zdHJhaW5cbiAgICAgICAgcG9pbnQgPSBlbGFzdGljID8gcG9wbW90aW9uLm1peChtYXgsIHBvaW50LCBlbGFzdGljLm1heCkgOiBNYXRoLm1pbihwb2ludCwgbWF4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgY29uc3RyYWludHMgaW4gdGVybXMgb2YgdGhlIHZpZXdwb3J0IHdoZW4gZGVmaW5lZCByZWxhdGl2ZWx5IHRvIHRoZVxuICogbWVhc3VyZWQgYXhpcy4gVGhpcyBpcyBtZWFzdXJlZCBmcm9tIHRoZSBuZWFyZXN0IGVkZ2UsIHNvIGEgbWF4IGNvbnN0cmFpbnQgb2YgMjAwXG4gKiBvbiBhbiBheGlzIHdpdGggYSBtYXggdmFsdWUgb2YgMzAwIHdvdWxkIHJldHVybiBhIGNvbnN0cmFpbnQgb2YgNTAwIC0gYXhpcyBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGF4aXMsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiBtaW4gIT09IHVuZGVmaW5lZCA/IGF4aXMubWluICsgbWluIDogdW5kZWZpbmVkLFxuICAgICAgICBtYXg6IG1heCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGF4aXMubWF4ICsgbWF4IC0gKGF4aXMubWF4IC0gYXhpcy5taW4pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgY29uc3RyYWludHMgaW4gdGVybXMgb2YgdGhlIHZpZXdwb3J0IHdoZW5cbiAqIGRlZmluZWQgcmVsYXRpdmVseSB0byB0aGUgbWVhc3VyZWQgYm91bmRpbmcgYm94LlxuICovXG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVDb25zdHJhaW50cyhsYXlvdXRCb3gsIF9hKSB7XG4gICAgdmFyIHRvcCA9IF9hLnRvcCwgbGVmdCA9IF9hLmxlZnQsIGJvdHRvbSA9IF9hLmJvdHRvbSwgcmlnaHQgPSBfYS5yaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LngsIGxlZnQsIHJpZ2h0KSxcbiAgICAgICAgeTogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC55LCB0b3AsIGJvdHRvbSksXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHZpZXdwb3J0IGNvbnN0cmFpbnRzIHdoZW4gZGVmaW5lZCBhcyBhbm90aGVyIHZpZXdwb3J0LXJlbGF0aXZlIGF4aXNcbiAqL1xuZnVuY3Rpb24gY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEF4aXMsIGNvbnN0cmFpbnRzQXhpcykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgbWluID0gY29uc3RyYWludHNBeGlzLm1pbiAtIGxheW91dEF4aXMubWluO1xuICAgIHZhciBtYXggPSBjb25zdHJhaW50c0F4aXMubWF4IC0gbGF5b3V0QXhpcy5tYXg7XG4gICAgLy8gSWYgdGhlIGNvbnN0cmFpbnRzIGF4aXMgaXMgYWN0dWFsbHkgc21hbGxlciB0aGFuIHRoZSBsYXlvdXQgYXhpcyB0aGVuIHdlIGNhblxuICAgIC8vIGZsaXAgdGhlIGNvbnN0cmFpbnRzXG4gICAgaWYgKGNvbnN0cmFpbnRzQXhpcy5tYXggLSBjb25zdHJhaW50c0F4aXMubWluIDxcbiAgICAgICAgbGF5b3V0QXhpcy5tYXggLSBsYXlvdXRBeGlzLm1pbikge1xuICAgICAgICBfYSA9IHRzbGliLl9fcmVhZChbbWF4LCBtaW5dLCAyKSwgbWluID0gX2FbMF0sIG1heCA9IF9hWzFdO1xuICAgIH1cbiAgICByZXR1cm4geyBtaW46IG1pbiwgbWF4OiBtYXggfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHZpZXdwb3J0IGNvbnN0cmFpbnRzIHdoZW4gZGVmaW5lZCBhcyBhbm90aGVyIHZpZXdwb3J0LXJlbGF0aXZlIGJveFxuICovXG5mdW5jdGlvbiBjYWxjVmlld3BvcnRDb25zdHJhaW50cyhsYXlvdXRCb3gsIGNvbnN0cmFpbnRzQm94KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBjb25zdHJhaW50c0JveC54KSxcbiAgICAgICAgeTogY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC55LCBjb25zdHJhaW50c0JveC55KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgYSB0cmFuc2Zvcm0gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBzb3VyY2UgYXhpcywgYmV0d2VlbiAwLTEsIHRoYXQgcmVzdWx0c1xuICogaW4gYW4gYXN0aGV0aWNhbGx5IHBsZWFzaW5nIHNjYWxlL3RyYW5zZm9ybSBuZWVkZWQgdG8gcHJvamVjdCBmcm9tIHNvdXJjZSB0byB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGNhbGNPcmlnaW4oc291cmNlLCB0YXJnZXQpIHtcbiAgICB2YXIgb3JpZ2luID0gMC41O1xuICAgIHZhciBzb3VyY2VMZW5ndGggPSBjYWxjTGVuZ3RoKHNvdXJjZSk7XG4gICAgdmFyIHRhcmdldExlbmd0aCA9IGNhbGNMZW5ndGgodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0TGVuZ3RoID4gc291cmNlTGVuZ3RoKSB7XG4gICAgICAgIG9yaWdpbiA9IHBvcG1vdGlvbi5wcm9ncmVzcyh0YXJnZXQubWluLCB0YXJnZXQubWF4IC0gc291cmNlTGVuZ3RoLCBzb3VyY2UubWluKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlTGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgIG9yaWdpbiA9IHBvcG1vdGlvbi5wcm9ncmVzcyhzb3VyY2UubWluLCBzb3VyY2UubWF4IC0gdGFyZ2V0TGVuZ3RoLCB0YXJnZXQubWluKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcG1vdGlvbi5jbGFtcCgwLCAxLCBvcmlnaW4pO1xufVxuLyoqXG4gKiBSZWJhc2UgdGhlIGNhbGN1bGF0ZWQgdmlld3BvcnQgY29uc3RyYWludHMgcmVsYXRpdmUgdG8gdGhlIGxheW91dC5taW4gcG9pbnQuXG4gKi9cbmZ1bmN0aW9uIHJlYmFzZUF4aXNDb25zdHJhaW50cyhsYXlvdXQsIGNvbnN0cmFpbnRzKSB7XG4gICAgdmFyIHJlbGF0aXZlQ29uc3RyYWludHMgPSB7fTtcbiAgICBpZiAoY29uc3RyYWludHMubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVsYXRpdmVDb25zdHJhaW50cy5taW4gPSBjb25zdHJhaW50cy5taW4gLSBsYXlvdXQubWluO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVsYXRpdmVDb25zdHJhaW50cy5tYXggPSBjb25zdHJhaW50cy5tYXggLSBsYXlvdXQubWluO1xuICAgIH1cbiAgICByZXR1cm4gcmVsYXRpdmVDb25zdHJhaW50cztcbn1cbnZhciBkZWZhdWx0RWxhc3RpYyA9IDAuMzU7XG4vKipcbiAqIEFjY2VwdHMgYSBkcmFnRWxhc3RpYyBwcm9wIGFuZCByZXR1cm5zIHJlc29sdmVkIGVsYXN0aWMgdmFsdWVzIGZvciBlYWNoIGF4aXMuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVEcmFnRWxhc3RpYyhkcmFnRWxhc3RpYykge1xuICAgIGlmIChkcmFnRWxhc3RpYyA9PT0gdm9pZCAwKSB7IGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWM7IH1cbiAgICBpZiAoZHJhZ0VsYXN0aWMgPT09IGZhbHNlKSB7XG4gICAgICAgIGRyYWdFbGFzdGljID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHJhZ0VsYXN0aWMgPT09IHRydWUpIHtcbiAgICAgICAgZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBcImxlZnRcIiwgXCJyaWdodFwiKSxcbiAgICAgICAgeTogcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBcInRvcFwiLCBcImJvdHRvbVwiKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBtaW5MYWJlbCwgbWF4TGFiZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIG1pbkxhYmVsKSxcbiAgICAgICAgbWF4OiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBtYXhMYWJlbCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIGxhYmVsKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiB0eXBlb2YgZHJhZ0VsYXN0aWMgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyBkcmFnRWxhc3RpY1xuICAgICAgICA6IChfYSA9IGRyYWdFbGFzdGljW2xhYmVsXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbn1cblxudmFyIGNyZWF0ZUF4aXNEZWx0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgdHJhbnNsYXRlOiAwLFxuICAgIHNjYWxlOiAxLFxuICAgIG9yaWdpbjogMCxcbiAgICBvcmlnaW5Qb2ludDogMCxcbn0pOyB9O1xudmFyIGNyZWF0ZURlbHRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICB4OiBjcmVhdGVBeGlzRGVsdGEoKSxcbiAgICB5OiBjcmVhdGVBeGlzRGVsdGEoKSxcbn0pOyB9O1xudmFyIGNyZWF0ZUF4aXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBtaW46IDAsIG1heDogMCB9KTsgfTtcbnZhciBjcmVhdGVCb3ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIHg6IGNyZWF0ZUF4aXMoKSxcbiAgICB5OiBjcmVhdGVBeGlzKCksXG59KTsgfTtcblxuZnVuY3Rpb24gZWFjaEF4aXMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gW2NhbGxiYWNrKFwieFwiKSwgY2FsbGJhY2soXCJ5XCIpXTtcbn1cblxuLyoqXG4gKiBCb3VuZGluZyBib3hlcyB0ZW5kIHRvIGJlIGRlZmluZWQgYXMgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLiBGb3IgdmFyaW91cyBvcGVyYXRpb25zXG4gKiBpdCdzIGVhc2llciB0byBjb25zaWRlciBlYWNoIGF4aXMgaW5kaXZpZHVhbGx5LiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBib3VuZGluZyBib3hcbiAqIGFzIGEgbWFwIG9mIHNpbmdsZS1heGlzIG1pbi9tYXggdmFsdWVzLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveChfYSkge1xuICAgIHZhciB0b3AgPSBfYS50b3AsIGxlZnQgPSBfYS5sZWZ0LCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b207XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeyBtaW46IGxlZnQsIG1heDogcmlnaHQgfSxcbiAgICAgICAgeTogeyBtaW46IHRvcCwgbWF4OiBib3R0b20gfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydEJveFRvQm91bmRpbmdCb3goX2EpIHtcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgIHJldHVybiB7IHRvcDogeS5taW4sIHJpZ2h0OiB4Lm1heCwgYm90dG9tOiB5Lm1heCwgbGVmdDogeC5taW4gfTtcbn1cbi8qKlxuICogQXBwbGllcyBhIFRyYW5zZm9ybVBvaW50IGZ1bmN0aW9uIHRvIGEgYm91bmRpbmcgYm94LiBUcmFuc2Zvcm1Qb2ludCBpcyB1c3VhbGx5IGEgZnVuY3Rpb25cbiAqIHByb3ZpZGVkIGJ5IEZyYW1lciB0byBhbGxvdyBtZWFzdXJlZCBwb2ludHMgdG8gYmUgY29ycmVjdGVkIGZvciBkZXZpY2Ugc2NhbGluZy4gVGhpcyBpcyB1c2VkXG4gKiB3aGVuIG1lYXN1cmluZyBET00gZWxlbWVudHMgYW5kIERPTSBldmVudCBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUJveFBvaW50cyhwb2ludCwgdHJhbnNmb3JtUG9pbnQpIHtcbiAgICBpZiAoIXRyYW5zZm9ybVBvaW50KVxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgdmFyIHRvcExlZnQgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IHBvaW50LmxlZnQsIHk6IHBvaW50LnRvcCB9KTtcbiAgICB2YXIgYm90dG9tUmlnaHQgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IHBvaW50LnJpZ2h0LCB5OiBwb2ludC5ib3R0b20gfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0b3BMZWZ0LnksXG4gICAgICAgIGxlZnQ6IHRvcExlZnQueCxcbiAgICAgICAgYm90dG9tOiBib3R0b21SaWdodC55LFxuICAgICAgICByaWdodDogYm90dG9tUmlnaHQueCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc0lkZW50aXR5U2NhbGUoc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgPT09IHVuZGVmaW5lZCB8fCBzY2FsZSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGhhc1NjYWxlKF9hKSB7XG4gICAgdmFyIHNjYWxlID0gX2Euc2NhbGUsIHNjYWxlWCA9IF9hLnNjYWxlWCwgc2NhbGVZID0gX2Euc2NhbGVZO1xuICAgIHJldHVybiAoIWlzSWRlbnRpdHlTY2FsZShzY2FsZSkgfHxcbiAgICAgICAgIWlzSWRlbnRpdHlTY2FsZShzY2FsZVgpIHx8XG4gICAgICAgICFpc0lkZW50aXR5U2NhbGUoc2NhbGVZKSk7XG59XG5mdW5jdGlvbiBoYXNUcmFuc2Zvcm0odmFsdWVzKSB7XG4gICAgcmV0dXJuIChoYXNTY2FsZSh2YWx1ZXMpIHx8XG4gICAgICAgIGhhc1RyYW5zbGF0ZSh2YWx1ZXMueCkgfHxcbiAgICAgICAgaGFzVHJhbnNsYXRlKHZhbHVlcy55KSB8fFxuICAgICAgICB2YWx1ZXMueiB8fFxuICAgICAgICB2YWx1ZXMucm90YXRlIHx8XG4gICAgICAgIHZhbHVlcy5yb3RhdGVYIHx8XG4gICAgICAgIHZhbHVlcy5yb3RhdGVZKTtcbn1cbmZ1bmN0aW9uIGhhc1RyYW5zbGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZSAhPT0gXCIwJVwiO1xufVxuXG4vKipcbiAqIFNjYWxlcyBhIHBvaW50IGJhc2VkIG9uIGEgZmFjdG9yIGFuZCBhbiBvcmlnaW5Qb2ludFxuICovXG5mdW5jdGlvbiBzY2FsZVBvaW50KHBvaW50LCBzY2FsZSwgb3JpZ2luUG9pbnQpIHtcbiAgICB2YXIgZGlzdGFuY2VGcm9tT3JpZ2luID0gcG9pbnQgLSBvcmlnaW5Qb2ludDtcbiAgICB2YXIgc2NhbGVkID0gc2NhbGUgKiBkaXN0YW5jZUZyb21PcmlnaW47XG4gICAgcmV0dXJuIG9yaWdpblBvaW50ICsgc2NhbGVkO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGEgcG9pbnRcbiAqL1xuZnVuY3Rpb24gYXBwbHlQb2ludERlbHRhKHBvaW50LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBpZiAoYm94U2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZVBvaW50KHBvaW50LCBzY2FsZSwgb3JpZ2luUG9pbnQpICsgdHJhbnNsYXRlO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGFuIGF4aXNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKSB7XG4gICAgaWYgKHRyYW5zbGF0ZSA9PT0gdm9pZCAwKSB7IHRyYW5zbGF0ZSA9IDA7IH1cbiAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDE7IH1cbiAgICBheGlzLm1pbiA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgICBheGlzLm1heCA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1heCwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogQXBwbGllcyBhIHRyYW5zbGF0ZS9zY2FsZSBkZWx0YSB0byBhIGJveFxuICovXG5mdW5jdGlvbiBhcHBseUJveERlbHRhKGJveCwgX2EpIHtcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgIGFwcGx5QXhpc0RlbHRhKGJveC54LCB4LnRyYW5zbGF0ZSwgeC5zY2FsZSwgeC5vcmlnaW5Qb2ludCk7XG4gICAgYXBwbHlBeGlzRGVsdGEoYm94LnksIHkudHJhbnNsYXRlLCB5LnNjYWxlLCB5Lm9yaWdpblBvaW50KTtcbn1cbi8qKlxuICogQXBwbHkgYSB0cmVlIG9mIGRlbHRhcyB0byBhIGJveC4gV2UgZG8gdGhpcyB0byBjYWxjdWxhdGUgdGhlIGVmZmVjdCBvZiBhbGwgdGhlIHRyYW5zZm9ybXNcbiAqIGluIGEgdHJlZSB1cG9uIG91ciBib3ggYmVmb3JlIHRoZW4gY2FsY3VsYXRpbmcgaG93IHRvIHByb2plY3QgaXQgaW50byBvdXIgZGVzaXJlZCB2aWV3cG9ydC1yZWxhdGl2ZSBib3hcbiAqXG4gKiBUaGlzIGlzIHRoZSBmaW5hbCBuZXN0ZWQgbG9vcCB3aXRoaW4gdXBkYXRlTGF5b3V0RGVsdGEgZm9yIGZ1dHVyZSByZWZhY3RvcmluZ1xuICovXG5mdW5jdGlvbiBhcHBseVRyZWVEZWx0YXMoYm94LCB0cmVlU2NhbGUsIHRyZWVQYXRoLCBpc1NoYXJlZFRyYW5zaXRpb24pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChpc1NoYXJlZFRyYW5zaXRpb24gPT09IHZvaWQgMCkgeyBpc1NoYXJlZFRyYW5zaXRpb24gPSBmYWxzZTsgfVxuICAgIHZhciB0cmVlTGVuZ3RoID0gdHJlZVBhdGgubGVuZ3RoO1xuICAgIGlmICghdHJlZUxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIFJlc2V0IHRoZSB0cmVlU2NhbGVcbiAgICB0cmVlU2NhbGUueCA9IHRyZWVTY2FsZS55ID0gMTtcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgZGVsdGE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IHRyZWVQYXRoW2ldO1xuICAgICAgICBkZWx0YSA9IG5vZGUucHJvamVjdGlvbkRlbHRhO1xuICAgICAgICBpZiAoKChfYiA9IChfYSA9IG5vZGUuaW5zdGFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdHlsZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc3BsYXkpID09PSBcImNvbnRlbnRzXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgbm9kZS5vcHRpb25zLmxheW91dFNjcm9sbCAmJlxuICAgICAgICAgICAgbm9kZS5zY3JvbGwgJiZcbiAgICAgICAgICAgIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KGJveCwgeyB4OiAtbm9kZS5zY3JvbGwueCwgeTogLW5vZGUuc2Nyb2xsLnkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBJbmNvcG9yYXRlIGVhY2ggYW5jZXN0b3IncyBzY2FsZSBpbnRvIGEgY3VsbXVsYXRpdmUgdHJlZVNjYWxlIGZvciB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgICAgdHJlZVNjYWxlLnggKj0gZGVsdGEueC5zY2FsZTtcbiAgICAgICAgICAgIHRyZWVTY2FsZS55ICo9IGRlbHRhLnkuc2NhbGU7XG4gICAgICAgICAgICAvLyBBcHBseSBlYWNoIGFuY2VzdG9yJ3MgY2FsY3VsYXRlZCBkZWx0YSBpbnRvIHRoaXMgY29tcG9uZW50J3MgcmVjb3JkZWQgbGF5b3V0IGJveFxuICAgICAgICAgICAgYXBwbHlCb3hEZWx0YShib3gsIGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTaGFyZWRUcmFuc2l0aW9uICYmIGhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUJveChib3gsIG5vZGUubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZUF4aXMoYXhpcywgZGlzdGFuY2UpIHtcbiAgICBheGlzLm1pbiA9IGF4aXMubWluICsgZGlzdGFuY2U7XG4gICAgYXhpcy5tYXggPSBheGlzLm1heCArIGRpc3RhbmNlO1xufVxuLyoqXG4gKiBBcHBseSBhIHRyYW5zZm9ybSB0byBhbiBheGlzIGZyb20gdGhlIGxhdGVzdCByZXNvbHZlZCBtb3Rpb24gdmFsdWVzLlxuICogVGhpcyBmdW5jdGlvbiBiYXNpY2FsbHkgYWN0cyBhcyBhIGJyaWRnZSBiZXR3ZWVuIGEgZmxhdCBtb3Rpb24gdmFsdWUgbWFwXG4gKiBhbmQgYXBwbHlBeGlzRGVsdGFcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQXhpcyhheGlzLCB0cmFuc2Zvcm1zLCBfYSkge1xuICAgIHZhciBfYiA9IHRzbGliLl9fcmVhZChfYSwgMyksIGtleSA9IF9iWzBdLCBzY2FsZUtleSA9IF9iWzFdLCBvcmlnaW5LZXkgPSBfYlsyXTtcbiAgICB2YXIgYXhpc09yaWdpbiA9IHRyYW5zZm9ybXNbb3JpZ2luS2V5XSAhPT0gdW5kZWZpbmVkID8gdHJhbnNmb3Jtc1tvcmlnaW5LZXldIDogMC41O1xuICAgIHZhciBvcmlnaW5Qb2ludCA9IHBvcG1vdGlvbi5taXgoYXhpcy5taW4sIGF4aXMubWF4LCBheGlzT3JpZ2luKTtcbiAgICAvLyBBcHBseSB0aGUgYXhpcyBkZWx0YSB0byB0aGUgZmluYWwgYXhpc1xuICAgIGFwcGx5QXhpc0RlbHRhKGF4aXMsIHRyYW5zZm9ybXNba2V5XSwgdHJhbnNmb3Jtc1tzY2FsZUtleV0sIG9yaWdpblBvaW50LCB0cmFuc2Zvcm1zLnNjYWxlKTtcbn1cbi8qKlxuICogVGhlIG5hbWVzIG9mIHRoZSBtb3Rpb24gdmFsdWVzIHdlIHdhbnQgdG8gYXBwbHkgYXMgdHJhbnNsYXRpb24sIHNjYWxlIGFuZCBvcmlnaW4uXG4gKi9cbnZhciB4S2V5cyQxID0gW1wieFwiLCBcInNjYWxlWFwiLCBcIm9yaWdpblhcIl07XG52YXIgeUtleXMkMSA9IFtcInlcIiwgXCJzY2FsZVlcIiwgXCJvcmlnaW5ZXCJdO1xuLyoqXG4gKiBBcHBseSBhIHRyYW5zZm9ybSB0byBhIGJveCBmcm9tIHRoZSBsYXRlc3QgcmVzb2x2ZWQgbW90aW9uIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQm94KGJveCwgdHJhbnNmb3JtKSB7XG4gICAgdHJhbnNmb3JtQXhpcyhib3gueCwgdHJhbnNmb3JtLCB4S2V5cyQxKTtcbiAgICB0cmFuc2Zvcm1BeGlzKGJveC55LCB0cmFuc2Zvcm0sIHlLZXlzJDEpO1xufVxuXG5mdW5jdGlvbiBtZWFzdXJlVmlld3BvcnRCb3goaW5zdGFuY2UsIHRyYW5zZm9ybVBvaW50KSB7XG4gICAgcmV0dXJuIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHRyYW5zZm9ybUJveFBvaW50cyhpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJhbnNmb3JtUG9pbnQpKTtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVQYWdlQm94KGVsZW1lbnQsIHJvb3RQcm9qZWN0aW9uTm9kZSwgdHJhbnNmb3JtUGFnZVBvaW50KSB7XG4gICAgdmFyIHZpZXdwb3J0Qm94ID0gbWVhc3VyZVZpZXdwb3J0Qm94KGVsZW1lbnQsIHRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gICAgdmFyIHNjcm9sbCA9IHJvb3RQcm9qZWN0aW9uTm9kZS5zY3JvbGw7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB0cmFuc2xhdGVBeGlzKHZpZXdwb3J0Qm94LngsIHNjcm9sbC54KTtcbiAgICAgICAgdHJhbnNsYXRlQXhpcyh2aWV3cG9ydEJveC55LCBzY3JvbGwueSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3cG9ydEJveDtcbn1cblxudmFyIGVsZW1lbnREcmFnQ29udHJvbHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKlxuICovXG4vLyBsZXQgbGF0ZXN0UG9pbnRlckV2ZW50OiBBbnlQb2ludGVyRXZlbnRcbnZhciBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHModmlzdWFsRWxlbWVudCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgZHJhZyBnZXN0dXJlIGxvY2ssIGVuc3VyaW5nIG9ubHkgb25lIGNvbXBvbmVudFxuICAgICAgICAvLyBjYW4gXCJjYXB0dXJlXCIgdGhlIGRyYWcgb2Ygb25lIG9yIGJvdGggYXhlcy5cbiAgICAgICAgLy8gVE9ETzogTG9vayBpbnRvIG1vdmluZyB0aGlzIGludG8gcGFuc2Vzc2lvbj9cbiAgICAgICAgdGhpcy5vcGVuR2xvYmFsTG9jayA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpblBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVybWl0dGVkIGJvdW5kYXJpZXMgb2YgdHJhdmVsLCBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVyLWF4aXMgcmVzb2x2ZWQgZWxhc3RpYyB2YWx1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsYXN0aWMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudDtcbiAgICB9XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAob3JpZ2luRXZlbnQsIF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLnNuYXBUb0N1cnNvciwgc25hcFRvQ3Vyc29yID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2M7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb24ndCBzdGFydCBkcmFnZ2luZyBpZiB0aGlzIGNvbXBvbmVudCBpcyBleGl0aW5nXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LmlzUHJlc2VudCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBvblNlc3Npb25TdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gU3RvcCBhbnkgYW5pbWF0aW9ucyBvbiBib3RoIGF4aXMgdmFsdWVzIGltbWVkaWF0ZWx5LiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byB0aHJvdyBhbmQgY2F0Y2hcbiAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAgICBfdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc25hcFRvQ3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc25hcFRvQ3Vyc29yKGV4dHJhY3RFdmVudEluZm8oZXZlbnQsIFwicGFnZVwiKS5wb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvblN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgdGhlIGdsb2JhbCBkcmFnIGdlc3R1cmUgbG9jayAtIG1heWJlIG1ha2UgdGhpcyBwYXJ0IG9mIFBhblNlc3Npb25cbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLmdldFByb3BzKCksIGRyYWcgPSBfYi5kcmFnLCBkcmFnUHJvcGFnYXRpb24gPSBfYi5kcmFnUHJvcGFnYXRpb24sIG9uRHJhZ1N0YXJ0ID0gX2Iub25EcmFnU3RhcnQ7XG4gICAgICAgICAgICBpZiAoZHJhZyAmJiAhZHJhZ1Byb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcGVuR2xvYmFsTG9jaygpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9wZW5HbG9iYWxMb2NrID0gZ2V0R2xvYmFsTG9jayhkcmFnKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24gJ3QgaGF2ZSB0aGUgbG9jaywgZG9uJ3Qgc3RhcnQgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZUNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLmlzQW5pbWF0aW9uQmxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVjb3JkIGdlc3R1cmUgb3JpZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5nZXQoKSB8fCAwO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBNb3Rpb25WYWx1ZSBpcyBhIHBlcmNlbnRhZ2UgdmFsdWUgY29udmVydCB0byBweFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZVZhbHVlVHlwZXMucGVyY2VudC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWFzdXJlZEF4aXMgPSAoX2IgPSAoX2EgPSBfdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXlvdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY3R1YWxbYXhpc107XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZEF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IGNhbGNMZW5ndGgobWVhc3VyZWRBeGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBsZW5ndGhfMSAqIChwYXJzZUZsb2F0KGN1cnJlbnQpIC8gMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5vcmlnaW5Qb2ludFtheGlzXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEZpcmUgb25EcmFnU3RhcnQgZXZlbnRcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0ID09PSBudWxsIHx8IG9uRHJhZ1N0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRyYWdTdGFydChldmVudCwgaW5mbyk7XG4gICAgICAgICAgICAoX2EgPSBfdGhpcy52aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5EcmFnLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uTW92ZSA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICAgICAgLy8gbGF0ZXN0UG9pbnRlckV2ZW50ID0gZXZlbnRcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmdldFByb3BzKCksIGRyYWdQcm9wYWdhdGlvbiA9IF9hLmRyYWdQcm9wYWdhdGlvbiwgZHJhZ0RpcmVjdGlvbkxvY2sgPSBfYS5kcmFnRGlyZWN0aW9uTG9jaywgb25EaXJlY3Rpb25Mb2NrID0gX2Eub25EaXJlY3Rpb25Mb2NrLCBvbkRyYWcgPSBfYS5vbkRyYWc7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3Qgc3VjY2Vzc2Z1bGx5IHJlY2VpdmUgdGhlIGdlc3R1cmUgbG9jaywgZWFybHkgcmV0dXJuLlxuICAgICAgICAgICAgaWYgKCFkcmFnUHJvcGFnYXRpb24gJiYgIV90aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpbmZvLm9mZnNldDtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZGV0ZWN0IGRyYWcgZGlyZWN0aW9uIGlmIGRpcmVjdGlvbkxvY2sgaXMgdHJ1ZVxuICAgICAgICAgICAgaWYgKGRyYWdEaXJlY3Rpb25Mb2NrICYmIF90aGlzLmN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHN1Y2Nlc3NmdWxseSBzZXQgYSBkaXJlY3Rpb24sIG5vdGlmeSBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50RGlyZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGlyZWN0aW9uTG9jayA9PT0gbnVsbCB8fCBvbkRpcmVjdGlvbkxvY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRGlyZWN0aW9uTG9jayhfdGhpcy5jdXJyZW50RGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIGVhY2ggcG9pbnQgd2l0aCB0aGUgbGF0ZXN0IHBvc2l0aW9uXG4gICAgICAgICAgICBfdGhpcy51cGRhdGVBeGlzKFwieFwiLCBpbmZvLnBvaW50LCBvZmZzZXQpO1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlQXhpcyhcInlcIiwgaW5mby5wb2ludCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWRlYWxseSB3ZSB3b3VsZCBsZWF2ZSB0aGUgcmVuZGVyZXIgdG8gZmlyZSBuYXR1cmFsbHkgYXQgdGhlIGVuZCBvZlxuICAgICAgICAgICAgICogdGhpcyBmcmFtZSBidXQgaWYgdGhlIGVsZW1lbnQgaXMgYWJvdXQgdG8gY2hhbmdlIGxheW91dCBhcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgKiBvZiBhIHJlLXJlbmRlciB3ZSB3YW50IHRvIGVuc3VyZSB0aGUgYnJvd3NlciBjYW4gcmVhZCB0aGUgbGF0ZXN0XG4gICAgICAgICAgICAgKiBib3VuZGluZyBib3ggdG8gZW5zdXJlIHRoZSBwb2ludGVyIGFuZCBlbGVtZW50IGRvbid0IGZhbGwgb3V0IG9mIHN5bmMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLnZpc3VhbEVsZW1lbnQuc3luY1JlbmRlcigpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIG11c3QgZmlyZSBhZnRlciB0aGUgc3luY1JlbmRlciBjYWxsIGFzIGl0IG1pZ2h0IHRyaWdnZXIgYSBzdGF0ZVxuICAgICAgICAgICAgICogY2hhbmdlIHdoaWNoIGl0c2VsZiBtaWdodCB0cmlnZ2VyIGEgbGF5b3V0IHVwZGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25EcmFnID09PSBudWxsIHx8IG9uRHJhZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnKGV2ZW50LCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uU2Vzc2lvbkVuZCA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0b3AoZXZlbnQsIGluZm8pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhblNlc3Npb24gPSBuZXcgUGFuU2Vzc2lvbihvcmlnaW5FdmVudCwge1xuICAgICAgICAgICAgb25TZXNzaW9uU3RhcnQ6IG9uU2Vzc2lvblN0YXJ0LFxuICAgICAgICAgICAgb25TdGFydDogb25TdGFydCxcbiAgICAgICAgICAgIG9uTW92ZTogb25Nb3ZlLFxuICAgICAgICAgICAgb25TZXNzaW9uRW5kOiBvblNlc3Npb25FbmQsXG4gICAgICAgIH0sIHsgdHJhbnNmb3JtUGFnZVBvaW50OiB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCkgfSk7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgIHZhciBpc0RyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nO1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICBpZiAoIWlzRHJhZ2dpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB2ZWxvY2l0eSA9IGluZm8udmVsb2NpdHk7XG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24odmVsb2NpdHkpO1xuICAgICAgICB2YXIgb25EcmFnRW5kID0gdGhpcy5nZXRQcm9wcygpLm9uRHJhZ0VuZDtcbiAgICAgICAgb25EcmFnRW5kID09PSBudWxsIHx8IG9uRHJhZ0VuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnRW5kKGV2ZW50LCBpbmZvKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24uaXNBbmltYXRpb25CbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5wYW5TZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kKCk7XG4gICAgICAgIHRoaXMucGFuU2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGRyYWdQcm9wYWdhdGlvbiA9IHRoaXMuZ2V0UHJvcHMoKS5kcmFnUHJvcGFnYXRpb247XG4gICAgICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmIHRoaXMub3Blbkdsb2JhbExvY2spIHtcbiAgICAgICAgICAgIHRoaXMub3Blbkdsb2JhbExvY2soKTtcbiAgICAgICAgICAgIHRoaXMub3Blbkdsb2JhbExvY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IHRoaXMudmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldEFjdGl2ZShleHBvcnRzLkFuaW1hdGlvblR5cGUuRHJhZywgZmFsc2UpO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUudXBkYXRlQXhpcyA9IGZ1bmN0aW9uIChheGlzLCBfcG9pbnQsIG9mZnNldCkge1xuICAgICAgICB2YXIgZHJhZyA9IHRoaXMuZ2V0UHJvcHMoKS5kcmFnO1xuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZHJhZ2dpbmcgdGhpcyBheGlzLCBkbyBhbiBlYXJseSByZXR1cm4uXG4gICAgICAgIGlmICghb2Zmc2V0IHx8ICFzaG91bGREcmFnKGF4aXMsIGRyYWcsIHRoaXMuY3VycmVudERpcmVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm9yaWdpblBvaW50W2F4aXNdICsgb2Zmc2V0W2F4aXNdO1xuICAgICAgICAvLyBBcHBseSBjb25zdHJhaW50c1xuICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50cyAmJiB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdKSB7XG4gICAgICAgICAgICBuZXh0ID0gYXBwbHlDb25zdHJhaW50cyhuZXh0LCB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdLCB0aGlzLmVsYXN0aWNbYXhpc10pO1xuICAgICAgICB9XG4gICAgICAgIGF4aXNWYWx1ZS5zZXQobmV4dCk7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5yZXNvbHZlQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0UHJvcHMoKSwgZHJhZ0NvbnN0cmFpbnRzID0gX2EuZHJhZ0NvbnN0cmFpbnRzLCBkcmFnRWxhc3RpYyA9IF9hLmRyYWdFbGFzdGljO1xuICAgICAgICB2YXIgbGF5b3V0ID0gKHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uIHx8IHt9KS5sYXlvdXQ7XG4gICAgICAgIHZhciBwcmV2Q29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgICAgICBpZiAoZHJhZ0NvbnN0cmFpbnRzICYmIGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdHJhaW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSB0aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRyYWdDb25zdHJhaW50cyAmJiBsYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0LmFjdHVhbCwgZHJhZ0NvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsYXN0aWMgPSByZXNvbHZlRHJhZ0VsYXN0aWMoZHJhZ0VsYXN0aWMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgb3V0cHV0dGluZyB0byBleHRlcm5hbCBNb3Rpb25WYWx1ZXMsIHdlIHdhbnQgdG8gcmViYXNlIHRoZSBtZWFzdXJlZCBjb25zdHJhaW50c1xuICAgICAgICAgKiBmcm9tIHZpZXdwb3J0LXJlbGF0aXZlIHRvIGNvbXBvbmVudC1yZWxhdGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwcmV2Q29uc3RyYWludHMgIT09IHRoaXMuY29uc3RyYWludHMgJiZcbiAgICAgICAgICAgIGxheW91dCAmJlxuICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyAmJlxuICAgICAgICAgICAgIXRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29uc3RyYWludHNbYXhpc10gPSByZWJhc2VBeGlzQ29uc3RyYWludHMobGF5b3V0LmFjdHVhbFtheGlzXSwgX3RoaXMuY29uc3RyYWludHNbYXhpc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5yZXNvbHZlUmVmQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0UHJvcHMoKSwgY29uc3RyYWludHMgPSBfYS5kcmFnQ29uc3RyYWludHMsIG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyA9IF9hLm9uTWVhc3VyZURyYWdDb25zdHJhaW50cztcbiAgICAgICAgaWYgKCFjb25zdHJhaW50cyB8fCAhaXNSZWZPYmplY3QoY29uc3RyYWludHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgY29uc3RyYWludHNFbGVtZW50ID0gY29uc3RyYWludHMuY3VycmVudDtcbiAgICAgICAgaGV5TGlzdGVuLmludmFyaWFudChjb25zdHJhaW50c0VsZW1lbnQgIT09IG51bGwsIFwiSWYgYGRyYWdDb25zdHJhaW50c2AgaXMgc2V0IGFzIGEgUmVhY3QgcmVmLCB0aGF0IHJlZiBtdXN0IGJlIHBhc3NlZCB0byBhbm90aGVyIGNvbXBvbmVudCdzIGByZWZgIHByb3AuXCIpO1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uO1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIGlmICghcHJvamVjdGlvbiB8fCAhcHJvamVjdGlvbi5sYXlvdXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjb25zdHJhaW50c0JveCA9IG1lYXN1cmVQYWdlQm94KGNvbnN0cmFpbnRzRWxlbWVudCwgcHJvamVjdGlvbi5yb290LCB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCkpO1xuICAgICAgICB2YXIgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzKHByb2plY3Rpb24ubGF5b3V0LmFjdHVhbCwgY29uc3RyYWludHNCb3gpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlcmUncyBhbiBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMgbGlzdGVuZXIgd2UgY2FsbCBpdCBhbmRcbiAgICAgICAgICogaWYgZGlmZmVyZW50IGNvbnN0cmFpbnRzIGFyZSByZXR1cm5lZCwgc2V0IGNvbnN0cmFpbnRzIHRvIHRoYXRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIHZhciB1c2VyQ29uc3RyYWludHMgPSBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMoY29udmVydEJveFRvQm91bmRpbmdCb3gobWVhc3VyZWRDb25zdHJhaW50cykpO1xuICAgICAgICAgICAgdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMgPSAhIXVzZXJDb25zdHJhaW50cztcbiAgICAgICAgICAgIGlmICh1c2VyQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgICAgICBtZWFzdXJlZENvbnN0cmFpbnRzID0gY29udmVydEJvdW5kaW5nQm94VG9Cb3godXNlckNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVhc3VyZWRDb25zdHJhaW50cztcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24gKHZlbG9jaXR5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0UHJvcHMoKSwgZHJhZyA9IF9hLmRyYWcsIGRyYWdNb21lbnR1bSA9IF9hLmRyYWdNb21lbnR1bSwgZHJhZ0VsYXN0aWMgPSBfYS5kcmFnRWxhc3RpYywgZHJhZ1RyYW5zaXRpb24gPSBfYS5kcmFnVHJhbnNpdGlvbiwgZHJhZ1NuYXBUb09yaWdpbiA9IF9hLmRyYWdTbmFwVG9PcmlnaW4sIG9uRHJhZ1RyYW5zaXRpb25FbmQgPSBfYS5vbkRyYWdUcmFuc2l0aW9uRW5kO1xuICAgICAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzIHx8IHt9O1xuICAgICAgICB2YXIgbW9tZW50dW1BbmltYXRpb25zID0gZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCBfdGhpcy5jdXJyZW50RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gKF9hID0gY29uc3RyYWludHMgPT09IG51bGwgfHwgY29uc3RyYWludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnN0cmFpbnRzW2F4aXNdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgICAgIGlmIChkcmFnU25hcFRvT3JpZ2luKVxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gPSB7IG1pbjogMCwgbWF4OiAwIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE92ZXJkYW1wIHRoZSBib3VuZGFyeSBzcHJpbmcgaWYgYGRyYWdFbGFzdGljYCBpcyBkaXNhYmxlZC4gVGhlcmUncyBzdGlsbCBhIGZyYW1lXG4gICAgICAgICAgICAgKiBvZiBzcHJpbmcgYW5pbWF0aW9ucyBzbyB3ZSBzaG91bGQgbG9vayBpbnRvIGFkZGluZyBhIGRpc2FibGUgc3ByaW5nIG9wdGlvbiB0byBgaW5lcnRpYWAuXG4gICAgICAgICAgICAgKiBXZSBjb3VsZCBkbyBzb21ldGhpbmcgaGVyZSB3aGVyZSB3ZSBhZmZlY3QgdGhlIGBib3VuY2VTdGlmZm5lc3NgIGFuZCBgYm91bmNlRGFtcGluZ2BcbiAgICAgICAgICAgICAqIHVzaW5nIHRoZSB2YWx1ZSBvZiBgZHJhZ0VsYXN0aWNgLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgYm91bmNlU3RpZmZuZXNzID0gZHJhZ0VsYXN0aWMgPyAyMDAgOiAxMDAwMDAwO1xuICAgICAgICAgICAgdmFyIGJvdW5jZURhbXBpbmcgPSBkcmFnRWxhc3RpYyA/IDQwIDogMTAwMDAwMDA7XG4gICAgICAgICAgICB2YXIgaW5lcnRpYSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHsgdHlwZTogXCJpbmVydGlhXCIsIHZlbG9jaXR5OiBkcmFnTW9tZW50dW0gPyB2ZWxvY2l0eVtheGlzXSA6IDAsIGJvdW5jZVN0aWZmbmVzczogYm91bmNlU3RpZmZuZXNzLCBib3VuY2VEYW1waW5nOiBib3VuY2VEYW1waW5nLCB0aW1lQ29uc3RhbnQ6IDc1MCwgcmVzdERlbHRhOiAxLCByZXN0U3BlZWQ6IDEwIH0sIGRyYWdUcmFuc2l0aW9uKSwgdHJhbnNpdGlvbik7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgYW5pbWF0aW5nIG9uIGFuIGV4dGVybmFsbHktcHJvdmlkZWQgYE1vdGlvblZhbHVlYCB3ZSBjYW4gdXNlIHRoZVxuICAgICAgICAgICAgLy8gY29tcG9uZW50J3MgYW5pbWF0aW9uIGNvbnRyb2xzIHdoaWNoIHdpbGwgaGFuZGxlIGludGVyYWN0aW9ucyB3aXRoIHdoaWxlSG92ZXIgKGV0YyksXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UganVzdCBoYXZlIHRvIGFuaW1hdGUgdGhlIGBNb3Rpb25WYWx1ZWAgaXRzZWxmLlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uKGF4aXMsIGluZXJ0aWEpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUnVuIGFsbCBhbmltYXRpb25zIGFuZCB0aGVuIHJlc29sdmUgdGhlIG5ldyBkcmFnIGNvbnN0cmFpbnRzLlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobW9tZW50dW1BbmltYXRpb25zKS50aGVuKG9uRHJhZ1RyYW5zaXRpb25FbmQpO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc3RhcnRBeGlzVmFsdWVBbmltYXRpb24gPSBmdW5jdGlvbiAoYXhpcywgdHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgIHJldHVybiBzdGFydEFuaW1hdGlvbihheGlzLCBheGlzVmFsdWUsIDAsIHRyYW5zaXRpb24pO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHsgcmV0dXJuIF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5zdG9wKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhZyB3b3JrcyBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gd2hpY2ggcHJvcHMgYXJlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogLSBJZiBfZHJhZ1ggYW5kIF9kcmFnWSBhcmUgcHJvdmlkZWQsIHdlIG91dHB1dCB0aGUgZ2VzdHVyZSBkZWx0YSBkaXJlY3RseSB0byB0aG9zZSBtb3Rpb24gdmFsdWVzLlxuICAgICAqIC0gT3RoZXJ3aXNlLCB3ZSBhcHBseSB0aGUgZGVsdGEgdG8gdGhlIHgveSBtb3Rpb24gdmFsdWVzLlxuICAgICAqL1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLmdldEF4aXNNb3Rpb25WYWx1ZSA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBkcmFnS2V5ID0gXCJfZHJhZ1wiICsgYXhpcy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgZXh0ZXJuYWxNb3Rpb25WYWx1ZSA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpW2RyYWdLZXldO1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWxNb3Rpb25WYWx1ZVxuICAgICAgICAgICAgPyBleHRlcm5hbE1vdGlvblZhbHVlXG4gICAgICAgICAgICA6IHRoaXMudmlzdWFsRWxlbWVudC5nZXRWYWx1ZShheGlzLCAoX2IgPSAoX2EgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS5pbml0aWFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYXhpc10pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc25hcFRvQ3Vyc29yID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICB2YXIgZHJhZyA9IF90aGlzLmdldFByb3BzKCkuZHJhZztcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBkcmFnZ2luZyB0aGlzIGF4aXMsIGRvIGFuIGVhcmx5IHJldHVybi5cbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCBfdGhpcy5jdXJyZW50RGlyZWN0aW9uKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcHJvamVjdGlvbiA9IF90aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgICAgIHZhciBheGlzVmFsdWUgPSBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgICBpZiAocHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmxheW91dCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHByb2plY3Rpb24ubGF5b3V0LmFjdHVhbFtheGlzXSwgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXg7XG4gICAgICAgICAgICAgICAgYXhpc1ZhbHVlLnNldChwb2ludFtheGlzXSAtIHBvcG1vdGlvbi5taXgobWluLCBtYXgsIDAuNSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHZpZXdwb3J0IHJlc2l6ZXMgd2Ugd2FudCB0byBjaGVjayBpZiB0aGUgbWVhc3VyZWQgY29uc3RyYWludHNcbiAgICAgKiBoYXZlIGNoYW5nZWQgYW5kLCBpZiBzbywgcmVwb3NpdGlvbiB0aGUgZWxlbWVudCB3aXRoaW4gdGhvc2UgbmV3IGNvbnN0cmFpbnRzXG4gICAgICogcmVsYXRpdmUgdG8gd2hlcmUgaXQgd2FzIGJlZm9yZSB0aGUgcmVzaXplLlxuICAgICAqL1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnNjYWxlUG9zaXRpb25XaXRoaW5Db25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLmdldFByb3BzKCksIGRyYWcgPSBfYi5kcmFnLCBkcmFnQ29uc3RyYWludHMgPSBfYi5kcmFnQ29uc3RyYWludHM7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIGlmICghaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSB8fCAhcHJvamVjdGlvbiB8fCAhdGhpcy5jb25zdHJhaW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgY3VycmVudCBhbmltYXRpb25zIGFzIHRoZXJlIGNhbiBiZSB2aXN1YWwgZ2xpdGNoaW5nIGlmIHdlIHRyeSB0byBkb1xuICAgICAgICAgKiB0aGlzIG1pZC1hbmltYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVjb3JkIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgKiBjb25zdHJhaW50cyBib3ggYW5kIHNhdmUgYXMgYSBwcm9ncmVzcyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBib3hQcm9ncmVzcyA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgdmFyIGF4aXNWYWx1ZSA9IF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICAgIGlmIChheGlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF0ZXN0ID0gYXhpc1ZhbHVlLmdldCgpO1xuICAgICAgICAgICAgICAgIGJveFByb2dyZXNzW2F4aXNdID0gY2FsY09yaWdpbih7IG1pbjogbGF0ZXN0LCBtYXg6IGxhdGVzdCB9LCBfdGhpcy5jb25zdHJhaW50c1theGlzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBsYXlvdXQgb2YgdGhpcyBlbGVtZW50IGFuZCByZXNvbHZlIHRoZSBsYXRlc3QgZHJhZyBjb25zdHJhaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5nZXRJbnN0YW5jZSgpLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHt9LCBcIlwiKVxuICAgICAgICAgICAgOiBcIm5vbmVcIjtcbiAgICAgICAgKF9hID0gcHJvamVjdGlvbi5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgIHByb2plY3Rpb24udXBkYXRlTGF5b3V0KCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbnN0cmFpbnRzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgZWFjaCBheGlzLCBjYWxjdWxhdGUgdGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIGxheW91dCBheGlzXG4gICAgICAgICAqIHdpdGhpbiB0aGUgbmV3IGNvbnN0cmFpbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGN1bGF0ZSBhIG5ldyB0cmFuc2Zvcm0gYmFzZWQgb24gdGhlIHByZXZpb3VzIGJveCBwcm9ncmVzc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgYXhpc1ZhbHVlID0gX3RoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuY29uc3RyYWludHNbYXhpc10sIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4O1xuICAgICAgICAgICAgYXhpc1ZhbHVlLnNldChwb3Btb3Rpb24ubWl4KG1pbiwgbWF4LCBib3hQcm9ncmVzc1theGlzXSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLmFkZExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBlbGVtZW50RHJhZ0NvbnRyb2xzLnNldCh0aGlzLnZpc3VhbEVsZW1lbnQsIHRoaXMpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNoIGEgcG9pbnRlcmRvd24gZXZlbnQgbGlzdGVuZXIgb24gdGhpcyBET00gZWxlbWVudCB0byBpbml0aWF0ZSBkcmFnIHRyYWNraW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHN0b3BQb2ludGVyTGlzdGVuZXIgPSBhZGRQb2ludGVyRXZlbnQoZWxlbWVudCwgXCJwb2ludGVyZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmdldFByb3BzKCksIGRyYWcgPSBfYS5kcmFnLCBfYiA9IF9hLmRyYWdMaXN0ZW5lciwgZHJhZ0xpc3RlbmVyID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICAgICAgICAgIGRyYWcgJiYgZHJhZ0xpc3RlbmVyICYmIF90aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRyYWdDb25zdHJhaW50cyA9IF90aGlzLmdldFByb3BzKCkuZHJhZ0NvbnN0cmFpbnRzO1xuICAgICAgICAgICAgaWYgKGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25zdHJhaW50cyA9IF90aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uO1xuICAgICAgICB2YXIgc3RvcE1lYXN1cmVMYXlvdXRMaXN0ZW5lciA9IHByb2plY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcIm1lYXN1cmVcIiwgbWVhc3VyZURyYWdDb25zdHJhaW50cyk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uICYmICFwcm9qZWN0aW9uLmxheW91dCkge1xuICAgICAgICAgICAgKF9hID0gcHJvamVjdGlvbi5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnVwZGF0ZUxheW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIG1lYXN1cmVEcmFnQ29uc3RyYWludHMoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaCBhIHdpbmRvdyByZXNpemUgbGlzdGVuZXIgdG8gc2NhbGUgdGhlIGRyYWdnYWJsZSB0YXJnZXQgd2l0aGluIGl0cyBkZWZpbmVkXG4gICAgICAgICAqIGNvbnN0cmFpbnRzIGFzIHRoZSB3aW5kb3cgcmVzaXplcy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBzdG9wUmVzaXplTGlzdGVuZXIgPSBhZGREb21FdmVudCh3aW5kb3csIFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zY2FsZVBvc2l0aW9uV2l0aGluQ29uc3RyYWludHMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZWxlbWVudCdzIGxheW91dCBjaGFuZ2VzLCBjYWxjdWxhdGUgdGhlIGRlbHRhIGFuZCBhcHBseSB0aGF0IHRvXG4gICAgICAgICAqIHRoZSBkcmFnIGdlc3R1cmUncyBvcmlnaW4gcG9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gX2EuZGVsdGEsIGhhc0xheW91dENoYW5nZWQgPSBfYS5oYXNMYXlvdXRDaGFuZ2VkO1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcgJiYgaGFzTGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3Rpb25WYWx1ZSA9IF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3Rpb25WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub3JpZ2luUG9pbnRbYXhpc10gKz0gZGVsdGFbYXhpc10udHJhbnNsYXRlO1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb25WYWx1ZS5zZXQobW90aW9uVmFsdWUuZ2V0KCkgKyBkZWx0YVtheGlzXS50cmFuc2xhdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLnZpc3VhbEVsZW1lbnQuc3luY1JlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdG9wUmVzaXplTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHN0b3BQb2ludGVyTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHN0b3BNZWFzdXJlTGF5b3V0TGlzdGVuZXIoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLmdldFByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgdmFyIF9hID0gcHJvcHMuZHJhZywgZHJhZyA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCBfYiA9IHByb3BzLmRyYWdEaXJlY3Rpb25Mb2NrLCBkcmFnRGlyZWN0aW9uTG9jayA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBfYyA9IHByb3BzLmRyYWdQcm9wYWdhdGlvbiwgZHJhZ1Byb3BhZ2F0aW9uID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gcHJvcHMuZHJhZ0NvbnN0cmFpbnRzLCBkcmFnQ29uc3RyYWludHMgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBwcm9wcy5kcmFnRWxhc3RpYywgZHJhZ0VsYXN0aWMgPSBfZSA9PT0gdm9pZCAwID8gZGVmYXVsdEVsYXN0aWMgOiBfZSwgX2YgPSBwcm9wcy5kcmFnTW9tZW50dW0sIGRyYWdNb21lbnR1bSA9IF9mID09PSB2b2lkIDAgPyB0cnVlIDogX2Y7XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgcHJvcHMpLCB7IGRyYWc6IGRyYWcsIGRyYWdEaXJlY3Rpb25Mb2NrOiBkcmFnRGlyZWN0aW9uTG9jaywgZHJhZ1Byb3BhZ2F0aW9uOiBkcmFnUHJvcGFnYXRpb24sIGRyYWdDb25zdHJhaW50czogZHJhZ0NvbnN0cmFpbnRzLCBkcmFnRWxhc3RpYzogZHJhZ0VsYXN0aWMsIGRyYWdNb21lbnR1bTogZHJhZ01vbWVudHVtIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHM7XG59KCkpO1xuZnVuY3Rpb24gc2hvdWxkRHJhZyhkaXJlY3Rpb24sIGRyYWcsIGN1cnJlbnREaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gKChkcmFnID09PSB0cnVlIHx8IGRyYWcgPT09IGRpcmVjdGlvbikgJiZcbiAgICAgICAgKGN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwgfHwgY3VycmVudERpcmVjdGlvbiA9PT0gZGlyZWN0aW9uKSk7XG59XG4vKipcbiAqIEJhc2VkIG9uIGFuIHgveSBvZmZzZXQgZGV0ZXJtaW5lIHRoZSBjdXJyZW50IGRyYWcgZGlyZWN0aW9uLiBJZiBib3RoIGF4aXMnIG9mZnNldHMgYXJlIGxvd2VyXG4gKiB0aGFuIHRoZSBwcm92aWRlZCB0aHJlc2hvbGQsIHJldHVybiBgbnVsbGAuXG4gKlxuICogQHBhcmFtIG9mZnNldCAtIFRoZSB4L3kgb2Zmc2V0IGZyb20gb3JpZ2luLlxuICogQHBhcmFtIGxvY2tUaHJlc2hvbGQgLSAoT3B0aW9uYWwpIC0gdGhlIG1pbmltdW0gYWJzb2x1dGUgb2Zmc2V0IGJlZm9yZSB3ZSBjYW4gZGV0ZXJtaW5lIGEgZHJhZyBkaXJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnREaXJlY3Rpb24ob2Zmc2V0LCBsb2NrVGhyZXNob2xkKSB7XG4gICAgaWYgKGxvY2tUaHJlc2hvbGQgPT09IHZvaWQgMCkgeyBsb2NrVGhyZXNob2xkID0gMTA7IH1cbiAgICB2YXIgZGlyZWN0aW9uID0gbnVsbDtcbiAgICBpZiAoTWF0aC5hYnMob2Zmc2V0LnkpID4gbG9ja1RocmVzaG9sZCkge1xuICAgICAgICBkaXJlY3Rpb24gPSBcInlcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoTWF0aC5hYnMob2Zmc2V0LngpID4gbG9ja1RocmVzaG9sZCkge1xuICAgICAgICBkaXJlY3Rpb24gPSBcInhcIjtcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBhbGxvd3MgYW4gZWxlbWVudCB0byBiZSBkcmFnZ2VkLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEcmFnKHByb3BzKSB7XG4gICAgdmFyIGdyb3VwRHJhZ0NvbnRyb2xzID0gcHJvcHMuZHJhZ0NvbnRyb2xzLCB2aXN1YWxFbGVtZW50ID0gcHJvcHMudmlzdWFsRWxlbWVudDtcbiAgICB2YXIgZHJhZ0NvbnRyb2xzID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHModmlzdWFsRWxlbWVudCk7IH0pO1xuICAgIC8vIElmIHdlJ3ZlIGJlZW4gcHJvdmlkZWQgYSBEcmFnQ29udHJvbHMgZm9yIG1hbnVhbCBjb250cm9sIG92ZXIgdGhlIGRyYWcgZ2VzdHVyZSxcbiAgICAvLyBzdWJzY3JpYmUgdGhpcyBjb21wb25lbnQgdG8gaXQgb24gbW91bnQuXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdyb3VwRHJhZ0NvbnRyb2xzICYmIGdyb3VwRHJhZ0NvbnRyb2xzLnN1YnNjcmliZShkcmFnQ29udHJvbHMpOyB9LCBbZHJhZ0NvbnRyb2xzLCBncm91cERyYWdDb250cm9sc10pO1xuICAgIC8vIEFwcGx5IHRoZSBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGVsZW1lbnRcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gZHJhZ0NvbnRyb2xzLmFkZExpc3RlbmVycygpOyB9LCBbZHJhZ0NvbnRyb2xzXSk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBoYW5kbGVycyAtXG4gKiBAcGFyYW0gcmVmIC1cbiAqXG4gKiBAcHJpdmF0ZVJlbWFya3NcbiAqIEN1cnJlbnRseSB0aGlzIHNldHMgbmV3IHBhbiBnZXN0dXJlIGZ1bmN0aW9ucyBldmVyeSByZW5kZXIuIFRoZSBtZW1vIHJvdXRlIGhhcyBiZWVuIGV4cGxvcmVkXG4gKiBpbiB0aGUgcGFzdCBidXQgdWx0aW1hdGVseSB3ZSdyZSBzdGlsbCBjcmVhdGluZyBuZXcgZnVuY3Rpb25zIGV2ZXJ5IHJlbmRlci4gQW4gb3B0aW1pc2F0aW9uXG4gKiB0byBleHBsb3JlIGlzIGNyZWF0aW5nIHRoZSBwYW4gZ2VzdHVyZXMgYW5kIGxvYWRpbmcgdGhlbSBpbnRvIGEgYHJlZmAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZVBhbkdlc3R1cmUoX2EpIHtcbiAgICB2YXIgb25QYW4gPSBfYS5vblBhbiwgb25QYW5TdGFydCA9IF9hLm9uUGFuU3RhcnQsIG9uUGFuRW5kID0gX2Eub25QYW5FbmQsIG9uUGFuU2Vzc2lvblN0YXJ0ID0gX2Eub25QYW5TZXNzaW9uU3RhcnQsIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50O1xuICAgIHZhciBoYXNQYW5FdmVudHMgPSBvblBhbiB8fCBvblBhblN0YXJ0IHx8IG9uUGFuRW5kIHx8IG9uUGFuU2Vzc2lvblN0YXJ0O1xuICAgIHZhciBwYW5TZXNzaW9uID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciB0cmFuc2Zvcm1QYWdlUG9pbnQgPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpLnRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICB2YXIgaGFuZGxlcnMgPSB7XG4gICAgICAgIG9uU2Vzc2lvblN0YXJ0OiBvblBhblNlc3Npb25TdGFydCxcbiAgICAgICAgb25TdGFydDogb25QYW5TdGFydCxcbiAgICAgICAgb25Nb3ZlOiBvblBhbixcbiAgICAgICAgb25FbmQ6IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICAgICAgcGFuU2Vzc2lvbi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIG9uUGFuRW5kICYmIG9uUGFuRW5kKGV2ZW50LCBpbmZvKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwYW5TZXNzaW9uLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhblNlc3Npb24uY3VycmVudC51cGRhdGVIYW5kbGVycyhoYW5kbGVycyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgIHBhblNlc3Npb24uY3VycmVudCA9IG5ldyBQYW5TZXNzaW9uKGV2ZW50LCBoYW5kbGVycywge1xuICAgICAgICAgICAgdHJhbnNmb3JtUGFnZVBvaW50OiB0cmFuc2Zvcm1QYWdlUG9pbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudCwgXCJwb2ludGVyZG93blwiLCBoYXNQYW5FdmVudHMgJiYgb25Qb2ludGVyRG93bik7XG4gICAgdXNlVW5tb3VudEVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiBwYW5TZXNzaW9uLmN1cnJlbnQgJiYgcGFuU2Vzc2lvbi5jdXJyZW50LmVuZCgpOyB9KTtcbn1cblxudmFyIGRyYWcgPSB7XG4gICAgcGFuOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VQYW5HZXN0dXJlKSxcbiAgICBkcmFnOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VEcmFnKSxcbn07XG5cbnZhciBuYW1lcyA9IFtcbiAgICBcIkxheW91dE1lYXN1cmVcIixcbiAgICBcIkJlZm9yZUxheW91dE1lYXN1cmVcIixcbiAgICBcIkxheW91dFVwZGF0ZVwiLFxuICAgIFwiVmlld3BvcnRCb3hVcGRhdGVcIixcbiAgICBcIlVwZGF0ZVwiLFxuICAgIFwiUmVuZGVyXCIsXG4gICAgXCJBbmltYXRpb25Db21wbGV0ZVwiLFxuICAgIFwiTGF5b3V0QW5pbWF0aW9uQ29tcGxldGVcIixcbiAgICBcIkFuaW1hdGlvblN0YXJ0XCIsXG4gICAgXCJMYXlvdXRBbmltYXRpb25TdGFydFwiLFxuICAgIFwiU2V0QXhpc1RhcmdldFwiLFxuICAgIFwiVW5tb3VudFwiLFxuXTtcbmZ1bmN0aW9uIGNyZWF0ZUxpZmVjeWNsZXMoKSB7XG4gICAgdmFyIG1hbmFnZXJzID0gbmFtZXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7IH0pO1xuICAgIHZhciBwcm9wU3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgIHZhciBsaWZlY3ljbGVzID0ge1xuICAgICAgICBjbGVhckFsbExpc3RlbmVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFuYWdlcnMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlcikgeyByZXR1cm4gbWFuYWdlci5jbGVhcigpOyB9KTsgfSxcbiAgICAgICAgdXBkYXRlUHJvcExpc3RlbmVyczogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhciBvbiA9IFwib25cIiArIG5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BMaXN0ZW5lciA9IHByb3BzW29uXTtcbiAgICAgICAgICAgICAgICAvLyBVbnN1YnNjcmliZSBleGlzdGluZyBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAoX2EgPSBwcm9wU3Vic2NyaXB0aW9uc1tuYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvcFN1YnNjcmlwdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBuZXcgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHByb3BMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBwcm9wU3Vic2NyaXB0aW9uc1tuYW1lXSA9IGxpZmVjeWNsZXNbb25dKHByb3BMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBtYW5hZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VyLCBpKSB7XG4gICAgICAgIGxpZmVjeWNsZXNbXCJvblwiICsgbmFtZXNbaV1dID0gZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIG1hbmFnZXIuYWRkKGhhbmRsZXIpOyB9O1xuICAgICAgICBsaWZlY3ljbGVzW1wibm90aWZ5XCIgKyBuYW1lc1tpXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlci5ub3RpZnkuYXBwbHkobWFuYWdlciwgdHNsaWIuX19zcHJlYWRBcnJheShbXSwgdHNsaWIuX19yZWFkKGFyZ3MpLCBmYWxzZSkpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBsaWZlY3ljbGVzO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMoZWxlbWVudCwgbmV4dCwgcHJldikge1xuICAgIHZhciBfYTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmV4dCkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gbmV4dFtrZXldO1xuICAgICAgICB2YXIgcHJldlZhbHVlID0gcHJldltrZXldO1xuICAgICAgICBpZiAoaXNNb3Rpb25WYWx1ZShuZXh0VmFsdWUpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBtb3Rpb24gdmFsdWUgZm91bmQgaW4gcHJvcHMgb3Igc3R5bGUsIHdlIHdhbnQgdG8gYWRkIGl0XG4gICAgICAgICAgICAgKiB0byBvdXIgdmlzdWFsIGVsZW1lbnQncyBtb3Rpb24gdmFsdWUgbWFwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbmV4dFZhbHVlKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgdGhlIHZlcnNpb24gb2YgdGhlIGluY29taW5nIG1vdGlvbiB2YWx1ZSB3aXRoIHRoaXMgdmVyc2lvblxuICAgICAgICAgICAgICogYW5kIHdhcm4gYWdhaW5zdCBtaXNtYXRjaGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgICAgIHdhcm5PbmNlKG5leHRWYWx1ZS52ZXJzaW9uID09PSBcIjYuNS4xXCIsIFwiQXR0ZW1wdGluZyB0byBtaXggRnJhbWVyIE1vdGlvbiB2ZXJzaW9ucyBcIi5jb25jYXQobmV4dFZhbHVlLnZlcnNpb24sIFwiIHdpdGggNi41LjEgbWF5IG5vdCB3b3JrIGFzIGV4cGVjdGVkLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNb3Rpb25WYWx1ZShwcmV2VmFsdWUpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIHN3YXBwaW5nIHRvIGEgbmV3IG1vdGlvbiB2YWx1ZSwgY3JlYXRlIGEgbmV3IG1vdGlvbiB2YWx1ZVxuICAgICAgICAgICAgICogZnJvbSB0aGF0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZShuZXh0VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2VmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgZmxhdCB2YWx1ZSB0aGF0IGhhcyBjaGFuZ2VkLCB1cGRhdGUgdGhlIG1vdGlvbiB2YWx1ZVxuICAgICAgICAgICAgICogb3IgY3JlYXRlIG9uZSBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBvbmx5IHdhbnQgdG8gZG8gdGhpcyBpZiB3ZSdyZVxuICAgICAgICAgICAgICogbm90IGhhbmRsaW5nIHRoZSB2YWx1ZSB3aXRoIG91ciBhbmltYXRpb24gc3RhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBPbmx5IHVwZGF0ZSB2YWx1ZXMgdGhhdCBhcmVuJ3QgYmVpbmcgYW5pbWF0ZWQgb3IgZXZlbiBsb29rZWQgYXRcbiAgICAgICAgICAgICAgICAhZXhpc3RpbmdWYWx1ZS5oYXNBbmltYXRlZCAmJiBleGlzdGluZ1ZhbHVlLnNldChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKChfYSA9IGVsZW1lbnQuZ2V0U3RhdGljVmFsdWUoa2V5KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV4dFZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxlIHJlbW92ZWQgdmFsdWVzXG4gICAgZm9yICh2YXIga2V5IGluIHByZXYpIHtcbiAgICAgICAgaWYgKG5leHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVWYWx1ZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dDtcbn1cblxudmFyIHZpc3VhbEVsZW1lbnQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS50cmVlVHlwZSwgdHJlZVR5cGUgPSBfYiA9PT0gdm9pZCAwID8gXCJcIiA6IF9iLCBidWlsZCA9IF9hLmJ1aWxkLCBnZXRCYXNlVGFyZ2V0ID0gX2EuZ2V0QmFzZVRhcmdldCwgbWFrZVRhcmdldEFuaW1hdGFibGUgPSBfYS5tYWtlVGFyZ2V0QW5pbWF0YWJsZSwgbWVhc3VyZVZpZXdwb3J0Qm94ID0gX2EubWVhc3VyZVZpZXdwb3J0Qm94LCByZW5kZXJJbnN0YW5jZSA9IF9hLnJlbmRlciwgcmVhZFZhbHVlRnJvbUluc3RhbmNlID0gX2EucmVhZFZhbHVlRnJvbUluc3RhbmNlLCByZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZSA9IF9hLnJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlLCBzb3J0Tm9kZVBvc2l0aW9uID0gX2Euc29ydE5vZGVQb3NpdGlvbiwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzID0gX2Euc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IF9hLnBhcmVudCwgcHJvcHMgPSBfYS5wcm9wcywgcHJlc2VuY2VJZCA9IF9hLnByZXNlbmNlSWQsIGJsb2NrSW5pdGlhbEFuaW1hdGlvbiA9IF9hLmJsb2NrSW5pdGlhbEFuaW1hdGlvbiwgdmlzdWFsU3RhdGUgPSBfYS52aXN1YWxTdGF0ZSwgc2hvdWxkUmVkdWNlTW90aW9uID0gX2Euc2hvdWxkUmVkdWNlTW90aW9uO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBsYXRlc3RWYWx1ZXMgPSB2aXN1YWxTdGF0ZS5sYXRlc3RWYWx1ZXMsIHJlbmRlclN0YXRlID0gdmlzdWFsU3RhdGUucmVuZGVyU3RhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5zdGFuY2Ugb2YgdGhlIHJlbmRlci1zcGVjaWZpYyBub2RlIHRoYXQgd2lsbCBiZSBoeWRyYXRlZCBieSB0aGVcbiAgICAgICAgICogZXhwb3NlZCBSZWFjdCByZWYuIFNvIGZvciBleGFtcGxlLCB0aGlzIHZpc3VhbCBlbGVtZW50IGNhbiBob3N0IGFcbiAgICAgICAgICogSFRNTEVsZW1lbnQsIHBsYWluIG9iamVjdCwgb3IgVGhyZWUuanMgb2JqZWN0LiBUaGUgZnVuY3Rpb25zIHByb3ZpZGVkXG4gICAgICAgICAqIGluIFZpc3VhbEVsZW1lbnRDb25maWcgYWxsb3cgdXMgdG8gaW50ZXJmYWNlIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpbnN0YW5jZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hbmFnZXMgdGhlIHN1YnNjcmlwdGlvbnMgZm9yIGEgdmlzdWFsIGVsZW1lbnQncyBsaWZlY3ljbGUsIGZvciBpbnN0YW5jZVxuICAgICAgICAgKiBvblJlbmRlclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGxpZmVjeWNsZXMgPSBjcmVhdGVMaWZlY3ljbGVzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiBhbGwgbW90aW9uIHZhbHVlcyBhdHRhY2hlZCB0byB0aGlzIHZpc3VhbCBlbGVtZW50LiBNb3Rpb25cbiAgICAgICAgICogdmFsdWVzIGFyZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIGFueSBnaXZlbiBhbmltYXRlZCB2YWx1ZS4gQSBtb3Rpb25cbiAgICAgICAgICogdmFsdWUgbWlnaHQgYmUgcHJvdmlkZWQgZXh0ZXJuYWxseSBieSB0aGUgY29tcG9uZW50IHZpYSBwcm9wcy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiBldmVyeSBzdWJzY3JpcHRpb24gdGhhdCBiaW5kcyB0aGUgcHJvdmlkZWQgb3IgZ2VuZXJhdGVkXG4gICAgICAgICAqIG1vdGlvbiB2YWx1ZXMgb25DaGFuZ2UgbGlzdGVuZXJzIHRvIHRoaXMgdmlzdWFsIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdmFsdWVTdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzbHktcHJvdmlkZWQgbW90aW9uIHZhbHVlcyBhcyByZXR1cm5lZFxuICAgICAgICAgKiBmcm9tIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcy4gV2UgdXNlIHRoZSBrZXlzIGluIGhlcmUgdG8gZGV0ZXJtaW5lXG4gICAgICAgICAqIGlmIGFueSBtb3Rpb24gdmFsdWVzIG5lZWQgdG8gYmUgcmVtb3ZlZCBhZnRlciBwcm9wcyBhcmUgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBwcmV2TW90aW9uVmFsdWVzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHZhbHVlcyBhcmUgcmVtb3ZlZCBmcm9tIGFsbCBhbmltYXRpb24gcHJvcHMgd2UgbmVlZCB0byBzZWFyY2hcbiAgICAgICAgICogZm9yIGEgZmFsbGJhY2sgdmFsdWUgdG8gYW5pbWF0ZSB0by4gVGhlc2UgdmFsdWVzIGFyZSB0cmFja2VkIGluIGJhc2VUYXJnZXQuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYmFzZVRhcmdldCA9IHRzbGliLl9fYXNzaWduKHt9LCBsYXRlc3RWYWx1ZXMpO1xuICAgICAgICAvLyBJbnRlcm5hbCBtZXRob2RzID09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAvKipcbiAgICAgICAgICogT24gbW91bnQsIHRoaXMgd2lsbCBiZSBoeWRyYXRlZCB3aXRoIGEgY2FsbGJhY2sgdG8gZGlzY29ubmVjdFxuICAgICAgICAgKiB0aGlzIHZpc3VhbCBlbGVtZW50IGZyb20gaXRzIHBhcmVudCBvbiB1bm1vdW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlbW92ZUZyb21WYXJpYW50VHJlZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgZWxlbWVudCB3aXRoIHRoZSBsYXRlc3Qgc3R5bGVzIG91dHNpZGUgb2YgdGhlIFJlYWN0XG4gICAgICAgICAqIHJlbmRlciBsaWZlY3ljbGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2UgfHwgIWlzTW91bnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cmlnZ2VyQnVpbGQoKTtcbiAgICAgICAgICAgIHJlbmRlckluc3RhbmNlKGluc3RhbmNlLCByZW5kZXJTdGF0ZSwgcHJvcHMuc3R5bGUsIGVsZW1lbnQucHJvamVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckJ1aWxkKCkge1xuICAgICAgICAgICAgYnVpbGQoZWxlbWVudCwgcmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgIGxpZmVjeWNsZXMubm90aWZ5VXBkYXRlKGxhdGVzdFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBiaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlT25DaGFuZ2UgPSB2YWx1ZS5vbkNoYW5nZShmdW5jdGlvbiAobGF0ZXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXNba2V5XSA9IGxhdGVzdFZhbHVlO1xuICAgICAgICAgICAgICAgIHByb3BzLm9uVXBkYXRlICYmIHN5bmNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnVwZGF0ZSh1cGRhdGUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHJlbW92ZU9uUmVuZGVyUmVxdWVzdCA9IHZhbHVlLm9uUmVuZGVyUmVxdWVzdChlbGVtZW50LnNjaGVkdWxlUmVuZGVyKTtcbiAgICAgICAgICAgIHZhbHVlU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlT25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICByZW1vdmVPblJlbmRlclJlcXVlc3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnkgbW90aW9uIHZhbHVlcyB0aGF0IGFyZSBwcm92aWRlZCB0byB0aGUgZWxlbWVudCB3aGVuIGNyZWF0ZWRcbiAgICAgICAgICogYXJlbid0IHlldCBib3VuZCB0byB0aGUgZWxlbWVudCwgYXMgdGhpcyB3b3VsZCB0ZWNobmljYWxseSBiZSBpbXB1cmUuXG4gICAgICAgICAqIEhvd2V2ZXIsIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgbW90aW9uIHZhbHVlcyBhbmQgc2V0IHRoZW0gdG8gdGhlXG4gICAgICAgICAqIGluaXRpYWwgdmFsdWVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogVGhpcyBpcyBpbXB1cmUgYW5kIHdlIHNob3VsZCBsb29rIGF0IGNoYW5naW5nIHRoaXMgdG8gcnVuIG9uIG1vdW50LlxuICAgICAgICAgKiBEb2luZyBzbyB3aWxsIGJyZWFrIHNvbWUgdGVzdHMgYnV0IHRoaXMgaXNuJ3QgbmVjY2Vzc2FyaWx5IGEgYnJlYWtpbmcgY2hhbmdlLFxuICAgICAgICAgKiBtb3JlIGEgcmVmbGVjdGlvbiBvZiB0aGUgdGVzdC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpbml0aWFsTW90aW9uVmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGluaXRpYWxNb3Rpb25WYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluaXRpYWxNb3Rpb25WYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChsYXRlc3RWYWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkICYmIGlzTW90aW9uVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuc2V0KGxhdGVzdFZhbHVlc1trZXldLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZSB3aGF0IHJvbGUgdGhpcyB2aXN1YWwgZWxlbWVudCBzaG91bGQgdGFrZSBpbiB0aGUgdmFyaWFudCB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgICAgICAgdmFyIGlzVmFyaWFudE5vZGUgPSBjaGVja0lmVmFyaWFudE5vZGUocHJvcHMpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHsgdHJlZVR5cGU6IHRyZWVUeXBlLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBpcyBhIG1pcnJvciBvZiB0aGUgaW50ZXJuYWwgaW5zdGFuY2UgcHJvcCwgd2hpY2gga2VlcHNcbiAgICAgICAgICAgICAqIFZpc3VhbEVsZW1lbnQgdHlwZS1jb21wYXRpYmxlIHdpdGggUmVhY3QncyBSZWZPYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGN1cnJlbnQ6IG51bGwsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZGVwdGggb2YgdGhpcyB2aXN1YWwgZWxlbWVudCB3aXRoaW4gdGhlIHZpc3VhbCBlbGVtZW50IHRyZWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlcHRoOiBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMCwgcGFyZW50OiBwYXJlbnQsIGNoaWxkcmVuOiBuZXcgU2V0KCksIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwcmVzZW5jZUlkOiBwcmVzZW5jZUlkLCBzaG91bGRSZWR1Y2VNb3Rpb246IHNob3VsZFJlZHVjZU1vdGlvbiwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgY29tcG9uZW50IGlzIHBhcnQgb2YgdGhlIHZhcmlhbnQgdHJlZSwgaXQgc2hvdWxkIHRyYWNrXG4gICAgICAgICAgICAgKiBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgYWxzbyBwYXJ0IG9mIHRoZSB0cmVlLiBUaGlzIGlzIGVzc2VudGlhbGx5XG4gICAgICAgICAgICAgKiBhIHNoYWRvdyB0cmVlIHRvIHNpbXBsaWZ5IGxvZ2ljIGFyb3VuZCBob3cgdG8gc3RhZ2dlciBvdmVyIGNoaWxkcmVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXJpYW50Q2hpbGRyZW46IGlzVmFyaWFudE5vZGUgPyBuZXcgU2V0KCkgOiB1bmRlZmluZWQsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaW5zdGFuY2UgaXMgdmlzaWJsZS4gVGhpcyBjYW4gYmUgY2hhbmdlZCBpbXBlcmF0aXZlbHlcbiAgICAgICAgICAgICAqIGJ5IHRoZSBwcm9qZWN0aW9uIHRyZWUsIGlzIGFuYWxvZ291cyB0byBDU1MncyB2aXNpYmlsaXR5IGluIHRoYXRcbiAgICAgICAgICAgICAqIGhpZGRlbiBlbGVtZW50cyBzaG91bGQgdGFrZSB1cCBsYXlvdXQsIGFuZCBuZWVkcyBlbmFjdGluZyBieSB0aGUgY29uZmlndXJlZFxuICAgICAgICAgICAgICogcmVuZGVyIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpc1Zpc2libGU6IHVuZGVmaW5lZCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vcm1hbGx5LCBpZiBhIGNvbXBvbmVudCBpcyBjb250cm9sbGVkIGJ5IGEgcGFyZW50J3MgdmFyaWFudHMsIGl0IGNhblxuICAgICAgICAgICAgICogcmVseSBvbiB0aGF0IGFuY2VzdG9yIHRvIHRyaWdnZXIgYW5pbWF0aW9ucyBmdXJ0aGVyIGRvd24gdGhlIHRyZWUuXG4gICAgICAgICAgICAgKiBIb3dldmVyLCBpZiBhIGNvbXBvbmVudCBpcyBjcmVhdGVkIGFmdGVyIGl0cyBwYXJlbnQgaXMgbW91bnRlZCwgdGhlIHBhcmVudFxuICAgICAgICAgICAgICogd29uJ3QgdHJpZ2dlciB0aGF0IG1vdW50IGFuaW1hdGlvbiBzbyB0aGUgY2hpbGQgbmVlZHMgdG8uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogVGhpcyBtaWdodCBiZSBiZXR0ZXIgcmVwbGFjZWQgd2l0aCBhIG1ldGhvZCBpc1BhcmVudE1vdW50ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWFudWFsbHlBbmltYXRlT25Nb3VudDogQm9vbGVhbihwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuaXNNb3VudGVkKCkpLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBjYW4gYmUgc2V0IGJ5IEFuaW1hdGVQcmVzZW5jZSB0byBmb3JjZSBjb21wb25lbnRzIHRoYXQgbW91bnRcbiAgICAgICAgICAgICAqIGF0IHRoZSBzYW1lIHRpbWUgYXMgaXQgdG8gbW91bnQgYXMgaWYgdGhleSBoYXZlIGluaXRpYWw9e2ZhbHNlfSBzZXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGJsb2NrSW5pdGlhbEFuaW1hdGlvbjogYmxvY2tJbml0aWFsQW5pbWF0aW9uLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBjb21wb25lbnQgaGFzIG1vdW50ZWQgeWV0LiBUaGlzIGlzIG1vc3RseSB1c2VkXG4gICAgICAgICAgICAgKiBieSB2YXJpYW50IGNoaWxkcmVuIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXkgbmVlZCB0byB0cmlnZ2VyIHRoZWlyXG4gICAgICAgICAgICAgKiBvd24gYW5pbWF0aW9ucyBvbiBtb3VudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBCb29sZWFuKGluc3RhbmNlKTsgfSwgbW91bnQ6IGZ1bmN0aW9uIChuZXdJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBlbGVtZW50LmN1cnJlbnQgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5wcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucHJvamVjdGlvbi5tb3VudChuZXdJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhbnROb2RlICYmIHBhcmVudCAmJiAhaXNDb250cm9sbGluZ1ZhcmlhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUZyb21WYXJpYW50VHJlZSA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5hZGRWYXJpYW50Q2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IHJldHVybiBiaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmNoaWxkcmVuLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IGVsZW1lbnQucHJvamVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVubW91bnQoKTtcbiAgICAgICAgICAgICAgICBzeW5jLmNhbmNlbFN5bmMudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgc3luYy5jYW5jZWxTeW5jLnJlbmRlcihyZW5kZXIpO1xuICAgICAgICAgICAgICAgIHZhbHVlU3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChyZW1vdmUpIHsgcmV0dXJuIHJlbW92ZSgpOyB9KTtcbiAgICAgICAgICAgICAgICByZW1vdmVGcm9tVmFyaWFudFRyZWUgPT09IG51bGwgfHwgcmVtb3ZlRnJvbVZhcmlhbnRUcmVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW1vdmVGcm9tVmFyaWFudFRyZWUoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuY2hpbGRyZW4uZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGxpZmVjeWNsZXMuY2xlYXJBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGQgYSBjaGlsZCB2aXN1YWwgZWxlbWVudCB0byBvdXIgc2V0IG9mIGNoaWxkcmVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRWYXJpYW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgY2xvc2VzdFZhcmlhbnROb2RlID0gZWxlbWVudC5nZXRDbG9zZXN0VmFyaWFudE5vZGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdFZhcmlhbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGNsb3Nlc3RWYXJpYW50Tm9kZS52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RWYXJpYW50Tm9kZS52YXJpYW50Q2hpbGRyZW4uZGVsZXRlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzb3J0Tm9kZVBvc2l0aW9uOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGVzZSBub2RlcyBhcmVuJ3QgZXZlbiBvZiB0aGUgc2FtZSB0eXBlIHdlIGNhbid0IGNvbXBhcmUgdGhlaXIgZGVwdGguXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCFzb3J0Tm9kZVBvc2l0aW9uIHx8IHRyZWVUeXBlICE9PSBvdGhlci50cmVlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvcnROb2RlUG9zaXRpb24oZWxlbWVudC5nZXRJbnN0YW5jZSgpLCBvdGhlci5nZXRJbnN0YW5jZSgpKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjbG9zZXN0IHZhcmlhbnQgbm9kZSBpbiB0aGUgdHJlZSBzdGFydGluZyBmcm9tXG4gICAgICAgICAgICAgKiB0aGlzIHZpc3VhbCBlbGVtZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRDbG9zZXN0VmFyaWFudE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYXJpYW50Tm9kZSA/IGVsZW1lbnQgOiBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKCk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXhwb3NlIHRoZSBsYXRlc3QgbGF5b3V0SWQgcHJvcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TGF5b3V0SWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BzLmxheW91dElkOyB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluc3RhbmNlOyB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0L3NldCB0aGUgbGF0ZXN0IHN0YXRpYyB2YWx1ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFN0YXRpY1ZhbHVlOiBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBsYXRlc3RWYWx1ZXNba2V5XTsgfSwgc2V0U3RhdGljVmFsdWU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7IHJldHVybiAobGF0ZXN0VmFsdWVzW2tleV0gPSB2YWx1ZSk7IH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBsYXRlc3QgbW90aW9uIHZhbHVlIHN0YXRlLiBDdXJyZW50bHkgb25seSB1c2VkIHRvIHRha2VcbiAgICAgICAgICAgICAqIGEgc25hcHNob3Qgb2YgdGhlIHZpc3VhbCBlbGVtZW50IC0gcGVyaGFwcyB0aGlzIGNhbiByZXR1cm4gdGhlIHdob2xlXG4gICAgICAgICAgICAgKiB2aXN1YWwgc3RhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TGF0ZXN0VmFsdWVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYXRlc3RWYWx1ZXM7IH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgdGhlIHZpc2libGl0eSBvZiB0aGUgdmlzdWFsIGVsZW1lbnQuIElmIGl0J3MgY2hhbmdlZCwgc2NoZWR1bGVcbiAgICAgICAgICAgICAqIGEgcmVuZGVyIHRvIHJlZmxlY3QgdGhlc2UgY2hhbmdlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0VmlzaWJpbGl0eTogZnVuY3Rpb24gKHZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pc1Zpc2libGUgPT09IHZpc2liaWxpdHkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmlzVmlzaWJsZSA9IHZpc2liaWxpdHk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1ha2UgYSB0YXJnZXQgYW5pbWF0YWJsZSBieSBQb3Btb3Rpb24uIEZvciBpbnN0YW5jZSwgaWYgd2UncmVcbiAgICAgICAgICAgICAqIHRyeWluZyB0byBhbmltYXRlIHdpZHRoIGZyb20gMTAwcHggdG8gMTAwdncgd2UgbmVlZCB0byBtZWFzdXJlIDEwMHZ3XG4gICAgICAgICAgICAgKiBpbiBwaXhlbHMgdG8gZGV0ZXJtaW5lIHdoYXQgd2UgcmVhbGx5IG5lZWQgdG8gYW5pbWF0ZSB0by4gVGhpcyBpcyBhbHNvXG4gICAgICAgICAgICAgKiBwbHVnZ2FibGUgdG8gc3VwcG9ydCBGcmFtZXIncyBjdXN0b20gdmFsdWUgdHlwZXMgbGlrZSBDb2xvcixcbiAgICAgICAgICAgICAqIGFuZCBDU1MgdmFyaWFibGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYWtlVGFyZ2V0QW5pbWF0YWJsZTogZnVuY3Rpb24gKHRhcmdldCwgY2FuTXV0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbk11dGF0ZSA9PT0gdm9pZCAwKSB7IGNhbk11dGF0ZSA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVRhcmdldEFuaW1hdGFibGUoZWxlbWVudCwgdGFyZ2V0LCBwcm9wcywgY2FuTXV0YXRlKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNZWFzdXJlIHRoZSBjdXJyZW50IHZpZXdwb3J0IGJveCB3aXRoIG9yIHdpdGhvdXQgdHJhbnNmb3Jtcy5cbiAgICAgICAgICAgICAqIE9ubHkgbWVhc3VyZXMgYXhpcy1hbGlnbmVkIGJveGVzLCByb3RhdGUgYW5kIHNrZXcgbXVzdCBiZSBtYW51YWxseVxuICAgICAgICAgICAgICogcmVtb3ZlZCB3aXRoIGEgcmUtcmVuZGVyIHRvIHdvcmsuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1lYXN1cmVWaWV3cG9ydEJveDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZWFzdXJlVmlld3BvcnRCb3goaW5zdGFuY2UsIHByb3BzKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gTW90aW9uIHZhbHVlcyA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIGEgbW90aW9uIHZhbHVlIGFuZCBiaW5kIGl0IHRvIHRoaXMgdmlzdWFsIGVsZW1lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZFZhbHVlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBleGlzdGluZyB2YWx1ZSBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNWYWx1ZShrZXkpKVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZVZhbHVlKGtleSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXNba2V5XSA9IHZhbHVlLmdldCgpO1xuICAgICAgICAgICAgICAgIGJpbmRUb01vdGlvblZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZSBhIG1vdGlvbiB2YWx1ZSBhbmQgdW5iaW5kIGFueSBhY3RpdmUgc3Vic2NyaXB0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVtb3ZlVmFsdWU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFsdWVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIChfYSA9IHZhbHVlU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVTdWJzY3JpcHRpb25zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsYXRlc3RWYWx1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICByZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZShrZXksIHJlbmRlclN0YXRlKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSBtb3Rpb24gdmFsdWUgZm9yIHRoaXMga2V5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhhc1ZhbHVlOiBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB2YWx1ZXMuaGFzKGtleSk7IH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYSBtb3Rpb24gdmFsdWUgZm9yIHRoaXMga2V5LiBJZiBjYWxsZWQgd2l0aCBhIGRlZmF1bHRcbiAgICAgICAgICAgICAqIHZhbHVlLCB3ZSdsbCBjcmVhdGUgb25lIGlmIG5vbmUgZXhpc3RzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbW90aW9uVmFsdWUoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEl0ZXJhdGUgb3ZlciBvdXIgbW90aW9uIHZhbHVlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yRWFjaFZhbHVlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHZhbHVlcy5mb3JFYWNoKGNhbGxiYWNrKTsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIHRyeWluZyB0byBhbmltYXRlIHRvIGEgcHJldmlvdXNseSB1bmVuY291bnRlcmVkIHZhbHVlLFxuICAgICAgICAgICAgICogd2UgbmVlZCB0byBjaGVjayBmb3IgaXQgaW4gb3VyIHN0YXRlIGFuZCBhcyBhIGxhc3QgcmVzb3J0IHJlYWQgaXRcbiAgICAgICAgICAgICAqIGRpcmVjdGx5IGZyb20gdGhlIGluc3RhbmNlICh3aGljaCBtaWdodCBoYXZlIHBlcmZvcm1hbmNlIGltcGxpY2F0aW9ucykuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlYWRWYWx1ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gbGF0ZXN0VmFsdWVzW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlYWRWYWx1ZUZyb21JbnN0YW5jZShpbnN0YW5jZSwga2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgdGhlIGJhc2UgdGFyZ2V0IHRvIGxhdGVyIGFuaW1hdGUgYmFjayB0by4gVGhpcyBpcyBjdXJyZW50bHlcbiAgICAgICAgICAgICAqIG9ubHkgaHlkcmF0ZWQgb24gY3JlYXRpb24gYW5kIHdoZW4gd2UgZmlyc3QgcmVhZCBhIHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXRCYXNlVGFyZ2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGJhc2VUYXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZpbmQgdGhlIGJhc2UgdGFyZ2V0IGZvciBhIHZhbHVlIHRoYXRzIGJlZW4gcmVtb3ZlZCBmcm9tIGFsbCBhbmltYXRpb25cbiAgICAgICAgICAgICAqIHByb3BzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRCYXNlVGFyZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldEJhc2VUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldEJhc2VUYXJnZXQocHJvcHMsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiAhaXNNb3Rpb25WYWx1ZSh0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VUYXJnZXRba2V5XTtcbiAgICAgICAgICAgIH0gfSwgbGlmZWN5Y2xlcyksIHsgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJ1aWxkIHRoZSByZW5kZXJlciBzdGF0ZSBiYXNlZCBvbiB0aGUgbGF0ZXN0IHZpc3VhbCBzdGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQnVpbGQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyU3RhdGU7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2NoZWR1bGUgYSByZW5kZXIgb24gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzY2hlZHVsZVJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN5bmNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnJlbmRlcihyZW5kZXIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTeW5jaHJvbm91c2x5IGZpcmUgcmVuZGVyLiBJdCdzIHByZWZlcmVkIHRoYXQgd2UgYmF0Y2ggcmVuZGVycyBidXRcbiAgICAgICAgICAgICAqIGluIG1hbnkgY2lyY3Vtc3RhbmNlcywgbGlrZSBsYXlvdXQgbWVhc3VyZW1lbnQsIHdlIG5lZWQgdG8gcnVuIHRoaXNcbiAgICAgICAgICAgICAqIHN5bmNocm9ub3VzbHkuIEhvd2V2ZXIgaW4gdGhvc2UgaW5zdGFuY2VzIG90aGVyIG1lYXN1cmVzIHNob3VsZCBiZSB0YWtlblxuICAgICAgICAgICAgICogdG8gYmF0Y2ggcmVhZHMvd3JpdGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzeW5jUmVuZGVyOiByZW5kZXIsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIHByb3ZpZGVkIHByb3BzLiBFbnN1cmUgYW55IG5ld2x5LWFkZGVkIG1vdGlvbiB2YWx1ZXMgYXJlXG4gICAgICAgICAgICAgKiBhZGRlZCB0byBvdXIgbWFwLCBvbGQgb25lcyByZW1vdmVkLCBhbmQgbGlzdGVuZXJzIHVwZGF0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldFByb3BzOiBmdW5jdGlvbiAobmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3UHJvcHMudHJhbnNmb3JtVGVtcGxhdGUgfHwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9wcyA9IG5ld1Byb3BzO1xuICAgICAgICAgICAgICAgIGxpZmVjeWNsZXMudXBkYXRlUHJvcExpc3RlbmVycyhuZXdQcm9wcyk7XG4gICAgICAgICAgICAgICAgcHJldk1vdGlvblZhbHVlcyA9IHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhlbGVtZW50LCBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpLCBwcmV2TW90aW9uVmFsdWVzKTtcbiAgICAgICAgICAgIH0sIGdldFByb3BzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wczsgfSwgXG4gICAgICAgICAgICAvLyBWYXJpYW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgdmFyaWFudCBkZWZpbml0aW9uIHdpdGggYSBnaXZlbiBuYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRWYXJpYW50OiBmdW5jdGlvbiAobmFtZSkgeyB2YXIgX2E7IHJldHVybiAoX2EgPSBwcm9wcy52YXJpYW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW25hbWVdOyB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgZGVmaW5lZCBkZWZhdWx0IHRyYW5zaXRpb24gb24gdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldERlZmF1bHRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wcy50cmFuc2l0aW9uOyB9LCBnZXRUcmFuc2Zvcm1QYWdlUG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMudHJhbnNmb3JtUGFnZVBvaW50O1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZWQgYnkgY2hpbGQgdmFyaWFudCBub2RlcyB0byBnZXQgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgdmFyaWFudCBwcm9wcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0VmFyaWFudENvbnRleHQ6IGZ1bmN0aW9uIChzdGFydEF0UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0QXRQYXJlbnQgPT09IHZvaWQgMCkgeyBzdGFydEF0UGFyZW50ID0gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRBdFBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5nZXRWYXJpYW50Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNDb250cm9sbGluZ1ZhcmlhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0XzEgPSAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmdldFZhcmlhbnRDb250ZXh0KCkpIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMuaW5pdGlhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0XzEuaW5pdGlhbCA9IHByb3BzLmluaXRpYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVZhcmlhbnRQcm9wczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSB2YXJpYW50UHJvcHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wID0gcHJvcHNbbmFtZV8xXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFudExhYmVsKHByb3ApIHx8IHByb3AgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0W25hbWVfMV0gPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbn07XG52YXIgdmFyaWFudFByb3BzID0gdHNsaWIuX19zcHJlYWRBcnJheShbXCJpbml0aWFsXCJdLCB0c2xpYi5fX3JlYWQodmFyaWFudFByaW9yaXR5T3JkZXIpLCBmYWxzZSk7XG52YXIgbnVtVmFyaWFudFByb3BzID0gdmFyaWFudFByb3BzLmxlbmd0aDtcblxuZnVuY3Rpb24gaXNDU1NWYXJpYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChcInZhcigtLVwiKTtcbn1cbi8qKlxuICogUGFyc2UgRnJhbWVyJ3Mgc3BlY2lhbCBDU1MgdmFyaWFibGUgZm9ybWF0IGludG8gYSBDU1MgdG9rZW4gYW5kIGEgZmFsbGJhY2suXG4gKlxuICogYGBgXG4gKiBgdmFyKC0tZm9vLCAjZmZmKWAgPT4gW2AtLWZvb2AsICcjZmZmJ11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjdXJyZW50XG4gKi9cbnZhciBjc3NWYXJpYWJsZVJlZ2V4ID0gL3ZhclxcKCgtLVthLXpBLVowLTktX10rKSw/ID8oW2EtekEtWjAtOSAoKSUjLiwtXSspP1xcKS87XG5mdW5jdGlvbiBwYXJzZUNTU1ZhcmlhYmxlKGN1cnJlbnQpIHtcbiAgICB2YXIgbWF0Y2ggPSBjc3NWYXJpYWJsZVJlZ2V4LmV4ZWMoY3VycmVudCk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIFssXTtcbiAgICB2YXIgX2EgPSB0c2xpYi5fX3JlYWQobWF0Y2gsIDMpLCB0b2tlbiA9IF9hWzFdLCBmYWxsYmFjayA9IF9hWzJdO1xuICAgIHJldHVybiBbdG9rZW4sIGZhbGxiYWNrXTtcbn1cbnZhciBtYXhEZXB0aCA9IDQ7XG5mdW5jdGlvbiBnZXRWYXJpYWJsZVZhbHVlKGN1cnJlbnQsIGVsZW1lbnQsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHsgZGVwdGggPSAxOyB9XG4gICAgaGV5TGlzdGVuLmludmFyaWFudChkZXB0aCA8PSBtYXhEZXB0aCwgXCJNYXggQ1NTIHZhcmlhYmxlIGZhbGxiYWNrIGRlcHRoIGRldGVjdGVkIGluIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoY3VycmVudCwgXCJcXFwiLiBUaGlzIG1heSBpbmRpY2F0ZSBhIGNpcmN1bGFyIGZhbGxiYWNrIGRlcGVuZGVuY3kuXCIpKTtcbiAgICB2YXIgX2EgPSB0c2xpYi5fX3JlYWQocGFyc2VDU1NWYXJpYWJsZShjdXJyZW50KSwgMiksIHRva2VuID0gX2FbMF0sIGZhbGxiYWNrID0gX2FbMV07XG4gICAgLy8gTm8gQ1NTIHZhcmlhYmxlIGRldGVjdGVkXG4gICAgaWYgKCF0b2tlbilcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIEF0dGVtcHQgdG8gcmVhZCB0aGlzIENTUyB2YXJpYWJsZSBvZmYgdGhlIGVsZW1lbnRcbiAgICB2YXIgcmVzb2x2ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHRva2VuKTtcbiAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDU1NWYXJpYWJsZShmYWxsYmFjaykpIHtcbiAgICAgICAgLy8gVGhlIGZhbGxiYWNrIG1pZ2h0IGl0c2VsZiBiZSBhIENTUyB2YXJpYWJsZSwgaW4gd2hpY2ggY2FzZSB3ZSBhdHRlbXB0IHRvIHJlc29sdmUgaXQgdG9vLlxuICAgICAgICByZXR1cm4gZ2V0VmFyaWFibGVWYWx1ZShmYWxsYmFjaywgZWxlbWVudCwgZGVwdGggKyAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICB9XG59XG4vKipcbiAqIFJlc29sdmUgQ1NTIHZhcmlhYmxlcyBmcm9tXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDU1NWYXJpYWJsZXModmlzdWFsRWxlbWVudCwgX2EsIHRyYW5zaXRpb25FbmQpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHRhcmdldCA9IHRzbGliLl9fcmVzdChfYSwgW10pO1xuICAgIHZhciBlbGVtZW50ID0gdmlzdWFsRWxlbWVudC5nZXRJbnN0YW5jZSgpO1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSlcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0OiB0YXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcbiAgICAvLyBJZiBgdHJhbnNpdGlvbkVuZGAgaXNuJ3QgYHVuZGVmaW5lZGAsIGNsb25lIGl0LiBXZSBjb3VsZCBjbG9uZSBgdGFyZ2V0YCBhbmQgYHRyYW5zaXRpb25FbmRgXG4gICAgLy8gb25seSBpZiB0aGV5IGNoYW5nZSBidXQgSSB0aGluayB0aGlzIHJlYWRzIGNsZWFyZXIgYW5kIHRoaXMgaXNuJ3QgYSBwZXJmb3JtYW5jZS1jcml0aWNhbCBwYXRoLlxuICAgIGlmICh0cmFuc2l0aW9uRW5kKSB7XG4gICAgICAgIHRyYW5zaXRpb25FbmQgPSB0c2xpYi5fX2Fzc2lnbih7fSwgdHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuICAgIC8vIEdvIHRocm91Z2ggZXhpc3RpbmcgYE1vdGlvblZhbHVlYHMgYW5kIGVuc3VyZSBhbnkgZXhpc3RpbmcgQ1NTIHZhcmlhYmxlcyBhcmUgcmVzb2x2ZWRcbiAgICB2aXN1YWxFbGVtZW50LmZvckVhY2hWYWx1ZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB2YWx1ZS5nZXQoKTtcbiAgICAgICAgaWYgKCFpc0NTU1ZhcmlhYmxlKGN1cnJlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBnZXRWYXJpYWJsZVZhbHVlKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgICBpZiAocmVzb2x2ZWQpXG4gICAgICAgICAgICB2YWx1ZS5zZXQocmVzb2x2ZWQpO1xuICAgIH0pO1xuICAgIC8vIEN5Y2xlIHRocm91Z2ggZXZlcnkgdGFyZ2V0IHByb3BlcnR5IGFuZCByZXNvbHZlIENTUyB2YXJpYWJsZXMuIEN1cnJlbnRseVxuICAgIC8vIHdlIG9ubHkgcmVhZCBzaW5nbGUtdmFyIHByb3BlcnRpZXMgbGlrZSBgdmFyKC0tZm9vKWAsIG5vdCBgY2FsYyh2YXIoLS1mb28pICsgMjBweClgXG4gICAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAoIWlzQ1NTVmFyaWFibGUoY3VycmVudCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBDbG9uZSB0YXJnZXQgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlblxuICAgICAgICB0YXJnZXRba2V5XSA9IHJlc29sdmVkO1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXNuJ3QgYWxyZWFkeSBzZXQgdGhpcyBrZXkgb24gYHRyYW5zaXRpb25FbmRgLCBzZXQgaXQgdG8gdGhlIHVucmVzb2x2ZWRcbiAgICAgICAgLy8gQ1NTIHZhcmlhYmxlLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiB0aGUgY29tcG9uZW50IHdpbGwgcmVmbGVjdFxuICAgICAgICAvLyBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgQ1NTIHZhcmlhYmxlLlxuICAgICAgICBpZiAodHJhbnNpdGlvbkVuZClcbiAgICAgICAgICAgIChfYiA9IHRyYW5zaXRpb25FbmRba2V5XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKHRyYW5zaXRpb25FbmRba2V5XSA9IGN1cnJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4geyB0YXJnZXQ6IHRhcmdldCwgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCB9O1xufVxuXG52YXIgcG9zaXRpb25hbEtleXMgPSBuZXcgU2V0KFtcbiAgICBcIndpZHRoXCIsXG4gICAgXCJoZWlnaHRcIixcbiAgICBcInRvcFwiLFxuICAgIFwibGVmdFwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcImJvdHRvbVwiLFxuICAgIFwieFwiLFxuICAgIFwieVwiLFxuXSk7XG52YXIgaXNQb3NpdGlvbmFsS2V5ID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcG9zaXRpb25hbEtleXMuaGFzKGtleSk7IH07XG52YXIgaGFzUG9zaXRpb25hbEtleSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5zb21lKGlzUG9zaXRpb25hbEtleSk7XG59O1xudmFyIHNldEFuZFJlc2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAodmFsdWUsIHRvKSB7XG4gICAgLy8gTG9va3Mgb2RkIGJ1dCBzZXR0aW5nIGl0IHR3aWNlIGRvZXNuJ3QgcmVuZGVyLCBpdCdsbCBqdXN0XG4gICAgLy8gc2V0IGJvdGggcHJldiBhbmQgY3VycmVudCB0byB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgdmFsdWUuc2V0KHRvLCBmYWxzZSk7XG4gICAgdmFsdWUuc2V0KHRvKTtcbn07XG52YXIgaXNOdW1PclB4VHlwZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYgPT09IHN0eWxlVmFsdWVUeXBlcy5udW1iZXIgfHwgdiA9PT0gc3R5bGVWYWx1ZVR5cGVzLnB4O1xufTtcbnZhciBCb3VuZGluZ0JveERpbWVuc2lvbjtcbihmdW5jdGlvbiAoQm91bmRpbmdCb3hEaW1lbnNpb24pIHtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcIndpZHRoXCJdID0gXCJ3aWR0aFwiO1xuICAgIEJvdW5kaW5nQm94RGltZW5zaW9uW1wiaGVpZ2h0XCJdID0gXCJoZWlnaHRcIjtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcImxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcInJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICAgIEJvdW5kaW5nQm94RGltZW5zaW9uW1widG9wXCJdID0gXCJ0b3BcIjtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcImJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG59KShCb3VuZGluZ0JveERpbWVuc2lvbiB8fCAoQm91bmRpbmdCb3hEaW1lbnNpb24gPSB7fSkpO1xudmFyIGdldFBvc0Zyb21NYXRyaXggPSBmdW5jdGlvbiAobWF0cml4LCBwb3MpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRyaXguc3BsaXQoXCIsIFwiKVtwb3NdKTtcbn07XG52YXIgZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCA9IGZ1bmN0aW9uIChwb3MyLCBwb3MzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYmJveCwgX2EpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IF9hLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gXCJub25lXCIgfHwgIXRyYW5zZm9ybSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB2YXIgbWF0cml4M2QgPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXgzZFxcKCguKylcXCkkLyk7XG4gICAgICAgIGlmIChtYXRyaXgzZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4M2RbMV0sIHBvczMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRyYW5zZm9ybS5tYXRjaCgvXm1hdHJpeFxcKCguKylcXCkkLyk7XG4gICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4WzFdLCBwb3MyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG52YXIgdHJhbnNmb3JtS2V5cyA9IG5ldyBTZXQoW1wieFwiLCBcInlcIiwgXCJ6XCJdKTtcbnZhciBub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cyA9IHRyYW5zZm9ybVByb3BzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhdHJhbnNmb3JtS2V5cy5oYXMoa2V5KTsgfSk7XG5mdW5jdGlvbiByZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtKHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgcmVtb3ZlZFRyYW5zZm9ybXMgPSBbXTtcbiAgICBub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybXMucHVzaChba2V5LCB2YWx1ZS5nZXQoKV0pO1xuICAgICAgICAgICAgdmFsdWUuc2V0KGtleS5zdGFydHNXaXRoKFwic2NhbGVcIikgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBcHBseSBjaGFuZ2VzIHRvIGVsZW1lbnQgYmVmb3JlIG1lYXN1cmVtZW50XG4gICAgaWYgKHJlbW92ZWRUcmFuc2Zvcm1zLmxlbmd0aClcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgcmV0dXJuIHJlbW92ZWRUcmFuc2Zvcm1zO1xufVxudmFyIHBvc2l0aW9uYWxWYWx1ZXMgPSB7XG4gICAgLy8gRGltZW5zaW9uc1xuICAgIHdpZHRoOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciB4ID0gX2EueDtcbiAgICAgICAgdmFyIF9jID0gX2IucGFkZGluZ0xlZnQsIHBhZGRpbmdMZWZ0ID0gX2MgPT09IHZvaWQgMCA/IFwiMFwiIDogX2MsIF9kID0gX2IucGFkZGluZ1JpZ2h0LCBwYWRkaW5nUmlnaHQgPSBfZCA9PT0gdm9pZCAwID8gXCIwXCIgOiBfZDtcbiAgICAgICAgcmV0dXJuIHgubWF4IC0geC5taW4gLSBwYXJzZUZsb2F0KHBhZGRpbmdMZWZ0KSAtIHBhcnNlRmxvYXQocGFkZGluZ1JpZ2h0KTtcbiAgICB9LFxuICAgIGhlaWdodDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgeSA9IF9hLnk7XG4gICAgICAgIHZhciBfYyA9IF9iLnBhZGRpbmdUb3AsIHBhZGRpbmdUb3AgPSBfYyA9PT0gdm9pZCAwID8gXCIwXCIgOiBfYywgX2QgPSBfYi5wYWRkaW5nQm90dG9tLCBwYWRkaW5nQm90dG9tID0gX2QgPT09IHZvaWQgMCA/IFwiMFwiIDogX2Q7XG4gICAgICAgIHJldHVybiB5Lm1heCAtIHkubWluIC0gcGFyc2VGbG9hdChwYWRkaW5nVG9wKSAtIHBhcnNlRmxvYXQocGFkZGluZ0JvdHRvbSk7XG4gICAgfSxcbiAgICB0b3A6IGZ1bmN0aW9uIChfYmJveCwgX2EpIHtcbiAgICAgICAgdmFyIHRvcCA9IF9hLnRvcDtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodG9wKTtcbiAgICB9LFxuICAgIGxlZnQ6IGZ1bmN0aW9uIChfYmJveCwgX2EpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBfYS5sZWZ0O1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChsZWZ0KTtcbiAgICB9LFxuICAgIGJvdHRvbTogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgeSA9IF9hLnk7XG4gICAgICAgIHZhciB0b3AgPSBfYi50b3A7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRvcCkgKyAoeS5tYXggLSB5Lm1pbik7XG4gICAgfSxcbiAgICByaWdodDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgeCA9IF9hLng7XG4gICAgICAgIHZhciBsZWZ0ID0gX2IubGVmdDtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobGVmdCkgKyAoeC5tYXggLSB4Lm1pbik7XG4gICAgfSxcbiAgICAvLyBUcmFuc2Zvcm1cbiAgICB4OiBnZXRUcmFuc2xhdGVGcm9tTWF0cml4KDQsIDEzKSxcbiAgICB5OiBnZXRUcmFuc2xhdGVGcm9tTWF0cml4KDUsIDE0KSxcbn07XG52YXIgY29udmVydENoYW5nZWRWYWx1ZVR5cGVzID0gZnVuY3Rpb24gKHRhcmdldCwgdmlzdWFsRWxlbWVudCwgY2hhbmdlZEtleXMpIHtcbiAgICB2YXIgb3JpZ2luQmJveCA9IHZpc3VhbEVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCk7XG4gICAgdmFyIGVsZW1lbnQgPSB2aXN1YWxFbGVtZW50LmdldEluc3RhbmNlKCk7XG4gICAgdmFyIGVsZW1lbnRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICB2YXIgZGlzcGxheSA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLmRpc3BsYXk7XG4gICAgdmFyIG9yaWdpbiA9IHt9O1xuICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIGN1cnJlbnRseSBzZXQgdG8gZGlzcGxheTogXCJub25lXCIsIG1ha2UgaXQgdmlzaWJsZSBiZWZvcmVcbiAgICAvLyBtZWFzdXJpbmcgdGhlIHRhcmdldCBib3VuZGluZyBib3hcbiAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShcImRpc3BsYXlcIiwgdGFyZ2V0LmRpc3BsYXkgfHwgXCJibG9ja1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkIG9yaWdpbnMgYmVmb3JlIHdlIHJlbmRlciBhbmQgdXBkYXRlIHN0eWxlc1xuICAgICAqL1xuICAgIGNoYW5nZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvcmlnaW5ba2V5XSA9IHBvc2l0aW9uYWxWYWx1ZXNba2V5XShvcmlnaW5CYm94LCBlbGVtZW50Q29tcHV0ZWRTdHlsZSk7XG4gICAgfSk7XG4gICAgLy8gQXBwbHkgdGhlIGxhdGVzdCB2YWx1ZXMgKGFzIHNldCBpbiBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcylcbiAgICB2aXN1YWxFbGVtZW50LnN5bmNSZW5kZXIoKTtcbiAgICB2YXIgdGFyZ2V0QmJveCA9IHZpc3VhbEVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCk7XG4gICAgY2hhbmdlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIFJlc3RvcmUgc3R5bGVzIHRvIHRoZWlyICoqY2FsY3VsYXRlZCBjb21wdXRlZCBzdHlsZSoqLCBub3QgdGhlaXIgYWN0dWFsXG4gICAgICAgIC8vIG9yaWdpbmFsbHkgc2V0IHN0eWxlLiBUaGlzIGFsbG93cyB1cyB0byBhbmltYXRlIGJldHdlZW4gZXF1aXZhbGVudCBwaXhlbCB1bml0cy5cbiAgICAgICAgdmFyIHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICBzZXRBbmRSZXNldFZlbG9jaXR5KHZhbHVlLCBvcmlnaW5ba2V5XSk7XG4gICAgICAgIHRhcmdldFtrZXldID0gcG9zaXRpb25hbFZhbHVlc1trZXldKHRhcmdldEJib3gsIGVsZW1lbnRDb21wdXRlZFN0eWxlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyA9IGZ1bmN0aW9uICh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCkge1xuICAgIGlmIChvcmlnaW4gPT09IHZvaWQgMCkgeyBvcmlnaW4gPSB7fTsgfVxuICAgIGlmICh0cmFuc2l0aW9uRW5kID09PSB2b2lkIDApIHsgdHJhbnNpdGlvbkVuZCA9IHt9OyB9XG4gICAgdGFyZ2V0ID0gdHNsaWIuX19hc3NpZ24oe30sIHRhcmdldCk7XG4gICAgdHJhbnNpdGlvbkVuZCA9IHRzbGliLl9fYXNzaWduKHt9LCB0cmFuc2l0aW9uRW5kKTtcbiAgICB2YXIgdGFyZ2V0UG9zaXRpb25hbEtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpLmZpbHRlcihpc1Bvc2l0aW9uYWxLZXkpO1xuICAgIC8vIFdlIHdhbnQgdG8gcmVtb3ZlIGFueSB0cmFuc2Zvcm0gdmFsdWVzIHRoYXQgY291bGQgYWZmZWN0IHRoZSBlbGVtZW50J3MgYm91bmRpbmcgYm94IGJlZm9yZVxuICAgIC8vIGl0J3MgbWVhc3VyZWQuIFdlJ2xsIHJlYXBwbHkgdGhlc2UgbGF0ZXIuXG4gICAgdmFyIHJlbW92ZWRUcmFuc2Zvcm1WYWx1ZXMgPSBbXTtcbiAgICB2YXIgaGFzQXR0ZW1wdGVkVG9SZW1vdmVUcmFuc2Zvcm1WYWx1ZXMgPSBmYWxzZTtcbiAgICB2YXIgY2hhbmdlZFZhbHVlVHlwZUtleXMgPSBbXTtcbiAgICB0YXJnZXRQb3NpdGlvbmFsS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQuaGFzVmFsdWUoa2V5KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGZyb20gPSBvcmlnaW5ba2V5XTtcbiAgICAgICAgdmFyIGZyb21UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZShmcm9tKTtcbiAgICAgICAgdmFyIHRvID0gdGFyZ2V0W2tleV07XG4gICAgICAgIHZhciB0b1R5cGU7XG4gICAgICAgIC8vIFRPRE86IFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgYmFzaWNhbGx5IHRocm93cyBhbiBlcnJvclxuICAgICAgICAvLyBpZiB5b3UgdHJ5IGFuZCBkbyB2YWx1ZSBjb252ZXJzaW9uIHZpYSBrZXlmcmFtZXMuIFRoZXJlJ3MgcHJvYmFibHlcbiAgICAgICAgLy8gYSB3YXkgb2YgZG9pbmcgdGhpcyBidXQgdGhlIHBlcmZvcm1hbmNlIGltcGxpY2F0aW9ucyB3b3VsZCBuZWVkIGdyZWF0ZXIgc2NydXRpbnksXG4gICAgICAgIC8vIGFzIGl0J2QgYmUgZG9pbmcgbXVsdGlwbGUgcmVzaXplLXJlbWVhc3VyZSBvcGVyYXRpb25zLlxuICAgICAgICBpZiAoaXNLZXlmcmFtZXNUYXJnZXQodG8pKSB7XG4gICAgICAgICAgICB2YXIgbnVtS2V5ZnJhbWVzID0gdG8ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGZyb21JbmRleCA9IHRvWzBdID09PSBudWxsID8gMSA6IDA7XG4gICAgICAgICAgICBmcm9tID0gdG9bZnJvbUluZGV4XTtcbiAgICAgICAgICAgIGZyb21UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZShmcm9tKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXg7IGkgPCBudW1LZXlmcmFtZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdG9UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG9baV0pO1xuICAgICAgICAgICAgICAgICAgICBoZXlMaXN0ZW4uaW52YXJpYW50KHRvVHlwZSA9PT0gZnJvbVR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc051bU9yUHhUeXBlKGZyb21UeXBlKSAmJiBpc051bU9yUHhUeXBlKHRvVHlwZSkpLCBcIktleWZyYW1lcyBtdXN0IGJlIG9mIHRoZSBzYW1lIGRpbWVuc2lvbiBhcyB0aGUgY3VycmVudCB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhleUxpc3Rlbi5pbnZhcmlhbnQoZmluZERpbWVuc2lvblZhbHVlVHlwZSh0b1tpXSkgPT09IHRvVHlwZSwgXCJBbGwga2V5ZnJhbWVzIG11c3QgYmUgb2YgdGhlIHNhbWUgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b1R5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVR5cGUgIT09IHRvVHlwZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhleSdyZSBib3RoIGp1c3QgbnVtYmVyIG9yIHB4LCBjb252ZXJ0IHRoZW0gYm90aCB0byBudW1iZXJzIHJhdGhlciB0aGFuXG4gICAgICAgICAgICAvLyByZWx5aW5nIG9uIHJlc2l6ZS9yZW1lYXN1cmUgdG8gY29udmVydCAod2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhpcyBzaXR1YXRpb24pXG4gICAgICAgICAgICBpZiAoaXNOdW1PclB4VHlwZShmcm9tVHlwZSkgJiYgaXNOdW1PclB4VHlwZSh0b1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB2YWx1ZS5nZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KHBhcnNlRmxvYXQoY3VycmVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gcGFyc2VGbG9hdCh0byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodG8pICYmIHRvVHlwZSA9PT0gc3R5bGVWYWx1ZVR5cGVzLnB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdG8ubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChmcm9tVHlwZSA9PT0gbnVsbCB8fCBmcm9tVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnJvbVR5cGUudHJhbnNmb3JtKSAmJlxuICAgICAgICAgICAgICAgICh0b1R5cGUgPT09IG51bGwgfHwgdG9UeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b1R5cGUudHJhbnNmb3JtKSAmJlxuICAgICAgICAgICAgICAgIChmcm9tID09PSAwIHx8IHRvID09PSAwKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIG9uZSBvciB0aGUgb3RoZXIgdmFsdWUgaXMgMCwgaXQncyBzYWZlIHRvIGNvZXJjZSBpdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyB0eXBlIG9mIHRoZSBvdGhlciB3aXRob3V0IG1lYXN1cmVtZW50XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KHRvVHlwZS50cmFuc2Zvcm0oZnJvbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBmcm9tVHlwZS50cmFuc2Zvcm0odG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGdvaW5nIHRvIGRvIHZhbHVlIGNvbnZlcnNpb24gdmlhIERPTSBtZWFzdXJlbWVudHMsIHdlIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZW1vdmUgbm9uLXBvc2l0aW9uYWwgdHJhbnNmb3JtIHZhbHVlcyB0aGF0IGNvdWxkIGFmZmVjdCB0aGUgYmJveCBtZWFzdXJlbWVudHMuXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBdHRlbXB0ZWRUb1JlbW92ZVRyYW5zZm9ybVZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkVHJhbnNmb3JtVmFsdWVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0odmlzdWFsRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlZFZhbHVlVHlwZUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25FbmRba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25FbmRba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25FbmRba2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICBzZXRBbmRSZXNldFZlbG9jaXR5KHZhbHVlLCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlZFZhbHVlVHlwZUtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBzY3JvbGxZXzEgPSBjaGFuZ2VkVmFsdWVUeXBlS2V5cy5pbmRleE9mKFwiaGVpZ2h0XCIpID49IDBcbiAgICAgICAgICAgID8gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHZhciBjb252ZXJ0ZWRUYXJnZXQgPSBjb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXModGFyZ2V0LCB2aXN1YWxFbGVtZW50LCBjaGFuZ2VkVmFsdWVUeXBlS2V5cyk7XG4gICAgICAgIC8vIElmIHdlIHJlbW92ZWQgdHJhbnNmb3JtIHZhbHVlcywgcmVhcHBseSB0aGVtIGJlZm9yZSB0aGUgbmV4dCByZW5kZXJcbiAgICAgICAgaWYgKHJlbW92ZWRUcmFuc2Zvcm1WYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZW1vdmVkVHJhbnNmb3JtVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gdHNsaWIuX19yZWFkKF9hLCAyKSwga2V5ID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWFwcGx5IG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICB2aXN1YWxFbGVtZW50LnN5bmNSZW5kZXIoKTtcbiAgICAgICAgLy8gUmVzdG9yZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgaWYgKHNjcm9sbFlfMSAhPT0gbnVsbClcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh7IHRvcDogc2Nyb2xsWV8xIH0pO1xuICAgICAgICByZXR1cm4geyB0YXJnZXQ6IGNvbnZlcnRlZFRhcmdldCwgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0OiB0YXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBDb252ZXJ0IHZhbHVlIHR5cGVzIGZvciB4L3kvd2lkdGgvaGVpZ2h0L3RvcC9sZWZ0L2JvdHRvbS9yaWdodFxuICpcbiAqIEFsbG93cyBhbmltYXRpb24gYmV0d2VlbiBgJ2F1dG8nYCAtPiBgJzEwMCUnYCBvciBgMGAgLT4gYCdjYWxjKDUwJSAtIDEwdncpJ2BcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdW5pdENvbnZlcnNpb24odmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpIHtcbiAgICByZXR1cm4gaGFzUG9zaXRpb25hbEtleSh0YXJnZXQpXG4gICAgICAgID8gY2hlY2tBbmRDb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXModmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpXG4gICAgICAgIDogeyB0YXJnZXQ6IHRhcmdldCwgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCB9O1xufVxuXG4vKipcbiAqIFBhcnNlIGEgRE9NIHZhcmlhbnQgdG8gbWFrZSBpdCBhbmltYXRhYmxlLiBUaGlzIGludm9sdmVzIHJlc29sdmluZyBDU1MgdmFyaWFibGVzXG4gKiBhbmQgZW5zdXJpbmcgYW5pbWF0aW9ucyBsaWtlIFwiMjAlXCIgPT4gXCJjYWxjKDUwdncpXCIgYXJlIHBlcmZvcm1lZCBpbiBwaXhlbHMuXG4gKi9cbnZhciBwYXJzZURvbVZhcmlhbnQgPSBmdW5jdGlvbiAodmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpIHtcbiAgICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlQ1NTVmFyaWFibGVzKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgdHJhbnNpdGlvbkVuZCk7XG4gICAgdGFyZ2V0ID0gcmVzb2x2ZWQudGFyZ2V0O1xuICAgIHRyYW5zaXRpb25FbmQgPSByZXNvbHZlZC50cmFuc2l0aW9uRW5kO1xuICAgIHJldHVybiB1bml0Q29udmVyc2lvbih2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbnZhciBodG1sQ29uZmlnID0ge1xuICAgIHRyZWVUeXBlOiBcImRvbVwiLFxuICAgIHJlYWRWYWx1ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGtleSkge1xuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1Qcm9wKGtleSkpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VHlwZSA/IGRlZmF1bHRUeXBlLmRlZmF1bHQgfHwgMCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUkMShkb21FbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKGlzQ1NTVmFyaWFibGUkMShrZXkpXG4gICAgICAgICAgICAgICAgPyBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoa2V5KVxuICAgICAgICAgICAgICAgIDogY29tcHV0ZWRTdHlsZVtrZXldKSB8fCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc29ydE5vZGVQb3NpdGlvbjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIHJldHVybnMgYSBiaXRtYXNrLCBieSB1c2luZyB0aGUgYml0d2lzZSAmXG4gICAgICAgICAqIHdlJ3JlIHJldHVybmluZyB0cnVlIGlmIDIgaW4gdGhhdCBiaXRtYXNrIGlzIHNldCB0byB0cnVlLiAyIGlzIHNldFxuICAgICAgICAgKiB0byB0cnVlIGlmIGIgcHJlY2VlZHMgYS5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgMiA/IDEgOiAtMTtcbiAgICB9LFxuICAgIGdldEJhc2VUYXJnZXQ6IGZ1bmN0aW9uIChwcm9wcywga2V5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHByb3BzLnN0eWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fba2V5XTtcbiAgICB9LFxuICAgIG1lYXN1cmVWaWV3cG9ydEJveDogZnVuY3Rpb24gKGVsZW1lbnQsIF9hKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1QYWdlUG9pbnQgPSBfYS50cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gICAgICAgIHJldHVybiBtZWFzdXJlVmlld3BvcnRCb3goZWxlbWVudCwgdHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB0cmFuc2Zvcm0gb24gdGhlIGN1cnJlbnQgRWxlbWVudC4gVGhpcyBpcyBjYWxsZWQgYXMgcGFydFxuICAgICAqIG9mIGEgYmF0Y2hlZCBwcm9jZXNzIGFjcm9zcyB0aGUgZW50aXJlIGxheW91dCB0cmVlLiBUbyByZW1vdmUgdGhpcyB3cml0ZVxuICAgICAqIGN5Y2xlIGl0J2QgYmUgaW50ZXJlc3RpbmcgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gXCJ1bmRvXCIgYWxsIHRoZSBjdXJyZW50XG4gICAgICogbGF5b3V0IHRyYW5zZm9ybXMgdXAgdGhlIHRyZWUgaW4gdGhlIHNhbWUgd2F5IHRoaXMuZ2V0Qm91bmRpbmdCb3hXaXRob3V0VHJhbnNmb3Jtc1xuICAgICAqIHdvcmtzXG4gICAgICovXG4gICAgcmVzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChlbGVtZW50LCBkb21FbGVtZW50LCBwcm9wcykge1xuICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGUgPSBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICAgICAgZG9tRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIilcbiAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdoYXRldmVyIGhhcHBlbnMgbmV4dCwgd2UgcmVzdG9yZSBvdXIgdHJhbnNmb3JtIG9uIHRoZSBuZXh0IGZyYW1lXG4gICAgICAgIGVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICB9LFxuICAgIHJlc3RvcmVUcmFuc2Zvcm06IGZ1bmN0aW9uIChpbnN0YW5jZSwgbXV0YWJsZVN0YXRlKSB7XG4gICAgICAgIGluc3RhbmNlLnN0eWxlLnRyYW5zZm9ybSA9IG11dGFibGVTdGF0ZS5zdHlsZS50cmFuc2Zvcm07XG4gICAgfSxcbiAgICByZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZTogZnVuY3Rpb24gKGtleSwgX2EpIHtcbiAgICAgICAgdmFyIHZhcnMgPSBfYS52YXJzLCBzdHlsZSA9IF9hLnN0eWxlO1xuICAgICAgICBkZWxldGUgdmFyc1trZXldO1xuICAgICAgICBkZWxldGUgc3R5bGVba2V5XTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IEhUTUwgYW5kIEZyYW1lci1zcGVjaWZpYyB2YWx1ZSB0eXBlcyBsaWtlIGBweGAtPmAlYCBhbmQgYENvbG9yYFxuICAgICAqIGNhbiBiZSBhbmltYXRlZCBieSBNb3Rpb24uXG4gICAgICovXG4gICAgbWFrZVRhcmdldEFuaW1hdGFibGU6IGZ1bmN0aW9uIChlbGVtZW50LCBfYSwgX2IsIGlzTW91bnRlZCkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtVmFsdWVzID0gX2IudHJhbnNmb3JtVmFsdWVzO1xuICAgICAgICBpZiAoaXNNb3VudGVkID09PSB2b2lkIDApIHsgaXNNb3VudGVkID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IF9hLnRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQgPSBfYS50cmFuc2l0aW9uRW5kLCB0YXJnZXQgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcInRyYW5zaXRpb25cIiwgXCJ0cmFuc2l0aW9uRW5kXCJdKTtcbiAgICAgICAgdmFyIG9yaWdpbiA9IGdldE9yaWdpbih0YXJnZXQsIHRyYW5zaXRpb24gfHwge30sIGVsZW1lbnQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgRnJhbWVyIGhhcyBwcm92aWRlZCBhIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYENvbG9yYCBldGMgdmFsdWUgdHlwZXMsIGNvbnZlcnQgdGhlbVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRyYW5zZm9ybVZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb25FbmQpXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbkVuZCA9IHRyYW5zZm9ybVZhbHVlcyh0cmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtVmFsdWVzKHRhcmdldCk7XG4gICAgICAgICAgICBpZiAob3JpZ2luKVxuICAgICAgICAgICAgICAgIG9yaWdpbiA9IHRyYW5zZm9ybVZhbHVlcyhvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICAgIGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzKGVsZW1lbnQsIHRhcmdldCwgb3JpZ2luKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZURvbVZhcmlhbnQoZWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbkVuZCA9IHBhcnNlZC50cmFuc2l0aW9uRW5kO1xuICAgICAgICAgICAgdGFyZ2V0ID0gcGFyc2VkLnRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24oeyB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kIH0sIHRhcmdldCk7XG4gICAgfSxcbiAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyQxLFxuICAgIGJ1aWxkOiBmdW5jdGlvbiAoZWxlbWVudCwgcmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNWaXNpYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlLnZpc2liaWxpdHkgPSBlbGVtZW50LmlzVmlzaWJsZVxuICAgICAgICAgICAgICAgID8gXCJ2aXNpYmxlXCJcbiAgICAgICAgICAgICAgICA6IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRIVE1MU3R5bGVzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9LFxuICAgIHJlbmRlcjogcmVuZGVySFRNTCxcbn07XG52YXIgaHRtbFZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50KGh0bWxDb25maWcpO1xuXG52YXIgc3ZnVmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGh0bWxDb25maWcpLCB7IGdldEJhc2VUYXJnZXQ6IGZ1bmN0aW9uIChwcm9wcywga2V5KSB7XG4gICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgIH0sIHJlYWRWYWx1ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVByb3Aoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0KSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9ICFjYW1lbENhc2VBdHRyaWJ1dGVzLmhhcyhrZXkpID8gY2FtZWxUb0Rhc2goa2V5KSA6IGtleTtcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgfSwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMsIGJ1aWxkOiBmdW5jdGlvbiAoX2VsZW1lbnQsIHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzKSB7XG4gICAgICAgIGJ1aWxkU1ZHQXR0cnMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIH0sIHJlbmRlcjogcmVuZGVyU1ZHIH0pKTtcblxudmFyIGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQgPSBmdW5jdGlvbiAoQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudClcbiAgICAgICAgPyBzdmdWaXN1YWxFbGVtZW50KG9wdGlvbnMsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IGZhbHNlIH0pXG4gICAgICAgIDogaHRtbFZpc3VhbEVsZW1lbnQob3B0aW9ucywgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogdHJ1ZSB9KTtcbn07XG5cbmZ1bmN0aW9uIHBpeGVsc1RvUGVyY2VudChwaXhlbHMsIGF4aXMpIHtcbiAgICBpZiAoYXhpcy5tYXggPT09IGF4aXMubWluKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKHBpeGVscyAvIChheGlzLm1heCAtIGF4aXMubWluKSkgKiAxMDA7XG59XG4vKipcbiAqIFdlIGFsd2F5cyBjb3JyZWN0IGJvcmRlclJhZGl1cyBhcyBhIHBlcmNlbnRhZ2UgcmF0aGVyIHRoYW4gcGl4ZWxzIHRvIHJlZHVjZSBwYWludHMuXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IGFyZSBwcm9qZWN0aW5nIGEgYm94IHRoYXQgaXMgMTAwcHggd2lkZSB3aXRoIGEgMTBweCBib3JkZXJSYWRpdXNcbiAqIGludG8gYSBib3ggdGhhdCBpcyAyMDBweCB3aWRlIHdpdGggYSAyMHB4IGJvcmRlclJhZGl1cywgdGhhdCBpcyBhY3R1YWxseSBhIDEwJVxuICogYm9yZGVyUmFkaXVzIGluIGJvdGggc3RhdGVzLiBJZiB3ZSBhbmltYXRlIGJldHdlZW4gdGhlIHR3byBpbiBwaXhlbHMgdGhhdCB3aWxsIHRyaWdnZXJcbiAqIGEgcGFpbnQgZWFjaCB0aW1lLiBJZiB3ZSBhbmltYXRlIGJldHdlZW4gdGhlIHR3byBpbiBwZXJjZW50YWdlIHdlJ2xsIGF2b2lkIGEgcGFpbnQuXG4gKi9cbnZhciBjb3JyZWN0Qm9yZGVyUmFkaXVzID0ge1xuICAgIGNvcnJlY3Q6IGZ1bmN0aW9uIChsYXRlc3QsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLnRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBsYXRlc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBsYXRlc3QgaXMgYSBzdHJpbmcsIGlmIGl0J3MgYSBwZXJjZW50YWdlIHdlIGNhbiByZXR1cm4gaW1tZWRpYXRlbHkgYXMgaXQnc1xuICAgICAgICAgKiBnb2luZyB0byBiZSBzdHJldGNoZWQgYXBwcm9wcmlhdGVseS4gT3RoZXJ3aXNlLCBpZiBpdCdzIGEgcGl4ZWwsIGNvbnZlcnQgaXQgdG8gYSBudW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHlwZW9mIGxhdGVzdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHN0eWxlVmFsdWVUeXBlcy5weC50ZXN0KGxhdGVzdCkpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3QgPSBwYXJzZUZsb2F0KGxhdGVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF0ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBsYXRlc3QgaXMgYSBudW1iZXIsIGl0J3MgYSBwaXhlbCB2YWx1ZS4gV2UgdXNlIHRoZSBjdXJyZW50IHZpZXdwb3J0Qm94IHRvIGNhbGN1bGF0ZSB0aGF0XG4gICAgICAgICAqIHBpeGVsIHZhbHVlIGFzIGEgcGVyY2VudGFnZSBvZiBlYWNoIGF4aXNcbiAgICAgICAgICovXG4gICAgICAgIHZhciB4ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgbm9kZS50YXJnZXQueCk7XG4gICAgICAgIHZhciB5ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgbm9kZS50YXJnZXQueSk7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh4LCBcIiUgXCIpLmNvbmNhdCh5LCBcIiVcIik7XG4gICAgfSxcbn07XG5cbnZhciB2YXJUb2tlbiA9IFwiXyRjc3NcIjtcbnZhciBjb3JyZWN0Qm94U2hhZG93ID0ge1xuICAgIGNvcnJlY3Q6IGZ1bmN0aW9uIChsYXRlc3QsIF9hKSB7XG4gICAgICAgIHZhciB0cmVlU2NhbGUgPSBfYS50cmVlU2NhbGUsIHByb2plY3Rpb25EZWx0YSA9IF9hLnByb2plY3Rpb25EZWx0YTtcbiAgICAgICAgdmFyIG9yaWdpbmFsID0gbGF0ZXN0O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2UgbmVlZCB0byBmaXJzdCBzdHJpcCBhbmQgc3RvcmUgQ1NTIHZhcmlhYmxlcyBmcm9tIHRoZSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY29udGFpbnNDU1NWYXJpYWJsZXMgPSBsYXRlc3QuaW5jbHVkZXMoXCJ2YXIoXCIpO1xuICAgICAgICB2YXIgY3NzVmFyaWFibGVzID0gW107XG4gICAgICAgIGlmIChjb250YWluc0NTU1ZhcmlhYmxlcykge1xuICAgICAgICAgICAgbGF0ZXN0ID0gbGF0ZXN0LnJlcGxhY2UoY3NzVmFyaWFibGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY3NzVmFyaWFibGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXJUb2tlbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFkb3cgPSBzdHlsZVZhbHVlVHlwZXMuY29tcGxleC5wYXJzZShsYXRlc3QpO1xuICAgICAgICAvLyBUT0RPOiBEb2Vzbid0IHN1cHBvcnQgbXVsdGlwbGUgc2hhZG93c1xuICAgICAgICBpZiAoc2hhZG93Lmxlbmd0aCA+IDUpXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHN0eWxlVmFsdWVUeXBlcy5jb21wbGV4LmNyZWF0ZVRyYW5zZm9ybWVyKGxhdGVzdCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0eXBlb2Ygc2hhZG93WzBdICE9PSBcIm51bWJlclwiID8gMSA6IDA7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3ZlcmFsbCBjb250ZXh0IHNjYWxlXG4gICAgICAgIHZhciB4U2NhbGUgPSBwcm9qZWN0aW9uRGVsdGEueC5zY2FsZSAqIHRyZWVTY2FsZS54O1xuICAgICAgICB2YXIgeVNjYWxlID0gcHJvamVjdGlvbkRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgICAgICAgc2hhZG93WzAgKyBvZmZzZXRdIC89IHhTY2FsZTtcbiAgICAgICAgc2hhZG93WzEgKyBvZmZzZXRdIC89IHlTY2FsZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZWFsbHkgd2UnZCBjb3JyZWN0IHggYW5kIHkgc2NhbGVzIGluZGl2aWR1YWxseSwgYnV0IGJlY2F1c2UgYmx1ciBhbmRcbiAgICAgICAgICogc3ByZWFkIGFwcGx5IHRvIGJvdGggd2UgaGF2ZSB0byB0YWtlIGEgc2NhbGUgYXZlcmFnZSBhbmQgYXBwbHkgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAgKiBXZSBjb3VsZCBwb3RlbnRpYWxseSBpbXByb3ZlIHRoZSBvdXRjb21lIG9mIHRoaXMgYnkgaW5jb3Jwb3JhdGluZyB0aGUgcmF0aW8gYmV0d2VlblxuICAgICAgICAgKiB0aGUgdHdvIHNjYWxlcy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBhdmVyYWdlU2NhbGUgPSBwb3Btb3Rpb24ubWl4KHhTY2FsZSwgeVNjYWxlLCAwLjUpO1xuICAgICAgICAvLyBCbHVyXG4gICAgICAgIGlmICh0eXBlb2Ygc2hhZG93WzIgKyBvZmZzZXRdID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgc2hhZG93WzIgKyBvZmZzZXRdIC89IGF2ZXJhZ2VTY2FsZTtcbiAgICAgICAgLy8gU3ByZWFkXG4gICAgICAgIGlmICh0eXBlb2Ygc2hhZG93WzMgKyBvZmZzZXRdID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgc2hhZG93WzMgKyBvZmZzZXRdIC89IGF2ZXJhZ2VTY2FsZTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRlbXBsYXRlKHNoYWRvdyk7XG4gICAgICAgIGlmIChjb250YWluc0NTU1ZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFyIGlfMSA9IDA7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSh2YXJUb2tlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjc3NWYXJpYWJsZSA9IGNzc1ZhcmlhYmxlc1tpXzFdO1xuICAgICAgICAgICAgICAgIGlfMSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBjc3NWYXJpYWJsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcbn07XG5cbnZhciBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBvbmx5IG1vdW50cyBwcm9qZWN0aW9uIG5vZGVzIGZvciBjb21wb25lbnRzIHRoYXRcbiAgICAgKiBuZWVkIG1lYXN1cmluZywgd2UgbWlnaHQgd2FudCB0byBkbyBpdCBmb3IgYWxsIGNvbXBvbmVudHNcbiAgICAgKiBpbiBvcmRlciB0byBpbmNvcnBvcmF0ZSB0cmFuc2Zvcm1zXG4gICAgICovXG4gICAgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQsIGxheW91dEdyb3VwID0gX2EubGF5b3V0R3JvdXAsIHN3aXRjaExheW91dEdyb3VwID0gX2Euc3dpdGNoTGF5b3V0R3JvdXAsIGxheW91dElkID0gX2EubGF5b3V0SWQ7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uO1xuICAgICAgICBhZGRTY2FsZUNvcnJlY3RvcihkZWZhdWx0U2NhbGVDb3JyZWN0b3JzKTtcbiAgICAgICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChsYXlvdXRHcm91cCA9PT0gbnVsbCB8fCBsYXlvdXRHcm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0R3JvdXAuZ3JvdXApXG4gICAgICAgICAgICAgICAgbGF5b3V0R3JvdXAuZ3JvdXAuYWRkKHByb2plY3Rpb24pO1xuICAgICAgICAgICAgaWYgKChzd2l0Y2hMYXlvdXRHcm91cCA9PT0gbnVsbCB8fCBzd2l0Y2hMYXlvdXRHcm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3dpdGNoTGF5b3V0R3JvdXAucmVnaXN0ZXIpICYmIGxheW91dElkKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoTGF5b3V0R3JvdXAucmVnaXN0ZXIocHJvamVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25Db21wbGV0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb2plY3Rpb24uc2V0T3B0aW9ucyh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgcHJvamVjdGlvbi5vcHRpb25zKSwgeyBvbkV4aXRDb21wbGV0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2FmZVRvUmVtb3ZlKCk7IH0gfSkpO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNFdmVyVXBkYXRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQucHJvdG90eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBsYXlvdXREZXBlbmRlbmN5ID0gX2EubGF5b3V0RGVwZW5kZW5jeSwgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQsIGRyYWcgPSBfYS5kcmFnLCBpc1ByZXNlbnQgPSBfYS5pc1ByZXNlbnQ7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uO1xuICAgICAgICBpZiAoIXByb2plY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IFdlIHVzZSB0aGlzIGRhdGEgaW4gcmVsZWdhdGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG9cbiAgICAgICAgICogcHJvbW90ZSBhIHByZXZpb3VzIGVsZW1lbnQuIFRoZXJlJ3Mgbm8gZ3VhcmFudGVlIGl0cyBwcmVzZW5jZSBkYXRhXG4gICAgICAgICAqIHdpbGwgaGF2ZSB1cGRhdGVkIGJ5IHRoaXMgcG9pbnQgLSBpZiBhIGJ1ZyBsaWtlIHRoaXMgYXJpc2VzIGl0IHdpbGxcbiAgICAgICAgICogaGF2ZSB0byBiZSB0aGF0IHdlIG1hcmtGb3JSZWxlZ2F0aW9uIGFuZCB0aGVuIGZpbmQgYSBuZXcgbGVhZCBzb21lIG90aGVyIHdheSxcbiAgICAgICAgICogcGVyaGFwcyBpbiBkaWRVcGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3Rpb24uaXNQcmVzZW50ID0gaXNQcmVzZW50O1xuICAgICAgICBpZiAoZHJhZyB8fFxuICAgICAgICAgICAgcHJldlByb3BzLmxheW91dERlcGVuZGVuY3kgIT09IGxheW91dERlcGVuZGVuY3kgfHxcbiAgICAgICAgICAgIGxheW91dERlcGVuZGVuY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvamVjdGlvbi53aWxsVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UHJvcHMuaXNQcmVzZW50ICE9PSBpc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9uLnByb21vdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcm9qZWN0aW9uLnJlbGVnYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGVyZSdzIGFub3RoZXIgc3RhY2sgbWVtYmVyIHRha2luZyBvdmVyIGZyb20gdGhpcyBvbmUsXG4gICAgICAgICAgICAgICAgICogaXQncyBpbiBjaGFyZ2Ugb2YgdGhlIGV4aXQgYW5pbWF0aW9uIGFuZCB0aGVyZWZvcmUgc2hvdWxkXG4gICAgICAgICAgICAgICAgICogYmUgaW4gY2hhcmdlIG9mIHRoZSBzYWZlIHRvIHJlbW92ZS4gT3RoZXJ3aXNlIHdlIGNhbGwgaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5wb3N0UmVuZGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBwcm9qZWN0aW9uLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZW1iZXJzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnByb3BzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24ucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgICAgICAgIGlmICghcHJvamVjdGlvbi5jdXJyZW50QW5pbWF0aW9uICYmIHByb2plY3Rpb24uaXNMZWFkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgbGF5b3V0R3JvdXAgPSBfYS5sYXlvdXRHcm91cCwgcHJvbW90ZUNvbnRleHQgPSBfYS5zd2l0Y2hMYXlvdXRHcm91cDtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB2aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQoKTtcbiAgICAgICAgICAgIGlmIChsYXlvdXRHcm91cCA9PT0gbnVsbCB8fCBsYXlvdXRHcm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0R3JvdXAuZ3JvdXApXG4gICAgICAgICAgICAgICAgbGF5b3V0R3JvdXAuZ3JvdXAucmVtb3ZlKHByb2plY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHByb21vdGVDb250ZXh0ID09PSBudWxsIHx8IHByb21vdGVDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9tb3RlQ29udGV4dC5kZXJlZ2lzdGVyKVxuICAgICAgICAgICAgICAgIHByb21vdGVDb250ZXh0LmRlcmVnaXN0ZXIocHJvamVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dC5wcm90b3R5cGUuc2FmZVRvUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2FmZVRvUmVtb3ZlID0gdGhpcy5wcm9wcy5zYWZlVG9SZW1vdmU7XG4gICAgICAgIHNhZmVUb1JlbW92ZSA9PT0gbnVsbCB8fCBzYWZlVG9SZW1vdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNhZmVUb1JlbW92ZSgpO1xuICAgIH07XG4gICAgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dDtcbn0oUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCkpO1xuZnVuY3Rpb24gTWVhc3VyZUxheW91dChwcm9wcykge1xuICAgIHZhciBfYSA9IHRzbGliLl9fcmVhZCh1c2VQcmVzZW5jZSgpLCAyKSwgaXNQcmVzZW50ID0gX2FbMF0sIHNhZmVUb1JlbW92ZSA9IF9hWzFdO1xuICAgIHZhciBsYXlvdXRHcm91cCA9IFJlYWN0LnVzZUNvbnRleHQoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCwgdHNsaWIuX19hc3NpZ24oe30sIHByb3BzLCB7IGxheW91dEdyb3VwOiBsYXlvdXRHcm91cCwgc3dpdGNoTGF5b3V0R3JvdXA6IFJlYWN0LnVzZUNvbnRleHQoU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0KSwgaXNQcmVzZW50OiBpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZTogc2FmZVRvUmVtb3ZlIH0pKSk7XG59XG52YXIgZGVmYXVsdFNjYWxlQ29ycmVjdG9ycyA9IHtcbiAgICBib3JkZXJSYWRpdXM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjb3JyZWN0Qm9yZGVyUmFkaXVzKSwgeyBhcHBseVRvOiBbXG4gICAgICAgICAgICBcImJvcmRlclRvcExlZnRSYWRpdXNcIixcbiAgICAgICAgICAgIFwiYm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcbiAgICAgICAgICAgIFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiLFxuICAgICAgICAgICAgXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiLFxuICAgICAgICBdIH0pLFxuICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgICBib3hTaGFkb3c6IGNvcnJlY3RCb3hTaGFkb3csXG59O1xuXG52YXIgbGF5b3V0RmVhdHVyZXMgPSB7XG4gICAgbWVhc3VyZUxheW91dDogTWVhc3VyZUxheW91dCxcbn07XG5cbi8qKlxuICogQW5pbWF0ZSBhIHNpbmdsZSB2YWx1ZSBvciBhIGBNb3Rpb25WYWx1ZWAuXG4gKlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGVpdGhlciBhIGBNb3Rpb25WYWx1ZWAgdG8gYW5pbWF0ZSwgb3IgYW4gaW5pdGlhbCBhbmltYXRpb24gdmFsdWUuXG4gKlxuICogVGhlIHNlY29uZCBpcyBlaXRoZXIgYSB2YWx1ZSB0byBhbmltYXRlIHRvLCBvciBhbiBhcnJheSBvZiBrZXlmcmFtZXMgdG8gYW5pbWF0ZSB0aHJvdWdoLlxuICpcbiAqIFRoZSB0aGlyZCBhcmd1bWVudCBjYW4gYmUgZWl0aGVyIHR3ZWVuIG9yIHNwcmluZyBvcHRpb25zLCBhbmQgb3B0aW9uYWwgbGlmZWN5Y2xlIG1ldGhvZHM6IGBvblVwZGF0ZWAsIGBvblBsYXlgLCBgb25Db21wbGV0ZWAsIGBvblJlcGVhdGAgYW5kIGBvblN0b3BgLlxuICpcbiAqIFJldHVybnMgYEFuaW1hdGlvblBsYXliYWNrQ29udHJvbHNgLCBjdXJyZW50bHkganVzdCBhIGBzdG9wYCBtZXRob2QuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gKlxuICogdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgY29uc3QgY29udHJvbHMgPSBhbmltYXRlKHgsIDEwMCwge1xuICogICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gKiAgICAgc3RpZmZuZXNzOiAyMDAwLFxuICogICAgIG9uQ29tcGxldGU6IHYgPT4ge31cbiAqICAgfSlcbiAqXG4gKiAgIHJldHVybiBjb250cm9scy5zdG9wXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBhbmltYXRlKGZyb20sIHRvLCB0cmFuc2l0aW9uKSB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT09IHZvaWQgMCkgeyB0cmFuc2l0aW9uID0ge307IH1cbiAgICB2YXIgdmFsdWUgPSBpc01vdGlvblZhbHVlKGZyb20pID8gZnJvbSA6IG1vdGlvblZhbHVlKGZyb20pO1xuICAgIHN0YXJ0QW5pbWF0aW9uKFwiXCIsIHZhbHVlLCB0bywgdHJhbnNpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuc3RvcCgpOyB9LFxuICAgICAgICBpc0FuaW1hdGluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuaXNBbmltYXRpbmcoKTsgfSxcbiAgICB9O1xufVxuXG52YXIgYm9yZGVycyA9IFtcIlRvcExlZnRcIiwgXCJUb3BSaWdodFwiLCBcIkJvdHRvbUxlZnRcIiwgXCJCb3R0b21SaWdodFwiXTtcbnZhciBudW1Cb3JkZXJzID0gYm9yZGVycy5sZW5ndGg7XG52YXIgYXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbn07XG52YXIgaXNQeCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgc3R5bGVWYWx1ZVR5cGVzLnB4LnRlc3QodmFsdWUpO1xufTtcbmZ1bmN0aW9uIG1peFZhbHVlcyh0YXJnZXQsIGZvbGxvdywgbGVhZCwgcHJvZ3Jlc3MsIHNob3VsZENyb3NzZmFkZU9wYWNpdHksIGlzT25seU1lbWJlcikge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBpZiAoc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSkge1xuICAgICAgICB0YXJnZXQub3BhY2l0eSA9IHBvcG1vdGlvbi5taXgoMCwgXG4gICAgICAgIC8vIChmb2xsb3c/Lm9wYWNpdHkgYXMgbnVtYmVyKSA/PyAwLFxuICAgICAgICAvLyBUT0RPIFJlaW5zdGF0ZSB0aGlzIGlmIG9ubHkgY2hpbGRcbiAgICAgICAgKF9hID0gbGVhZC5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLCBlYXNlQ3Jvc3NmYWRlSW4ocHJvZ3Jlc3MpKTtcbiAgICAgICAgdGFyZ2V0Lm9wYWNpdHlFeGl0ID0gcG9wbW90aW9uLm1peCgoX2IgPSBmb2xsb3cub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMSwgMCwgZWFzZUNyb3NzZmFkZU91dChwcm9ncmVzcykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09ubHlNZW1iZXIpIHtcbiAgICAgICAgdGFyZ2V0Lm9wYWNpdHkgPSBwb3Btb3Rpb24ubWl4KChfYyA9IGZvbGxvdy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAxLCAoX2QgPSBsZWFkLm9wYWNpdHkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDEsIHByb2dyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWl4IGJvcmRlciByYWRpdXNcbiAgICAgKi9cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUJvcmRlcnM7IGkrKykge1xuICAgICAgICB2YXIgYm9yZGVyTGFiZWwgPSBcImJvcmRlclwiLmNvbmNhdChib3JkZXJzW2ldLCBcIlJhZGl1c1wiKTtcbiAgICAgICAgdmFyIGZvbGxvd1JhZGl1cyA9IGdldFJhZGl1cyhmb2xsb3csIGJvcmRlckxhYmVsKTtcbiAgICAgICAgdmFyIGxlYWRSYWRpdXMgPSBnZXRSYWRpdXMobGVhZCwgYm9yZGVyTGFiZWwpO1xuICAgICAgICBpZiAoZm9sbG93UmFkaXVzID09PSB1bmRlZmluZWQgJiYgbGVhZFJhZGl1cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvbGxvd1JhZGl1cyB8fCAoZm9sbG93UmFkaXVzID0gMCk7XG4gICAgICAgIGxlYWRSYWRpdXMgfHwgKGxlYWRSYWRpdXMgPSAwKTtcbiAgICAgICAgdmFyIGNhbk1peCA9IGZvbGxvd1JhZGl1cyA9PT0gMCB8fFxuICAgICAgICAgICAgbGVhZFJhZGl1cyA9PT0gMCB8fFxuICAgICAgICAgICAgaXNQeChmb2xsb3dSYWRpdXMpID09PSBpc1B4KGxlYWRSYWRpdXMpO1xuICAgICAgICBpZiAoY2FuTWl4KSB7XG4gICAgICAgICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdID0gTWF0aC5tYXgocG9wbW90aW9uLm1peChhc051bWJlcihmb2xsb3dSYWRpdXMpLCBhc051bWJlcihsZWFkUmFkaXVzKSwgcHJvZ3Jlc3MpLCAwKTtcbiAgICAgICAgICAgIGlmIChzdHlsZVZhbHVlVHlwZXMucGVyY2VudC50ZXN0KGxlYWRSYWRpdXMpIHx8IHN0eWxlVmFsdWVUeXBlcy5wZXJjZW50LnRlc3QoZm9sbG93UmFkaXVzKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtib3JkZXJMYWJlbF0gKz0gXCIlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdID0gbGVhZFJhZGl1cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNaXggcm90YXRpb25cbiAgICAgKi9cbiAgICBpZiAoZm9sbG93LnJvdGF0ZSB8fCBsZWFkLnJvdGF0ZSkge1xuICAgICAgICB0YXJnZXQucm90YXRlID0gcG9wbW90aW9uLm1peChmb2xsb3cucm90YXRlIHx8IDAsIGxlYWQucm90YXRlIHx8IDAsIHByb2dyZXNzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSYWRpdXModmFsdWVzLCByYWRpdXNOYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB2YWx1ZXNbcmFkaXVzTmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlcy5ib3JkZXJSYWRpdXM7XG59XG4vLyAvKipcbi8vICAqIFdlIG9ubHkgd2FudCB0byBtaXggdGhlIGJhY2tncm91bmQgY29sb3IgaWYgdGhlcmUncyBhIGZvbGxvdyBlbGVtZW50XG4vLyAgKiB0aGF0IHdlJ3JlIG5vdCBjcm9zc2ZhZGluZyBvcGFjaXR5IGJldHdlZW4uIEZvciBpbnN0YW5jZSB3aXRoIHN3aXRjaFxuLy8gICogQW5pbWF0ZVNoYXJlZExheW91dCBhbmltYXRpb25zLCB0aGlzIGhlbHBzIHRoZSBpbGx1c2lvbiBvZiBhIGNvbnRpbnVvdXNcbi8vICAqIGVsZW1lbnQgYmVpbmcgYW5pbWF0ZWQgYnV0IGFsc28gY3V0cyBkb3duIG9uIHRoZSBudW1iZXIgb2YgcGFpbnRzIHRyaWdnZXJlZFxuLy8gICogZm9yIGVsZW1lbnRzIHdoZXJlIG9wYWNpdHkgaXMgZG9pbmcgdGhhdCB3b3JrIGZvciB1cy5cbi8vICAqL1xuLy8gaWYgKFxuLy8gICAgICFoYXNGb2xsb3dFbGVtZW50ICYmXG4vLyAgICAgbGF0ZXN0TGVhZFZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IgJiZcbi8vICAgICBsYXRlc3RGb2xsb3dWYWx1ZXMuYmFja2dyb3VuZENvbG9yXG4vLyApIHtcbi8vICAgICAvKipcbi8vICAgICAgKiBUaGlzIGlzbid0IGlkZWFsIHBlcmZvcm1hbmNlLXdpc2UgYXMgbWl4Q29sb3IgaXMgY3JlYXRpbmcgYSBuZXcgZnVuY3Rpb24gZXZlcnkgZnJhbWUuXG4vLyAgICAgICogV2UgY291bGQgcHJvYmFibHkgY3JlYXRlIGEgbWl4ZXIgdGhhdCBydW5zIGF0IHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uIGJ1dFxuLy8gICAgICAqIHRoZSBpZGVhIGJlaGluZCB0aGUgY3Jvc3NmYWRlciBpcyB0aGF0IGl0IHJ1bnMgZHluYW1pY2FsbHkgYmV0d2VlbiB0d28gcG90ZW50aWFsbHlcbi8vICAgICAgKiBjaGFuZ2luZyB0YXJnZXRzIChpZSBvcGFjaXR5IG9yIGJvcmRlclJhZGl1cyBtYXkgYmUgYW5pbWF0aW5nIGluZGVwZW5kZW50bHkgdmlhIHZhcmlhbnRzKVxuLy8gICAgICAqL1xuLy8gICAgIGxlYWRTdGF0ZS5iYWNrZ3JvdW5kQ29sb3IgPSBmb2xsb3dTdGF0ZS5iYWNrZ3JvdW5kQ29sb3IgPSBtaXhDb2xvcihcbi8vICAgICAgICAgbGF0ZXN0Rm9sbG93VmFsdWVzLmJhY2tncm91bmRDb2xvciBhcyBzdHJpbmcsXG4vLyAgICAgICAgIGxhdGVzdExlYWRWYWx1ZXMuYmFja2dyb3VuZENvbG9yIGFzIHN0cmluZ1xuLy8gICAgICkocClcbi8vIH1cbnZhciBlYXNlQ3Jvc3NmYWRlSW4gPSBjb21wcmVzcygwLCAwLjUsIHBvcG1vdGlvbi5jaXJjT3V0KTtcbnZhciBlYXNlQ3Jvc3NmYWRlT3V0ID0gY29tcHJlc3MoMC41LCAwLjk1LCBwb3Btb3Rpb24ubGluZWFyKTtcbmZ1bmN0aW9uIGNvbXByZXNzKG1pbiwgbWF4LCBlYXNpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgLy8gQ291bGQgcmVwbGFjZSBpZnMgd2l0aCBjbGFtcFxuICAgICAgICBpZiAocCA8IG1pbilcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpZiAocCA+IG1heClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gZWFzaW5nKHBvcG1vdGlvbi5wcm9ncmVzcyhtaW4sIG1heCwgcCkpO1xuICAgIH07XG59XG5cbi8qKlxuICogUmVzZXQgYW4gYXhpcyB0byB0aGUgcHJvdmlkZWQgb3JpZ2luIGJveC5cbiAqXG4gKiBUaGlzIGlzIGEgbXV0YXRpdmUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBjb3B5QXhpc0ludG8oYXhpcywgb3JpZ2luQXhpcykge1xuICAgIGF4aXMubWluID0gb3JpZ2luQXhpcy5taW47XG4gICAgYXhpcy5tYXggPSBvcmlnaW5BeGlzLm1heDtcbn1cbi8qKlxuICogUmVzZXQgYSBib3ggdG8gdGhlIHByb3ZpZGVkIG9yaWdpbiBib3guXG4gKlxuICogVGhpcyBpcyBhIG11dGF0aXZlIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29weUJveEludG8oYm94LCBvcmlnaW5Cb3gpIHtcbiAgICBjb3B5QXhpc0ludG8oYm94LngsIG9yaWdpbkJveC54KTtcbiAgICBjb3B5QXhpc0ludG8oYm94LnksIG9yaWdpbkJveC55KTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBkZWx0YSBmcm9tIGEgcG9pbnQuIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIHN0ZXBzIG9mIGFwcGx5UG9pbnREZWx0YSBpbiByZXZlcnNlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVBvaW50RGVsdGEocG9pbnQsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICAgIHBvaW50IC09IHRyYW5zbGF0ZTtcbiAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIDEgLyBzY2FsZSwgb3JpZ2luUG9pbnQpO1xuICAgIGlmIChib3hTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50ID0gc2NhbGVQb2ludChwb2ludCwgMSAvIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbn1cbi8qKlxuICogUmVtb3ZlIGEgZGVsdGEgZnJvbSBhbiBheGlzLiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseUF4aXNEZWx0YSBpbiByZXZlcnNlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUF4aXNEZWx0YShheGlzLCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW4sIGJveFNjYWxlLCBvcmlnaW5BeGlzLCBzb3VyY2VBeGlzKSB7XG4gICAgaWYgKHRyYW5zbGF0ZSA9PT0gdm9pZCAwKSB7IHRyYW5zbGF0ZSA9IDA7IH1cbiAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDE7IH1cbiAgICBpZiAob3JpZ2luID09PSB2b2lkIDApIHsgb3JpZ2luID0gMC41OyB9XG4gICAgaWYgKG9yaWdpbkF4aXMgPT09IHZvaWQgMCkgeyBvcmlnaW5BeGlzID0gYXhpczsgfVxuICAgIGlmIChzb3VyY2VBeGlzID09PSB2b2lkIDApIHsgc291cmNlQXhpcyA9IGF4aXM7IH1cbiAgICBpZiAoc3R5bGVWYWx1ZVR5cGVzLnBlcmNlbnQudGVzdCh0cmFuc2xhdGUpKSB7XG4gICAgICAgIHRyYW5zbGF0ZSA9IHBhcnNlRmxvYXQodHJhbnNsYXRlKTtcbiAgICAgICAgdmFyIHJlbGF0aXZlUHJvZ3Jlc3MgPSBwb3Btb3Rpb24ubWl4KHNvdXJjZUF4aXMubWluLCBzb3VyY2VBeGlzLm1heCwgdHJhbnNsYXRlIC8gMTAwKTtcbiAgICAgICAgdHJhbnNsYXRlID0gcmVsYXRpdmVQcm9ncmVzcyAtIHNvdXJjZUF4aXMubWluO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRyYW5zbGF0ZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBvcmlnaW5Qb2ludCA9IHBvcG1vdGlvbi5taXgob3JpZ2luQXhpcy5taW4sIG9yaWdpbkF4aXMubWF4LCBvcmlnaW4pO1xuICAgIGlmIChheGlzID09PSBvcmlnaW5BeGlzKVxuICAgICAgICBvcmlnaW5Qb2ludCAtPSB0cmFuc2xhdGU7XG4gICAgYXhpcy5taW4gPSByZW1vdmVQb2ludERlbHRhKGF4aXMubWluLCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xuICAgIGF4aXMubWF4ID0gcmVtb3ZlUG9pbnREZWx0YShheGlzLm1heCwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogUmVtb3ZlIGEgdHJhbnNmb3JtcyBmcm9tIGFuIGF4aXMuIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIHN0ZXBzIG9mIGFwcGx5QXhpc1RyYW5zZm9ybXMgaW4gcmV2ZXJzZVxuICogYW5kIGFjdHMgYXMgYSBicmlkZ2UgYmV0d2VlbiBtb3Rpb24gdmFsdWVzIGFuZCByZW1vdmVBeGlzRGVsdGFcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYXhpcywgdHJhbnNmb3JtcywgX2EsIG9yaWdpbiwgc291cmNlQXhpcykge1xuICAgIHZhciBfYiA9IHRzbGliLl9fcmVhZChfYSwgMyksIGtleSA9IF9iWzBdLCBzY2FsZUtleSA9IF9iWzFdLCBvcmlnaW5LZXkgPSBfYlsyXTtcbiAgICByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNmb3Jtc1trZXldLCB0cmFuc2Zvcm1zW3NjYWxlS2V5XSwgdHJhbnNmb3Jtc1tvcmlnaW5LZXldLCB0cmFuc2Zvcm1zLnNjYWxlLCBvcmlnaW4sIHNvdXJjZUF4aXMpO1xufVxuLyoqXG4gKiBUaGUgbmFtZXMgb2YgdGhlIG1vdGlvbiB2YWx1ZXMgd2Ugd2FudCB0byBhcHBseSBhcyB0cmFuc2xhdGlvbiwgc2NhbGUgYW5kIG9yaWdpbi5cbiAqL1xudmFyIHhLZXlzID0gW1wieFwiLCBcInNjYWxlWFwiLCBcIm9yaWdpblhcIl07XG52YXIgeUtleXMgPSBbXCJ5XCIsIFwic2NhbGVZXCIsIFwib3JpZ2luWVwiXTtcbi8qKlxuICogUmVtb3ZlIGEgdHJhbnNmb3JtcyBmcm9tIGFuIGJveC4gVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc3RlcHMgb2YgYXBwbHlBeGlzQm94IGluIHJldmVyc2VcbiAqIGFuZCBhY3RzIGFzIGEgYnJpZGdlIGJldHdlZW4gbW90aW9uIHZhbHVlcyBhbmQgcmVtb3ZlQXhpc0RlbHRhXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94LCB0cmFuc2Zvcm1zLCBvcmlnaW5Cb3gsIHNvdXJjZUJveCkge1xuICAgIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGJveC54LCB0cmFuc2Zvcm1zLCB4S2V5cywgb3JpZ2luQm94ID09PSBudWxsIHx8IG9yaWdpbkJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luQm94LngsIHNvdXJjZUJveCA9PT0gbnVsbCB8fCBzb3VyY2VCb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZUJveC54KTtcbiAgICByZW1vdmVBeGlzVHJhbnNmb3Jtcyhib3gueSwgdHJhbnNmb3JtcywgeUtleXMsIG9yaWdpbkJveCA9PT0gbnVsbCB8fCBvcmlnaW5Cb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbkJveC55LCBzb3VyY2VCb3ggPT09IG51bGwgfHwgc291cmNlQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2VCb3gueSk7XG59XG5cbmZ1bmN0aW9uIGlzQXhpc0RlbHRhWmVybyhkZWx0YSkge1xuICAgIHJldHVybiBkZWx0YS50cmFuc2xhdGUgPT09IDAgJiYgZGVsdGEuc2NhbGUgPT09IDE7XG59XG5mdW5jdGlvbiBpc0RlbHRhWmVybyhkZWx0YSkge1xuICAgIHJldHVybiBpc0F4aXNEZWx0YVplcm8oZGVsdGEueCkgJiYgaXNBeGlzRGVsdGFaZXJvKGRlbHRhLnkpO1xufVxuZnVuY3Rpb24gYm94RXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gKGEueC5taW4gPT09IGIueC5taW4gJiZcbiAgICAgICAgYS54Lm1heCA9PT0gYi54Lm1heCAmJlxuICAgICAgICBhLnkubWluID09PSBiLnkubWluICYmXG4gICAgICAgIGEueS5tYXggPT09IGIueS5tYXgpO1xufVxuXG52YXIgTm9kZVN0YWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVTdGFjaygpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgfVxuICAgIE5vZGVTdGFjay5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgYWRkVW5pcXVlSXRlbSh0aGlzLm1lbWJlcnMsIG5vZGUpO1xuICAgICAgICBub2RlLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgfTtcbiAgICBOb2RlU3RhY2sucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJlbW92ZUl0ZW0odGhpcy5tZW1iZXJzLCBub2RlKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMucHJldkxlYWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkxlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMubGVhZCkge1xuICAgICAgICAgICAgdmFyIHByZXZMZWFkID0gdGhpcy5tZW1iZXJzW3RoaXMubWVtYmVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvbW90ZShwcmV2TGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGVTdGFjay5wcm90b3R5cGUucmVsZWdhdGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaW5kZXhPZk5vZGUgPSB0aGlzLm1lbWJlcnMuZmluZEluZGV4KGZ1bmN0aW9uIChtZW1iZXIpIHsgcmV0dXJuIG5vZGUgPT09IG1lbWJlcjsgfSk7XG4gICAgICAgIGlmIChpbmRleE9mTm9kZSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgdGhlIG5leHQgcHJvamVjdGlvbiBub2RlIHRoYXQgaXMgcHJlc2VudFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHByZXZMZWFkO1xuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXhPZk5vZGU7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5tZW1iZXJzW2ldO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5pc1ByZXNlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcHJldkxlYWQgPSBtZW1iZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnByb21vdGUocHJldkxlYWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGVTdGFjay5wcm90b3R5cGUucHJvbW90ZSA9IGZ1bmN0aW9uIChub2RlLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcHJldkxlYWQgPSB0aGlzLmxlYWQ7XG4gICAgICAgIGlmIChub2RlID09PSBwcmV2TGVhZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5wcmV2TGVhZCA9IHByZXZMZWFkO1xuICAgICAgICB0aGlzLmxlYWQgPSBub2RlO1xuICAgICAgICBub2RlLnNob3coKTtcbiAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICBwcmV2TGVhZC5pbnN0YW5jZSAmJiBwcmV2TGVhZC5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgbm9kZS5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgbm9kZS5yZXN1bWVGcm9tID0gcHJldkxlYWQ7XG4gICAgICAgICAgICBpZiAocHJlc2VydmVGb2xsb3dPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZXN1bWVGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkxlYWQuc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNuYXBzaG90ID0gcHJldkxlYWQuc25hcHNob3Q7XG4gICAgICAgICAgICAgICAgbm9kZS5zbmFwc2hvdC5sYXRlc3RWYWx1ZXMgPVxuICAgICAgICAgICAgICAgICAgICBwcmV2TGVhZC5hbmltYXRpb25WYWx1ZXMgfHwgcHJldkxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgICAgICAgICAgIG5vZGUuc25hcHNob3QuaXNTaGFyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfYSA9IG5vZGUucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBub2RlLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNyb3NzZmFkZSA9IG5vZGUub3B0aW9ucy5jcm9zc2ZhZGU7XG4gICAgICAgICAgICBpZiAoY3Jvc3NmYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXZMZWFkLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVE9ETzpcbiAgICAgICAgICAgICAqICAgLSBUZXN0IGJvcmRlciByYWRpdXMgd2hlbiBwcmV2aW91cyBub2RlIHdhcyBkZWxldGVkXG4gICAgICAgICAgICAgKiAgIC0gYm94U2hhZG93IG1peGluZ1xuICAgICAgICAgICAgICogICAtIFNoYXJlZCBiZXR3ZWVuIGVsZW1lbnQgQSBpbiBzY3JvbGxlZCBjb250YWluZXIgYW5kIGVsZW1lbnQgQiAoc2Nyb2xsIHN0YXlzIHRoZSBzYW1lIG9yIGNoYW5nZXMpXG4gICAgICAgICAgICAgKiAgIC0gU2hhcmVkIGJldHdlZW4gZWxlbWVudCBBIGluIHRyYW5zZm9ybWVkIGNvbnRhaW5lciBhbmQgZWxlbWVudCBCICh0cmFuc2Zvcm0gc3RheXMgdGhlIHNhbWUgb3IgY2hhbmdlcylcbiAgICAgICAgICAgICAqICAgLSBTaGFyZWQgYmV0d2VlbiBlbGVtZW50IEEgaW4gc2Nyb2xsZWQgcGFnZSBhbmQgZWxlbWVudCBCIChzY3JvbGwgc3RheXMgdGhlIHNhbWUgb3IgY2hhbmdlcylcbiAgICAgICAgICAgICAqIC0tLVxuICAgICAgICAgICAgICogICAtIENyb3NzZmFkZSBvcGFjaXR5IG9mIHJvb3Qgbm9kZXNcbiAgICAgICAgICAgICAqICAgLSBsYXlvdXRJZCBjaGFuZ2VzIGFmdGVyIGFuaW1hdGlvblxuICAgICAgICAgICAgICogICAtIGxheW91dElkIGNoYW5nZXMgbWlkIGFuaW1hdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGVTdGFjay5wcm90b3R5cGUuZXhpdEFuaW1hdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IG5vZGUub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgIChfZSA9IChfYyA9IG5vZGUucmVzdW1pbmdGcm9tKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9kID0gX2Mub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOb2RlU3RhY2sucHJvdG90eXBlLnNjaGVkdWxlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5pbnN0YW5jZSAmJiBub2RlLnNjaGVkdWxlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhciBhbnkgbGVhZHMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCB0aGlzIHJlbmRlciB0byBwcmV2ZW50IHRoZW0gZnJvbSBiZWluZ1xuICAgICAqIHVzZWQgaW4gZnV0dXJlIGFuaW1hdGlvbnMgYW5kIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICovXG4gICAgTm9kZVN0YWNrLnByb3RvdHlwZS5yZW1vdmVMZWFkU25hcHNob3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlYWQgJiYgdGhpcy5sZWFkLnNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLmxlYWQuc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOb2RlU3RhY2s7XG59KCkpO1xuXG52YXIgaWRlbnRpdHlQcm9qZWN0aW9uID0gXCJ0cmFuc2xhdGUzZCgwcHgsIDBweCwgMCkgc2NhbGUoMSwgMSkgc2NhbGUoMSwgMSlcIjtcbmZ1bmN0aW9uIGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybShkZWx0YSwgdHJlZVNjYWxlLCBsYXRlc3RUcmFuc2Zvcm0pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNsYXRpb25zIHdlIHVzZSB0byBjYWxjdWxhdGUgYXJlIGFsd2F5cyByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICAgKiBCdXQgd2hlbiB3ZSBhcHBseSBzY2FsZXMsIHdlIGFsc28gc2NhbGUgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgYW4gZWxlbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAqIEZvciBpbnN0YW5jZSBpZiB3ZSBoYXZlIGEgdHJlZVNjYWxlICh0aGUgY3VsbWluYXRpb24gb2YgYWxsIHBhcmVudCBzY2FsZXMpIG9mIDAuNSBhbmQgd2UgbmVlZFxuICAgICAqIHRvIG1vdmUgYW4gZWxlbWVudCAxMDAgcGl4ZWxzLCB3ZSBhY3R1YWxseSBuZWVkIHRvIG1vdmUgaXQgMjAwIGluIHdpdGhpbiB0aGF0IHNjYWxlZCBzcGFjZS5cbiAgICAgKi9cbiAgICB2YXIgeFRyYW5zbGF0ZSA9IGRlbHRhLngudHJhbnNsYXRlIC8gdHJlZVNjYWxlLng7XG4gICAgdmFyIHlUcmFuc2xhdGUgPSBkZWx0YS55LnRyYW5zbGF0ZSAvIHRyZWVTY2FsZS55O1xuICAgIHZhciB0cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdCh4VHJhbnNsYXRlLCBcInB4LCBcIikuY29uY2F0KHlUcmFuc2xhdGUsIFwicHgsIDApIFwiKTtcbiAgICAvKipcbiAgICAgKiBBcHBseSBzY2FsZSBjb3JyZWN0aW9uIGZvciB0aGUgdHJlZSB0cmFuc2Zvcm0uXG4gICAgICogVGhpcyB3aWxsIGFwcGx5IHNjYWxlIHRvIHRoZSBzY3JlZW4tb3JpZW50YXRlZCBheGVzLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSArPSBcInNjYWxlKFwiLmNvbmNhdCgxIC8gdHJlZVNjYWxlLngsIFwiLCBcIikuY29uY2F0KDEgLyB0cmVlU2NhbGUueSwgXCIpIFwiKTtcbiAgICBpZiAobGF0ZXN0VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciByb3RhdGUgPSBsYXRlc3RUcmFuc2Zvcm0ucm90YXRlLCByb3RhdGVYID0gbGF0ZXN0VHJhbnNmb3JtLnJvdGF0ZVgsIHJvdGF0ZVkgPSBsYXRlc3RUcmFuc2Zvcm0ucm90YXRlWTtcbiAgICAgICAgaWYgKHJvdGF0ZSlcbiAgICAgICAgICAgIHRyYW5zZm9ybSArPSBcInJvdGF0ZShcIi5jb25jYXQocm90YXRlLCBcImRlZykgXCIpO1xuICAgICAgICBpZiAocm90YXRlWClcbiAgICAgICAgICAgIHRyYW5zZm9ybSArPSBcInJvdGF0ZVgoXCIuY29uY2F0KHJvdGF0ZVgsIFwiZGVnKSBcIik7XG4gICAgICAgIGlmIChyb3RhdGVZKVxuICAgICAgICAgICAgdHJhbnNmb3JtICs9IFwicm90YXRlWShcIi5jb25jYXQocm90YXRlWSwgXCJkZWcpIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGUgdG8gbWF0Y2ggdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgdG8gdGhlIHNpemUgd2Ugd2FudCBpdC5cbiAgICAgKiBUaGlzIHdpbGwgYXBwbHkgc2NhbGUgdG8gdGhlIGVsZW1lbnQtb3JpZW50YXRlZCBheGVzLlxuICAgICAqL1xuICAgIHZhciBlbGVtZW50U2NhbGVYID0gZGVsdGEueC5zY2FsZSAqIHRyZWVTY2FsZS54O1xuICAgIHZhciBlbGVtZW50U2NhbGVZID0gZGVsdGEueS5zY2FsZSAqIHRyZWVTY2FsZS55O1xuICAgIHRyYW5zZm9ybSArPSBcInNjYWxlKFwiLmNvbmNhdChlbGVtZW50U2NhbGVYLCBcIiwgXCIpLmNvbmNhdChlbGVtZW50U2NhbGVZLCBcIilcIik7XG4gICAgcmV0dXJuIHRyYW5zZm9ybSA9PT0gaWRlbnRpdHlQcm9qZWN0aW9uID8gXCJub25lXCIgOiB0cmFuc2Zvcm07XG59XG5cbnZhciBjb21wYXJlQnlEZXB0aCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZGVwdGggLSBiLmRlcHRoO1xufTtcblxudmFyIEZsYXRUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZsYXRUcmVlKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICBGbGF0VHJlZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIH07XG4gICAgRmxhdFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZW1vdmVJdGVtKHRoaXMuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICB9O1xuICAgIEZsYXRUcmVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSAmJiB0aGlzLmNoaWxkcmVuLnNvcnQoY29tcGFyZUJ5RGVwdGgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBGbGF0VHJlZTtcbn0oKSk7XG5cbi8qKlxuICogV2UgdXNlIDEwMDAgYXMgdGhlIGFuaW1hdGlvbiB0YXJnZXQgYXMgMC0xMDAwIG1hcHMgYmV0dGVyIHRvIHBpeGVscyB0aGFuIDAtMVxuICogd2hpY2ggaGFzIGEgbm90aWNlYWJsZSBkaWZmZXJlbmNlIGluIHNwcmluZyBhbmltYXRpb25zXG4gKi9cbnZhciBhbmltYXRpb25UYXJnZXQgPSAxMDAwO1xuZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbk5vZGUoX2EpIHtcbiAgICB2YXIgYXR0YWNoUmVzaXplTGlzdGVuZXIgPSBfYS5hdHRhY2hSZXNpemVMaXN0ZW5lciwgZGVmYXVsdFBhcmVudCA9IF9hLmRlZmF1bHRQYXJlbnQsIG1lYXN1cmVTY3JvbGwgPSBfYS5tZWFzdXJlU2Nyb2xsLCBjaGVja0lzU2Nyb2xsUm9vdCA9IF9hLmNoZWNrSXNTY3JvbGxSb290LCByZXNldFRyYW5zZm9ybSA9IF9hLnJlc2V0VHJhbnNmb3JtO1xuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFByb2plY3Rpb25Ob2RlKGlkLCBsYXRlc3RWYWx1ZXMsIHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChsYXRlc3RWYWx1ZXMgPT09IHZvaWQgMCkgeyBsYXRlc3RWYWx1ZXMgPSB7fTsgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7IHBhcmVudCA9IGRlZmF1bHRQYXJlbnQgPT09IG51bGwgfHwgZGVmYXVsdFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdFBhcmVudCgpOyB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgU2V0IGNvbnRhaW5pbmcgYWxsIHRoaXMgY29tcG9uZW50J3MgY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCB0byBpdGVyYXRlXG4gICAgICAgICAgICAgKiB0aHJvdWdoIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUT0RPOiBUaGlzIGNvdWxkIGJlIGZhc3RlciB0byBpdGVyYXRlIGFzIGEgZmxhdCBhcnJheSBzdG9yZWQgb24gdGhlIHJvb3Qgbm9kZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3B0aW9ucyBmb3IgdGhlIG5vZGUuIFdlIHVzZSB0aGlzIHRvIGNvbmZpZ3VyZSB3aGF0IGtpbmQgb2YgbGF5b3V0IGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBwZXJmb3JtIChpZiBhbnkpLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2UgdXNlIHRoaXMgdG8gZGV0ZWN0IHdoZW4gaXRzIHNhZmUgdG8gc2h1dCBkb3duIHBhcnQgb2YgYSBwcm9qZWN0aW9uIHRyZWUuXG4gICAgICAgICAgICAgKiBXZSBoYXZlIHRvIGtlZXAgcHJvamVjdGluZyBjaGlsZHJlbiBmb3Igc2NhbGUgY29ycmVjdGlvbiBhbmQgcmVsYXRpdmUgcHJvamVjdGlvblxuICAgICAgICAgICAgICogdW50aWwgYWxsIHRoZWlyIHBhcmVudHMgc3RvcCBwZXJmb3JtaW5nIGxheW91dCBhbmltYXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVHJlZUFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGlvbkJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIGlmIHdlIHRoaW5rIHRoaXMgbGF5b3V0IGhhcyBiZWVuIGNoYW5nZWQuIFdlIGNhbid0IGFsd2F5cyBrbm93IHRoaXMsXG4gICAgICAgICAgICAgKiBjdXJyZW50bHkgd2Ugc2V0IGl0IHRvIHRydWUgZXZlcnkgdGltZSBhIGNvbXBvbmVudCByZW5kZXJzLCBvciBpZiBpdCBoYXMgYSBsYXlvdXREZXBlbmRlbmN5XG4gICAgICAgICAgICAgKiBpZiB0aGF0IGhhcyBjaGFuZ2VkIGJldHdlZW4gcmVuZGVycy4gQWRkaXRpb25hbGx5LCBjb21wb25lbnRzIGNhbiBiZSBncm91cGVkIGJ5IExheW91dEdyb3VwXG4gICAgICAgICAgICAgKiBhbmQgaWYgb25lIG5vZGUgaXMgZGlydGllZCwgdGhleSBhbGwgYXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmxvY2sgbGF5b3V0IHVwZGF0ZXMgZm9yIGluc3RhbnQgbGF5b3V0IHRyYW5zaXRpb25zIHRocm91Z2hvdXQgdGhlIHRyZWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBiZXR3ZWVuIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgYHdpbGxVcGRhdGVgIGNhbGwgYW5kIHRoZSBlbmQgb2YgdGhlIGBkaWRVcGRhdGVgXG4gICAgICAgICAgICAgKiBjYWxsLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhbiBTVkcgZWxlbWVudCB3ZSBjdXJyZW50bHkgZGlzYWJsZSBwcm9qZWN0aW9uIHRyYW5zZm9ybXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1NWRyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIHRydWUgKGR1cmluZyBwcm9tb3Rpb24pIGlmIGEgbm9kZSBkb2luZyBhbiBpbnN0YW50IGxheW91dCB0cmFuc2l0aW9uIG5lZWRzIHRvIHJlc2V0XG4gICAgICAgICAgICAgKiBpdHMgcHJvamVjdGlvbiBzdHlsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubmVlZHNSZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFncyB3aGV0aGVyIHRoaXMgbm9kZSBzaG91bGQgaGF2ZSBpdHMgdHJhbnNmb3JtIHJlc2V0IHByaW9yIHRvIG1lYXN1cmluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjYWxjdWxhdGVkIGNvbnRleHR1YWwvYWNjdW11bGF0ZWQvdHJlZSBzY2FsZS5cbiAgICAgICAgICAgICAqIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHNjYWxlIGNhbGN1bGNhdGVkIHByb2plY3Rpb24gdHJhbnNmb3JtcywgYXMgdGhlc2UgYXJlXG4gICAgICAgICAgICAgKiBjYWxjdWxhdGVkIGluIHNjcmVlbi1zcGFjZSBidXQgbmVlZCB0byBiZSBzY2FsZWQgZm9yIGVsZW1lbnRzIHRvIGFjdHVhbGx5XG4gICAgICAgICAgICAgKiBtYWtlIGl0IHRvIHRoZWlyIGNhbGN1bGF0ZWQgZGVzdGluYXRpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IExhenktaW5pdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnRyZWVTY2FsZSA9IHsgeDogMSwgeTogMSB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvLyBOb3RlOiBDdXJyZW50bHkgb25seSBydW5uaW5nIG9uIHJvb3Qgbm9kZVxuICAgICAgICAgICAgdGhpcy5wb3RlbnRpYWxOb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tVcGRhdGVGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubm9kZXMuZm9yRWFjaChyZXNvbHZlVGFyZ2V0RGVsdGEpO1xuICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzLmZvckVhY2goY2FsY1Byb2plY3Rpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2hhcmVkIGxheW91dFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBUT0RPIE9ubHkgcnVubmluZyBvbiByb290IG5vZGVcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdFZhbHVlcyA9IGxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IHx8IHBhcmVudCA6IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXJlbnQgPyB0c2xpYi5fX3NwcmVhZEFycmF5KHRzbGliLl9fc3ByZWFkQXJyYXkoW10sIHRzbGliLl9fcmVhZChwYXJlbnQucGF0aCksIGZhbHNlKSwgW3BhcmVudF0sIGZhbHNlKSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmRlcHRoID0gcGFyZW50ID8gcGFyZW50LmRlcHRoICsgMSA6IDA7XG4gICAgICAgICAgICBpZCAmJiB0aGlzLnJvb3QucmVnaXN0ZXJQb3RlbnRpYWxOb2RlKGlkLCB0aGlzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoW2ldLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5ldyBGbGF0VHJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ldmVudEhhbmRsZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycy5zZXQobmFtZSwgbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXJzLmdldChuYW1lKS5hZGQoaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5ub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25NYW5hZ2VyID0gdGhpcy5ldmVudEhhbmRsZXJzLmdldChuYW1lKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk1hbmFnZXIgPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uTWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Vic2NyaXB0aW9uTWFuYWdlci5ub3RpZnkuYXBwbHkoc3Vic2NyaXB0aW9uTWFuYWdlciwgdHNsaWIuX19zcHJlYWRBcnJheShbXSwgdHNsaWIuX19yZWFkKGFyZ3MpLCBmYWxzZSkpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVnaXN0ZXJQb3RlbnRpYWxOb2RlID0gZnVuY3Rpb24gKGlkLCBub2RlKSB7XG4gICAgICAgICAgICB0aGlzLnBvdGVudGlhbE5vZGVzLnNldChpZCwgbm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaWZlY3ljbGVzXG4gICAgICAgICAqL1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUubW91bnQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoaXNMYXlvdXREaXJ0eSA9PT0gdm9pZCAwKSB7IGlzTGF5b3V0RGlydHkgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pc1NWRyA9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIGluc3RhbmNlLnRhZ05hbWUgIT09IFwic3ZnXCI7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLm9wdGlvbnMsIGxheW91dElkID0gX2IubGF5b3V0SWQsIGxheW91dCA9IF9iLmxheW91dCwgdmlzdWFsRWxlbWVudCA9IF9iLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodmlzdWFsRWxlbWVudCAmJiAhdmlzdWFsRWxlbWVudC5nZXRJbnN0YW5jZSgpKSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMuYWRkKHRoaXMpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGlsZHJlbi5hZGQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmlkICYmIHRoaXMucm9vdC5wb3RlbnRpYWxOb2Rlcy5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICBpZiAoaXNMYXlvdXREaXJ0eSAmJiAobGF5b3V0IHx8IGxheW91dElkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0YWNoUmVzaXplTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdW5ibG9ja1RpbWVvdXRfMTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzaXplVW5ibG9ja1VwZGF0ZV8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF90aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXR0YWNoUmVzaXplTGlzdGVuZXIoaW5zdGFuY2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucm9vdC51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodW5ibG9ja1RpbWVvdXRfMSk7XG4gICAgICAgICAgICAgICAgICAgIHVuYmxvY2tUaW1lb3V0XzEgPSB3aW5kb3cuc2V0VGltZW91dChyZXNpemVVbmJsb2NrVXBkYXRlXzEsIDI1MCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0FuaW1hdGVkU2luY2VSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzLmZvckVhY2goZmluaXNoQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheW91dElkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnJlZ2lzdGVyU2hhcmVkTm9kZShsYXlvdXRJZCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHJlZ2lzdGVyIHRoZSBoYW5kbGVyIGlmIGl0IHJlcXVpcmVzIGxheW91dCBhbmltYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgKGxheW91dElkIHx8IGxheW91dCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IF9hLmRlbHRhLCBoYXNMYXlvdXRDaGFuZ2VkID0gX2EuaGFzTGF5b3V0Q2hhbmdlZCwgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gX2EuaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkLCBuZXdMYXlvdXQgPSBfYS5sYXlvdXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1RyZWVBbmltYXRpb25CbG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IENoZWNrIGhlcmUgaWYgYW4gYW5pbWF0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5b3V0VHJhbnNpdGlvbiA9IChfYyA9IChfYiA9IF90aGlzLm9wdGlvbnMudHJhbnNpdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9nID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLCBvbkxheW91dEFuaW1hdGlvblN0YXJ0ID0gX2cub25MYXlvdXRBbmltYXRpb25TdGFydCwgb25MYXlvdXRBbmltYXRpb25Db21wbGV0ZSA9IF9nLm9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGU7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgdGFyZ2V0IGxheW91dCBvZiB0aGUgZWxlbWVudCBtaWdodCBzdGF5IHRoZSBzYW1lLFxuICAgICAgICAgICAgICAgICAgICAgKiBidXQgaXRzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q2hhbmdlZCA9ICFfdGhpcy50YXJnZXRMYXlvdXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFib3hFcXVhbHMoX3RoaXMudGFyZ2V0TGF5b3V0LCBuZXdMYXlvdXQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbGF5b3V0IGhhc24ndCBzZWVtZWQgdG8gaGF2ZSBjaGFuZ2VkLCBpdCBtaWdodCBiZSB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBlbGVtZW50IGlzIHZpc3VhbGx5IGluIHRoZSBzYW1lIHBsYWNlIGluIHRoZSBkb2N1bWVudCBidXQgaXRzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgaGFzIGluZGVlZCBjaGFuZ2VkLiBTbyBoZXJlIHdlIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSAhaGFzTGF5b3V0Q2hhbmdlZCAmJiBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9kID0gX3RoaXMucmVzdW1lRnJvbSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmluc3RhbmNlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGhhc0xheW91dENoYW5nZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFyZ2V0Q2hhbmdlZCB8fCAhX3RoaXMuY3VycmVudEFuaW1hdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VtaW5nRnJvbSA9IF90aGlzLnJlc3VtZUZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdW1pbmdGcm9tLnJlc3VtaW5nRnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEFuaW1hdGlvbk9yaWdpbihkZWx0YSwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBnZXRWYWx1ZVRyYW5zaXRpb24obGF5b3V0VHJhbnNpdGlvbiwgXCJsYXlvdXRcIikpLCB7IG9uUGxheTogb25MYXlvdXRBbmltYXRpb25TdGFydCwgb25Db21wbGV0ZTogb25MYXlvdXRBbmltYXRpb25Db21wbGV0ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aXN1YWxFbGVtZW50LnNob3VsZFJlZHVjZU1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMuZGVsYXkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMudHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRBbmltYXRpb24oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBsYXlvdXQgaGFzbid0IGNoYW5nZWQgYW5kIHdlIGhhdmUgYW4gYW5pbWF0aW9uIHRoYXQgaGFzbid0IHN0YXJ0ZWQgeWV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICogZmluaXNoIGl0IGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgaXQgd2lsbCBiZSBhbmltYXRpbmcgZnJvbSBhIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IHdhcyBwcm9iYWJseSBuZXZlciBjb21taXRlZCB0byBzY3JlZW4gYW5kIGxvb2sgbGlrZSBhIGp1bXB5IGJveC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNMYXlvdXRDaGFuZ2VkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maW5pc2hBbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzTGVhZCgpICYmICgoX2YgPSAoX2UgPSBfdGhpcy5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXRMYXlvdXQgPSBuZXdMYXlvdXQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sYXlvdXRJZCAmJiB0aGlzLndpbGxVcGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5ub2Rlcy5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoaWxkcmVuLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzeW5jLmNhbmNlbFN5bmMucHJlUmVuZGVyKHRoaXMudXBkYXRlUHJvamVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIG9ubHkgb24gdGhlIHJvb3RcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmJsb2NrVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUudW5ibG9ja1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5pc1VwZGF0ZUJsb2NrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgfHwgdGhpcy51cGRhdGVCbG9ja2VkQnlSZXNpemU7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5pc1RyZWVBbmltYXRpb25CbG9ja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmlzQW5pbWF0aW9uQmxvY2tlZCB8fFxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSkgfHxcbiAgICAgICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vdGU6IGN1cnJlbnRseSBvbmx5IHJ1bm5pbmcgb24gcm9vdCBub2RlXG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zdGFydFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVXBkYXRlQmxvY2tlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLm5vZGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChyZXNldFJvdGF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLndpbGxVcGRhdGUgPSBmdW5jdGlvbiAoc2hvdWxkTm90aWZ5TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnlMaXN0ZW5lcnMgPT09IHZvaWQgMCkgeyBzaG91bGROb3RpZnlMaXN0ZW5lcnMgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5yb290LmlzVXBkYXRlQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICF0aGlzLnJvb3QuaXNVcGRhdGluZyAmJiB0aGlzLnJvb3Quc3RhcnRVcGRhdGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTGF5b3V0RGlydHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgbm9kZS5zaG91bGRSZXNldFRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVE9ETzogQ2hlY2sgd2UgaGF2ZW4ndCB1cGRhdGVkIHRoZSBzY3JvbGxcbiAgICAgICAgICAgICAgICAgKiBzaW5jZSB0aGUgbGFzdCBkaWRVcGRhdGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9kID0gdGhpcy5vcHRpb25zLCBsYXlvdXRJZCA9IF9kLmxheW91dElkLCBsYXlvdXQgPSBfZC5sYXlvdXQ7XG4gICAgICAgICAgICBpZiAobGF5b3V0SWQgPT09IHVuZGVmaW5lZCAmJiAhbGF5b3V0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1UZW1wbGF0ZSA9IChfYyA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0UHJvcHMoKS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICAgICAgICAgIHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB0cmFuc2Zvcm1UZW1wbGF0ZSA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1UZW1wbGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgc2hvdWxkTm90aWZ5TGlzdGVuZXJzICYmIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwid2lsbFVwZGF0ZVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgcnVubmluZyBvbiByb290IG5vZGVcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmRpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGVXYXNCbG9ja2VkID0gdGhpcy5pc1VwZGF0ZUJsb2NrZWQoKTtcbiAgICAgICAgICAgIC8vIFdoZW4gZG9pbmcgYW4gaW5zdGFudCB0cmFuc2l0aW9uLCB3ZSBza2lwIHRoZSBsYXlvdXQgdXBkYXRlLFxuICAgICAgICAgICAgLy8gYnV0IHNob3VsZCBzdGlsbCBjbGVhbiB1cCB0aGUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIHNuYXBzaG90IGNvdWxkIGJlIHRha2VuIGNvcnJlY3RseS5cbiAgICAgICAgICAgIGlmICh1cGRhdGVXYXNCbG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmJsb2NrVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjbGVhck1lYXN1cmVtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVXBkYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlYXJjaCBmb3IgYW5kIG1vdW50IG5ld2x5LWFkZGVkIHByb2plY3Rpb24gZWxlbWVudHMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogRXZlcnkgdGltZSBhIG5ldyBjb21wb25lbnQgaXMgcmVuZGVyZWQgd2UgY291bGQgc2VhcmNoIHVwIHRoZSB0cmVlIGZvclxuICAgICAgICAgICAgICogdGhlIGNsb3Nlc3QgbW91bnRlZCBub2RlIGFuZCBxdWVyeSBmcm9tIHRoZXJlIHJhdGhlciB0aGFuIGRvY3VtZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3RlbnRpYWxOb2Rlcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3RlbnRpYWxOb2Rlcy5mb3JFYWNoKG1vdW50Tm9kZUVhcmx5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvdGVudGlhbE5vZGVzLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdyaXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChyZXNldFRyYW5zZm9ybVN0eWxlKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVhZCA9PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gVXBkYXRlIGxheW91dCBtZWFzdXJlbWVudHMgb2YgdXBkYXRlZCBjaGlsZHJlblxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHVwZGF0ZUxheW91dCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdyaXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnMgdGhhdCB0aGUgbGF5b3V0IGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChub3RpZnlMYXlvdXRVcGRhdGUpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICAgICAgLy8gRmx1c2ggYW55IHNjaGVkdWxlZCB1cGRhdGVzXG4gICAgICAgICAgICBzeW5jLmZsdXNoU3luYy51cGRhdGUoKTtcbiAgICAgICAgICAgIHN5bmMuZmx1c2hTeW5jLnByZVJlbmRlcigpO1xuICAgICAgICAgICAgc3luYy5mbHVzaFN5bmMucmVuZGVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5jbGVhckFsbFNuYXBzaG90cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjbGVhclNuYXBzaG90KTtcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkTm9kZXMuZm9yRWFjaChyZW1vdmVMZWFkU25hcHNob3RzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN5bmNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnByZVJlbmRlcih0aGlzLnVwZGF0ZVByb2plY3Rpb24sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgdW5tb3VudGluZyBub2RlIGlzIGluIGEgbGF5b3V0R3JvdXAgYW5kIGRpZCB0cmlnZ2VyIGEgd2lsbFVwZGF0ZSxcbiAgICAgICAgICAgICAqIHdlIG1hbnVhbGx5IGNhbGwgZGlkVXBkYXRlIHRvIGdpdmUgYSBjaGFuY2UgdG8gdGhlIHNpYmxpbmdzIHRvIGFuaW1hdGUuXG4gICAgICAgICAgICAgKiBPdGhlcndpc2UsIGNsZWFudXAgYWxsIHNuYXBzaG90cyB0byBwcmV2ZW50cyBmdXR1cmUgbm9kZXMgZnJvbSByZXVzaW5nIHRoZW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN5bmNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnBvc3RSZW5kZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0xheW91dERpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yb290LmNoZWNrVXBkYXRlRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgbWVhc3VyZW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUudXBkYXRlU25hcHNob3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zbmFwc2hvdCB8fCAhdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbWVhc3VyZWQgPSB0aGlzLm1lYXN1cmUoKTtcbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLnJlbW92ZVRyYW5zZm9ybSh0aGlzLnJlbW92ZUVsZW1lbnRTY3JvbGwobWVhc3VyZWQpKTtcbiAgICAgICAgICAgIHJvdW5kQm94KGxheW91dCk7XG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0ge1xuICAgICAgICAgICAgICAgIG1lYXN1cmVkOiBtZWFzdXJlZCxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXM6IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBUT0RPOiBJbmNvcnBvcmF0ZSBpbnRvIGEgZm9yd2FyZGVkIHNjcm9sbCBvZmZzZXRcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWx3YXlzTWVhc3VyZUxheW91dCAmJiB0aGlzLmlzTGVhZCgpKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gYSBub2RlIGlzIG1vdW50ZWQsIGl0IHNpbXBseSByZXN1bWVzIGZyb20gdGhlIHByZXZMZWFkJ3NcbiAgICAgICAgICAgICAqIHNuYXBzaG90IGluc3RlYWQgb2YgdGFraW5nIGEgbmV3IG9uZSwgYnV0IHRoZSBhbmNlc3RvcnMgc2Nyb2xsXG4gICAgICAgICAgICAgKiBtaWdodCBoYXZlIHVwZGF0ZWQgd2hpbGUgdGhlIHByZXZMZWFkIGlzIHVubW91bnRlZC4gV2UgbmVlZCB0b1xuICAgICAgICAgICAgICogdXBkYXRlIHRoZSBzY3JvbGwgYWdhaW4gdG8gbWFrZSBzdXJlIHRoZSBsYXlvdXQgd2UgbWVhc3VyZSBpc1xuICAgICAgICAgICAgICogdXAgdG8gZGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1lRnJvbSAmJiAhdGhpcy5yZXN1bWVGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1lYXN1cmVkID0gdGhpcy5tZWFzdXJlKCk7XG4gICAgICAgICAgICByb3VuZEJveChtZWFzdXJlZCk7XG4gICAgICAgICAgICB2YXIgcHJldkxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQgPSB7XG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IG1lYXN1cmVkLFxuICAgICAgICAgICAgICAgIGFjdHVhbDogdGhpcy5yZW1vdmVFbGVtZW50U2Nyb2xsKG1lYXN1cmVkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmxheW91dENvcnJlY3RlZCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwibWVhc3VyZVwiLCB0aGlzLmxheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub3RpZnlMYXlvdXRNZWFzdXJlKHRoaXMubGF5b3V0LmFjdHVhbCwgcHJldkxheW91dCA9PT0gbnVsbCB8fCBwcmV2TGF5b3V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2TGF5b3V0LmFjdHVhbCk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS51cGRhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dFNjcm9sbCAmJiB0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Njcm9sbFJvb3QgPSBjaGVja0lzU2Nyb2xsUm9vdCh0aGlzLmluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbCA9IG1lYXN1cmVTY3JvbGwodGhpcy5pbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5yZXNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghcmVzZXRUcmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzUmVzZXRSZXF1ZXN0ZWQgPSB0aGlzLmlzTGF5b3V0RGlydHkgfHwgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybTtcbiAgICAgICAgICAgIHZhciBoYXNQcm9qZWN0aW9uID0gdGhpcy5wcm9qZWN0aW9uRGVsdGEgJiYgIWlzRGVsdGFaZXJvKHRoaXMucHJvamVjdGlvbkRlbHRhKTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1UZW1wbGF0ZSA9IChfYSA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UHJvcHMoKS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlID0gdHJhbnNmb3JtVGVtcGxhdGUgPT09IG51bGwgfHwgdHJhbnNmb3JtVGVtcGxhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQgPSB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlICE9PSB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzUmVzZXRSZXF1ZXN0ZWQgJiZcbiAgICAgICAgICAgICAgICAoaGFzUHJvamVjdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICBoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVRlbXBsYXRlSGFzQ2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICByZXNldFRyYW5zZm9ybSh0aGlzLmluc3RhbmNlLCB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUubWVhc3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2aXN1YWxFbGVtZW50ID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgdmFyIGJveCA9IHZpc3VhbEVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdmlld3BvcnQgc2Nyb2xsIHRvIGdpdmUgcGFnZS1yZWxhdGl2ZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgdmFyIHNjcm9sbCA9IHRoaXMucm9vdC5zY3JvbGw7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3gueCwgc2Nyb2xsLngpO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LnksIHNjcm9sbC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib3g7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50U2Nyb2xsID0gZnVuY3Rpb24gKGJveCkge1xuICAgICAgICAgICAgdmFyIGJveFdpdGhvdXRTY3JvbGwgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRTY3JvbGwsIGJveCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBlcmZvcm1hbmNlIFRPRE86IEtlZXAgYSBjdW11bGF0aXZlIHNjcm9sbCBvZmZzZXQgZG93biB0aGUgdHJlZVxuICAgICAgICAgICAgICogcmF0aGVyIHRoYW4gbG9vcCBiYWNrIHVwIHRoZSBwYXRoLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxfMSA9IG5vZGUuc2Nyb2xsLCBvcHRpb25zID0gbm9kZS5vcHRpb25zLCBpc1Njcm9sbFJvb3QgPSBub2RlLmlzU2Nyb2xsUm9vdDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5yb290ICYmIHNjcm9sbF8xICYmIG9wdGlvbnMubGF5b3V0U2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgbmV3IHNjcm9sbCByb290LCB3ZSB3YW50IHRvIHJlbW92ZSBhbGwgcHJldmlvdXMgc2Nyb2xsc1xuICAgICAgICAgICAgICAgICAgICAgKiBmcm9tIHRoZSB2aWV3cG9ydCBib3guXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTY3JvbGxSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0U2Nyb2xsLCBib3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RTY3JvbGwgPSB0aGlzLnJvb3Quc2Nyb2xsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBVbmRvIHRoZSBhcHBsaWNhdGlvbiBvZiBwYWdlIHNjcm9sbCB0aGF0IHdhcyBvcmlnaW5hbGx5IGFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0byB0aGUgbWVhc3VyZWQgYm91bmRpbmcgYm94LlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm9vdFNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC54LCAtcm9vdFNjcm9sbC54KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueSwgLXJvb3RTY3JvbGwueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLngsIHNjcm9sbF8xLngpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueSwgc2Nyb2xsXzEueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJveFdpdGhvdXRTY3JvbGw7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChib3gsIHRyYW5zZm9ybU9ubHkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1Pbmx5ID09PSB2b2lkIDApIHsgdHJhbnNmb3JtT25seSA9IGZhbHNlOyB9XG4gICAgICAgICAgICB2YXIgd2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKHdpdGhUcmFuc2Zvcm1zLCBib3gpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zZm9ybU9ubHkgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vcHRpb25zLmxheW91dFNjcm9sbCAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLnNjcm9sbCAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlICE9PSBub2RlLnJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAtbm9kZS5zY3JvbGwueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IC1ub2RlLnNjcm9sbC55LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIG5vZGUubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2l0aFRyYW5zZm9ybXM7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5yZW1vdmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYm94KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgYm94V2l0aG91dFRyYW5zZm9ybSA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgY29weUJveEludG8oYm94V2l0aG91dFRyYW5zZm9ybSwgYm94KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGhhc1NjYWxlKG5vZGUubGF0ZXN0VmFsdWVzKSAmJiBub2RlLnVwZGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUJveCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlQm94ID0gbm9kZS5tZWFzdXJlKCk7XG4gICAgICAgICAgICAgICAgY29weUJveEludG8oc291cmNlQm94LCBub2RlQm94KTtcbiAgICAgICAgICAgICAgICByZW1vdmVCb3hUcmFuc2Zvcm1zKGJveFdpdGhvdXRUcmFuc2Zvcm0sIG5vZGUubGF0ZXN0VmFsdWVzLCAoX2EgPSBub2RlLnNuYXBzaG90KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGF5b3V0LCBzb3VyY2VCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVCb3hUcmFuc2Zvcm1zKGJveFdpdGhvdXRUcmFuc2Zvcm0sIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib3hXaXRob3V0VHJhbnNmb3JtO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zZXRUYXJnZXREZWx0YSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXREZWx0YSA9IGRlbHRhO1xuICAgICAgICAgICAgdGhpcy5yb290LnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyksIHsgY3Jvc3NmYWRlOiAoX2EgPSBvcHRpb25zLmNyb3NzZmFkZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmNsZWFyTWVhc3VyZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmxheW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50YXJnZXREZWx0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGcmFtZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5yZXNvbHZlVGFyZ2V0RGVsdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLm9wdGlvbnMsIGxheW91dCA9IF9iLmxheW91dCwgbGF5b3V0SWQgPSBfYi5sYXlvdXRJZDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBubyBsYXlvdXQsIHdlIGNhbid0IHBlcmZvcm0gcHJvamVjdGlvbiwgc28gZWFybHkgcmV0dXJuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIShsYXlvdXQgfHwgbGF5b3V0SWQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgZG9uJ3QgaGF2ZSBhIHRhcmdldERlbHRhIGJ1dCBkbyBoYXZlIGEgbGF5b3V0LCB3ZSBjYW4gYXR0ZW1wdCB0byByZXNvbHZlXG4gICAgICAgICAgICAgKiBhIHJlbGF0aXZlUGFyZW50LiBUaGlzIHdpbGwgYWxsb3cgYSBjb21wb25lbnQgdG8gcGVyZm9ybSBzY2FsZSBjb3JyZWN0aW9uXG4gICAgICAgICAgICAgKiBldmVuIGlmIG5vIGFuaW1hdGlvbiBoYXMgc3RhcnRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gVE9ETyBJZiB0aGlzIGlzIHVuc3VjY2Vzc2Z1bCB0aGlzIGN1cnJlbnRseSBoYXBwZW5zIGV2ZXJ5IGZyYW1lXG4gICAgICAgICAgICBpZiAoIXRoaXMudGFyZ2V0RGVsdGEgJiYgIXRoaXMucmVsYXRpdmVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGEgc2VtaS1yZXBldGl0aW9uIG9mIGZ1cnRoZXIgZG93biB0aGlzIGZ1bmN0aW9uLCBtYWtlIERSWVxuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSB0aGlzLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVQYXJlbnQgJiYgdGhpcy5yZWxhdGl2ZVBhcmVudC5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sIHRoaXMubGF5b3V0LmFjdHVhbCwgdGhpcy5yZWxhdGl2ZVBhcmVudC5sYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIG5vIHJlbGF0aXZlIHRhcmdldCBvciBubyB0YXJnZXQgZGVsdGEgb3VyIHRhcmdldCBpc24ndCB2YWxpZFxuICAgICAgICAgICAgICogZm9yIHRoaXMgZnJhbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5yZWxhdGl2ZVRhcmdldCAmJiAhdGhpcy50YXJnZXREZWx0YSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExhenktaW5pdCB0YXJnZXQgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRXaXRoVHJhbnNmb3JtcyA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSd2ZSBnb3QgYSByZWxhdGl2ZSBib3ggZm9yIHRoaXMgY29tcG9uZW50LCByZXNvbHZlIGl0IGludG8gYSB0YXJnZXQgcmVsYXRpdmUgdG8gdGhlIHBhcmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVUYXJnZXQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luICYmXG4gICAgICAgICAgICAgICAgKChfYSA9IHRoaXMucmVsYXRpdmVQYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlQm94KHRoaXMudGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlUGFyZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgd2UndmUgb25seSBnb3QgYSB0YXJnZXREZWx0YSwgcmVzb2x2ZSBpdCBpbnRvIGEgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnRhcmdldERlbHRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgaXMgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IGV2ZXJ5IGZyYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5hcHBseVRyYW5zZm9ybSh0aGlzLmxheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy50YXJnZXQsIHRoaXMubGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFwcGx5Qm94RGVsdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0RGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgbm8gdGFyZ2V0LCB1c2Ugb3duIGxheW91dCBhcyB0YXJnZXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnRhcmdldCwgdGhpcy5sYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UndmUgYmVlbiB0b2xkIHRvIGF0dGVtcHQgdG8gcmVzb2x2ZSBhIHJlbGF0aXZlIHRhcmdldCwgZG8gc28uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCA9IHRoaXMuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZVBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICBCb29sZWFuKHRoaXMucmVsYXRpdmVQYXJlbnQucmVzdW1pbmdGcm9tKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLnJlbGF0aXZlUGFyZW50Lm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbih0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCB0aGlzLnRhcmdldCwgdGhpcy5yZWxhdGl2ZVBhcmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQgfHwgaGFzVHJhbnNmb3JtKHRoaXMucGFyZW50LmxhdGVzdFZhbHVlcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodGhpcy5wYXJlbnQucmVsYXRpdmVUYXJnZXQgfHwgdGhpcy5wYXJlbnQudGFyZ2V0RGVsdGEpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5jYWxjUHJvamVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IHRoaXMub3B0aW9ucywgbGF5b3V0ID0gX2IubGF5b3V0LCBsYXlvdXRJZCA9IF9iLmxheW91dElkO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIHNlY3Rpb24gb2YgdGhlIHRyZWUgaXNuJ3QgYW5pbWF0aW5nIHdlIGNhblxuICAgICAgICAgICAgICogZGVsZXRlIG91ciB0YXJnZXQgc291cmNlcyBmb3IgdGhlIGZvbGxvd2luZyBmcmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1RyZWVBbmltYXRpbmcgPSBCb29sZWFuKCgoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVHJlZUFuaW1hdGluZykgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gfHxcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVHJlZUFuaW1hdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxheW91dCB8fCAhKGxheW91dCB8fCBsYXlvdXRJZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVzZXQgdGhlIGNvcnJlY3RlZCBib3ggd2l0aCB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIGJveCwgYXMgd2UncmUgdGhlbiBnb2luZ1xuICAgICAgICAgICAgICogdG8gcGVyZm9ybSBtdXRhdGl2ZSBvcGVyYXRpb25zIG9uIGl0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLmxheW91dENvcnJlY3RlZCwgdGhpcy5sYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgYWxsIHRoZSBwYXJlbnQgZGVsdGFzIHRvIHRoaXMgYm94IHRvIHByb2R1Y2UgdGhlIGNvcnJlY3RlZCBib3guIFRoaXNcbiAgICAgICAgICAgICAqIGlzIHRoZSBsYXlvdXQgYm94LCBhcyBpdCB3aWxsIGFwcGVhciBvbiBzY3JlZW4gYXMgYSByZXN1bHQgb2YgdGhlIHRyYW5zZm9ybXMgb2YgaXRzIHBhcmVudHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFwcGx5VHJlZURlbHRhcyh0aGlzLmxheW91dENvcnJlY3RlZCwgdGhpcy50cmVlU2NhbGUsIHRoaXMucGF0aCwgQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkgfHwgdGhpcyAhPT0gbGVhZCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbGVhZC50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvamVjdGlvbkRlbHRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldlRyZWVTY2FsZVggPSB0aGlzLnRyZWVTY2FsZS54O1xuICAgICAgICAgICAgdmFyIHByZXZUcmVlU2NhbGVZID0gdGhpcy50cmVlU2NhbGUueTtcbiAgICAgICAgICAgIHZhciBwcmV2UHJvamVjdGlvblRyYW5zZm9ybSA9IHRoaXMucHJvamVjdGlvblRyYW5zZm9ybTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIHRoZSBjb3JyZWN0ZWQgYm94IGFuZCB0aGUgdGFyZ2V0IGJveCBiZWZvcmUgdXNlci1zZXQgdHJhbnNmb3JtcyB3ZXJlIGFwcGxpZWQuXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgYWxsb3cgdXMgdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0ZWQgYm9yZGVyUmFkaXVzIGFuZCBib3hTaGFkb3cgdG8gY29tcGVuc2F0ZVxuICAgICAgICAgICAgICogZm9yIG91ciBsYXlvdXQgcmVwcm9qZWN0aW9uLCBidXQgc3RpbGwgYWxsb3cgdGhlbSB0byBiZSBzY2FsZWQgY29ycmVjdGx5IGJ5IHRoZSB1c2VyLlxuICAgICAgICAgICAgICogSXQgbWlnaHQgYmUgdGhhdCB0byBzaW1wbGlmeSB0aGlzIHdlIG1heSB3YW50IHRvIGFjY2VwdCB0aGF0IHVzZXItc2V0IHNjYWxlIGlzIGFsc28gY29ycmVjdGVkXG4gICAgICAgICAgICAgKiBhbmQgd2Ugd291bGRuJ3QgaGF2ZSB0byBrZWVwIGFuZCBjYWxjIGJvdGggZGVsdGFzLCBPUiB3ZSBjb3VsZCBzdXBwb3J0IGEgdXNlciBzZXR0aW5nXG4gICAgICAgICAgICAgKiB0byBhbGxvdyBwZW9wbGUgdG8gY2hvb3NlIHdoZXRoZXIgdGhlc2Ugc3R5bGVzIGFyZSBjb3JyZWN0ZWQgYmFzZWQgb24ganVzdCB0aGVcbiAgICAgICAgICAgICAqIGxheW91dCByZXByb2plY3Rpb24gb3IgdGhlIGZpbmFsIGJvdW5kaW5nIGJveC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FsY0JveERlbHRhKHRoaXMucHJvamVjdGlvbkRlbHRhLCB0aGlzLmxheW91dENvcnJlY3RlZCwgdGFyZ2V0LCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm0gPSBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0odGhpcy5wcm9qZWN0aW9uRGVsdGEsIHRoaXMudHJlZVNjYWxlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm0gIT09IHByZXZQcm9qZWN0aW9uVHJhbnNmb3JtIHx8XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlU2NhbGUueCAhPT0gcHJldlRyZWVTY2FsZVggfHxcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVTY2FsZS55ICE9PSBwcmV2VHJlZVNjYWxlWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJwcm9qZWN0aW9uVXBkYXRlXCIsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRPRE86IFNjaGVkdWxlIHJlbmRlclxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFRPRE86IFNjaGVkdWxlIHJlbmRlclxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc2NoZWR1bGVSZW5kZXIgPSBmdW5jdGlvbiAobm90aWZ5QWxsKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGlmIChub3RpZnlBbGwgPT09IHZvaWQgMCkgeyBub3RpZnlBbGwgPSB0cnVlOyB9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMpLnNjaGVkdWxlUmVuZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgICAgICBub3RpZnlBbGwgJiYgKChfYyA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNjaGVkdWxlUmVuZGVyKCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1pbmdGcm9tICYmICF0aGlzLnJlc3VtaW5nRnJvbS5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc2V0QW5pbWF0aW9uT3JpZ2luID0gZnVuY3Rpb24gKGRlbHRhLCBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPT09IHZvaWQgMCkgeyBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gZmFsc2U7IH1cbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IHRoaXMuc25hcHNob3Q7XG4gICAgICAgICAgICB2YXIgc25hcHNob3RMYXRlc3RWYWx1ZXMgPSAoc25hcHNob3QgPT09IG51bGwgfHwgc25hcHNob3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNuYXBzaG90LmxhdGVzdFZhbHVlcykgfHwge307XG4gICAgICAgICAgICB2YXIgbWl4ZWRWYWx1ZXMgPSB0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgdmFyIHRhcmdldERlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQgPSAhaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZDtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZUxheW91dCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgdmFyIGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uID0gc25hcHNob3QgPT09IG51bGwgfHwgc25hcHNob3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNuYXBzaG90LmlzU2hhcmVkO1xuICAgICAgICAgICAgdmFyIGlzT25seU1lbWJlciA9ICgoKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVtYmVycy5sZW5ndGgpIHx8IDApIDw9IDE7XG4gICAgICAgICAgICB2YXIgc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSA9IEJvb2xlYW4oaXNTaGFyZWRMYXlvdXRBbmltYXRpb24gJiZcbiAgICAgICAgICAgICAgICAhaXNPbmx5TWVtYmVyICYmXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNyb3NzZmFkZSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnBhdGguc29tZShoYXNPcGFjaXR5Q3Jvc3NmYWRlKSk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHRoaXMubWl4VGFyZ2V0RGVsdGEgPSBmdW5jdGlvbiAobGF0ZXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IGxhdGVzdCAvIDEwMDA7XG4gICAgICAgICAgICAgICAgbWl4QXhpc0RlbHRhKHRhcmdldERlbHRhLngsIGRlbHRhLngsIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBtaXhBeGlzRGVsdGEodGFyZ2V0RGVsdGEueSwgZGVsdGEueSwgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFRhcmdldERlbHRhKHRhcmdldERlbHRhKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVsYXRpdmVUYXJnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGF5b3V0ICYmXG4gICAgICAgICAgICAgICAgICAgICgoX2EgPSBfdGhpcy5yZWxhdGl2ZVBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxheW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVMYXlvdXQsIF90aGlzLmxheW91dC5hY3R1YWwsIF90aGlzLnJlbGF0aXZlUGFyZW50LmxheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgICAgICAgICBtaXhCb3goX3RoaXMucmVsYXRpdmVUYXJnZXQsIF90aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCByZWxhdGl2ZUxheW91dCwgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTaGFyZWRMYXlvdXRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW9uVmFsdWVzID0gbWl4ZWRWYWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIG1peFZhbHVlcyhtaXhlZFZhbHVlcywgc25hcHNob3RMYXRlc3RWYWx1ZXMsIF90aGlzLmxhdGVzdFZhbHVlcywgcHJvZ3Jlc3MsIHNob3VsZENyb3NzZmFkZU9wYWNpdHksIGlzT25seU1lbWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnJvb3Quc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubWl4VGFyZ2V0RGVsdGEoMCk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zdGFydEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwiYW5pbWF0aW9uU3RhcnRcIik7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnJlbnRBbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHN5bmMuY2FuY2VsU3luYy51cGRhdGUodGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN0YXJ0IHRoZSBhbmltYXRpb24gaW4gdGhlIG5leHQgZnJhbWUgdG8gaGF2ZSBhIGZyYW1lIHdpdGggcHJvZ3Jlc3MgMCxcbiAgICAgICAgICAgICAqIHdoZXJlIHRoZSB0YXJnZXQgaXMgdGhlIHNhbWUgYXMgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0ZWQsIHNvIHdlIGNhblxuICAgICAgICAgICAgICogY2FsY3VsYXRlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbnMgY29ycmVjdGx5IGZvciBpbnN0YW50IHRyYW5zaXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS51cGRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0ZSgwLCBhbmltYXRpb25UYXJnZXQsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBvblVwZGF0ZTogZnVuY3Rpb24gKGxhdGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWl4VGFyZ2V0RGVsdGEobGF0ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IG9wdGlvbnMub25VcGRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGxhdGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IG9wdGlvbnMub25Db21wbGV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzdW1pbmdGcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uID0gX3RoaXMuY3VycmVudEFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ0FuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuY29tcGxldGVBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4aXRBbmltYXRpb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20gPVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVmFsdWVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwiYW5pbWF0aW9uQ29tcGxldGVcIik7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5maW5pc2hBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5taXhUYXJnZXREZWx0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgYW5pbWF0aW9uVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1zVG9UYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLmdldExlYWQoKSwgdGFyZ2V0V2l0aFRyYW5zZm9ybXMgPSBfYS50YXJnZXRXaXRoVHJhbnNmb3JtcywgdGFyZ2V0ID0gX2EudGFyZ2V0LCBsYXlvdXQgPSBfYS5sYXlvdXQsIGxhdGVzdFZhbHVlcyA9IF9hLmxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIGlmICghdGFyZ2V0V2l0aFRyYW5zZm9ybXMgfHwgIXRhcmdldCB8fCAhbGF5b3V0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRhcmdldFdpdGhUcmFuc2Zvcm1zLCB0YXJnZXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSB0aGUgbGF0ZXN0IHVzZXItc2V0IHRyYW5zZm9ybXMgdG8gdGhlIHRhcmdldEJveCB0byBwcm9kdWNlIHRoZSB0YXJnZXRCb3hGaW5hbC5cbiAgICAgICAgICAgICAqIFRoaXMgaXMgdGhlIGZpbmFsIGJveCB0aGF0IHdlIHdpbGwgdGhlbiBwcm9qZWN0IGludG8gYnkgY2FsY3VsYXRpbmcgYSB0cmFuc2Zvcm0gZGVsdGEgYW5kXG4gICAgICAgICAgICAgKiBhcHBseWluZyBpdCB0byB0aGUgY29ycmVjdGVkIGJveC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KHRhcmdldFdpdGhUcmFuc2Zvcm1zLCBsYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIGRlbHRhIGJldHdlZW4gdGhlIGNvcnJlY3RlZCBib3ggYW5kIHRoZSBmaW5hbCB0YXJnZXQgYm94LCBhZnRlclxuICAgICAgICAgICAgICogdXNlci1zZXQgdHJhbnNmb3JtcyBhcmUgYXBwbGllZCB0byBpdC4gVGhpcyB3aWxsIGJlIHVzZWQgYnkgdGhlIHJlbmRlcmVyIHRvXG4gICAgICAgICAgICAgKiBjcmVhdGUgYSB0cmFuc2Zvcm0gc3R5bGUgdGhhdCB3aWxsIHJlcHJvamVjdCB0aGUgZWxlbWVudCBmcm9tIGl0cyBhY3R1YWwgbGF5b3V0XG4gICAgICAgICAgICAgKiBpbnRvIHRoZSBkZXNpcmVkIGJvdW5kaW5nIGJveC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FsY0JveERlbHRhKHRoaXMucHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSwgdGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRhcmdldFdpdGhUcmFuc2Zvcm1zLCBsYXRlc3RWYWx1ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVnaXN0ZXJTaGFyZWROb2RlID0gZnVuY3Rpb24gKGxheW91dElkLCBub2RlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGlmICghdGhpcy5zaGFyZWROb2Rlcy5oYXMobGF5b3V0SWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZWROb2Rlcy5zZXQobGF5b3V0SWQsIG5ldyBOb2RlU3RhY2soKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnNoYXJlZE5vZGVzLmdldChsYXlvdXRJZCk7XG4gICAgICAgICAgICBzdGFjay5hZGQobm9kZSk7XG4gICAgICAgICAgICBub2RlLnByb21vdGUoe1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IChfYSA9IG5vZGUub3B0aW9ucy5pbml0aWFsUHJvbW90aW9uQ29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUZvbGxvd09wYWNpdHk6IChfYyA9IChfYiA9IG5vZGUub3B0aW9ucy5pbml0aWFsUHJvbW90aW9uQ29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hvdWxkUHJlc2VydmVGb2xsb3dPcGFjaXR5KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgbm9kZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmlzTGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFjayA/IHN0YWNrLmxlYWQgPT09IHRoaXMgOiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuZ2V0TGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBsYXlvdXRJZCA9IHRoaXMub3B0aW9ucy5sYXlvdXRJZDtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRJZCA/ICgoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZWFkKSB8fCB0aGlzIDogdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmdldFByZXZMZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGxheW91dElkID0gdGhpcy5vcHRpb25zLmxheW91dElkO1xuICAgICAgICAgICAgcmV0dXJuIGxheW91dElkID8gKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJldkxlYWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5nZXRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXRJZCA9IHRoaXMub3B0aW9ucy5sYXlvdXRJZDtcbiAgICAgICAgICAgIGlmIChsYXlvdXRJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LnNoYXJlZE5vZGVzLmdldChsYXlvdXRJZCk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5wcm9tb3RlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbmVlZHNSZXNldCA9IF9iLm5lZWRzUmVzZXQsIHRyYW5zaXRpb24gPSBfYi50cmFuc2l0aW9uLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkgPSBfYi5wcmVzZXJ2ZUZvbGxvd09wYWNpdHk7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2spXG4gICAgICAgICAgICAgICAgc3RhY2sucHJvbW90ZSh0aGlzLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpO1xuICAgICAgICAgICAgaWYgKG5lZWRzUmVzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24pXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlbGVnYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnJlbGVnYXRlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVzZXRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2aXN1YWxFbGVtZW50ID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBkZXRlY3RlZCByb3RhdGlvbiB2YWx1ZXMsIHdlIGNhbiBlYXJseSByZXR1cm4gd2l0aG91dCBhIGZvcmNlZCByZW5kZXIuXG4gICAgICAgICAgICB2YXIgaGFzUm90YXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBLZWVwIGEgcmVjb3JkIG9mIGFsbCB0aGUgdmFsdWVzIHdlJ3ZlIHJlc2V0XG4gICAgICAgICAgICB2YXIgcmVzZXRWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSByb3RhdGUgdmFsdWUgb2YgYWxsIGF4ZXMgYW5kIHJlc2V0IHRvIDBcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtQXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gdHJhbnNmb3JtQXhlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gXCJyb3RhdGVcIiArIGF4aXM7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyByb3RhdGlvbiBkb2Vzbid0IGV4aXN0IGFzIGEgbW90aW9uIHZhbHVlLCB0aGVuIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZXNldCBpdFxuICAgICAgICAgICAgICAgIGlmICghdmlzdWFsRWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNSb3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgcm90YXRpb24gYW5kIHRoZW4gdGVtcG9yYXJpbHkgc2V0IGl0IHRvIDBcbiAgICAgICAgICAgICAgICByZXNldFZhbHVlc1trZXldID0gdmlzdWFsRWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoa2V5LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcm90YXRpb24gdmFsdWVzLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueSBtb3JlLlxuICAgICAgICAgICAgaWYgKCFoYXNSb3RhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gRm9yY2UgYSByZW5kZXIgb2YgdGhpcyBlbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gd2l0aCBhbGwgcm90YXRpb25zXG4gICAgICAgICAgICAvLyBzZXQgdG8gMC5cbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgICAgICAgICAvLyBQdXQgYmFjayBhbGwgdGhlIHZhbHVlcyB3ZSByZXNldFxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHJlc2V0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShrZXksIHJlc2V0VmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSByZW5kZXIgZm9yIHRoZSBuZXh0IGZyYW1lLiBUaGlzIGVuc3VyZXMgd2Ugd29uJ3QgdmlzdWFsbHlcbiAgICAgICAgICAgIC8vIHNlZSB0aGUgZWxlbWVudCB3aXRoIHRoZSByZXNldCByb3RhdGUgdmFsdWUgYXBwbGllZC5cbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmdldFByb2plY3Rpb25TdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVQcm9wKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGlmIChzdHlsZVByb3AgPT09IHZvaWQgMCkgeyBzdHlsZVByb3AgPSB7fTsgfVxuICAgICAgICAgICAgLy8gVE9ETzogUmV0dXJuIGxpZmVjeWNsZS1wZXJzaXN0ZW50IG9iamVjdFxuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlIHx8IHRoaXMuaXNTVkcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2aXNpYmlsaXR5OiBcImhpZGRlblwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGUgPSAoX2EgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wb2ludGVyRXZlbnRzID1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVhZCA9IHRoaXMuZ2V0TGVhZCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb2plY3Rpb25EZWx0YSB8fCAhdGhpcy5sYXlvdXQgfHwgIWxlYWQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVtcHR5U3R5bGVzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eVN0eWxlcy5vcGFjaXR5ID0gKF9iID0gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlTdHlsZXMucG9pbnRlckV2ZW50cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1Byb2plY3RlZCAmJiAhaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eVN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVN0eWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZXNUb1JlbmRlciA9IGxlYWQuYW5pbWF0aW9uVmFsdWVzIHx8IGxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXNUb1RhcmdldCgpO1xuICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSh0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0sIHRoaXMudHJlZVNjYWxlLCB2YWx1ZXNUb1JlbmRlcik7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUodmFsdWVzVG9SZW5kZXIsIHN0eWxlcy50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9nID0gdGhpcy5wcm9qZWN0aW9uRGVsdGEsIHggPSBfZy54LCB5ID0gX2cueTtcbiAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm1PcmlnaW4gPSBcIlwiLmNvbmNhdCh4Lm9yaWdpbiAqIDEwMCwgXCIlIFwiKS5jb25jYXQoeS5vcmlnaW4gKiAxMDAsIFwiJSAwXCIpO1xuICAgICAgICAgICAgaWYgKGxlYWQuYW5pbWF0aW9uVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIGxlYWQgY29tcG9uZW50IGlzIGFuaW1hdGluZywgYXNzaWduIHRoaXMgZWl0aGVyIHRoZSBlbnRlcmluZy9sZWF2aW5nXG4gICAgICAgICAgICAgICAgICogb3BhY2l0eVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHN0eWxlcy5vcGFjaXR5ID1cbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoX2QgPSAoX2MgPSB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucHJlc2VydmVPcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE9yIHdlJ3JlIG5vdCBhbmltYXRpbmcgYXQgYWxsLCBzZXQgdGhlIGxlYWQgY29tcG9uZW50IHRvIGl0cyBhY3R1YWxcbiAgICAgICAgICAgICAgICAgKiBvcGFjaXR5IGFuZCBvdGhlciBjb21wb25lbnRzIHRvIGhpZGRlbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKF9lID0gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoX2YgPSB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgc2NhbGUgY29ycmVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2NhbGVDb3JyZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1RvUmVuZGVyW2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIF9oID0gc2NhbGVDb3JyZWN0b3JzW2tleV0sIGNvcnJlY3QgPSBfaC5jb3JyZWN0LCBhcHBseVRvID0gX2guYXBwbHlUbztcbiAgICAgICAgICAgICAgICB2YXIgY29ycmVjdGVkID0gY29ycmVjdCh2YWx1ZXNUb1JlbmRlcltrZXldLCBsZWFkKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbHlUbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gYXBwbHlUby5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1thcHBseVRvW2ldXSA9IGNvcnJlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW2tleV0gPSBjb3JyZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXNhYmxlIHBvaW50ZXIgZXZlbnRzIG9uIGZvbGxvdyBjb21wb25lbnRzLiBUaGlzIGlzIHRvIGVuc3VyZVxuICAgICAgICAgICAgICogdGhhdCBpZiBhIGZvbGxvdyBjb21wb25lbnQgY292ZXJzIGEgbGVhZCBjb21wb25lbnQgaXQgZG9lc24ndCBibG9ja1xuICAgICAgICAgICAgICogcG9pbnRlciBldmVudHMgb24gdGhlIGxlYWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0SWQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMucG9pbnRlckV2ZW50cyA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmNsZWFyU25hcHNob3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZUZyb20gPSB0aGlzLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICAvLyBPbmx5IHJ1biBvbiByb290XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5yZXNldFRyZWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyB2YXIgX2E7IHJldHVybiAoX2EgPSBub2RlLmN1cnJlbnRBbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5yb290Lm5vZGVzLmZvckVhY2goY2xlYXJNZWFzdXJlbWVudHMpO1xuICAgICAgICAgICAgdGhpcy5yb290LnNoYXJlZE5vZGVzLmNsZWFyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9qZWN0aW9uTm9kZTtcbiAgICB9KCkpO1xufVxuZnVuY3Rpb24gdXBkYXRlTGF5b3V0KG5vZGUpIHtcbiAgICBub2RlLnVwZGF0ZUxheW91dCgpO1xufVxuZnVuY3Rpb24gbm90aWZ5TGF5b3V0VXBkYXRlKG5vZGUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgdmFyIHNuYXBzaG90ID0gKF9iID0gKF9hID0gbm9kZS5yZXN1bWVGcm9tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc25hcHNob3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5vZGUuc25hcHNob3Q7XG4gICAgaWYgKG5vZGUuaXNMZWFkKCkgJiZcbiAgICAgICAgbm9kZS5sYXlvdXQgJiZcbiAgICAgICAgc25hcHNob3QgJiZcbiAgICAgICAgbm9kZS5oYXNMaXN0ZW5lcnMoXCJkaWRVcGRhdGVcIikpIHtcbiAgICAgICAgdmFyIF9lID0gbm9kZS5sYXlvdXQsIGxheW91dF8xID0gX2UuYWN0dWFsLCBtZWFzdXJlZExheW91dCA9IF9lLm1lYXN1cmVkO1xuICAgICAgICAvLyBUT0RPIE1heWJlIHdlIHdhbnQgdG8gYWxzbyByZXNpemUgdGhlIGxheW91dCBzbmFwc2hvdCBzbyB3ZSBkb24ndCB0cmlnZ2VyXG4gICAgICAgIC8vIGFuaW1hdGlvbnMgZm9yIGluc3RhbmNlIGlmIGxheW91dD1cInNpemVcIiBhbmQgYW4gZWxlbWVudCBoYXMgb25seSBjaGFuZ2VkIHBvc2l0aW9uXG4gICAgICAgIGlmIChub2RlLm9wdGlvbnMuYW5pbWF0aW9uVHlwZSA9PT0gXCJzaXplXCIpIHtcbiAgICAgICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNTbmFwc2hvdCA9IHNuYXBzaG90LmlzU2hhcmVkXG4gICAgICAgICAgICAgICAgICAgID8gc25hcHNob3QubWVhc3VyZWRbYXhpc11cbiAgICAgICAgICAgICAgICAgICAgOiBzbmFwc2hvdC5sYXlvdXRbYXhpc107XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGNhbGNMZW5ndGgoYXhpc1NuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBheGlzU25hcHNob3QubWluID0gbGF5b3V0XzFbYXhpc10ubWluO1xuICAgICAgICAgICAgICAgIGF4aXNTbmFwc2hvdC5tYXggPSBheGlzU25hcHNob3QubWluICsgbGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5vcHRpb25zLmFuaW1hdGlvblR5cGUgPT09IFwicG9zaXRpb25cIikge1xuICAgICAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1NuYXBzaG90ID0gc25hcHNob3QuaXNTaGFyZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzbmFwc2hvdC5tZWFzdXJlZFtheGlzXVxuICAgICAgICAgICAgICAgICAgICA6IHNuYXBzaG90LmxheW91dFtheGlzXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gY2FsY0xlbmd0aChsYXlvdXRfMVtheGlzXSk7XG4gICAgICAgICAgICAgICAgYXhpc1NuYXBzaG90Lm1heCA9IGF4aXNTbmFwc2hvdC5taW4gKyBsZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5b3V0RGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICBjYWxjQm94RGVsdGEobGF5b3V0RGVsdGEsIGxheW91dF8xLCBzbmFwc2hvdC5sYXlvdXQpO1xuICAgICAgICB2YXIgdmlzdWFsRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICBpZiAoc25hcHNob3QuaXNTaGFyZWQpIHtcbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh2aXN1YWxEZWx0YSwgbm9kZS5hcHBseVRyYW5zZm9ybShtZWFzdXJlZExheW91dCwgdHJ1ZSksIHNuYXBzaG90Lm1lYXN1cmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh2aXN1YWxEZWx0YSwgbGF5b3V0XzEsIHNuYXBzaG90LmxheW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc0xheW91dENoYW5nZWQgPSAhaXNEZWx0YVplcm8obGF5b3V0RGVsdGEpO1xuICAgICAgICB2YXIgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmICghbm9kZS5yZXN1bWVGcm9tKSB7XG4gICAgICAgICAgICBub2RlLnJlbGF0aXZlUGFyZW50ID0gbm9kZS5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgcmVsYXRpdmVQYXJlbnQgaXMgaXRzZWxmIHJlc3VtaW5nIGZyb20gYSBkaWZmZXJlbnQgZWxlbWVudCB0aGVuXG4gICAgICAgICAgICAgKiB0aGUgcmVsYXRpdmUgc25hcHNob3QgaXMgbm90IHJlbGF2ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChub2RlLnJlbGF0aXZlUGFyZW50ICYmICFub2RlLnJlbGF0aXZlUGFyZW50LnJlc3VtZUZyb20pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2YgPSBub2RlLnJlbGF0aXZlUGFyZW50LCBwYXJlbnRTbmFwc2hvdCA9IF9mLnNuYXBzaG90LCBwYXJlbnRMYXlvdXQgPSBfZi5sYXlvdXQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFNuYXBzaG90ICYmIHBhcmVudExheW91dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVsYXRpdmVTbmFwc2hvdCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZVNuYXBzaG90LCBzbmFwc2hvdC5sYXlvdXQsIHBhcmVudFNuYXBzaG90LmxheW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWxhdGl2ZUxheW91dCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZUxheW91dCwgbGF5b3V0XzEsIHBhcmVudExheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJveEVxdWFscyhyZWxhdGl2ZVNuYXBzaG90LCByZWxhdGl2ZUxheW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub3RpZnlMaXN0ZW5lcnMoXCJkaWRVcGRhdGVcIiwge1xuICAgICAgICAgICAgbGF5b3V0OiBsYXlvdXRfMSxcbiAgICAgICAgICAgIHNuYXBzaG90OiBzbmFwc2hvdCxcbiAgICAgICAgICAgIGRlbHRhOiB2aXN1YWxEZWx0YSxcbiAgICAgICAgICAgIGxheW91dERlbHRhOiBsYXlvdXREZWx0YSxcbiAgICAgICAgICAgIGhhc0xheW91dENoYW5nZWQ6IGhhc0xheW91dENoYW5nZWQsXG4gICAgICAgICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ6IGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUuaXNMZWFkKCkpIHtcbiAgICAgICAgKF9kID0gKF9jID0gbm9kZS5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcmluZyB0cmFuc2l0aW9uXG4gICAgICogVE9ETzogSW52ZXN0aWdhdGUgd2h5IHRoaXMgdHJhbnNpdGlvbiBpcyBiZWluZyBwYXNzZWQgaW4gYXMge3R5cGU6IGZhbHNlIH0gZnJvbSBGcmFtZXJcbiAgICAgKiBhbmQgd2h5IHdlIG5lZWQgaXQgYXQgYWxsXG4gICAgICovXG4gICAgbm9kZS5vcHRpb25zLnRyYW5zaXRpb24gPSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjbGVhclNuYXBzaG90KG5vZGUpIHtcbiAgICBub2RlLmNsZWFyU25hcHNob3QoKTtcbn1cbmZ1bmN0aW9uIGNsZWFyTWVhc3VyZW1lbnRzKG5vZGUpIHtcbiAgICBub2RlLmNsZWFyTWVhc3VyZW1lbnRzKCk7XG59XG5mdW5jdGlvbiByZXNldFRyYW5zZm9ybVN0eWxlKG5vZGUpIHtcbiAgICB2YXIgdmlzdWFsRWxlbWVudCA9IG5vZGUub3B0aW9ucy52aXN1YWxFbGVtZW50O1xuICAgIGlmICh2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS5vbkJlZm9yZUxheW91dE1lYXN1cmUpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5ub3RpZnlCZWZvcmVMYXlvdXRNZWFzdXJlKCk7XG4gICAgfVxuICAgIG5vZGUucmVzZXRUcmFuc2Zvcm0oKTtcbn1cbmZ1bmN0aW9uIGZpbmlzaEFuaW1hdGlvbihub2RlKSB7XG4gICAgbm9kZS5maW5pc2hBbmltYXRpb24oKTtcbiAgICBub2RlLnRhcmdldERlbHRhID0gbm9kZS5yZWxhdGl2ZVRhcmdldCA9IG5vZGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldERlbHRhKG5vZGUpIHtcbiAgICBub2RlLnJlc29sdmVUYXJnZXREZWx0YSgpO1xufVxuZnVuY3Rpb24gY2FsY1Byb2plY3Rpb24obm9kZSkge1xuICAgIG5vZGUuY2FsY1Byb2plY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIHJlc2V0Um90YXRpb24obm9kZSkge1xuICAgIG5vZGUucmVzZXRSb3RhdGlvbigpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGVhZFNuYXBzaG90cyhzdGFjaykge1xuICAgIHN0YWNrLnJlbW92ZUxlYWRTbmFwc2hvdCgpO1xufVxuZnVuY3Rpb24gbWl4QXhpc0RlbHRhKG91dHB1dCwgZGVsdGEsIHApIHtcbiAgICBvdXRwdXQudHJhbnNsYXRlID0gcG9wbW90aW9uLm1peChkZWx0YS50cmFuc2xhdGUsIDAsIHApO1xuICAgIG91dHB1dC5zY2FsZSA9IHBvcG1vdGlvbi5taXgoZGVsdGEuc2NhbGUsIDEsIHApO1xuICAgIG91dHB1dC5vcmlnaW4gPSBkZWx0YS5vcmlnaW47XG4gICAgb3V0cHV0Lm9yaWdpblBvaW50ID0gZGVsdGEub3JpZ2luUG9pbnQ7XG59XG5mdW5jdGlvbiBtaXhBeGlzKG91dHB1dCwgZnJvbSwgdG8sIHApIHtcbiAgICBvdXRwdXQubWluID0gcG9wbW90aW9uLm1peChmcm9tLm1pbiwgdG8ubWluLCBwKTtcbiAgICBvdXRwdXQubWF4ID0gcG9wbW90aW9uLm1peChmcm9tLm1heCwgdG8ubWF4LCBwKTtcbn1cbmZ1bmN0aW9uIG1peEJveChvdXRwdXQsIGZyb20sIHRvLCBwKSB7XG4gICAgbWl4QXhpcyhvdXRwdXQueCwgZnJvbS54LCB0by54LCBwKTtcbiAgICBtaXhBeGlzKG91dHB1dC55LCBmcm9tLnksIHRvLnksIHApO1xufVxuZnVuY3Rpb24gaGFzT3BhY2l0eUNyb3NzZmFkZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmFuaW1hdGlvblZhbHVlcyAmJiBub2RlLmFuaW1hdGlvblZhbHVlcy5vcGFjaXR5RXhpdCAhPT0gdW5kZWZpbmVkKTtcbn1cbnZhciBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbiA9IHtcbiAgICBkdXJhdGlvbjogMC40NSxcbiAgICBlYXNlOiBbMC40LCAwLCAwLjEsIDFdLFxufTtcbmZ1bmN0aW9uIG1vdW50Tm9kZUVhcmx5KG5vZGUsIGlkKSB7XG4gICAgLyoqXG4gICAgICogUmF0aGVyIHRoYW4gc2VhcmNoaW5nIHRoZSBET00gZnJvbSBkb2N1bWVudCB3ZSBjYW4gc2VhcmNoIHRoZVxuICAgICAqIHBhdGggZm9yIHRoZSBkZWVwZXN0IG1vdW50ZWQgYW5jZXN0b3IgYW5kIHNlYXJjaCBmcm9tIHRoZXJlXG4gICAgICovXG4gICAgdmFyIHNlYXJjaE5vZGUgPSBub2RlLnJvb3Q7XG4gICAgZm9yICh2YXIgaSA9IG5vZGUucGF0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoQm9vbGVhbihub2RlLnBhdGhbaV0uaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICBzZWFyY2hOb2RlID0gbm9kZS5wYXRoW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNlYXJjaEVsZW1lbnQgPSBzZWFyY2hOb2RlICYmIHNlYXJjaE5vZGUgIT09IG5vZGUucm9vdCA/IHNlYXJjaE5vZGUuaW5zdGFuY2UgOiBkb2N1bWVudDtcbiAgICB2YXIgZWxlbWVudCA9IHNlYXJjaEVsZW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLXByb2plY3Rpb24taWQ9XFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXVwiKSk7XG4gICAgaWYgKGVsZW1lbnQpXG4gICAgICAgIG5vZGUubW91bnQoZWxlbWVudCwgdHJ1ZSk7XG59XG5mdW5jdGlvbiByb3VuZEF4aXMoYXhpcykge1xuICAgIGF4aXMubWluID0gTWF0aC5yb3VuZChheGlzLm1pbik7XG4gICAgYXhpcy5tYXggPSBNYXRoLnJvdW5kKGF4aXMubWF4KTtcbn1cbmZ1bmN0aW9uIHJvdW5kQm94KGJveCkge1xuICAgIHJvdW5kQXhpcyhib3gueCk7XG4gICAgcm91bmRBeGlzKGJveC55KTtcbn1cblxudmFyIERvY3VtZW50UHJvamVjdGlvbk5vZGUgPSBjcmVhdGVQcm9qZWN0aW9uTm9kZSh7XG4gICAgYXR0YWNoUmVzaXplTGlzdGVuZXI6IGZ1bmN0aW9uIChyZWYsIG5vdGlmeSkgeyByZXR1cm4gYWRkRG9tRXZlbnQocmVmLCBcInJlc2l6ZVwiLCBub3RpZnkpOyB9LFxuICAgIG1lYXN1cmVTY3JvbGw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgIHg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgeTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICB9KTsgfSxcbiAgICBjaGVja0lzU2Nyb2xsUm9vdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbn0pO1xuXG52YXIgcm9vdFByb2plY3Rpb25Ob2RlID0ge1xuICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbn07XG52YXIgSFRNTFByb2plY3Rpb25Ob2RlID0gY3JlYXRlUHJvamVjdGlvbk5vZGUoe1xuICAgIG1lYXN1cmVTY3JvbGw6IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gKHtcbiAgICAgICAgeDogaW5zdGFuY2Uuc2Nyb2xsTGVmdCxcbiAgICAgICAgeTogaW5zdGFuY2Uuc2Nyb2xsVG9wLFxuICAgIH0pOyB9LFxuICAgIGRlZmF1bHRQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyb290UHJvamVjdGlvbk5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIGRvY3VtZW50Tm9kZSA9IG5ldyBEb2N1bWVudFByb2plY3Rpb25Ob2RlKDAsIHt9KTtcbiAgICAgICAgICAgIGRvY3VtZW50Tm9kZS5tb3VudCh3aW5kb3cpO1xuICAgICAgICAgICAgZG9jdW1lbnROb2RlLnNldE9wdGlvbnMoeyBsYXlvdXRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudCA9IGRvY3VtZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQ7XG4gICAgfSxcbiAgICByZXNldFRyYW5zZm9ybTogZnVuY3Rpb24gKGluc3RhbmNlLCB2YWx1ZSkge1xuICAgICAgICBpbnN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBcIm5vbmVcIjtcbiAgICB9LFxuICAgIGNoZWNrSXNTY3JvbGxSb290OiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4od2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5zdGFuY2UpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpO1xuICAgIH0sXG59KTtcblxudmFyIGZlYXR1cmVCdW5kbGUgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgYW5pbWF0aW9ucyksIGdlc3R1cmVBbmltYXRpb25zKSwgZHJhZyksIGxheW91dEZlYXR1cmVzKTtcbi8qKlxuICogSFRNTCAmIFNWRyBjb21wb25lbnRzLCBvcHRpbWlzZWQgZm9yIHVzZSB3aXRoIGdlc3R1cmVzIGFuZCBhbmltYXRpb24uIFRoZXNlIGNhbiBiZSB1c2VkIGFzXG4gKiBkcm9wLWluIHJlcGxhY2VtZW50cyBmb3IgYW55IEhUTUwgJiBTVkcgY29tcG9uZW50LCBhbGwgQ1NTICYgU1ZHIHByb3BlcnRpZXMgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBtb3Rpb24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZU1vdGlvblByb3h5KGZ1bmN0aW9uIChDb21wb25lbnQsIGNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVEb21Nb3Rpb25Db25maWcoQ29tcG9uZW50LCBjb25maWcsIGZlYXR1cmVCdW5kbGUsIGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQsIEhUTUxQcm9qZWN0aW9uTm9kZSk7XG59KTtcbi8qKlxuICogQ3JlYXRlIGEgRE9NIGBtb3Rpb25gIGNvbXBvbmVudCB3aXRoIHRoZSBwcm92aWRlZCBzdHJpbmcuIFRoaXMgaXMgcHJpbWFyaWx5IGludGVuZGVkXG4gKiBhcyBhIGZ1bGwgYWx0ZXJuYXRpdmUgdG8gYG1vdGlvbmAgZm9yIGNvbnN1bWVycyB3aG8gaGF2ZSB0byBzdXBwb3J0IGVudmlyb25tZW50cyB0aGF0IGRvbid0XG4gKiBzdXBwb3J0IGBQcm94eWAuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgY3JlYXRlRG9tTW90aW9uQ29tcG9uZW50IH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGNvbnN0IG1vdGlvbiA9IHtcbiAqICAgZGl2OiBjcmVhdGVEb21Nb3Rpb25Db21wb25lbnQoJ2RpdicpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudChrZXkpIHtcbiAgICByZXR1cm4gY3JlYXRlTW90aW9uQ29tcG9uZW50KGNyZWF0ZURvbU1vdGlvbkNvbmZpZyhrZXksIHsgZm9yd2FyZE1vdGlvblByb3BzOiBmYWxzZSB9LCBmZWF0dXJlQnVuZGxlLCBjcmVhdGVEb21WaXN1YWxFbGVtZW50LCBIVE1MUHJvamVjdGlvbk5vZGUpKTtcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbnZhciBtID0gY3JlYXRlTW90aW9uUHJveHkoY3JlYXRlRG9tTW90aW9uQ29uZmlnKTtcblxuZnVuY3Rpb24gdXNlSXNNb3VudGVkKCkge1xuICAgIHZhciBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gaXNNb3VudGVkO1xufVxuXG5mdW5jdGlvbiB1c2VGb3JjZVVwZGF0ZSgpIHtcbiAgICB2YXIgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gICAgdmFyIF9hID0gdHNsaWIuX19yZWFkKFJlYWN0LnVzZVN0YXRlKDApLCAyKSwgZm9yY2VkUmVuZGVyQ291bnQgPSBfYVswXSwgc2V0Rm9yY2VkUmVuZGVyQ291bnQgPSBfYVsxXTtcbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ICYmIHNldEZvcmNlZFJlbmRlckNvdW50KGZvcmNlZFJlbmRlckNvdW50ICsgMSk7XG4gICAgfSwgW2ZvcmNlZFJlbmRlckNvdW50XSk7XG4gICAgLyoqXG4gICAgICogRGVmZXIgdGhpcyB0byB0aGUgZW5kIG9mIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSBpbiBjYXNlIHRoZXJlIGFyZSBtdWx0aXBsZVxuICAgICAqIHN5bmNocm9ub3VzIGNhbGxzLlxuICAgICAqL1xuICAgIHZhciBkZWZlcnJlZEZvcmNlUmVuZGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gc3luY19fZGVmYXVsdFtcImRlZmF1bHRcIl0ucG9zdFJlbmRlcihmb3JjZVJlbmRlcik7IH0sIFtmb3JjZVJlbmRlcl0pO1xuICAgIHJldHVybiBbZGVmZXJyZWRGb3JjZVJlbmRlciwgZm9yY2VkUmVuZGVyQ291bnRdO1xufVxuXG52YXIgUHJlc2VuY2VDaGlsZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpbml0aWFsID0gX2EuaW5pdGlhbCwgaXNQcmVzZW50ID0gX2EuaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSA9IF9hLm9uRXhpdENvbXBsZXRlLCBjdXN0b20gPSBfYS5jdXN0b20sIHByZXNlbmNlQWZmZWN0c0xheW91dCA9IF9hLnByZXNlbmNlQWZmZWN0c0xheW91dDtcbiAgICB2YXIgcHJlc2VuY2VDaGlsZHJlbiA9IHVzZUNvbnN0YW50KG5ld0NoaWxkcmVuTWFwKTtcbiAgICB2YXIgaWQgPSB1c2VJZCgpO1xuICAgIHZhciBjb250ZXh0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGluaXRpYWw6IGluaXRpYWwsXG4gICAgICAgIGlzUHJlc2VudDogaXNQcmVzZW50LFxuICAgICAgICBjdXN0b206IGN1c3RvbSxcbiAgICAgICAgb25FeGl0Q29tcGxldGU6IGZ1bmN0aW9uIChjaGlsZElkKSB7XG4gICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgIHByZXNlbmNlQ2hpbGRyZW4uc2V0KGNoaWxkSWQsIHRydWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IHRzbGliLl9fdmFsdWVzKHByZXNlbmNlQ2hpbGRyZW4udmFsdWVzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0NvbXBsZXRlID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDb21wbGV0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gY2FuIHN0b3Agc2VhcmNoaW5nIHdoZW4gYW55IGlzIGluY29tcGxldGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkV4aXRDb21wbGV0ZSA9PT0gbnVsbCB8fCBvbkV4aXRDb21wbGV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FeGl0Q29tcGxldGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChjaGlsZElkKSB7XG4gICAgICAgICAgICBwcmVzZW5jZUNoaWxkcmVuLnNldChjaGlsZElkLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJlc2VuY2VDaGlsZHJlbi5kZWxldGUoY2hpbGRJZCk7IH07XG4gICAgICAgIH0sXG4gICAgfSk7IH0sIFxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcmVzZW5jZSBvZiBhIGNoaWxkIGFmZmVjdHMgdGhlIGxheW91dCBvZiB0aGUgY29tcG9uZW50cyBhcm91bmQgaXQsXG4gICAgICogd2Ugd2FudCB0byBtYWtlIGEgbmV3IGNvbnRleHQgdmFsdWUgdG8gZW5zdXJlIHRoZXkgZ2V0IHJlLXJlbmRlcmVkXG4gICAgICogc28gdGhleSBjYW4gZGV0ZWN0IHRoYXQgbGF5b3V0IGNoYW5nZS5cbiAgICAgKi9cbiAgICBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgPyB1bmRlZmluZWQgOiBbaXNQcmVzZW50XSk7XG4gICAgUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByZXNlbmNlQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoXywga2V5KSB7IHJldHVybiBwcmVzZW5jZUNoaWxkcmVuLnNldChrZXksIGZhbHNlKTsgfSk7XG4gICAgfSwgW2lzUHJlc2VudF0pO1xuICAgIC8qKlxuICAgICAqIElmIHRoZXJlJ3Mgbm8gYG1vdGlvbmAgY29tcG9uZW50cyB0byBmaXJlIGV4aXQgYW5pbWF0aW9ucywgd2Ugd2FudCB0byByZW1vdmUgdGhpc1xuICAgICAqIGNvbXBvbmVudCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICFpc1ByZXNlbnQgJiYgIXByZXNlbmNlQ2hpbGRyZW4uc2l6ZSAmJiAob25FeGl0Q29tcGxldGUgPT09IG51bGwgfHwgb25FeGl0Q29tcGxldGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRXhpdENvbXBsZXRlKCkpO1xuICAgIH0sIFtpc1ByZXNlbnRdKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQcmVzZW5jZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgY2hpbGRyZW4pKTtcbn07XG5mdW5jdGlvbiBuZXdDaGlsZHJlbk1hcCgpIHtcbiAgICByZXR1cm4gbmV3IE1hcCgpO1xufVxuXG52YXIgZ2V0Q2hpbGRLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmtleSB8fCBcIlwiOyB9O1xuZnVuY3Rpb24gdXBkYXRlQ2hpbGRMb29rdXAoY2hpbGRyZW4sIGFsbENoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGtleSA9IGdldENoaWxkS2V5KGNoaWxkKTtcbiAgICAgICAgYWxsQ2hpbGRyZW4uc2V0KGtleSwgY2hpbGQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gb25seUVsZW1lbnRzKGNoaWxkcmVuKSB7XG4gICAgdmFyIGZpbHRlcmVkID0gW107XG4gICAgLy8gV2UgdXNlIGZvckVhY2ggaGVyZSBpbnN0ZWFkIG9mIG1hcCBhcyBtYXAgbXV0YXRlcyB0aGUgY29tcG9uZW50IGtleSBieSBwcmVwcmVuZGluZyBgLiRgXG4gICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpXG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKGNoaWxkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmlsdGVyZWQ7XG59XG4vKipcbiAqIGBBbmltYXRlUHJlc2VuY2VgIGVuYWJsZXMgdGhlIGFuaW1hdGlvbiBvZiBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS5cbiAqXG4gKiBXaGVuIGFkZGluZy9yZW1vdmluZyBtb3JlIHRoYW4gYSBzaW5nbGUgY2hpbGQsIGV2ZXJ5IGNoaWxkICoqbXVzdCoqIGJlIGdpdmVuIGEgdW5pcXVlIGBrZXlgIHByb3AuXG4gKlxuICogQW55IGBtb3Rpb25gIGNvbXBvbmVudHMgdGhhdCBoYXZlIGFuIGBleGl0YCBwcm9wZXJ0eSBkZWZpbmVkIHdpbGwgYW5pbWF0ZSBvdXQgd2hlbiByZW1vdmVkIGZyb21cbiAqIHRoZSB0cmVlLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgbW90aW9uLCBBbmltYXRlUHJlc2VuY2UgfSBmcm9tICdmcmFtZXItbW90aW9uJ1xuICpcbiAqIGV4cG9ydCBjb25zdCBJdGVtcyA9ICh7IGl0ZW1zIH0pID0+IChcbiAqICAgPEFuaW1hdGVQcmVzZW5jZT5cbiAqICAgICB7aXRlbXMubWFwKGl0ZW0gPT4gKFxuICogICAgICAgPG1vdGlvbi5kaXZcbiAqICAgICAgICAga2V5PXtpdGVtLmlkfVxuICogICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAgfX1cbiAqICAgICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxIH19XG4gKiAgICAgICAgIGV4aXQ9e3sgb3BhY2l0eTogMCB9fVxuICogICAgICAgLz5cbiAqICAgICApKX1cbiAqICAgPC9BbmltYXRlUHJlc2VuY2U+XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIHNlcXVlbmNlIGV4aXQgYW5pbWF0aW9ucyB0aHJvdWdob3V0IGEgdHJlZSB1c2luZyB2YXJpYW50cy5cbiAqXG4gKiBJZiBhIGNoaWxkIGNvbnRhaW5zIG11bHRpcGxlIGBtb3Rpb25gIGNvbXBvbmVudHMgd2l0aCBgZXhpdGAgcHJvcHMsIGl0IHdpbGwgb25seSB1bm1vdW50IHRoZSBjaGlsZFxuICogb25jZSBhbGwgYG1vdGlvbmAgY29tcG9uZW50cyBoYXZlIGZpbmlzaGVkIGFuaW1hdGluZyBvdXQuIExpa2V3aXNlLCBhbnkgY29tcG9uZW50cyB1c2luZ1xuICogYHVzZVByZXNlbmNlYCBhbGwgbmVlZCB0byBjYWxsIGBzYWZlVG9SZW1vdmVgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIEFuaW1hdGVQcmVzZW5jZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjdXN0b20gPSBfYS5jdXN0b20sIF9iID0gX2EuaW5pdGlhbCwgaW5pdGlhbCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIG9uRXhpdENvbXBsZXRlID0gX2Eub25FeGl0Q29tcGxldGUsIGV4aXRCZWZvcmVFbnRlciA9IF9hLmV4aXRCZWZvcmVFbnRlciwgX2MgPSBfYS5wcmVzZW5jZUFmZmVjdHNMYXlvdXQsIHByZXNlbmNlQWZmZWN0c0xheW91dCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2M7XG4gICAgLy8gV2Ugd2FudCB0byBmb3JjZSBhIHJlLXJlbmRlciBvbmNlIGFsbCBleGl0aW5nIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZC4gV2VcbiAgICAvLyBlaXRoZXIgdXNlIGEgbG9jYWwgZm9yY2VSZW5kZXIgZnVuY3Rpb24sIG9yIG9uZSBmcm9tIGEgcGFyZW50IGNvbnRleHQgaWYgaXQgZXhpc3RzLlxuICAgIHZhciBfZCA9IHRzbGliLl9fcmVhZCh1c2VGb3JjZVVwZGF0ZSgpLCAxKSwgZm9yY2VSZW5kZXIgPSBfZFswXTtcbiAgICB2YXIgZm9yY2VSZW5kZXJMYXlvdXRHcm91cCA9IFJlYWN0LnVzZUNvbnRleHQoTGF5b3V0R3JvdXBDb250ZXh0KS5mb3JjZVJlbmRlcjtcbiAgICBpZiAoZm9yY2VSZW5kZXJMYXlvdXRHcm91cClcbiAgICAgICAgZm9yY2VSZW5kZXIgPSBmb3JjZVJlbmRlckxheW91dEdyb3VwO1xuICAgIHZhciBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBjaGlsZHJlbiB0aGF0IGFyZW4ndCBSZWFjdEVsZW1lbnRzLiBXZSBjYW4gb25seSB0cmFjayBSZWFjdEVsZW1lbnRzIHdpdGggYSBwcm9wcy5rZXlcbiAgICB2YXIgZmlsdGVyZWRDaGlsZHJlbiA9IG9ubHlFbGVtZW50cyhjaGlsZHJlbik7XG4gICAgdmFyIGNoaWxkcmVuVG9SZW5kZXIgPSBmaWx0ZXJlZENoaWxkcmVuO1xuICAgIHZhciBleGl0aW5nID0gbmV3IFNldCgpO1xuICAgIC8vIEtlZXAgYSBsaXZpbmcgcmVjb3JkIG9mIHRoZSBjaGlsZHJlbiB3ZSdyZSBhY3R1YWxseSByZW5kZXJpbmcgc28gd2VcbiAgICAvLyBjYW4gZGlmZiB0byBmaWd1cmUgb3V0IHdoaWNoIGFyZSBlbnRlcmluZyBhbmQgZXhpdGluZ1xuICAgIHZhciBwcmVzZW50Q2hpbGRyZW4gPSBSZWFjdC51c2VSZWYoY2hpbGRyZW5Ub1JlbmRlcik7XG4gICAgLy8gQSBsb29rdXAgdGFibGUgdG8gcXVpY2tseSByZWZlcmVuY2UgY29tcG9uZW50cyBieSBrZXlcbiAgICB2YXIgYWxsQ2hpbGRyZW4gPSBSZWFjdC51c2VSZWYobmV3IE1hcCgpKS5jdXJyZW50O1xuICAgIC8vIElmIHRoaXMgaXMgdGhlIGluaXRpYWwgY29tcG9uZW50IHJlbmRlciwganVzdCBkZWFsIHdpdGggbG9naWMgc3Vycm91bmRpbmcgd2hldGhlclxuICAgIC8vIHdlIHBsYXkgb25Nb3VudCBhbmltYXRpb25zIG9yIG5vdC5cbiAgICB2YXIgaXNJbml0aWFsUmVuZGVyID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpc0luaXRpYWxSZW5kZXIuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB1cGRhdGVDaGlsZExvb2t1cChmaWx0ZXJlZENoaWxkcmVuLCBhbGxDaGlsZHJlbik7XG4gICAgICAgIHByZXNlbnRDaGlsZHJlbi5jdXJyZW50ID0gY2hpbGRyZW5Ub1JlbmRlcjtcbiAgICB9KTtcbiAgICB1c2VVbm1vdW50RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNJbml0aWFsUmVuZGVyLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBhbGxDaGlsZHJlbi5jbGVhcigpO1xuICAgICAgICBleGl0aW5nLmNsZWFyKCk7XG4gICAgfSk7XG4gICAgaWYgKGlzSW5pdGlhbFJlbmRlci5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuVG9SZW5kZXIubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQcmVzZW5jZUNoaWxkLCB7IGtleTogZ2V0Q2hpbGRLZXkoY2hpbGQpLCBpc1ByZXNlbnQ6IHRydWUsIGluaXRpYWw6IGluaXRpYWwgPyB1bmRlZmluZWQgOiBmYWxzZSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0OiBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgfSwgY2hpbGQpKTsgfSkpKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyBhIHN1YnNlcXVlbnQgcmVuZGVyLCBkZWFsIHdpdGggZW50ZXJpbmcgYW5kIGV4aXRpbmcgY2hpbGRyZW5cbiAgICBjaGlsZHJlblRvUmVuZGVyID0gdHNsaWIuX19zcHJlYWRBcnJheShbXSwgdHNsaWIuX19yZWFkKGNoaWxkcmVuVG9SZW5kZXIpLCBmYWxzZSk7XG4gICAgLy8gRGlmZiB0aGUga2V5cyBvZiB0aGUgY3VycmVudGx5LXByZXNlbnQgYW5kIHRhcmdldCBjaGlsZHJlbiB0byB1cGRhdGUgb3VyXG4gICAgLy8gZXhpdGluZyBsaXN0LlxuICAgIHZhciBwcmVzZW50S2V5cyA9IHByZXNlbnRDaGlsZHJlbi5jdXJyZW50Lm1hcChnZXRDaGlsZEtleSk7XG4gICAgdmFyIHRhcmdldEtleXMgPSBmaWx0ZXJlZENoaWxkcmVuLm1hcChnZXRDaGlsZEtleSk7XG4gICAgLy8gRGlmZiB0aGUgcHJlc2VudCBjaGlsZHJlbiB3aXRoIG91ciB0YXJnZXQgY2hpbGRyZW4gYW5kIG1hcmsgdGhvc2UgdGhhdCBhcmUgZXhpdGluZ1xuICAgIHZhciBudW1QcmVzZW50ID0gcHJlc2VudEtleXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUHJlc2VudDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcmVzZW50S2V5c1tpXTtcbiAgICAgICAgaWYgKHRhcmdldEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgZXhpdGluZy5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB3ZSBjdXJyZW50bHkgaGF2ZSBleGl0aW5nIGNoaWxkcmVuLCBhbmQgd2UncmUgZGVmZXJyaW5nIHJlbmRlcmluZyBpbmNvbWluZyBjaGlsZHJlblxuICAgIC8vIHVudGlsIGFmdGVyIGFsbCBjdXJyZW50IGNoaWxkcmVuIGhhdmUgZXhpdGluZywgZW1wdHkgdGhlIGNoaWxkcmVuVG9SZW5kZXIgYXJyYXlcbiAgICBpZiAoZXhpdEJlZm9yZUVudGVyICYmIGV4aXRpbmcuc2l6ZSkge1xuICAgICAgICBjaGlsZHJlblRvUmVuZGVyID0gW107XG4gICAgfVxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgY3VycmVudGx5IGV4aXRpbmcgY29tcG9uZW50cyBhbmQgY2xvbmUgdGhlbSB0byBvdmVyd3JpdGUgYGFuaW1hdGVgXG4gICAgLy8gd2l0aCBhbnkgYGV4aXRgIHByb3AgdGhleSBtaWdodCBoYXZlIGRlZmluZWQuXG4gICAgZXhpdGluZy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBjb21wb25lbnQgaXMgYWN0dWFsbHkgZW50ZXJpbmcgYWdhaW4sIGVhcmx5IHJldHVyblxuICAgICAgICBpZiAodGFyZ2V0S2V5cy5pbmRleE9mKGtleSkgIT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgY2hpbGQgPSBhbGxDaGlsZHJlbi5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGluc2VydGlvbkluZGV4ID0gcHJlc2VudEtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICB2YXIgb25FeGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWxsQ2hpbGRyZW4uZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBleGl0aW5nLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgY2hpbGQgZnJvbSB0aGUgcHJlc2VudCBjaGlsZHJlblxuICAgICAgICAgICAgdmFyIHJlbW92ZUluZGV4ID0gcHJlc2VudENoaWxkcmVuLmN1cnJlbnQuZmluZEluZGV4KGZ1bmN0aW9uIChwcmVzZW50Q2hpbGQpIHsgcmV0dXJuIHByZXNlbnRDaGlsZC5rZXkgPT09IGtleTsgfSk7XG4gICAgICAgICAgICBwcmVzZW50Q2hpbGRyZW4uY3VycmVudC5zcGxpY2UocmVtb3ZlSW5kZXgsIDEpO1xuICAgICAgICAgICAgLy8gRGVmZXIgcmUtcmVuZGVyaW5nIHVudGlsIGFsbCBleGl0aW5nIGNoaWxkcmVuIGhhdmUgaW5kZWVkIGxlZnRcbiAgICAgICAgICAgIGlmICghZXhpdGluZy5zaXplKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudENoaWxkcmVuLmN1cnJlbnQgPSBmaWx0ZXJlZENoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIG9uRXhpdENvbXBsZXRlICYmIG9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkcmVuVG9SZW5kZXIuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUHJlc2VuY2VDaGlsZCwgeyBrZXk6IGdldENoaWxkS2V5KGNoaWxkKSwgaXNQcmVzZW50OiBmYWxzZSwgb25FeGl0Q29tcGxldGU6IG9uRXhpdCwgY3VzdG9tOiBjdXN0b20sIHByZXNlbmNlQWZmZWN0c0xheW91dDogcHJlc2VuY2VBZmZlY3RzTGF5b3V0IH0sIGNoaWxkKSk7XG4gICAgfSk7XG4gICAgLy8gQWRkIGBNb3Rpb25Db250ZXh0YCBldmVuIHRvIGNoaWxkcmVuIHRoYXQgZG9uJ3QgbmVlZCBpdCB0byBlbnN1cmUgd2UncmUgcmVuZGVyaW5nXG4gICAgLy8gdGhlIHNhbWUgdHJlZSBiZXR3ZWVuIHJlbmRlcnNcbiAgICBjaGlsZHJlblRvUmVuZGVyID0gY2hpbGRyZW5Ub1JlbmRlci5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgIHJldHVybiBleGl0aW5nLmhhcyhrZXkpID8gKGNoaWxkKSA6IChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUHJlc2VuY2VDaGlsZCwgeyBrZXk6IGdldENoaWxkS2V5KGNoaWxkKSwgaXNQcmVzZW50OiB0cnVlLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQ6IHByZXNlbmNlQWZmZWN0c0xheW91dCB9LCBjaGlsZCkpO1xuICAgIH0pO1xuICAgIGlmIChlbnYgIT09IFwicHJvZHVjdGlvblwiICYmXG4gICAgICAgIGV4aXRCZWZvcmVFbnRlciAmJlxuICAgICAgICBjaGlsZHJlblRvUmVuZGVyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiWW91J3JlIGF0dGVtcHRpbmcgdG8gYW5pbWF0ZSBtdWx0aXBsZSBjaGlsZHJlbiB3aXRoaW4gQW5pbWF0ZVByZXNlbmNlLCBidXQgaXRzIGV4aXRCZWZvcmVFbnRlciBwcm9wIGlzIHNldCB0byB0cnVlLiBUaGlzIHdpbGwgbGVhZCB0byBvZGQgdmlzdWFsIGJlaGF2aW91ci5cIik7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIGV4aXRpbmcuc2l6ZVxuICAgICAgICA/IGNoaWxkcmVuVG9SZW5kZXJcbiAgICAgICAgOiBjaGlsZHJlblRvUmVuZGVyLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCk7IH0pKSk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbnZhciBEZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuICFub2RlLmlzTGF5b3V0RGlydHkgJiYgbm9kZS53aWxsVXBkYXRlKGZhbHNlKTtcbn07XG5mdW5jdGlvbiBub2RlR3JvdXAoKSB7XG4gICAgdmFyIG5vZGVzID0gbmV3IFNldCgpO1xuICAgIHZhciBzdWJzY3JpcHRpb25zID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgZGlydHlBbGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBub2Rlcy5mb3JFYWNoKG5vdGlmeSk7IH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zZXQobm9kZSwgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwid2lsbFVwZGF0ZVwiLCBkaXJ0eUFsbCkpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBub2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICAoX2EgPSBzdWJzY3JpcHRpb25zLmdldChub2RlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKCk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgIGRpcnR5QWxsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpcnR5OiBkaXJ0eUFsbCxcbiAgICB9O1xufVxuXG52YXIgc2hvdWxkSW5oZXJpdEdyb3VwID0gZnVuY3Rpb24gKGluaGVyaXQpIHsgcmV0dXJuIGluaGVyaXQgPT09IHRydWU7IH07XG52YXIgc2hvdWxkSW5oZXJpdElkID0gZnVuY3Rpb24gKGluaGVyaXQpIHtcbiAgICByZXR1cm4gc2hvdWxkSW5oZXJpdEdyb3VwKGluaGVyaXQgPT09IHRydWUpIHx8IGluaGVyaXQgPT09IFwiaWRcIjtcbn07XG52YXIgTGF5b3V0R3JvdXAgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpZCA9IF9hLmlkLCBpbmhlcml0SWQgPSBfYS5pbmhlcml0SWQsIF9kID0gX2EuaW5oZXJpdCwgaW5oZXJpdCA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2Q7XG4gICAgLy8gTWFpbnRhaW4gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCBpbmhlcml0SWQgdW50aWwgNy4wXG4gICAgaWYgKGluaGVyaXRJZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBpbmhlcml0ID0gaW5oZXJpdElkO1xuICAgIHZhciBsYXlvdXRHcm91cENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KExheW91dEdyb3VwQ29udGV4dCk7XG4gICAgdmFyIGRlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIHZhciBfZSA9IHRzbGliLl9fcmVhZCh1c2VGb3JjZVVwZGF0ZSgpLCAyKSwgZm9yY2VSZW5kZXIgPSBfZVswXSwga2V5ID0gX2VbMV07XG4gICAgdmFyIGNvbnRleHQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIHVwc3RyZWFtSWQgPSAoX2IgPSBsYXlvdXRHcm91cENvbnRleHQuaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQ7XG4gICAgaWYgKGNvbnRleHQuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkSW5oZXJpdElkKGluaGVyaXQpICYmIHVwc3RyZWFtSWQpIHtcbiAgICAgICAgICAgIGlkID0gaWQgPyB1cHN0cmVhbUlkICsgXCItXCIgKyBpZCA6IHVwc3RyZWFtSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZ3JvdXA6IHNob3VsZEluaGVyaXRHcm91cChpbmhlcml0KVxuICAgICAgICAgICAgICAgID8gKF9jID0gbGF5b3V0R3JvdXBDb250ZXh0ID09PSBudWxsIHx8IGxheW91dEdyb3VwQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0R3JvdXBDb250ZXh0Lmdyb3VwKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBub2RlR3JvdXAoKVxuICAgICAgICAgICAgICAgIDogbm9kZUdyb3VwKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBtZW1vaXplZENvbnRleHQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgY29udGV4dC5jdXJyZW50KSwgeyBmb3JjZVJlbmRlcjogZm9yY2VSZW5kZXIgfSkpOyB9LCBba2V5XSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTGF5b3V0R3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBtZW1vaXplZENvbnRleHQgfSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBpZCA9IDA7XG52YXIgQW5pbWF0ZVNoYXJlZExheW91dCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGV5TGlzdGVuLndhcm5pbmcoZmFsc2UsIFwiQW5pbWF0ZVNoYXJlZExheW91dCBpcyBkZXByZWNhdGVkOiBodHRwczovL3d3dy5mcmFtZXIuY29tL2RvY3MvZ3VpZGUtdXBncmFkZS8jI3NoYXJlZC1sYXlvdXQtYW5pbWF0aW9uc1wiKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTGF5b3V0R3JvdXAsIHsgaWQ6IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiYXNsLVwiLmNvbmNhdChpZCsrKTsgfSkgfSwgY2hpbGRyZW4pKTtcbn07XG5cbi8qKlxuICogYE1vdGlvbkNvbmZpZ2AgaXMgdXNlZCB0byBzZXQgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBhbGwgY2hpbGRyZW4gYG1vdGlvbmAgY29tcG9uZW50cy5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IG1vdGlvbiwgTW90aW9uQ29uZmlnIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGV4cG9ydCBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPE1vdGlvbkNvbmZpZyB0cmFuc2l0aW9uPXt7IHR5cGU6IFwic3ByaW5nXCIgfX0+XG4gKiAgICAgICA8bW90aW9uLmRpdiBhbmltYXRlPXt7IHg6IDEwMCB9fSAvPlxuICogICAgIDwvTW90aW9uQ29uZmlnPlxuICogICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIE1vdGlvbkNvbmZpZyhfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpc1ZhbGlkUHJvcCA9IF9hLmlzVmFsaWRQcm9wLCBjb25maWcgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiaXNWYWxpZFByb3BcIl0pO1xuICAgIGlzVmFsaWRQcm9wICYmIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wKGlzVmFsaWRQcm9wKTtcbiAgICAvKipcbiAgICAgKiBJbmhlcml0IHByb3BzIGZyb20gYW55IHBhcmVudCBNb3Rpb25Db25maWcgY29tcG9uZW50c1xuICAgICAqL1xuICAgIGNvbmZpZyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpKSwgY29uZmlnKTtcbiAgICAvKipcbiAgICAgKiBEb24ndCBhbGxvdyBpc1N0YXRpYyB0byBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzIGFzIGl0IGFmZmVjdHMgaG93IG1hbnkgaG9va3NcbiAgICAgKiBtb3Rpb24gY29tcG9uZW50cyBmaXJlLlxuICAgICAqL1xuICAgIGNvbmZpZy5pc1N0YXRpYyA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZy5pc1N0YXRpYzsgfSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRpbmcgYSBuZXcgY29uZmlnIGNvbnRleHQgb2JqZWN0IHdpbGwgcmUtcmVuZGVyIGV2ZXJ5IGBtb3Rpb25gIGNvbXBvbmVudFxuICAgICAqIGV2ZXJ5IHRpbWUgaXQgcmVuZGVycy4gU28gd2Ugb25seSB3YW50IHRvIGNyZWF0ZSBhIG5ldyBvbmUgc3BhcmluZ2x5LlxuICAgICAqL1xuICAgIHZhciBjb250ZXh0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH0sIFtKU09OLnN0cmluZ2lmeShjb25maWcudHJhbnNpdGlvbiksIGNvbmZpZy50cmFuc2Zvcm1QYWdlUG9pbnQsIGNvbmZpZy5yZWR1Y2VkTW90aW9uXSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTW90aW9uQ29uZmlnQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCBjaGlsZHJlbikpO1xufVxuXG4vKipcbiAqIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYG1gIGNvbXBvbmVudCB0byByZWR1Y2UgYnVuZGxlIHNpemUuXG4gKlxuICogYG1gIGlzIGEgdmVyc2lvbiBvZiB0aGUgYG1vdGlvbmAgY29tcG9uZW50IHRoYXQgb25seSBsb2FkcyBmdW5jdGlvbmFsaXR5XG4gKiBjcml0aWNhbCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICpcbiAqIGBMYXp5TW90aW9uYCBjYW4gdGhlbiBiZSB1c2VkIHRvIGVpdGhlciBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm91c2x5XG4gKiBsb2FkIGFuaW1hdGlvbiBhbmQgZ2VzdHVyZSBzdXBwb3J0LlxuICpcbiAqIGBgYGpzeFxuICogLy8gU3luY2hyb25vdXMgbG9hZGluZ1xuICogaW1wb3J0IHsgTGF6eU1vdGlvbiwgbSwgZG9tQW5pbWF0aW9ucyB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPExhenlNb3Rpb24gZmVhdHVyZXM9e2RvbUFuaW1hdGlvbnN9PlxuICogICAgICAgPG0uZGl2IGFuaW1hdGU9e3sgc2NhbGU6IDIgfX0gLz5cbiAqICAgICA8L0xhenlNb3Rpb24+XG4gKiAgIClcbiAqIH1cbiAqXG4gKiAvLyBBc3luY2hyb25vdXMgbG9hZGluZ1xuICogaW1wb3J0IHsgTGF6eU1vdGlvbiwgbSB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPExhenlNb3Rpb24gZmVhdHVyZXM9eygpID0+IGltcG9ydCgnLi9wYXRoL3RvL2RvbUFuaW1hdGlvbnMnKX0+XG4gKiAgICAgICA8bS5kaXYgYW5pbWF0ZT17eyBzY2FsZTogMiB9fSAvPlxuICogICAgIDwvTGF6eU1vdGlvbj5cbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBMYXp5TW90aW9uKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGZlYXR1cmVzID0gX2EuZmVhdHVyZXMsIF9iID0gX2Euc3RyaWN0LCBzdHJpY3QgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgICB2YXIgX2MgPSB0c2xpYi5fX3JlYWQoUmVhY3QudXNlU3RhdGUoIWlzTGF6eUJ1bmRsZShmZWF0dXJlcykpLCAyKSwgc2V0SXNMb2FkZWQgPSBfY1sxXTtcbiAgICB2YXIgbG9hZGVkUmVuZGVyZXIgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGlzIGEgc3luY2hyb25vdXMgbG9hZCwgbG9hZCBmZWF0dXJlcyBpbW1lZGlhdGVseVxuICAgICAqL1xuICAgIGlmICghaXNMYXp5QnVuZGxlKGZlYXR1cmVzKSkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBmZWF0dXJlcy5yZW5kZXJlciwgbG9hZGVkRmVhdHVyZXMgPSB0c2xpYi5fX3Jlc3QoZmVhdHVyZXMsIFtcInJlbmRlcmVyXCJdKTtcbiAgICAgICAgbG9hZGVkUmVuZGVyZXIuY3VycmVudCA9IHJlbmRlcmVyO1xuICAgICAgICBsb2FkRmVhdHVyZXMobG9hZGVkRmVhdHVyZXMpO1xuICAgIH1cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNMYXp5QnVuZGxlKGZlYXR1cmVzKSkge1xuICAgICAgICAgICAgZmVhdHVyZXMoKS50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciByZW5kZXJlciA9IF9hLnJlbmRlcmVyLCBsb2FkZWRGZWF0dXJlcyA9IHRzbGliLl9fcmVzdChfYSwgW1wicmVuZGVyZXJcIl0pO1xuICAgICAgICAgICAgICAgIGxvYWRGZWF0dXJlcyhsb2FkZWRGZWF0dXJlcyk7XG4gICAgICAgICAgICAgICAgbG9hZGVkUmVuZGVyZXIuY3VycmVudCA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGVkKHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTGF6eUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgcmVuZGVyZXI6IGxvYWRlZFJlbmRlcmVyLmN1cnJlbnQsIHN0cmljdDogc3RyaWN0IH0gfSwgY2hpbGRyZW4pKTtcbn1cbmZ1bmN0aW9uIGlzTGF6eUJ1bmRsZShmZWF0dXJlcykge1xuICAgIHJldHVybiB0eXBlb2YgZmVhdHVyZXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxudmFyIFJlb3JkZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gY2hlY2tSZW9yZGVyKG9yZGVyLCB2YWx1ZSwgb2Zmc2V0LCB2ZWxvY2l0eSkge1xuICAgIGlmICghdmVsb2NpdHkpXG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB2YXIgaW5kZXggPSBvcmRlci5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0udmFsdWUgPT09IHZhbHVlOyB9KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgdmFyIG5leHRPZmZzZXQgPSB2ZWxvY2l0eSA+IDAgPyAxIDogLTE7XG4gICAgdmFyIG5leHRJdGVtID0gb3JkZXJbaW5kZXggKyBuZXh0T2Zmc2V0XTtcbiAgICBpZiAoIW5leHRJdGVtKVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgdmFyIGl0ZW0gPSBvcmRlcltpbmRleF07XG4gICAgdmFyIG5leHRMYXlvdXQgPSBuZXh0SXRlbS5sYXlvdXQ7XG4gICAgdmFyIG5leHRJdGVtQ2VudGVyID0gcG9wbW90aW9uLm1peChuZXh0TGF5b3V0Lm1pbiwgbmV4dExheW91dC5tYXgsIDAuNSk7XG4gICAgaWYgKChuZXh0T2Zmc2V0ID09PSAxICYmIGl0ZW0ubGF5b3V0Lm1heCArIG9mZnNldCA+IG5leHRJdGVtQ2VudGVyKSB8fFxuICAgICAgICAobmV4dE9mZnNldCA9PT0gLTEgJiYgaXRlbS5sYXlvdXQubWluICsgb2Zmc2V0IDwgbmV4dEl0ZW1DZW50ZXIpKSB7XG4gICAgICAgIHJldHVybiBtb3ZlSXRlbShvcmRlciwgaW5kZXgsIGluZGV4ICsgbmV4dE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBvcmRlcjtcbn1cblxuZnVuY3Rpb24gUmVvcmRlckdyb3VwKF9hLCBleHRlcm5hbFJlZikge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBfYiA9IF9hLmFzLCBhcyA9IF9iID09PSB2b2lkIDAgPyBcInVsXCIgOiBfYiwgX2MgPSBfYS5heGlzLCBheGlzID0gX2MgPT09IHZvaWQgMCA/IFwieVwiIDogX2MsIG9uUmVvcmRlciA9IF9hLm9uUmVvcmRlciwgdmFsdWVzID0gX2EudmFsdWVzLCBwcm9wcyA9IHRzbGliLl9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJhc1wiLCBcImF4aXNcIiwgXCJvblJlb3JkZXJcIiwgXCJ2YWx1ZXNcIl0pO1xuICAgIHZhciBDb21wb25lbnQgPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7IHJldHVybiBtb3Rpb24oYXMpOyB9KTtcbiAgICB2YXIgb3JkZXIgPSBbXTtcbiAgICB2YXIgaXNSZW9yZGVyaW5nID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICBoZXlMaXN0ZW4uaW52YXJpYW50KEJvb2xlYW4odmFsdWVzKSwgXCJSZW9yZGVyLkdyb3VwIG11c3QgYmUgcHJvdmlkZWQgYSB2YWx1ZXMgcHJvcFwiKTtcbiAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgYXhpczogYXhpcyxcbiAgICAgICAgcmVnaXN0ZXJJdGVtOiBmdW5jdGlvbiAodmFsdWUsIGxheW91dCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbnN1cmUgZW50cmllcyBjYW4ndCBhZGQgdGhlbXNlbHZlcyBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobGF5b3V0ICYmXG4gICAgICAgICAgICAgICAgb3JkZXIuZmluZEluZGV4KGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gdmFsdWUgPT09IGVudHJ5LnZhbHVlOyB9KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvcmRlci5wdXNoKHsgdmFsdWU6IHZhbHVlLCBsYXlvdXQ6IGxheW91dFtheGlzXSB9KTtcbiAgICAgICAgICAgICAgICBvcmRlci5zb3J0KGNvbXBhcmVNaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVPcmRlcjogZnVuY3Rpb24gKGlkLCBvZmZzZXQsIHZlbG9jaXR5KSB7XG4gICAgICAgICAgICBpZiAoaXNSZW9yZGVyaW5nLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG5ld09yZGVyID0gY2hlY2tSZW9yZGVyKG9yZGVyLCBpZCwgb2Zmc2V0LCB2ZWxvY2l0eSk7XG4gICAgICAgICAgICBpZiAob3JkZXIgIT09IG5ld09yZGVyKSB7XG4gICAgICAgICAgICAgICAgaXNSZW9yZGVyaW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9uUmVvcmRlcihuZXdPcmRlclxuICAgICAgICAgICAgICAgICAgICAubWFwKGdldFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWVzLmluZGV4T2YodmFsdWUpICE9PSAtMTsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNSZW9yZGVyaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHRzbGliLl9fYXNzaWduKHt9LCBwcm9wcywgeyByZWY6IGV4dGVybmFsUmVmIH0pLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVvcmRlckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgY2hpbGRyZW4pKSk7XG59XG52YXIgR3JvdXAgPSBSZWFjdC5mb3J3YXJkUmVmKFJlb3JkZXJHcm91cCk7XG5mdW5jdGlvbiBnZXRWYWx1ZShpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0udmFsdWU7XG59XG5mdW5jdGlvbiBjb21wYXJlTWluKGEsIGIpIHtcbiAgICByZXR1cm4gYS5sYXlvdXQubWluIC0gYi5sYXlvdXQubWluO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgTW90aW9uVmFsdWVgIHRvIHRyYWNrIHRoZSBzdGF0ZSBhbmQgdmVsb2NpdHkgb2YgYSB2YWx1ZS5cbiAqXG4gKiBVc3VhbGx5LCB0aGVzZSBhcmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5LiBGb3IgYWR2YW5jZWQgdXNlLWNhc2VzLCBsaWtlIHVzZSB3aXRoIGB1c2VUcmFuc2Zvcm1gLCB5b3UgY2FuIGNyZWF0ZSBgTW90aW9uVmFsdWVgcyBleHRlcm5hbGx5IGFuZCBwYXNzIHRoZW0gaW50byB0aGUgYW5pbWF0ZWQgY29tcG9uZW50IHZpYSB0aGUgYHN0eWxlYCBwcm9wLlxuICpcbiAqIGBgYGpzeFxuICogZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBzY2FsZSA9IHVzZU1vdGlvblZhbHVlKDEpXG4gKlxuICogICByZXR1cm4gPG1vdGlvbi5kaXYgc3R5bGU9e3sgc2NhbGUgfX0gLz5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBpbml0aWFsIC0gVGhlIGluaXRpYWwgc3RhdGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VNb3Rpb25WYWx1ZShpbml0aWFsKSB7XG4gICAgdmFyIHZhbHVlID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbW90aW9uVmFsdWUoaW5pdGlhbCk7IH0pO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgbW90aW9uIHZhbHVlIGlzIGJlaW5nIHVzZWQgaW4gc3RhdGljIG1vZGUsIGxpa2Ugb25cbiAgICAgKiB0aGUgRnJhbWVyIGNhbnZhcywgZm9yY2UgY29tcG9uZW50cyB0byByZXJlbmRlciB3aGVuIHRoZSBtb3Rpb25cbiAgICAgKiB2YWx1ZSBpcyB1cGRhdGVkLlxuICAgICAqL1xuICAgIHZhciBpc1N0YXRpYyA9IFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCkuaXNTdGF0aWM7XG4gICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgIHZhciBfYSA9IHRzbGliLl9fcmVhZChSZWFjdC51c2VTdGF0ZShpbml0aWFsKSwgMiksIHNldExhdGVzdF8xID0gX2FbMV07XG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZS5vbkNoYW5nZShzZXRMYXRlc3RfMSk7IH0sIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgaXNDdXN0b21WYWx1ZVR5cGUgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2Lm1peDtcbn07XG52YXIgZ2V0TWl4ZXIgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKGlzQ3VzdG9tVmFsdWVUeXBlKHYpID8gdi5taXggOiB1bmRlZmluZWQpOyB9O1xuZnVuY3Rpb24gdHJhbnNmb3JtKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgdXNlSW1tZWRpYXRlID0gIUFycmF5LmlzQXJyYXkoYXJnc1swXSk7XG4gICAgdmFyIGFyZ09mZnNldCA9IHVzZUltbWVkaWF0ZSA/IDAgOiAtMTtcbiAgICB2YXIgaW5wdXRWYWx1ZSA9IGFyZ3NbMCArIGFyZ09mZnNldF07XG4gICAgdmFyIGlucHV0UmFuZ2UgPSBhcmdzWzEgKyBhcmdPZmZzZXRdO1xuICAgIHZhciBvdXRwdXRSYW5nZSA9IGFyZ3NbMiArIGFyZ09mZnNldF07XG4gICAgdmFyIG9wdGlvbnMgPSBhcmdzWzMgKyBhcmdPZmZzZXRdO1xuICAgIHZhciBpbnRlcnBvbGF0b3IgPSBwb3Btb3Rpb24uaW50ZXJwb2xhdGUoaW5wdXRSYW5nZSwgb3V0cHV0UmFuZ2UsIHRzbGliLl9fYXNzaWduKHsgbWl4ZXI6IGdldE1peGVyKG91dHB1dFJhbmdlWzBdKSB9LCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIHVzZUltbWVkaWF0ZSA/IGludGVycG9sYXRvcihpbnB1dFZhbHVlKSA6IGludGVycG9sYXRvcjtcbn1cblxuZnVuY3Rpb24gdXNlT25DaGFuZ2UodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vbkNoYW5nZShjYWxsYmFjayk7XG4gICAgfSwgW2NhbGxiYWNrXSk7XG59XG5mdW5jdGlvbiB1c2VNdWx0aU9uQ2hhbmdlKHZhbHVlcywgaGFuZGxlcikge1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5vbkNoYW5nZShoYW5kbGVyKTsgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHVuc3Vic2NyaWJlKSB7IHJldHVybiB1bnN1YnNjcmliZSgpOyB9KTsgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlQ29tYmluZU1vdGlvblZhbHVlcyh2YWx1ZXMsIGNvbWJpbmVWYWx1ZXMpIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIHRoZSByZXR1cm5lZCBtb3Rpb24gdmFsdWUuIFRoaXMgcmVtYWlucyB0aGUgc2FtZSBiZXR3ZWVuIHJlbmRlcnMuXG4gICAgICovXG4gICAgdmFyIHZhbHVlID0gdXNlTW90aW9uVmFsdWUoY29tYmluZVZhbHVlcygpKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHdpbGwgdXBkYXRlIHRoZSB0ZW1wbGF0ZSBtb3Rpb24gdmFsdWUgd2l0aCB0aGUgbGF0ZXN0IHZhbHVlcy5cbiAgICAgKiBUaGlzIGlzIHByZS1ib3VuZCBzbyB3aGVuZXZlciBhIG1vdGlvbiB2YWx1ZSB1cGRhdGVzIGl0IGNhbiBzY2hlZHVsZSBpdHNcbiAgICAgKiBleGVjdXRpb24gaW4gRnJhbWVzeW5jLiBJZiBpdCdzIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgaXQgd29uJ3QgYmUgZmlyZWQgdHdpY2VcbiAgICAgKiBpbiBhIHNpbmdsZSBmcmFtZS5cbiAgICAgKi9cbiAgICB2YXIgdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZS5zZXQoY29tYmluZVZhbHVlcygpKTsgfTtcbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IHVwZGF0ZSB0aGUgbW90aW9uIHZhbHVlIHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMgZHVyaW5nIHRoZSByZW5kZXIuXG4gICAgICogVGhpcyBlbnN1cmVzIHRoYXQgd2l0aGluIGEgUmVhY3QgcmVuZGVyLCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIERPTSBhcmUgdXAtdG8tZGF0ZS5cbiAgICAgKi9cbiAgICB1cGRhdGVWYWx1ZSgpO1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBhbGwgbW90aW9uIHZhbHVlcyBmb3VuZCB3aXRoaW4gdGhlIHRlbXBsYXRlLiBXaGVuZXZlciBhbnkgb2YgdGhlbSBjaGFuZ2UsXG4gICAgICogc2NoZWR1bGUgYW4gdXBkYXRlLlxuICAgICAqL1xuICAgIHVzZU11bHRpT25DaGFuZ2UodmFsdWVzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS51cGRhdGUodXBkYXRlVmFsdWUsIGZhbHNlLCB0cnVlKTsgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2Zvcm0oaW5wdXQsIGlucHV0UmFuZ2VPclRyYW5zZm9ybWVyLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICAgIHZhciB0cmFuc2Zvcm1lciA9IHR5cGVvZiBpbnB1dFJhbmdlT3JUcmFuc2Zvcm1lciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXJcbiAgICAgICAgOiB0cmFuc2Zvcm0oaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXIsIG91dHB1dFJhbmdlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dClcbiAgICAgICAgPyB1c2VMaXN0VHJhbnNmb3JtKGlucHV0LCB0cmFuc2Zvcm1lcilcbiAgICAgICAgOiB1c2VMaXN0VHJhbnNmb3JtKFtpbnB1dF0sIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gdHNsaWIuX19yZWFkKF9hLCAxKSwgbGF0ZXN0ID0gX2JbMF07XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIobGF0ZXN0KTtcbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiB1c2VMaXN0VHJhbnNmb3JtKHZhbHVlcywgdHJhbnNmb3JtZXIpIHtcbiAgICB2YXIgbGF0ZXN0ID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0pO1xuICAgIHJldHVybiB1c2VDb21iaW5lTW90aW9uVmFsdWVzKHZhbHVlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICBsYXRlc3QubGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIG51bVZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVmFsdWVzOyBpKyspIHtcbiAgICAgICAgICAgIGxhdGVzdFtpXSA9IHZhbHVlc1tpXS5nZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIobGF0ZXN0KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlRGVmYXVsdE1vdGlvblZhbHVlKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB2b2lkIDApIHsgZGVmYXVsdFZhbHVlID0gMDsgfVxuICAgIHJldHVybiBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlIDogdXNlTW90aW9uVmFsdWUoZGVmYXVsdFZhbHVlKTtcbn1cbmZ1bmN0aW9uIFJlb3JkZXJJdGVtKF9hLCBleHRlcm5hbFJlZikge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBzdHlsZSA9IF9hLnN0eWxlLCB2YWx1ZSA9IF9hLnZhbHVlLCBfYiA9IF9hLmFzLCBhcyA9IF9iID09PSB2b2lkIDAgPyBcImxpXCIgOiBfYiwgb25EcmFnID0gX2Eub25EcmFnLCBfYyA9IF9hLmxheW91dCwgbGF5b3V0ID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgcHJvcHMgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwic3R5bGVcIiwgXCJ2YWx1ZVwiLCBcImFzXCIsIFwib25EcmFnXCIsIFwibGF5b3V0XCJdKTtcbiAgICB2YXIgQ29tcG9uZW50ID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbW90aW9uKGFzKTsgfSk7XG4gICAgdmFyIGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFJlb3JkZXJDb250ZXh0KTtcbiAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgIHg6IHVzZURlZmF1bHRNb3Rpb25WYWx1ZShzdHlsZSA9PT0gbnVsbCB8fCBzdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGUueCksXG4gICAgICAgIHk6IHVzZURlZmF1bHRNb3Rpb25WYWx1ZShzdHlsZSA9PT0gbnVsbCB8fCBzdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGUueSksXG4gICAgfTtcbiAgICB2YXIgekluZGV4ID0gdXNlVHJhbnNmb3JtKFtwb2ludC54LCBwb2ludC55XSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IHRzbGliLl9fcmVhZChfYSwgMiksIGxhdGVzdFggPSBfYlswXSwgbGF0ZXN0WSA9IF9iWzFdO1xuICAgICAgICByZXR1cm4gbGF0ZXN0WCB8fCBsYXRlc3RZID8gMSA6IFwidW5zZXRcIjtcbiAgICB9KTtcbiAgICB2YXIgbWVhc3VyZWRMYXlvdXQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgaGV5TGlzdGVuLmludmFyaWFudChCb29sZWFuKGNvbnRleHQpLCBcIlJlb3JkZXIuSXRlbSBtdXN0IGJlIGEgY2hpbGQgb2YgUmVvcmRlci5Hcm91cFwiKTtcbiAgICB2YXIgX2QgPSBjb250ZXh0LCBheGlzID0gX2QuYXhpcywgcmVnaXN0ZXJJdGVtID0gX2QucmVnaXN0ZXJJdGVtLCB1cGRhdGVPcmRlciA9IF9kLnVwZGF0ZU9yZGVyO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlZ2lzdGVySXRlbSh2YWx1ZSwgbWVhc3VyZWRMYXlvdXQuY3VycmVudCk7XG4gICAgfSwgW2NvbnRleHRdKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHRzbGliLl9fYXNzaWduKHsgZHJhZzogYXhpcyB9LCBwcm9wcywgeyBkcmFnU25hcFRvT3JpZ2luOiB0cnVlLCBzdHlsZTogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHN0eWxlKSwgeyB4OiBwb2ludC54LCB5OiBwb2ludC55LCB6SW5kZXg6IHpJbmRleCB9KSwgbGF5b3V0OiBsYXlvdXQsIG9uRHJhZzogZnVuY3Rpb24gKGV2ZW50LCBnZXN0dXJlUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IGdlc3R1cmVQb2ludC52ZWxvY2l0eTtcbiAgICAgICAgICAgIHZlbG9jaXR5W2F4aXNdICYmXG4gICAgICAgICAgICAgICAgdXBkYXRlT3JkZXIodmFsdWUsIHBvaW50W2F4aXNdLmdldCgpLCB2ZWxvY2l0eVtheGlzXSk7XG4gICAgICAgICAgICBvbkRyYWcgPT09IG51bGwgfHwgb25EcmFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRyYWcoZXZlbnQsIGdlc3R1cmVQb2ludCk7XG4gICAgICAgIH0sIG9uTGF5b3V0TWVhc3VyZTogZnVuY3Rpb24gKG1lYXN1cmVkKSB7XG4gICAgICAgICAgICBtZWFzdXJlZExheW91dC5jdXJyZW50ID0gbWVhc3VyZWQ7XG4gICAgICAgIH0sIHJlZjogZXh0ZXJuYWxSZWYgfSksIGNoaWxkcmVuKSk7XG59XG52YXIgSXRlbSA9IFJlYWN0LmZvcndhcmRSZWYoUmVvcmRlckl0ZW0pO1xuXG52YXIgUmVvcmRlciA9IHtcbiAgICBHcm91cDogR3JvdXAsXG4gICAgSXRlbTogSXRlbSxcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG52YXIgZG9tQW5pbWF0aW9uID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyByZW5kZXJlcjogY3JlYXRlRG9tVmlzdWFsRWxlbWVudCB9LCBhbmltYXRpb25zKSwgZ2VzdHVyZUFuaW1hdGlvbnMpO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xudmFyIGRvbU1heCA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBkb21BbmltYXRpb24pLCBkcmFnKSwgbGF5b3V0RmVhdHVyZXMpLCB7IHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3I6IEhUTUxQcm9qZWN0aW9uTm9kZSB9KTtcblxuLyoqXG4gKiBDb21iaW5lIG11bHRpcGxlIG1vdGlvbiB2YWx1ZXMgaW50byBhIG5ldyBvbmUgdXNpbmcgYSBzdHJpbmcgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7XG4gKiAgIG1vdGlvbixcbiAqICAgdXNlU3ByaW5nLFxuICogICB1c2VNb3Rpb25WYWx1ZSxcbiAqICAgdXNlTW90aW9uVGVtcGxhdGVcbiAqIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGZ1bmN0aW9uIENvbXBvbmVudCgpIHtcbiAqICAgY29uc3Qgc2hhZG93WCA9IHVzZVNwcmluZygwKVxuICogICBjb25zdCBzaGFkb3dZID0gdXNlTW90aW9uVmFsdWUoMClcbiAqICAgY29uc3Qgc2hhZG93ID0gdXNlTW90aW9uVGVtcGxhdGVgZHJvcC1zaGFkb3coJHtzaGFkb3dYfXB4ICR7c2hhZG93WX1weCAyMHB4IHJnYmEoMCwwLDAsMC4zKSlgXG4gKlxuICogICByZXR1cm4gPG1vdGlvbi5kaXYgc3R5bGU9e3sgZmlsdGVyOiBzaGFkb3cgfX0gLz5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlTW90aW9uVGVtcGxhdGUoZnJhZ21lbnRzKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhbHVlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJ1aWxkIGEgc3RyaW5nIGZyb20gdGhlIGxhdGVzdCBtb3Rpb24gdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBudW1GcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIGJ1aWxkVmFsdWUoKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUZyYWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSB2YWx1ZXNbaV0uZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgcmV0dXJuIHVzZUNvbWJpbmVNb3Rpb25WYWx1ZXModmFsdWVzLCBidWlsZFZhbHVlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYE1vdGlvblZhbHVlYCB0aGF0LCB3aGVuIGBzZXRgLCB3aWxsIHVzZSBhIHNwcmluZyBhbmltYXRpb24gdG8gYW5pbWF0ZSB0byBpdHMgbmV3IHN0YXRlLlxuICpcbiAqIEl0IGNhbiBlaXRoZXIgd29yayBhcyBhIHN0YW5kLWFsb25lIGBNb3Rpb25WYWx1ZWAgYnkgaW5pdGlhbGlzaW5nIGl0IHdpdGggYSB2YWx1ZSwgb3IgYXMgYSBzdWJzY3JpYmVyXG4gKiB0byBhbm90aGVyIGBNb3Rpb25WYWx1ZWAuXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBgYGBqc3hcbiAqIGNvbnN0IHggPSB1c2VTcHJpbmcoMCwgeyBzdGlmZm5lc3M6IDMwMCB9KVxuICogY29uc3QgeSA9IHVzZVNwcmluZyh4LCB7IGRhbXBpbmc6IDEwIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaW5wdXRWYWx1ZSAtIGBNb3Rpb25WYWx1ZWAgb3IgbnVtYmVyLiBJZiBwcm92aWRlZCBhIGBNb3Rpb25WYWx1ZWAsIHdoZW4gdGhlIGlucHV0IGBNb3Rpb25WYWx1ZWAgY2hhbmdlcywgdGhlIGNyZWF0ZWQgYE1vdGlvblZhbHVlYCB3aWxsIHNwcmluZyB0b3dhcmRzIHRoYXQgdmFsdWUuXG4gKiBAcGFyYW0gc3ByaW5nQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgc3ByaW5nLlxuICogQHJldHVybnMgYE1vdGlvblZhbHVlYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlU3ByaW5nKHNvdXJjZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgdmFyIGlzU3RhdGljID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KS5pc1N0YXRpYztcbiAgICB2YXIgYWN0aXZlU3ByaW5nQW5pbWF0aW9uID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciB2YWx1ZSA9IHVzZU1vdGlvblZhbHVlKGlzTW90aW9uVmFsdWUoc291cmNlKSA/IHNvdXJjZS5nZXQoKSA6IHNvdXJjZSk7XG4gICAgUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hdHRhY2goZnVuY3Rpb24gKHYsIHNldCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIG1vcmUgaG9sbGlzdGljIGFwcHJvYWNoIHRvIHRoaXMgbWlnaHQgYmUgdG8gdXNlIGlzU3RhdGljIHRvIGZpeCBWaXN1YWxFbGVtZW50IGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIGF0IHRoYXQgbGV2ZWwsIGJ1dCB0aGlzIHdpbGwgd29yayBmb3Igbm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc1N0YXRpYylcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0KHYpO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVNwcmluZ0FuaW1hdGlvbi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlU3ByaW5nQW5pbWF0aW9uLmN1cnJlbnQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlU3ByaW5nQW5pbWF0aW9uLmN1cnJlbnQgPSBwb3Btb3Rpb24uYW5pbWF0ZSh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7IGZyb206IHZhbHVlLmdldCgpLCB0bzogdiwgdmVsb2NpdHk6IHZhbHVlLmdldFZlbG9jaXR5KCkgfSwgY29uZmlnKSwgeyBvblVwZGF0ZTogc2V0IH0pKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXQoKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW0pTT04uc3RyaW5naWZ5KGNvbmZpZyldKTtcbiAgICB1c2VPbkNoYW5nZShzb3VyY2UsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2YWx1ZS5zZXQocGFyc2VGbG9hdCh2KSk7IH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYE1vdGlvblZhbHVlYCB0aGF0IHVwZGF0ZXMgd2hlbiB0aGUgdmVsb2NpdHkgb2YgdGhlIHByb3ZpZGVkIGBNb3Rpb25WYWx1ZWAgY2hhbmdlcy5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcbiAqIGNvbnN0IHhWZWxvY2l0eSA9IHVzZVZlbG9jaXR5KHgpXG4gKiBjb25zdCB4QWNjZWxlcmF0aW9uID0gdXNlVmVsb2NpdHkoeFZlbG9jaXR5KVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VWZWxvY2l0eSh2YWx1ZSkge1xuICAgIHZhciB2ZWxvY2l0eSA9IHVzZU1vdGlvblZhbHVlKHZhbHVlLmdldFZlbG9jaXR5KCkpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzLmFkZChmdW5jdGlvbiAobmV3VmVsb2NpdHkpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5LnNldChuZXdWZWxvY2l0eSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFt2YWx1ZV0pO1xuICAgIHJldHVybiB2ZWxvY2l0eTtcbn1cblxudmFyIGNyZWF0ZVNjcm9sbE1vdGlvblZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgc2Nyb2xsWDogbW90aW9uVmFsdWUoMCksXG4gICAgc2Nyb2xsWTogbW90aW9uVmFsdWUoMCksXG4gICAgc2Nyb2xsWFByb2dyZXNzOiBtb3Rpb25WYWx1ZSgwKSxcbiAgICBzY3JvbGxZUHJvZ3Jlc3M6IG1vdGlvblZhbHVlKDApLFxufSk7IH07XG5mdW5jdGlvbiB1c2VTY3JvbGwoX2EpIHtcbiAgICBpZiAoX2EgPT09IHZvaWQgMCkgeyBfYSA9IHt9OyB9XG4gICAgdmFyIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lciwgdGFyZ2V0ID0gX2EudGFyZ2V0LCBvcHRpb25zID0gdHNsaWIuX19yZXN0KF9hLCBbXCJjb250YWluZXJcIiwgXCJ0YXJnZXRcIl0pO1xuICAgIHZhciB2YWx1ZXMgPSB1c2VDb25zdGFudChjcmVhdGVTY3JvbGxNb3Rpb25WYWx1ZXMpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9tLnNjcm9sbChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnk7XG4gICAgICAgICAgICB2YWx1ZXMuc2Nyb2xsWC5zZXQoeC5jdXJyZW50KTtcbiAgICAgICAgICAgIHZhbHVlcy5zY3JvbGxYUHJvZ3Jlc3Muc2V0KHgucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgdmFsdWVzLnNjcm9sbFkuc2V0KHkuY3VycmVudCk7XG4gICAgICAgICAgICB2YWx1ZXMuc2Nyb2xsWVByb2dyZXNzLnNldCh5LnByb2dyZXNzKTtcbiAgICAgICAgfSwgdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGNvbnRhaW5lcjogKGNvbnRhaW5lciA9PT0gbnVsbCB8fCBjb250YWluZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRhaW5lci5jdXJyZW50KSB8fCB1bmRlZmluZWQsIHRhcmdldDogKHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldC5jdXJyZW50KSB8fCB1bmRlZmluZWQgfSkpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdmFsdWVzO1xufVxuXG5mdW5jdGlvbiB1c2VFbGVtZW50U2Nyb2xsKHJlZikge1xuICAgIHdhcm5PbmNlKGZhbHNlLCBcInVzZUVsZW1lbnRTY3JvbGwgaXMgZGVwcmVjYXRlZC4gQ29udmVydCB0byB1c2VTY3JvbGwoeyBjb250YWluZXI6IHJlZiB9KS5cIik7XG4gICAgcmV0dXJuIHVzZVNjcm9sbCh7IGNvbnRhaW5lcjogcmVmIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VWaWV3cG9ydFNjcm9sbCgpIHtcbiAgICB3YXJuT25jZShmYWxzZSwgXCJ1c2VWaWV3cG9ydFNjcm9sbCBpcyBkZXByZWNhdGVkLiBDb252ZXJ0IHRvIHVzZVNjcm9sbCgpLlwiKTtcbiAgICByZXR1cm4gdXNlU2Nyb2xsKCk7XG59XG5cbnZhciBnZXRDdXJyZW50VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH1cbiAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERhdGUubm93KCk7IH07XG5mdW5jdGlvbiB1c2VBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICAgIHZhciBpbml0aWFsVGltZXN0YW1wID0gdXNlQ29uc3RhbnQoZ2V0Q3VycmVudFRpbWUpO1xuICAgIHZhciBpc1N0YXRpYyA9IFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCkuaXNTdGF0aWM7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcHJvdmlkZVRpbWVTaW5jZVN0YXJ0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gX2EudGltZXN0YW1wO1xuICAgICAgICAgICAgY2FsbGJhY2sodGltZXN0YW1wIC0gaW5pdGlhbFRpbWVzdGFtcCk7XG4gICAgICAgIH07XG4gICAgICAgIHN5bmNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnVwZGF0ZShwcm92aWRlVGltZVNpbmNlU3RhcnQsIHRydWUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3luYy5jYW5jZWxTeW5jLnVwZGF0ZShwcm92aWRlVGltZVNpbmNlU3RhcnQpOyB9O1xuICAgIH0sIFtjYWxsYmFja10pO1xufVxuXG5mdW5jdGlvbiB1c2VUaW1lKCkge1xuICAgIHZhciB0aW1lID0gdXNlTW90aW9uVmFsdWUoMCk7XG4gICAgdXNlQW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRpbWUuc2V0KHQpOyB9KTtcbiAgICByZXR1cm4gdGltZTtcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGlvbkNvbnRyb2xzKCkge1xuICAgIC8qKlxuICAgICAqIFRyYWNrIHdoZXRoZXIgdGhlIGhvc3QgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgICAqL1xuICAgIHZhciBoYXNNb3VudGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogUGVuZGluZyBhbmltYXRpb25zIHRoYXQgYXJlIHN0YXJ0ZWQgYmVmb3JlIGEgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICogVE9ETzogUmVtb3ZlIHRoaXMgYXMgYW5pbWF0aW9ucyBzaG91bGQgb25seSBydW4gaW4gZWZmZWN0c1xuICAgICAqL1xuICAgIHZhciBwZW5kaW5nQW5pbWF0aW9ucyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBsaW5rZWQgY29tcG9uZW50IGFuaW1hdGlvbiBjb250cm9scy5cbiAgICAgKi9cbiAgICB2YXIgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGNvbnRyb2xzID0ge1xuICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uICh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycy5hZGQodmlzdWFsRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdm9pZCBzdWJzY3JpYmVycy5kZWxldGUodmlzdWFsRWxlbWVudCk7IH07XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdHJhbnNpdGlvbk92ZXJyaWRlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRPRE86IFdlIG9ubHkgcGVyZm9ybSB0aGlzIGhhc01vdW50ZWQgY2hlY2sgYmVjYXVzZSBpbiBGcmFtZXIgd2UgdXNlZCB0b1xuICAgICAgICAgICAgICogZW5jb3VyYWdlIHRoZSBhYmlsaXR5IHRvIHN0YXJ0IGFuIGFuaW1hdGlvbiB3aXRoaW4gdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuICAgICAgICAgICAgICogaXNuJ3QgYmVoYXZpb3VyIGNvbmN1cnJlbnQtc2FmZSBzbyB3aGVuIHdlIG1ha2UgRnJhbWVyIGNvbmN1cnJlbnQtc2FmZVxuICAgICAgICAgICAgICogd2UgY2FuIGRpdGNoIHRoaXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChoYXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnNfMSA9IFtdO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnB1c2goYW5pbWF0ZVZpc3VhbEVsZW1lbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbk92ZXJyaWRlOiB0cmFuc2l0aW9uT3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9uc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQW5pbWF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogW2RlZmluaXRpb24sIHRyYW5zaXRpb25PdmVycmlkZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgaGV5TGlzdGVuLmludmFyaWFudChoYXNNb3VudGVkLCBcImNvbnRyb2xzLnNldCgpIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCBoYXMgbW91bnRlZC4gQ29uc2lkZXIgY2FsbGluZyB3aXRoaW4gYSB1c2VFZmZlY3QgaG9vay5cIik7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAodmlzdWFsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHNldFZhbHVlcyh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc3RvcEFuaW1hdGlvbih2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBtb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaGFzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICBwZW5kaW5nQW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBfYS5hbmltYXRpb24sIHJlc29sdmUgPSBfYS5yZXNvbHZlO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzLnN0YXJ0LmFwcGx5KGNvbnRyb2xzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtdLCB0c2xpYi5fX3JlYWQoYW5pbWF0aW9uKSwgZmFsc2UpKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGhhc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250cm9scy5zdG9wKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIGNvbnRyb2xzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYEFuaW1hdGlvbkNvbnRyb2xzYCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbWFudWFsbHkgc3RhcnQsIHN0b3BcbiAqIGFuZCBzZXF1ZW5jZSBhbmltYXRpb25zIG9uIG9uZSBvciBtb3JlIGNvbXBvbmVudHMuXG4gKlxuICogVGhlIHJldHVybmVkIGBBbmltYXRpb25Db250cm9sc2Agc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgYGFuaW1hdGVgIHByb3BlcnR5XG4gKiBvZiB0aGUgY29tcG9uZW50cyB5b3Ugd2FudCB0byBhbmltYXRlLlxuICpcbiAqIFRoZXNlIGNvbXBvbmVudHMgY2FuIHRoZW4gYmUgYW5pbWF0ZWQgd2l0aCB0aGUgYHN0YXJ0YCBtZXRob2QuXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbiAqIGltcG9ydCB7IG1vdGlvbiwgdXNlQW5pbWF0aW9uIH0gZnJvbSAnZnJhbWVyLW1vdGlvbidcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gTXlDb21wb25lbnQocHJvcHMpIHtcbiAqICAgIGNvbnN0IGNvbnRyb2xzID0gdXNlQW5pbWF0aW9uKClcbiAqXG4gKiAgICBjb250cm9scy5zdGFydCh7XG4gKiAgICAgICAgeDogMTAwLFxuICogICAgICAgIHRyYW5zaXRpb246IHsgZHVyYXRpb246IDAuNSB9LFxuICogICAgfSlcbiAqXG4gKiAgICByZXR1cm4gPG1vdGlvbi5kaXYgYW5pbWF0ZT17Y29udHJvbHN9IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBbmltYXRpb24gY29udHJvbGxlciB3aXRoIGBzdGFydGAgYW5kIGBzdG9wYCBtZXRob2RzXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VBbmltYXRpb25Db250cm9scygpIHtcbiAgICB2YXIgY29udHJvbHMgPSB1c2VDb25zdGFudChhbmltYXRpb25Db250cm9scyk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGNvbnRyb2xzLm1vdW50LCBbXSk7XG4gICAgcmV0dXJuIGNvbnRyb2xzO1xufVxudmFyIHVzZUFuaW1hdGlvbiA9IHVzZUFuaW1hdGlvbkNvbnRyb2xzO1xuXG4vKipcbiAqIEN5Y2xlcyB0aHJvdWdoIGEgc2VyaWVzIG9mIHZpc3VhbCBwcm9wZXJ0aWVzLiBDYW4gYmUgdXNlZCB0byB0b2dnbGUgYmV0d2VlbiBvciBjeWNsZSB0aHJvdWdoIGFuaW1hdGlvbnMuIEl0IHdvcmtzIHNpbWlsYXIgdG8gYHVzZVN0YXRlYCBpbiBSZWFjdC4gSXQgaXMgcHJvdmlkZWQgYW4gaW5pdGlhbCBhcnJheSBvZiBwb3NzaWJsZSBzdGF0ZXMsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHR3byBhcmd1bWVudHMuXG4gKlxuICogQW4gaW5kZXggdmFsdWUgY2FuIGJlIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgYGN5Y2xlYCBmdW5jdGlvbiB0byBjeWNsZSB0byBhIHNwZWNpZmljIGluZGV4LlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCJcbiAqIGltcG9ydCB7IG1vdGlvbiwgdXNlQ3ljbGUgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBbeCwgY3ljbGVYXSA9IHVzZUN5Y2xlKDAsIDUwLCAxMDApXG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxtb3Rpb24uZGl2XG4gKiAgICAgICBhbmltYXRlPXt7IHg6IHggfX1cbiAqICAgICAgIG9uVGFwPXsoKSA9PiBjeWNsZVgoKX1cbiAqICAgICAgLz5cbiAqICAgIClcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBpdGVtcyAtIGl0ZW1zIHRvIGN5Y2xlIHRocm91Z2hcbiAqIEByZXR1cm5zIFtjdXJyZW50U3RhdGUsIGN5Y2xlU3RhdGVdXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VDeWNsZSgpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgdmFyIF9hID0gdHNsaWIuX19yZWFkKFJlYWN0LnVzZVN0YXRlKGl0ZW1zW2luZGV4LmN1cnJlbnRdKSwgMiksIGl0ZW0gPSBfYVswXSwgc2V0SXRlbSA9IF9hWzFdO1xuICAgIHZhciBydW5DeWNsZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIGluZGV4LmN1cnJlbnQgPVxuICAgICAgICAgICAgdHlwZW9mIG5leHQgIT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICA/IHBvcG1vdGlvbi53cmFwKDAsIGl0ZW1zLmxlbmd0aCwgaW5kZXguY3VycmVudCArIDEpXG4gICAgICAgICAgICAgICAgOiBuZXh0O1xuICAgICAgICBzZXRJdGVtKGl0ZW1zW2luZGV4LmN1cnJlbnRdKTtcbiAgICB9LCB0c2xpYi5fX3NwcmVhZEFycmF5KFtpdGVtcy5sZW5ndGhdLCB0c2xpYi5fX3JlYWQoaXRlbXMpLCBmYWxzZSkpO1xuICAgIHJldHVybiBbaXRlbSwgcnVuQ3ljbGVdO1xufVxuXG5mdW5jdGlvbiB1c2VJblZpZXcocmVmLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCByb290ID0gX2Iucm9vdCwgbWFyZ2luID0gX2IubWFyZ2luLCBhbW91bnQgPSBfYi5hbW91bnQsIF9jID0gX2Iub25jZSwgb25jZSA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jO1xuICAgIHZhciBfZCA9IHRzbGliLl9fcmVhZChSZWFjdC51c2VTdGF0ZShmYWxzZSksIDIpLCBpc0luVmlldyA9IF9kWzBdLCBzZXRJblZpZXcgPSBfZFsxXTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghcmVmLmN1cnJlbnQgfHwgKG9uY2UgJiYgaXNJblZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgb25FbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldEluVmlldyh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBvbmNlID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0SW5WaWV3KGZhbHNlKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByb290OiAoX2EgPSByb290ID09PSBudWxsIHx8IHJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb3QuY3VycmVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWFyZ2luOiBtYXJnaW4sXG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudCA9PT0gXCJzb21lXCIgPyBcImFueVwiIDogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZG9tLmluVmlldyhyZWYuY3VycmVudCwgb25FbnRlciwgb3B0aW9ucyk7XG4gICAgfSwgW3Jvb3QsIHJlZiwgbWFyZ2luLCBvbmNlXSk7XG4gICAgcmV0dXJuIGlzSW5WaWV3O1xufVxuXG4vKipcbiAqIENhbiBtYW51YWxseSB0cmlnZ2VyIGEgZHJhZyBnZXN0dXJlIG9uIG9uZSBvciBtb3JlIGBkcmFnYC1lbmFibGVkIGBtb3Rpb25gIGNvbXBvbmVudHMuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBkcmFnQ29udHJvbHMgPSB1c2VEcmFnQ29udHJvbHMoKVxuICpcbiAqIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xuICogICBkcmFnQ29udHJvbHMuc3RhcnQoZXZlbnQsIHsgc25hcFRvQ3Vyc29yOiB0cnVlIH0pXG4gKiB9XG4gKlxuICogcmV0dXJuIChcbiAqICAgPD5cbiAqICAgICA8ZGl2IG9uUG9pbnRlckRvd249e3N0YXJ0RHJhZ30gLz5cbiAqICAgICA8bW90aW9uLmRpdiBkcmFnPVwieFwiIGRyYWdDb250cm9scz17ZHJhZ0NvbnRyb2xzfSAvPlxuICogICA8Lz5cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIERyYWdDb250cm9scyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcmFnQ29udHJvbHMoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29udHJvbHMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSBhIGNvbXBvbmVudCdzIGludGVybmFsIGBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzYCB0byB0aGUgdXNlci1mYWNpbmcgQVBJLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgRHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY29udHJvbHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scy5hZGQoY29udHJvbHMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29tcG9uZW50Q29udHJvbHMuZGVsZXRlKGNvbnRyb2xzKTsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgZHJhZyBnZXN0dXJlIG9uIGV2ZXJ5IGBtb3Rpb25gIGNvbXBvbmVudCB0aGF0IGhhcyB0aGlzIHNldCBvZiBkcmFnIGNvbnRyb2xzXG4gICAgICogcGFzc2VkIGludG8gaXQgdmlhIHRoZSBgZHJhZ0NvbnRyb2xzYCBwcm9wLlxuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogZHJhZ0NvbnRyb2xzLnN0YXJ0KGUsIHtcbiAgICAgKiAgIHNuYXBUb0N1cnNvcjogdHJ1ZVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBQb2ludGVyRXZlbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBEcmFnQ29udHJvbHMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbHMpIHtcbiAgICAgICAgICAgIGNvbnRyb2xzLnN0YXJ0KGV2ZW50Lm5hdGl2ZUV2ZW50IHx8IGV2ZW50LCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRHJhZ0NvbnRyb2xzO1xufSgpKTtcbnZhciBjcmVhdGVEcmFnQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRHJhZ0NvbnRyb2xzKCk7IH07XG4vKipcbiAqIFVzdWFsbHksIGRyYWdnaW5nIGlzIGluaXRpYXRlZCBieSBwcmVzc2luZyBkb3duIG9uIGEgYG1vdGlvbmAgY29tcG9uZW50IHdpdGggYSBgZHJhZ2AgcHJvcFxuICogYW5kIG1vdmluZyBpdC4gRm9yIHNvbWUgdXNlLWNhc2VzLCBmb3IgaW5zdGFuY2UgY2xpY2tpbmcgYXQgYW4gYXJiaXRyYXJ5IHBvaW50IG9uIGEgdmlkZW8gc2NydWJiZXIsIHdlXG4gKiBtaWdodCB3YW50IHRvIGluaXRpYXRlIHRoYXQgZHJhZ2dpbmcgZnJvbSBhIGRpZmZlcmVudCBjb21wb25lbnQgdGhhbiB0aGUgZHJhZ2dhYmxlIG9uZS5cbiAqXG4gKiBCeSBjcmVhdGluZyBhIGBkcmFnQ29udHJvbHNgIHVzaW5nIHRoZSBgdXNlRHJhZ0NvbnRyb2xzYCBob29rLCB3ZSBjYW4gcGFzcyB0aGlzIGludG9cbiAqIHRoZSBkcmFnZ2FibGUgY29tcG9uZW50J3MgYGRyYWdDb250cm9sc2AgcHJvcC4gSXQgZXhwb3NlcyBhIGBzdGFydGAgbWV0aG9kXG4gKiB0aGF0IGNhbiBzdGFydCBkcmFnZ2luZyBmcm9tIHBvaW50ZXIgZXZlbnRzIG9uIG90aGVyIGNvbXBvbmVudHMuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBkcmFnQ29udHJvbHMgPSB1c2VEcmFnQ29udHJvbHMoKVxuICpcbiAqIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xuICogICBkcmFnQ29udHJvbHMuc3RhcnQoZXZlbnQsIHsgc25hcFRvQ3Vyc29yOiB0cnVlIH0pXG4gKiB9XG4gKlxuICogcmV0dXJuIChcbiAqICAgPD5cbiAqICAgICA8ZGl2IG9uUG9pbnRlckRvd249e3N0YXJ0RHJhZ30gLz5cbiAqICAgICA8bW90aW9uLmRpdiBkcmFnPVwieFwiIGRyYWdDb250cm9scz17ZHJhZ0NvbnRyb2xzfSAvPlxuICogICA8Lz5cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlRHJhZ0NvbnRyb2xzKCkge1xuICAgIHJldHVybiB1c2VDb25zdGFudChjcmVhdGVEcmFnQ29udHJvbHMpO1xufVxuXG5mdW5jdGlvbiB1c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gc3RhcnRUcmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKGNiKSB7XG4gICAgaWYgKCFyb290UHJvamVjdGlvbk5vZGUuY3VycmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50LmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudC5ibG9ja1VwZGF0ZSgpO1xuICAgIGNiID09PSBudWxsIHx8IGNiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYigpO1xufVxuXG5mdW5jdGlvbiB1c2VJbnN0YW50VHJhbnNpdGlvbigpIHtcbiAgICB2YXIgX2EgPSB0c2xpYi5fX3JlYWQodXNlRm9yY2VVcGRhdGUoKSwgMiksIGZvcmNlVXBkYXRlID0gX2FbMF0sIGZvcmNlZFJlbmRlckNvdW50ID0gX2FbMV07XG4gICAgdmFyIHN0YXJ0SW5zdGFudExheW91dFRyYW5zaXRpb24gPSB1c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbigpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmJsb2NrIGFmdGVyIHR3byBhbmltYXRpb24gZnJhbWVzLCBvdGhlcndpc2UgdGhpcyB3aWxsIHVuYmxvY2sgdG9vIHNvb24uXG4gICAgICAgICAqL1xuICAgICAgICBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5wb3N0UmVuZGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5wb3N0UmVuZGVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChpbnN0YW50QW5pbWF0aW9uU3RhdGUuY3VycmVudCA9IGZhbHNlKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtmb3JjZWRSZW5kZXJDb3VudF0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgc3RhcnRJbnN0YW50TGF5b3V0VHJhbnNpdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnN0YW50QW5pbWF0aW9uU3RhdGUuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUmVzZXRQcm9qZWN0aW9uKCkge1xuICAgIHZhciByZXNldCA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdCA9IHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50O1xuICAgICAgICBpZiAoIXJvb3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJvb3QucmVzZXRUcmVlKCk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiByZXNldDtcbn1cblxudmFyIGNyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7fSk7IH07XG52YXIgc3RhdGVWaXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudCh7XG4gICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBtZWFzdXJlVmlld3BvcnRCb3g6IGNyZWF0ZUJveCxcbiAgICByZXNldFRyYW5zZm9ybTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIHJlc3RvcmVUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHsgfSxcbiAgICByZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkgeyB9LFxuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogY3JlYXRlT2JqZWN0LFxuICAgIHJlYWRWYWx1ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKF9zdGF0ZSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmluaXRpYWxTdGF0ZVtrZXldIHx8IDA7XG4gICAgfSxcbiAgICBtYWtlVGFyZ2V0QW5pbWF0YWJsZTogZnVuY3Rpb24gKGVsZW1lbnQsIF9hKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gX2EudHJhbnNpdGlvbiwgdHJhbnNpdGlvbkVuZCA9IF9hLnRyYW5zaXRpb25FbmQsIHRhcmdldCA9IHRzbGliLl9fcmVzdChfYSwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xuICAgICAgICB2YXIgb3JpZ2luID0gZ2V0T3JpZ2luKHRhcmdldCwgdHJhbnNpdGlvbiB8fCB7fSwgZWxlbWVudCk7XG4gICAgICAgIGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzKGVsZW1lbnQsIHRhcmdldCwgb3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiwgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCB9LCB0YXJnZXQpO1xuICAgIH0sXG59KTtcbnZhciB1c2VWaXN1YWxTdGF0ZSA9IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBjcmVhdGVPYmplY3QsXG4gICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZU9iamVjdCxcbn0pO1xuLyoqXG4gKiBUaGlzIGlzIG5vdCBhbiBvZmZpY2lhbGx5IHN1cHBvcnRlZCBBUEkgYW5kIG1heSBiZSByZW1vdmVkXG4gKiBvbiBhbnkgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gdXNlQW5pbWF0ZWRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICB2YXIgX2EgPSB0c2xpYi5fX3JlYWQoUmVhY3QudXNlU3RhdGUoaW5pdGlhbFN0YXRlKSwgMiksIGFuaW1hdGlvblN0YXRlID0gX2FbMF0sIHNldEFuaW1hdGlvblN0YXRlID0gX2FbMV07XG4gICAgdmFyIHZpc3VhbFN0YXRlID0gdXNlVmlzdWFsU3RhdGUoe30sIGZhbHNlKTtcbiAgICB2YXIgZWxlbWVudCA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlVmlzdWFsRWxlbWVudCh7IHByb3BzOiB7fSwgdmlzdWFsU3RhdGU6IHZpc3VhbFN0YXRlIH0sIHsgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUgfSk7XG4gICAgfSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWxlbWVudC5tb3VudCh7fSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnVubW91bnQ7XG4gICAgfSwgW2VsZW1lbnRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBlbGVtZW50LnNldFByb3BzKHtcbiAgICAgICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHNldEFuaW1hdGlvblN0YXRlKHRzbGliLl9fYXNzaWduKHt9LCB2KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LCBbc2V0QW5pbWF0aW9uU3RhdGUsIGVsZW1lbnRdKTtcbiAgICB2YXIgc3RhcnRBbmltYXRpb24gPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0ZVZpc3VhbEVsZW1lbnQoZWxlbWVudCwgYW5pbWF0aW9uRGVmaW5pdGlvbik7XG4gICAgfTsgfSk7XG4gICAgcmV0dXJuIFthbmltYXRpb25TdGF0ZSwgc3RhcnRBbmltYXRpb25dO1xufVxuXG4vLyBLZWVwIHRoaW5ncyByZWFzb25hYmxlIGFuZCBhdm9pZCBzY2FsZTogSW5maW5pdHkuIEluIHByYWN0aXNlIHdlIG1pZ2h0IG5lZWRcbi8vIHRvIGFkZCBhbm90aGVyIHZhbHVlLCBvcGFjaXR5LCB0aGF0IGNvdWxkIGludGVycG9sYXRlIHNjYWxlWC9ZIFswLDAuMDFdID0+IFswLDFdXG4vLyB0byBzaW1wbHkgaGlkZSBjb250ZW50IGF0IHVucmVhc29uYWJsZSBzY2FsZXMuXG52YXIgbWF4U2NhbGUgPSAxMDAwMDA7XG52YXIgaW52ZXJ0U2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgPiAwLjAwMSA/IDEgLyBzY2FsZSA6IG1heFNjYWxlO1xufTtcbnZhciBoYXNXYXJuZWQgPSBmYWxzZTtcbi8qKlxuICogUmV0dXJucyBhIGBNb3Rpb25WYWx1ZWAgZWFjaCBmb3IgYHNjYWxlWGAgYW5kIGBzY2FsZVlgIHRoYXQgdXBkYXRlIHdpdGggdGhlIGludmVyc2VcbiAqIG9mIHRoZWlyIHJlc3BlY3RpdmUgcGFyZW50IHNjYWxlcy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgdW5kb2luZyB0aGUgZGlzdG9ydGlvbiBvZiBjb250ZW50IHdoZW4gc2NhbGluZyBhIHBhcmVudCBjb21wb25lbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgYHVzZUludmVydGVkU2NhbGVgIHdpbGwgYXV0b21hdGljYWxseSBmZXRjaCBgc2NhbGVYYCBhbmQgYHNjYWxlWWAgZnJvbSB0aGUgbmVhcmVzdCBwYXJlbnQuXG4gKiBCeSBwYXNzaW5nIG90aGVyIGBNb3Rpb25WYWx1ZWBzIGluIGFzIGB1c2VJbnZlcnRlZFNjYWxlKHsgc2NhbGVYLCBzY2FsZVkgfSlgLCBpdCB3aWxsIGludmVydCB0aGUgb3V0cHV0XG4gKiBvZiB0aG9zZSBpbnN0ZWFkLlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgTXlDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHVzZUludmVydGVkU2NhbGUoKVxuICogICByZXR1cm4gPG1vdGlvbi5kaXYgc3R5bGU9e3sgc2NhbGVYLCBzY2FsZVkgfX0gLz5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIHVzZUludmVydGVkU2NhbGUoc2NhbGUpIHtcbiAgICB2YXIgcGFyZW50U2NhbGVYID0gdXNlTW90aW9uVmFsdWUoMSk7XG4gICAgdmFyIHBhcmVudFNjYWxlWSA9IHVzZU1vdGlvblZhbHVlKDEpO1xuICAgIHZhciB2aXN1YWxFbGVtZW50ID0gdXNlVmlzdWFsRWxlbWVudENvbnRleHQoKTtcbiAgICBoZXlMaXN0ZW4uaW52YXJpYW50KCEhKHNjYWxlIHx8IHZpc3VhbEVsZW1lbnQpLCBcIklmIG5vIHNjYWxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIHVzZUludmVydGVkU2NhbGUgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGNoaWxkIG9mIGFub3RoZXIgbW90aW9uIGNvbXBvbmVudC5cIik7XG4gICAgaGV5TGlzdGVuLndhcm5pbmcoaGFzV2FybmVkLCBcInVzZUludmVydGVkU2NhbGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIDMuMC4gVXNlIHRoZSBsYXlvdXQgcHJvcCBpbnN0ZWFkLlwiKTtcbiAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgIGlmIChzY2FsZSkge1xuICAgICAgICBwYXJlbnRTY2FsZVggPSBzY2FsZS5zY2FsZVggfHwgcGFyZW50U2NhbGVYO1xuICAgICAgICBwYXJlbnRTY2FsZVkgPSBzY2FsZS5zY2FsZVkgfHwgcGFyZW50U2NhbGVZO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgIHBhcmVudFNjYWxlWCA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoXCJzY2FsZVhcIiwgMSk7XG4gICAgICAgIHBhcmVudFNjYWxlWSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoXCJzY2FsZVlcIiwgMSk7XG4gICAgfVxuICAgIHZhciBzY2FsZVggPSB1c2VUcmFuc2Zvcm0ocGFyZW50U2NhbGVYLCBpbnZlcnRTY2FsZSk7XG4gICAgdmFyIHNjYWxlWSA9IHVzZVRyYW5zZm9ybShwYXJlbnRTY2FsZVksIGludmVydFNjYWxlKTtcbiAgICByZXR1cm4geyBzY2FsZVg6IHNjYWxlWCwgc2NhbGVZOiBzY2FsZVkgfTtcbn1cblxuZXhwb3J0cy5BbmltYXRlUHJlc2VuY2UgPSBBbmltYXRlUHJlc2VuY2U7XG5leHBvcnRzLkFuaW1hdGVTaGFyZWRMYXlvdXQgPSBBbmltYXRlU2hhcmVkTGF5b3V0O1xuZXhwb3J0cy5EZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0ID0gRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dDtcbmV4cG9ydHMuRHJhZ0NvbnRyb2xzID0gRHJhZ0NvbnRyb2xzO1xuZXhwb3J0cy5GbGF0VHJlZSA9IEZsYXRUcmVlO1xuZXhwb3J0cy5MYXlvdXRHcm91cCA9IExheW91dEdyb3VwO1xuZXhwb3J0cy5MYXlvdXRHcm91cENvbnRleHQgPSBMYXlvdXRHcm91cENvbnRleHQ7XG5leHBvcnRzLkxhenlNb3Rpb24gPSBMYXp5TW90aW9uO1xuZXhwb3J0cy5Nb3Rpb25Db25maWcgPSBNb3Rpb25Db25maWc7XG5leHBvcnRzLk1vdGlvbkNvbmZpZ0NvbnRleHQgPSBNb3Rpb25Db25maWdDb250ZXh0O1xuZXhwb3J0cy5Nb3Rpb25Db250ZXh0ID0gTW90aW9uQ29udGV4dDtcbmV4cG9ydHMuTW90aW9uVmFsdWUgPSBNb3Rpb25WYWx1ZTtcbmV4cG9ydHMuUHJlc2VuY2VDb250ZXh0ID0gUHJlc2VuY2VDb250ZXh0O1xuZXhwb3J0cy5SZW9yZGVyID0gUmVvcmRlcjtcbmV4cG9ydHMuU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0ID0gU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0O1xuZXhwb3J0cy5hZGRQb2ludGVyRXZlbnQgPSBhZGRQb2ludGVyRXZlbnQ7XG5leHBvcnRzLmFkZFNjYWxlQ29ycmVjdG9yID0gYWRkU2NhbGVDb3JyZWN0b3I7XG5leHBvcnRzLmFuaW1hdGUgPSBhbmltYXRlO1xuZXhwb3J0cy5hbmltYXRlVmlzdWFsRWxlbWVudCA9IGFuaW1hdGVWaXN1YWxFbGVtZW50O1xuZXhwb3J0cy5hbmltYXRpb25Db250cm9scyA9IGFuaW1hdGlvbkNvbnRyb2xzO1xuZXhwb3J0cy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbmV4cG9ydHMuY2FsY0xlbmd0aCA9IGNhbGNMZW5ndGg7XG5leHBvcnRzLmNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzID0gY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXM7XG5leHBvcnRzLmNyZWF0ZUJveCA9IGNyZWF0ZUJveDtcbmV4cG9ydHMuY3JlYXRlRG9tTW90aW9uQ29tcG9uZW50ID0gY3JlYXRlRG9tTW90aW9uQ29tcG9uZW50O1xuZXhwb3J0cy5jcmVhdGVNb3Rpb25Db21wb25lbnQgPSBjcmVhdGVNb3Rpb25Db21wb25lbnQ7XG5leHBvcnRzLmRvbUFuaW1hdGlvbiA9IGRvbUFuaW1hdGlvbjtcbmV4cG9ydHMuZG9tTWF4ID0gZG9tTWF4O1xuZXhwb3J0cy5maWx0ZXJQcm9wcyA9IGZpbHRlclByb3BzO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5leHBvcnRzLmlzRHJhZ0FjdGl2ZSA9IGlzRHJhZ0FjdGl2ZTtcbmV4cG9ydHMuaXNNb3Rpb25WYWx1ZSA9IGlzTW90aW9uVmFsdWU7XG5leHBvcnRzLmlzVmFsaWRNb3Rpb25Qcm9wID0gaXNWYWxpZE1vdGlvblByb3A7XG5leHBvcnRzLm0gPSBtO1xuZXhwb3J0cy5tYWtlVXNlVmlzdWFsU3RhdGUgPSBtYWtlVXNlVmlzdWFsU3RhdGU7XG5leHBvcnRzLm1vdGlvbiA9IG1vdGlvbjtcbmV4cG9ydHMubW90aW9uVmFsdWUgPSBtb3Rpb25WYWx1ZTtcbmV4cG9ydHMucmVzb2x2ZU1vdGlvblZhbHVlID0gcmVzb2x2ZU1vdGlvblZhbHVlO1xuZXhwb3J0cy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5leHBvcnRzLnVzZUFuaW1hdGlvbiA9IHVzZUFuaW1hdGlvbjtcbmV4cG9ydHMudXNlQW5pbWF0aW9uQ29udHJvbHMgPSB1c2VBbmltYXRpb25Db250cm9scztcbmV4cG9ydHMudXNlQW5pbWF0aW9uRnJhbWUgPSB1c2VBbmltYXRpb25GcmFtZTtcbmV4cG9ydHMudXNlQ3ljbGUgPSB1c2VDeWNsZTtcbmV4cG9ydHMudXNlRGVwcmVjYXRlZEFuaW1hdGVkU3RhdGUgPSB1c2VBbmltYXRlZFN0YXRlO1xuZXhwb3J0cy51c2VEZXByZWNhdGVkSW52ZXJ0ZWRTY2FsZSA9IHVzZUludmVydGVkU2NhbGU7XG5leHBvcnRzLnVzZURvbUV2ZW50ID0gdXNlRG9tRXZlbnQ7XG5leHBvcnRzLnVzZURyYWdDb250cm9scyA9IHVzZURyYWdDb250cm9scztcbmV4cG9ydHMudXNlRWxlbWVudFNjcm9sbCA9IHVzZUVsZW1lbnRTY3JvbGw7XG5leHBvcnRzLnVzZUZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGU7XG5leHBvcnRzLnVzZUluVmlldyA9IHVzZUluVmlldztcbmV4cG9ydHMudXNlSW5zdGFudExheW91dFRyYW5zaXRpb24gPSB1c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbjtcbmV4cG9ydHMudXNlSW5zdGFudFRyYW5zaXRpb24gPSB1c2VJbnN0YW50VHJhbnNpdGlvbjtcbmV4cG9ydHMudXNlSXNQcmVzZW50ID0gdXNlSXNQcmVzZW50O1xuZXhwb3J0cy51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTW90aW9uVGVtcGxhdGUgPSB1c2VNb3Rpb25UZW1wbGF0ZTtcbmV4cG9ydHMudXNlTW90aW9uVmFsdWUgPSB1c2VNb3Rpb25WYWx1ZTtcbmV4cG9ydHMudXNlUHJlc2VuY2UgPSB1c2VQcmVzZW5jZTtcbmV4cG9ydHMudXNlUmVkdWNlZE1vdGlvbiA9IHVzZVJlZHVjZWRNb3Rpb247XG5leHBvcnRzLnVzZVJlZHVjZWRNb3Rpb25Db25maWcgPSB1c2VSZWR1Y2VkTW90aW9uQ29uZmlnO1xuZXhwb3J0cy51c2VSZXNldFByb2plY3Rpb24gPSB1c2VSZXNldFByb2plY3Rpb247XG5leHBvcnRzLnVzZVNjcm9sbCA9IHVzZVNjcm9sbDtcbmV4cG9ydHMudXNlU3ByaW5nID0gdXNlU3ByaW5nO1xuZXhwb3J0cy51c2VUaW1lID0gdXNlVGltZTtcbmV4cG9ydHMudXNlVHJhbnNmb3JtID0gdXNlVHJhbnNmb3JtO1xuZXhwb3J0cy51c2VVbm1vdW50RWZmZWN0ID0gdXNlVW5tb3VudEVmZmVjdDtcbmV4cG9ydHMudXNlVmVsb2NpdHkgPSB1c2VWZWxvY2l0eTtcbmV4cG9ydHMudXNlVmlld3BvcnRTY3JvbGwgPSB1c2VWaWV3cG9ydFNjcm9sbDtcbmV4cG9ydHMudXNlVmlzdWFsRWxlbWVudENvbnRleHQgPSB1c2VWaXN1YWxFbGVtZW50Q29udGV4dDtcbmV4cG9ydHMudmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQ7XG5leHBvcnRzLndyYXBIYW5kbGVyID0gd3JhcEhhbmRsZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0c2xpYiIsInJlcXVpcmUiLCJSZWFjdCIsImhleUxpc3RlbiIsInN0eWxlVmFsdWVUeXBlcyIsInBvcG1vdGlvbiIsInN5bmMiLCJkb20iLCJfaW50ZXJvcERlZmF1bHRMZWdhY3kiLCJlIiwiX2ludGVyb3BOYW1lc3BhY2UiLCJfX2VzTW9kdWxlIiwibiIsImNyZWF0ZSIsImtleXMiLCJmb3JFYWNoIiwiayIsImQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZnJlZXplIiwiUmVhY3RfX25hbWVzcGFjZSIsIlJlYWN0X19kZWZhdWx0Iiwic3luY19fZGVmYXVsdCIsImRlZmF1bHRFbnZpcm9ubWVudCIsImVudiIsInByb2Nlc3MiLCJ1bmRlZmluZWQiLCJjcmVhdGVEZWZpbml0aW9uIiwicHJvcE5hbWVzIiwiaXNFbmFibGVkIiwicHJvcHMiLCJzb21lIiwibmFtZSIsImZlYXR1cmVEZWZpbml0aW9ucyIsIm1lYXN1cmVMYXlvdXQiLCJhbmltYXRpb24iLCJleGl0IiwiZHJhZyIsImZvY3VzIiwiaG92ZXIiLCJ0YXAiLCJwYW4iLCJpblZpZXciLCJsb2FkRmVhdHVyZXMiLCJmZWF0dXJlcyIsImtleSIsInByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IiLCJDb21wb25lbnQiLCJMYXp5Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJzdHJpY3QiLCJmZWF0dXJlTmFtZXMiLCJudW1GZWF0dXJlcyIsImxlbmd0aCIsInVzZUZlYXR1cmVzIiwidmlzdWFsRWxlbWVudCIsInByZWxvYWRlZEZlYXR1cmVzIiwibGF6eUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiaW52YXJpYW50IiwiaSIsIm5hbWVfMSIsIl9hIiwicHVzaCIsImNyZWF0ZUVsZW1lbnQiLCJfX2Fzc2lnbiIsIk1vdGlvbkNvbmZpZ0NvbnRleHQiLCJ0cmFuc2Zvcm1QYWdlUG9pbnQiLCJwIiwiaXNTdGF0aWMiLCJyZWR1Y2VkTW90aW9uIiwiTW90aW9uQ29udGV4dCIsInVzZVZpc3VhbEVsZW1lbnRDb250ZXh0IiwiUHJlc2VuY2VDb250ZXh0IiwiaXNCcm93c2VyIiwiZG9jdW1lbnQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwicHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJjdXJyZW50IiwiaGFzRGV0ZWN0ZWQiLCJpbml0UHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwibW90aW9uTWVkaWFRdWVyeV8xIiwic2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzIiwibWF0Y2hlcyIsImFkZExpc3RlbmVyIiwidXNlUmVkdWNlZE1vdGlvbiIsIl9fcmVhZCIsInVzZVN0YXRlIiwic2hvdWxkUmVkdWNlTW90aW9uIiwidXNlUmVkdWNlZE1vdGlvbkNvbmZpZyIsInJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlIiwidXNlVmlzdWFsRWxlbWVudCIsInZpc3VhbFN0YXRlIiwiY3JlYXRlVmlzdWFsRWxlbWVudCIsInBhcmVudCIsInByZXNlbmNlQ29udGV4dCIsInZpc3VhbEVsZW1lbnRSZWYiLCJ1c2VSZWYiLCJyZW5kZXJlciIsInByZXNlbmNlSWQiLCJpZCIsImJsb2NrSW5pdGlhbEFuaW1hdGlvbiIsImluaXRpYWwiLCJzeW5jUmVuZGVyIiwiYW5pbWF0aW9uU3RhdGUiLCJhbmltYXRlQ2hhbmdlcyIsIm5vdGlmeVVubW91bnQiLCJpc1JlZk9iamVjdCIsInJlZiIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInVzZU1vdGlvblJlZiIsImV4dGVybmFsUmVmIiwidXNlQ2FsbGJhY2siLCJpbnN0YW5jZSIsIm1vdW50IiwidW5tb3VudCIsImlzVmFyaWFudExhYmVscyIsInYiLCJBcnJheSIsImlzQXJyYXkiLCJpc1ZhcmlhbnRMYWJlbCIsImdldEN1cnJlbnQiLCJmb3JFYWNoVmFsdWUiLCJnZXRWZWxvY2l0eSQxIiwidmVsb2NpdHkiLCJnZXRWZWxvY2l0eSIsInJlc29sdmVWYXJpYW50RnJvbVByb3BzIiwiZGVmaW5pdGlvbiIsImN1c3RvbSIsImN1cnJlbnRWYWx1ZXMiLCJjdXJyZW50VmVsb2NpdHkiLCJ2YXJpYW50cyIsInJlc29sdmVWYXJpYW50IiwiZ2V0UHJvcHMiLCJjaGVja0lmQ29udHJvbGxpbmdWYXJpYW50cyIsImFuaW1hdGUiLCJzdGFydCIsIndoaWxlSG92ZXIiLCJ3aGlsZURyYWciLCJ3aGlsZVRhcCIsIndoaWxlRm9jdXMiLCJjaGVja0lmVmFyaWFudE5vZGUiLCJCb29sZWFuIiwiZ2V0Q3VycmVudFRyZWVWYXJpYW50cyIsImNvbnRleHQiLCJpbmhlcml0IiwidXNlQ3JlYXRlTW90aW9uQ29udGV4dCIsInVzZU1lbW8iLCJ2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5IiwicHJvcCIsImpvaW4iLCJ1c2VDb25zdGFudCIsImluaXQiLCJnbG9iYWxQcm9qZWN0aW9uU3RhdGUiLCJoYXNBbmltYXRlZFNpbmNlUmVzaXplIiwiaGFzRXZlclVwZGF0ZWQiLCJpZCQxIiwidXNlUHJvamVjdGlvbklkIiwiTGF5b3V0R3JvdXBDb250ZXh0IiwiU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0IiwidXNlUHJvamVjdGlvbiIsInByb2plY3Rpb25JZCIsIlByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IiLCJfYiIsImxheW91dElkIiwibGF5b3V0IiwiZHJhZ0NvbnN0cmFpbnRzIiwibGF5b3V0U2Nyb2xsIiwiaW5pdGlhbFByb21vdGlvbkNvbmZpZyIsInByb2plY3Rpb24iLCJnZXRMYXRlc3RWYWx1ZXMiLCJzZXRPcHRpb25zIiwiYWx3YXlzTWVhc3VyZUxheW91dCIsInNjaGVkdWxlUmVuZGVyIiwiYW5pbWF0aW9uVHlwZSIsIlZpc3VhbEVsZW1lbnRIYW5kbGVyIiwiX3N1cGVyIiwiX19leHRlbmRzIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsInVwZGF0ZVByb3BzIiwiY29tcG9uZW50RGlkVXBkYXRlIiwic2V0UHJvcHMiLCJyZW5kZXIiLCJjaGlsZHJlbiIsImNyZWF0ZU1vdGlvbkNvbXBvbmVudCIsInVzZVJlbmRlciIsInVzZVZpc3VhbFN0YXRlIiwiTW90aW9uQ29tcG9uZW50IiwidXNlTGF5b3V0SWQiLCJjb25maWciLCJQcm92aWRlciIsImZvcndhcmRSZWYiLCJsYXlvdXRHcm91cElkIiwiY3JlYXRlTW90aW9uUHJveHkiLCJjcmVhdGVDb25maWciLCJjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWciLCJQcm94eSIsImNvbXBvbmVudENhY2hlIiwiTWFwIiwiX3RhcmdldCIsImhhcyIsInNldCIsImxvd2VyY2FzZVNWR0VsZW1lbnRzIiwiaXNTVkdDb21wb25lbnQiLCJpbmNsdWRlcyIsImluZGV4T2YiLCJ0ZXN0Iiwic2NhbGVDb3JyZWN0b3JzIiwiYWRkU2NhbGVDb3JyZWN0b3IiLCJjb3JyZWN0b3JzIiwiYXNzaWduIiwidHJhbnNmb3JtQXhlcyIsIm9yZGVyIiwidHJhbnNmb3JtUHJvcHMiLCJvcGVyYXRpb25LZXkiLCJheGVzS2V5Iiwic29ydFRyYW5zZm9ybVByb3BzIiwiYSIsImIiLCJ0cmFuc2Zvcm1Qcm9wU2V0IiwiU2V0IiwiaXNUcmFuc2Zvcm1Qcm9wIiwidHJhbnNmb3JtT3JpZ2luUHJvcHMiLCJpc1RyYW5zZm9ybU9yaWdpblByb3AiLCJpc0ZvcmNlZE1vdGlvblZhbHVlIiwiaXNNb3Rpb25WYWx1ZSIsInRyYW5zbGF0ZUFsaWFzIiwieCIsInkiLCJ6IiwidHJhbnNmb3JtUGVyc3BlY3RpdmUiLCJidWlsZFRyYW5zZm9ybSIsInRyYW5zZm9ybUlzRGVmYXVsdCIsInRyYW5zZm9ybVRlbXBsYXRlIiwidHJhbnNmb3JtIiwidHJhbnNmb3JtS2V5cyIsIl9jIiwiZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24iLCJfZCIsImFsbG93VHJhbnNmb3JtTm9uZSIsInRyYW5zZm9ybVN0cmluZyIsInNvcnQiLCJ0cmFuc2Zvcm1IYXNaIiwibnVtVHJhbnNmb3JtS2V5cyIsImNvbmNhdCIsInRyaW0iLCJidWlsZFRyYW5zZm9ybU9yaWdpbiIsIm9yaWdpblgiLCJvcmlnaW5ZIiwib3JpZ2luWiIsImlzQ1NTVmFyaWFibGUkMSIsInN0YXJ0c1dpdGgiLCJnZXRWYWx1ZUFzVHlwZSIsInR5cGUiLCJpbnQiLCJudW1iZXIiLCJNYXRoIiwicm91bmQiLCJudW1iZXJWYWx1ZVR5cGVzIiwiYm9yZGVyV2lkdGgiLCJweCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyUmFkaXVzIiwicmFkaXVzIiwiYm9yZGVyVG9wTGVmdFJhZGl1cyIsImJvcmRlclRvcFJpZ2h0UmFkaXVzIiwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMiLCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIiwid2lkdGgiLCJtYXhXaWR0aCIsImhlaWdodCIsIm1heEhlaWdodCIsInNpemUiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJwYWRkaW5nIiwicGFkZGluZ1RvcCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsIm1hcmdpbiIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsInJvdGF0ZSIsImRlZ3JlZXMiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJzY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlWiIsInNrZXciLCJza2V3WCIsInNrZXdZIiwiZGlzdGFuY2UiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsInRyYW5zbGF0ZVoiLCJwZXJzcGVjdGl2ZSIsIm9wYWNpdHkiLCJhbHBoYSIsInByb2dyZXNzUGVyY2VudGFnZSIsInpJbmRleCIsImZpbGxPcGFjaXR5Iiwic3Ryb2tlT3BhY2l0eSIsIm51bU9jdGF2ZXMiLCJidWlsZEhUTUxTdHlsZXMiLCJzdGF0ZSIsImxhdGVzdFZhbHVlcyIsIm9wdGlvbnMiLCJzdHlsZSIsInZhcnMiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJoYXNUcmFuc2Zvcm0iLCJoYXNUcmFuc2Zvcm1PcmlnaW4iLCJ0cmFuc2Zvcm1Jc05vbmUiLCJ2YWx1ZVR5cGUiLCJ2YWx1ZUFzVHlwZSIsImRlZmF1bHQiLCJjcmVhdGVIdG1sUmVuZGVyU3RhdGUiLCJjb3B5UmF3VmFsdWVzT25seSIsInRhcmdldCIsInNvdXJjZSIsInVzZUluaXRpYWxNb3Rpb25WYWx1ZXMiLCJ1c2VTdHlsZSIsInN0eWxlUHJvcCIsInRyYW5zZm9ybVZhbHVlcyIsInVzZUhUTUxQcm9wcyIsImh0bWxQcm9wcyIsImRyYWdMaXN0ZW5lciIsImRyYWdnYWJsZSIsInVzZXJTZWxlY3QiLCJXZWJraXRVc2VyU2VsZWN0IiwiV2Via2l0VG91Y2hDYWxsb3V0IiwidG91Y2hBY3Rpb24iLCJ2YWxpZE1vdGlvblByb3BzIiwiaXNWYWxpZE1vdGlvblByb3AiLCJzaG91bGRGb3J3YXJkIiwibG9hZEV4dGVybmFsSXNWYWxpZFByb3AiLCJpc1ZhbGlkUHJvcCIsImZpbHRlclByb3BzIiwiaXNEb20iLCJmb3J3YXJkTW90aW9uUHJvcHMiLCJmaWx0ZXJlZFByb3BzIiwiY2FsY09yaWdpbiQxIiwib3JpZ2luIiwib2Zmc2V0IiwiY2FsY1NWR1RyYW5zZm9ybU9yaWdpbiIsImRpbWVuc2lvbnMiLCJweE9yaWdpblgiLCJweE9yaWdpblkiLCJkYXNoS2V5cyIsImFycmF5IiwiY2FtZWxLZXlzIiwiYnVpbGRTVkdQYXRoIiwiYXR0cnMiLCJzcGFjaW5nIiwidXNlRGFzaENhc2UiLCJwYXRoTGVuZ3RoIiwicGF0aFNwYWNpbmciLCJidWlsZFNWR0F0dHJzIiwiYXR0clgiLCJhdHRyWSIsInBhdGhPZmZzZXQiLCJsYXRlc3QiLCJfX3Jlc3QiLCJjcmVhdGVTdmdSZW5kZXJTdGF0ZSIsInVzZVNWR1Byb3BzIiwidmlzdWFsUHJvcHMiLCJyYXdTdHlsZXMiLCJjcmVhdGVVc2VSZW5kZXIiLCJ1c2VWaXN1YWxQcm9wcyIsImVsZW1lbnRQcm9wcyIsIkNBTUVMX0NBU0VfUEFUVEVSTiIsIlJFUExBQ0VfVEVNUExBVEUiLCJjYW1lbFRvRGFzaCIsInN0ciIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInJlbmRlckhUTUwiLCJlbGVtZW50IiwiZ2V0UHJvamVjdGlvblN0eWxlcyIsInNldFByb3BlcnR5IiwiY2FtZWxDYXNlQXR0cmlidXRlcyIsInJlbmRlclNWRyIsInJlbmRlclN0YXRlIiwiX3N0eWxlUHJvcCIsInNldEF0dHJpYnV0ZSIsInNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyQxIiwibmV3VmFsdWVzIiwic2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIiwidGFyZ2V0S2V5IiwidG9VcHBlckNhc2UiLCJpc0FuaW1hdGlvbkNvbnRyb2xzIiwiaXNLZXlmcmFtZXNUYXJnZXQiLCJpc0N1c3RvbVZhbHVlIiwibWl4IiwidG9WYWx1ZSIsInJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMiLCJyZXNvbHZlTW90aW9uVmFsdWUiLCJ1bndyYXBwZWRWYWx1ZSIsIm1ha2VTdGF0ZSIsImNyZWF0ZVJlbmRlclN0YXRlIiwib25Nb3VudCIsIm1ha2VMYXRlc3RWYWx1ZXMiLCJtYWtlVXNlVmlzdWFsU3RhdGUiLCJzY3JhcGVNb3Rpb25WYWx1ZXMiLCJ2YWx1ZXMiLCJtb3Rpb25WYWx1ZXMiLCJpc0NvbnRyb2xsaW5nVmFyaWFudHMiLCJpc1ZhcmlhbnROb2RlIiwiaW5pdGlhbEFuaW1hdGlvbklzQmxvY2tlZCIsInZhcmlhbnRUb1NldCIsImxpc3QiLCJyZXNvbHZlZCIsInRyYW5zaXRpb25FbmQiLCJ0cmFuc2l0aW9uIiwidmFsdWVUYXJnZXQiLCJpbmRleCIsInN2Z01vdGlvbkNvbmZpZyIsImdldEJCb3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJodG1sTW90aW9uQ29uZmlnIiwiY3JlYXRlRG9tTW90aW9uQ29uZmlnIiwiYmFzZUNvbmZpZyIsIkFuaW1hdGlvblR5cGUiLCJhZGREb21FdmVudCIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJwYXNzaXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1c2VEb21FdmVudCIsInVzZUZvY3VzR2VzdHVyZSIsIm9uRm9jdXMiLCJzZXRBY3RpdmUiLCJGb2N1cyIsIm9uQmx1ciIsImlzTW91c2VFdmVudCIsImV2ZW50IiwiUG9pbnRlckV2ZW50IiwicG9pbnRlclR5cGUiLCJNb3VzZUV2ZW50IiwiaXNUb3VjaEV2ZW50IiwiaGFzVG91Y2hlcyIsInRvdWNoZXMiLCJmaWx0ZXJQcmltYXJ5UG9pbnRlciIsImV2ZW50SGFuZGxlciIsImlzUHJpbWFyeVBvaW50ZXIiLCJidXR0b24iLCJkZWZhdWx0UGFnZVBvaW50IiwicGFnZVgiLCJwYWdlWSIsInBvaW50RnJvbVRvdWNoIiwicG9pbnRUeXBlIiwicHJpbWFyeVRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJwb2ludCIsInBvaW50RnJvbU1vdXNlIiwiZXh0cmFjdEV2ZW50SW5mbyIsIndyYXBIYW5kbGVyIiwic2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIiLCJsaXN0ZW5lciIsInN1cHBvcnRzUG9pbnRlckV2ZW50cyIsIm9ucG9pbnRlcmRvd24iLCJzdXBwb3J0c1RvdWNoRXZlbnRzIiwib250b3VjaHN0YXJ0Iiwic3VwcG9ydHNNb3VzZUV2ZW50cyIsIm9ubW91c2Vkb3duIiwibW91c2VFdmVudE5hbWVzIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInBvaW50ZXJjYW5jZWwiLCJwb2ludGVyb3ZlciIsInBvaW50ZXJvdXQiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJ0b3VjaEV2ZW50TmFtZXMiLCJnZXRQb2ludGVyRXZlbnROYW1lIiwiYWRkUG9pbnRlckV2ZW50IiwidXNlUG9pbnRlckV2ZW50IiwiY3JlYXRlTG9jayIsImxvY2siLCJvcGVuTG9jayIsImdsb2JhbEhvcml6b250YWxMb2NrIiwiZ2xvYmFsVmVydGljYWxMb2NrIiwiZ2V0R2xvYmFsTG9jayIsIm9wZW5Ib3Jpem9udGFsXzEiLCJvcGVuVmVydGljYWxfMSIsImlzRHJhZ0FjdGl2ZSIsIm9wZW5HZXN0dXJlTG9jayIsImNyZWF0ZUhvdmVyRXZlbnQiLCJpc0FjdGl2ZSIsImNhbGxiYWNrIiwiaW5mbyIsIkhvdmVyIiwidXNlSG92ZXJHZXN0dXJlIiwib25Ib3ZlclN0YXJ0Iiwib25Ib3ZlckVuZCIsImlzTm9kZU9yQ2hpbGQiLCJjaGlsZCIsInBhcmVudEVsZW1lbnQiLCJ1c2VVbm1vdW50RWZmZWN0IiwidXNlVGFwR2VzdHVyZSIsIm9uVGFwIiwib25UYXBTdGFydCIsIm9uVGFwQ2FuY2VsIiwiaGFzUHJlc3NMaXN0ZW5lcnMiLCJpc1ByZXNzaW5nIiwiY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycyIsImV2ZW50T3B0aW9ucyIsIm9uUG9pbnRlckRvd24iLCJyZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIiLCJjaGVja1BvaW50ZXJFbmQiLCJUYXAiLCJvblBvaW50ZXJVcCIsImdldEluc3RhbmNlIiwib25Qb2ludGVyQ2FuY2VsIiwicGlwZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiY29uZGl0aW9uIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiYWRkIiwib2JzZXJ2ZXJDYWxsYmFja3MiLCJXZWFrTWFwIiwib2JzZXJ2ZXJzIiwiZmlyZU9ic2VydmVyQ2FsbGJhY2siLCJlbnRyeSIsImZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcyIsImVudHJpZXMiLCJpbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJyb290IiwibG9va3VwUm9vdCIsInJvb3RPYnNlcnZlcnMiLCJKU09OIiwic3RyaW5naWZ5IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlSW50ZXJzZWN0aW9uIiwicm9vdEludGVyZXNlY3Rpb25PYnNlcnZlciIsIm9ic2VydmUiLCJkZWxldGUiLCJ1bm9ic2VydmUiLCJ1c2VWaWV3cG9ydCIsIndoaWxlSW5WaWV3Iiwib25WaWV3cG9ydEVudGVyIiwib25WaWV3cG9ydExlYXZlIiwidmlld3BvcnQiLCJoYXNFbnRlcmVkVmlldyIsImlzSW5WaWV3Iiwic2hvdWxkT2JzZXJ2ZSIsIm9uY2UiLCJ1c2VPYnNlcnZlciIsInVzZU1pc3NpbmdJbnRlcnNlY3Rpb25PYnNlcnZlciIsInVzZUludGVyc2VjdGlvbk9ic2VydmVyIiwidGhyZXNob2xkTmFtZXMiLCJhbGwiLCJyb290TWFyZ2luIiwiYW1vdW50IiwidGhyZXNob2xkIiwiaW50ZXJzZWN0aW9uQ2FsbGJhY2siLCJpc0ludGVyc2VjdGluZyIsIkluVmlldyIsImZhbGxiYWNrIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibWFrZVJlbmRlcmxlc3NDb21wb25lbnQiLCJob29rIiwiZ2VzdHVyZUFuaW1hdGlvbnMiLCJjb3VudGVyIiwiaW5jcmVtZW50SWQiLCJ1c2VJZCIsInVzZVByZXNlbmNlIiwiaXNQcmVzZW50Iiwib25FeGl0Q29tcGxldGUiLCJyZWdpc3RlciIsInNhZmVUb1JlbW92ZSIsInVzZUlzUHJlc2VudCIsInNoYWxsb3dDb21wYXJlIiwibmV4dCIsInByZXYiLCJwcmV2TGVuZ3RoIiwic2Vjb25kc1RvTWlsbGlzZWNvbmRzIiwic2Vjb25kcyIsImVhc2luZ0xvb2t1cCIsImxpbmVhciIsImVhc2VJbiIsImVhc2VJbk91dCIsImVhc2VPdXQiLCJjaXJjSW4iLCJjaXJjSW5PdXQiLCJjaXJjT3V0IiwiYmFja0luIiwiYmFja0luT3V0IiwiYmFja091dCIsImFudGljaXBhdGUiLCJib3VuY2VJbiIsImJvdW5jZUluT3V0IiwiYm91bmNlT3V0IiwiZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24iLCJ4MSIsInkxIiwieDIiLCJ5MiIsImN1YmljQmV6aWVyIiwiaXNFYXNpbmdBcnJheSIsImVhc2UiLCJpc0FuaW1hdGFibGUiLCJjb21wbGV4IiwidW5kZXJEYW1wZWRTcHJpbmciLCJzdGlmZm5lc3MiLCJkYW1waW5nIiwicmVzdFNwZWVkIiwiY3JpdGljYWxseURhbXBlZFNwcmluZyIsInRvIiwic3FydCIsImxpbmVhclR3ZWVuIiwiZHVyYXRpb24iLCJrZXlmcmFtZXMiLCJkZWZhdWx0VHJhbnNpdGlvbnMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsImdldERlZmF1bHRUcmFuc2l0aW9uIiwidmFsdWVLZXkiLCJ0cmFuc2l0aW9uRmFjdG9yeSIsImRlZmF1bHRWYWx1ZVR5cGVzIiwib3V0bGluZUNvbG9yIiwiZmlsbCIsInN0cm9rZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyVG9wQ29sb3IiLCJib3JkZXJSaWdodENvbG9yIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJib3JkZXJMZWZ0Q29sb3IiLCJmaWx0ZXIiLCJXZWJraXRGaWx0ZXIiLCJnZXREZWZhdWx0VmFsdWVUeXBlIiwiZ2V0QW5pbWF0YWJsZU5vbmUiLCJkZWZhdWx0VmFsdWVUeXBlIiwiaW5zdGFudEFuaW1hdGlvblN0YXRlIiwiaXNUcmFuc2l0aW9uRGVmaW5lZCIsIndoZW4iLCJkZWxheSIsImRlbGF5Q2hpbGRyZW4iLCJzdGFnZ2VyQ2hpbGRyZW4iLCJzdGFnZ2VyRGlyZWN0aW9uIiwicmVwZWF0IiwicmVwZWF0VHlwZSIsInJlcGVhdERlbGF5IiwiZnJvbSIsImxlZ2FjeVJlcGVhdFdhcm5pbmciLCJjb252ZXJ0VHJhbnNpdGlvblRvQW5pbWF0aW9uT3B0aW9ucyIsInRpbWVzIiwieW95byIsImZsaXAiLCJsb29wIiwibWFwIiwid2FybmluZyIsImdldERlbGF5RnJvbVRyYW5zaXRpb24iLCJ2YWx1ZVRyYW5zaXRpb24iLCJnZXRWYWx1ZVRyYW5zaXRpb24iLCJoeWRyYXRlS2V5ZnJhbWVzIiwiX19zcHJlYWRBcnJheSIsImdldFBvcG1vdGlvbkFuaW1hdGlvbk9wdGlvbnMiLCJnZXRBbmltYXRpb24iLCJvbkNvbXBsZXRlIiwiaXNUYXJnZXRBbmltYXRhYmxlIiwiaXNaZXJvIiwiZ2V0WmVyb1VuaXQiLCJpc09yaWdpbkFuaW1hdGFibGUiLCJvblVwZGF0ZSIsImluZXJ0aWEiLCJmaW5hbFRhcmdldCIsInN0b3AiLCJwYXJzZUZsb2F0IiwicG90ZW50aWFsVW5pdFR5cGUiLCJzdGFydEFuaW1hdGlvbiIsImRlbGF5VGltZXIiLCJjb250cm9scyIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJpc051bWVyaWNhbFN0cmluZyIsImlzWmVyb1ZhbHVlU3RyaW5nIiwiYWRkVW5pcXVlSXRlbSIsImFyciIsIml0ZW0iLCJyZW1vdmVJdGVtIiwic3BsaWNlIiwibW92ZUl0ZW0iLCJmcm9tSW5kZXgiLCJ0b0luZGV4Iiwic2xpY2UiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJTdWJzY3JpcHRpb25NYW5hZ2VyIiwic3Vic2NyaXB0aW9ucyIsIl90aGlzIiwibm90aWZ5IiwiYyIsIm51bVN1YnNjcmlwdGlvbnMiLCJnZXRTaXplIiwiY2xlYXIiLCJpc0Zsb2F0IiwiaXNOYU4iLCJNb3Rpb25WYWx1ZSIsInZlcnNpb24iLCJ0aW1lRGVsdGEiLCJsYXN0VXBkYXRlZCIsInVwZGF0ZVN1YnNjcmliZXJzIiwidmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycyIsInJlbmRlclN1YnNjcmliZXJzIiwiY2FuVHJhY2tWZWxvY2l0eSIsInVwZGF0ZUFuZE5vdGlmeSIsImdldEZyYW1lRGF0YSIsImRlbHRhIiwidGltZXN0YW1wIiwicG9zdFJlbmRlciIsInNjaGVkdWxlVmVsb2NpdHlDaGVjayIsInZlbG9jaXR5Q2hlY2siLCJoYXNBbmltYXRlZCIsIm9uQ2hhbmdlIiwic3Vic2NyaXB0aW9uIiwiY2xlYXJMaXN0ZW5lcnMiLCJvblJlbmRlclJlcXVlc3QiLCJhdHRhY2giLCJwYXNzaXZlRWZmZWN0IiwiZ2V0UHJldmlvdXMiLCJ2ZWxvY2l0eVBlclNlY29uZCIsIlByb21pc2UiLCJyZXNvbHZlIiwic3RvcEFuaW1hdGlvbiIsInRoZW4iLCJjbGVhckFuaW1hdGlvbiIsImlzQW5pbWF0aW5nIiwiZGVzdHJveSIsIm1vdGlvblZhbHVlIiwidGVzdFZhbHVlVHlwZSIsImF1dG8iLCJwYXJzZSIsImRpbWVuc2lvblZhbHVlVHlwZXMiLCJwZXJjZW50IiwidnciLCJ2aCIsImZpbmREaW1lbnNpb25WYWx1ZVR5cGUiLCJmaW5kIiwidmFsdWVUeXBlcyIsImZpbmRWYWx1ZVR5cGUiLCJzZXRNb3Rpb25WYWx1ZSIsImhhc1ZhbHVlIiwiZ2V0VmFsdWUiLCJhZGRWYWx1ZSIsInNldFRhcmdldCIsIm1ha2VUYXJnZXRBbmltYXRhYmxlIiwic2V0VmFyaWFudHMiLCJ2YXJpYW50TGFiZWxzIiwicmV2ZXJzZWRMYWJlbHMiLCJyZXZlcnNlIiwidmFyaWFudCIsImdldFZhcmlhbnQiLCJ2YXJpYW50Q2hpbGRyZW4iLCJzZXRWYWx1ZXMiLCJjaGVja1RhcmdldEZvck5ld1ZhbHVlcyIsIm5ld1ZhbHVlS2V5cyIsIm51bU5ld1ZhbHVlcyIsInRhcmdldFZhbHVlIiwicmVhZFZhbHVlIiwic2V0QmFzZVRhcmdldCIsImdldE9yaWdpbkZyb21UcmFuc2l0aW9uIiwiZ2V0T3JpZ2luIiwiYW5pbWF0ZVZpc3VhbEVsZW1lbnQiLCJub3RpZnlBbmltYXRpb25TdGFydCIsImFuaW1hdGlvbnMiLCJhbmltYXRlVmFyaWFudCIsInJlc29sdmVkRGVmaW5pdGlvbiIsImFuaW1hdGVUYXJnZXQiLCJub3RpZnlBbmltYXRpb25Db21wbGV0ZSIsInRyYW5zaXRpb25PdmVycmlkZSIsImdldENoaWxkQW5pbWF0aW9ucyIsImZvcndhcmREZWxheSIsImFuaW1hdGVDaGlsZHJlbiIsImZpcnN0IiwibGFzdCIsIl9lIiwiX2YiLCJhbmltYXRpb25UeXBlU3RhdGUiLCJnZXRTdGF0ZSIsInNob3VsZEJsb2NrQW5pbWF0aW9uIiwibWF4U3RhZ2dlckR1cmF0aW9uIiwiZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24iLCJzb3J0QnlUcmVlT3JkZXIiLCJzb3J0Tm9kZVBvc2l0aW9uIiwicHJvdGVjdGVkS2V5cyIsIm5lZWRzQW5pbWF0aW5nIiwic2hvdWxkQmxvY2siLCJ2YXJpYW50UHJpb3JpdHlPcmRlciIsIkFuaW1hdGUiLCJEcmFnIiwiRXhpdCIsInJldmVyc2VQcmlvcml0eU9yZGVyIiwibnVtQW5pbWF0aW9uVHlwZXMiLCJhbmltYXRlTGlzdCIsImNyZWF0ZUFuaW1hdGlvblN0YXRlIiwiY3JlYXRlU3RhdGUiLCJhbGxBbmltYXRlZEtleXMiLCJpc0luaXRpYWxSZW5kZXIiLCJidWlsZFJlc29sdmVkVHlwZVZhbHVlcyIsImFjYyIsImlzQW5pbWF0ZWQiLCJzZXRBbmltYXRlRnVuY3Rpb24iLCJtYWtlQW5pbWF0b3IiLCJjaGFuZ2VkQWN0aXZlVHlwZSIsImdldFZhcmlhbnRDb250ZXh0IiwicmVtb3ZlZEtleXMiLCJlbmNvdW50ZXJlZEtleXMiLCJyZW1vdmVkVmFyaWFudEluZGV4IiwiSW5maW5pdHkiLCJfbG9vcF8xIiwidHlwZVN0YXRlIiwicHJvcElzVmFyaWFudCIsImFjdGl2ZURlbHRhIiwiaXNJbmhlcml0ZWQiLCJtYW51YWxseUFuaW1hdGVPbk1vdW50IiwicHJldlByb3AiLCJ2YXJpYW50RGlkQ2hhbmdlIiwiY2hlY2tWYXJpYW50c0RpZENoYW5nZSIsInNob3VsZEFuaW1hdGVUeXBlIiwiZGVmaW5pdGlvbkxpc3QiLCJyZXNvbHZlZFZhbHVlcyIsInJlZHVjZSIsInByZXZSZXNvbHZlZFZhbHVlcyIsImFsbEtleXMiLCJtYXJrVG9BbmltYXRlIiwiZmFsbGJhY2tBbmltYXRpb25fMSIsImZhbGxiYWNrVGFyZ2V0IiwiZ2V0QmFzZVRhcmdldCIsInNob3VsZEFuaW1hdGUiLCJjcmVhdGVUeXBlU3RhdGUiLCJzdWJzY3JpYmUiLCJQYW5TZXNzaW9uIiwiaGFuZGxlcnMiLCJzdGFydEV2ZW50IiwibGFzdE1vdmVFdmVudCIsImxhc3RNb3ZlRXZlbnRJbmZvIiwidXBkYXRlUG9pbnQiLCJnZXRQYW5JbmZvIiwiaGlzdG9yeSIsImlzUGFuU3RhcnRlZCIsImlzRGlzdGFuY2VQYXN0VGhyZXNob2xkIiwib25TdGFydCIsIm9uTW92ZSIsImhhbmRsZVBvaW50ZXJNb3ZlIiwidHJhbnNmb3JtUG9pbnQiLCJidXR0b25zIiwiaGFuZGxlUG9pbnRlclVwIiwidXBkYXRlIiwiZW5kIiwib25FbmQiLCJvblNlc3Npb25FbmQiLCJwYW5JbmZvIiwiaW5pdGlhbEluZm8iLCJvblNlc3Npb25TdGFydCIsInJlbW92ZUxpc3RlbmVycyIsInVwZGF0ZUhhbmRsZXJzIiwiY2FuY2VsU3luYyIsInN1YnRyYWN0UG9pbnQiLCJsYXN0RGV2aWNlUG9pbnQiLCJzdGFydERldmljZVBvaW50IiwidGltZXN0YW1wZWRQb2ludCIsImxhc3RQb2ludCIsInRpbWUiLCJjYWxjTGVuZ3RoIiwiYXhpcyIsIm1heCIsIm1pbiIsImlzTmVhciIsIm1heERpc3RhbmNlIiwiY2FsY0F4aXNEZWx0YSIsIm9yaWdpblBvaW50IiwidHJhbnNsYXRlIiwiY2FsY0JveERlbHRhIiwiY2FsY1JlbGF0aXZlQXhpcyIsInJlbGF0aXZlIiwiY2FsY1JlbGF0aXZlQm94IiwiY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uIiwiY2FsY1JlbGF0aXZlUG9zaXRpb24iLCJhcHBseUNvbnN0cmFpbnRzIiwiZWxhc3RpYyIsImNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyIsImNhbGNSZWxhdGl2ZUNvbnN0cmFpbnRzIiwibGF5b3V0Qm94IiwiY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzIiwibGF5b3V0QXhpcyIsImNvbnN0cmFpbnRzQXhpcyIsImNhbGNWaWV3cG9ydENvbnN0cmFpbnRzIiwiY29uc3RyYWludHNCb3giLCJjYWxjT3JpZ2luIiwic291cmNlTGVuZ3RoIiwidGFyZ2V0TGVuZ3RoIiwicHJvZ3Jlc3MiLCJjbGFtcCIsInJlYmFzZUF4aXNDb25zdHJhaW50cyIsImNvbnN0cmFpbnRzIiwicmVsYXRpdmVDb25zdHJhaW50cyIsImRlZmF1bHRFbGFzdGljIiwicmVzb2x2ZURyYWdFbGFzdGljIiwiZHJhZ0VsYXN0aWMiLCJyZXNvbHZlQXhpc0VsYXN0aWMiLCJtaW5MYWJlbCIsIm1heExhYmVsIiwicmVzb2x2ZVBvaW50RWxhc3RpYyIsImxhYmVsIiwiY3JlYXRlQXhpc0RlbHRhIiwiY3JlYXRlRGVsdGEiLCJjcmVhdGVBeGlzIiwiY3JlYXRlQm94IiwiZWFjaEF4aXMiLCJjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCIsImNvbnZlcnRCb3hUb0JvdW5kaW5nQm94IiwidHJhbnNmb3JtQm94UG9pbnRzIiwidG9wTGVmdCIsImJvdHRvbVJpZ2h0IiwiaXNJZGVudGl0eVNjYWxlIiwiaGFzU2NhbGUiLCJoYXNUcmFuc2xhdGUiLCJzY2FsZVBvaW50IiwiZGlzdGFuY2VGcm9tT3JpZ2luIiwic2NhbGVkIiwiYXBwbHlQb2ludERlbHRhIiwiYm94U2NhbGUiLCJhcHBseUF4aXNEZWx0YSIsImFwcGx5Qm94RGVsdGEiLCJib3giLCJhcHBseVRyZWVEZWx0YXMiLCJ0cmVlU2NhbGUiLCJ0cmVlUGF0aCIsImlzU2hhcmVkVHJhbnNpdGlvbiIsInRyZWVMZW5ndGgiLCJub2RlIiwicHJvamVjdGlvbkRlbHRhIiwiZGlzcGxheSIsInNjcm9sbCIsInRyYW5zZm9ybUJveCIsInRyYW5zbGF0ZUF4aXMiLCJ0cmFuc2Zvcm1BeGlzIiwidHJhbnNmb3JtcyIsInNjYWxlS2V5Iiwib3JpZ2luS2V5IiwiYXhpc09yaWdpbiIsInhLZXlzJDEiLCJ5S2V5cyQxIiwibWVhc3VyZVZpZXdwb3J0Qm94IiwibWVhc3VyZVBhZ2VCb3giLCJyb290UHJvamVjdGlvbk5vZGUiLCJ2aWV3cG9ydEJveCIsImVsZW1lbnREcmFnQ29udHJvbHMiLCJWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzIiwib3Blbkdsb2JhbExvY2siLCJpc0RyYWdnaW5nIiwiY3VycmVudERpcmVjdGlvbiIsImhhc011dGF0ZWRDb25zdHJhaW50cyIsIm9yaWdpbkV2ZW50Iiwic25hcFRvQ3Vyc29yIiwiZHJhZ1Byb3BhZ2F0aW9uIiwib25EcmFnU3RhcnQiLCJyZXNvbHZlQ29uc3RyYWludHMiLCJpc0FuaW1hdGlvbkJsb2NrZWQiLCJnZXRBeGlzTW90aW9uVmFsdWUiLCJtZWFzdXJlZEF4aXMiLCJhY3R1YWwiLCJsZW5ndGhfMSIsImRyYWdEaXJlY3Rpb25Mb2NrIiwib25EaXJlY3Rpb25Mb2NrIiwib25EcmFnIiwiZ2V0Q3VycmVudERpcmVjdGlvbiIsInVwZGF0ZUF4aXMiLCJwYW5TZXNzaW9uIiwiZ2V0VHJhbnNmb3JtUGFnZVBvaW50IiwiY2FuY2VsIiwib25EcmFnRW5kIiwiX3BvaW50Iiwic2hvdWxkRHJhZyIsImF4aXNWYWx1ZSIsInByZXZDb25zdHJhaW50cyIsInJlc29sdmVSZWZDb25zdHJhaW50cyIsIm9uTWVhc3VyZURyYWdDb25zdHJhaW50cyIsImNvbnN0cmFpbnRzRWxlbWVudCIsIm1lYXN1cmVkQ29uc3RyYWludHMiLCJ1c2VyQ29uc3RyYWludHMiLCJkcmFnTW9tZW50dW0iLCJkcmFnVHJhbnNpdGlvbiIsImRyYWdTbmFwVG9PcmlnaW4iLCJvbkRyYWdUcmFuc2l0aW9uRW5kIiwibW9tZW50dW1BbmltYXRpb25zIiwiYm91bmNlU3RpZmZuZXNzIiwiYm91bmNlRGFtcGluZyIsInRpbWVDb25zdGFudCIsInJlc3REZWx0YSIsInN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uIiwiZHJhZ0tleSIsImV4dGVybmFsTW90aW9uVmFsdWUiLCJzY2FsZVBvc2l0aW9uV2l0aGluQ29uc3RyYWludHMiLCJib3hQcm9ncmVzcyIsInVwZGF0ZVNjcm9sbCIsInVwZGF0ZUxheW91dCIsImFkZExpc3RlbmVycyIsInN0b3BQb2ludGVyTGlzdGVuZXIiLCJtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIiwic3RvcE1lYXN1cmVMYXlvdXRMaXN0ZW5lciIsInN0b3BSZXNpemVMaXN0ZW5lciIsImhhc0xheW91dENoYW5nZWQiLCJkaXJlY3Rpb24iLCJsb2NrVGhyZXNob2xkIiwiYWJzIiwidXNlRHJhZyIsImdyb3VwRHJhZ0NvbnRyb2xzIiwiZHJhZ0NvbnRyb2xzIiwidXNlUGFuR2VzdHVyZSIsIm9uUGFuIiwib25QYW5TdGFydCIsIm9uUGFuRW5kIiwib25QYW5TZXNzaW9uU3RhcnQiLCJoYXNQYW5FdmVudHMiLCJuYW1lcyIsImNyZWF0ZUxpZmVjeWNsZXMiLCJtYW5hZ2VycyIsInByb3BTdWJzY3JpcHRpb25zIiwibGlmZWN5Y2xlcyIsImNsZWFyQWxsTGlzdGVuZXJzIiwibWFuYWdlciIsInVwZGF0ZVByb3BMaXN0ZW5lcnMiLCJvbiIsInByb3BMaXN0ZW5lciIsImFyZ3MiLCJfaSIsInVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyIsIm5leHRWYWx1ZSIsInByZXZWYWx1ZSIsImV4aXN0aW5nVmFsdWUiLCJnZXRTdGF0aWNWYWx1ZSIsInJlbW92ZVZhbHVlIiwidHJlZVR5cGUiLCJidWlsZCIsInJlbmRlckluc3RhbmNlIiwicmVhZFZhbHVlRnJvbUluc3RhbmNlIiwicmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUiLCJpc01vdW50ZWQiLCJ2YWx1ZVN1YnNjcmlwdGlvbnMiLCJwcmV2TW90aW9uVmFsdWVzIiwiYmFzZVRhcmdldCIsInJlbW92ZUZyb21WYXJpYW50VHJlZSIsInRyaWdnZXJCdWlsZCIsIm5vdGlmeVVwZGF0ZSIsImJpbmRUb01vdGlvblZhbHVlIiwicmVtb3ZlT25DaGFuZ2UiLCJsYXRlc3RWYWx1ZSIsInJlbW92ZU9uUmVuZGVyUmVxdWVzdCIsImluaXRpYWxNb3Rpb25WYWx1ZXMiLCJkZXB0aCIsImlzVmlzaWJsZSIsIm5ld0luc3RhbmNlIiwiYWRkVmFyaWFudENoaWxkIiwicmVtb3ZlIiwiY2xvc2VzdFZhcmlhbnROb2RlIiwiZ2V0Q2xvc2VzdFZhcmlhbnROb2RlIiwib3RoZXIiLCJnZXRMYXlvdXRJZCIsInNldFN0YXRpY1ZhbHVlIiwic2V0VmlzaWJpbGl0eSIsInZpc2liaWxpdHkiLCJjYW5NdXRhdGUiLCJkZWZhdWx0VmFsdWUiLCJuZXdQcm9wcyIsInN0YXJ0QXRQYXJlbnQiLCJjb250ZXh0XzEiLCJudW1WYXJpYW50UHJvcHMiLCJ2YXJpYW50UHJvcHMiLCJpc0NTU1ZhcmlhYmxlIiwiY3NzVmFyaWFibGVSZWdleCIsInBhcnNlQ1NTVmFyaWFibGUiLCJtYXRjaCIsImV4ZWMiLCJ0b2tlbiIsIm1heERlcHRoIiwiZ2V0VmFyaWFibGVWYWx1ZSIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicmVzb2x2ZUNTU1ZhcmlhYmxlcyIsIkVsZW1lbnQiLCJwb3NpdGlvbmFsS2V5cyIsImlzUG9zaXRpb25hbEtleSIsImhhc1Bvc2l0aW9uYWxLZXkiLCJzZXRBbmRSZXNldFZlbG9jaXR5IiwiaXNOdW1PclB4VHlwZSIsIkJvdW5kaW5nQm94RGltZW5zaW9uIiwiZ2V0UG9zRnJvbU1hdHJpeCIsIm1hdHJpeCIsInBvcyIsInNwbGl0IiwiZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCIsInBvczIiLCJwb3MzIiwiX2Jib3giLCJtYXRyaXgzZCIsIm5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm1LZXlzIiwicmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybSIsInJlbW92ZWRUcmFuc2Zvcm1zIiwicG9zaXRpb25hbFZhbHVlcyIsImNvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyIsImNoYW5nZWRLZXlzIiwib3JpZ2luQmJveCIsImVsZW1lbnRDb21wdXRlZFN0eWxlIiwidGFyZ2V0QmJveCIsImNoZWNrQW5kQ29udmVydENoYW5nZWRWYWx1ZVR5cGVzIiwidGFyZ2V0UG9zaXRpb25hbEtleXMiLCJyZW1vdmVkVHJhbnNmb3JtVmFsdWVzIiwiaGFzQXR0ZW1wdGVkVG9SZW1vdmVUcmFuc2Zvcm1WYWx1ZXMiLCJjaGFuZ2VkVmFsdWVUeXBlS2V5cyIsImZyb21UeXBlIiwidG9UeXBlIiwibnVtS2V5ZnJhbWVzIiwic2Nyb2xsWV8xIiwicGFnZVlPZmZzZXQiLCJjb252ZXJ0ZWRUYXJnZXQiLCJzY3JvbGxUbyIsInVuaXRDb252ZXJzaW9uIiwicGFyc2VEb21WYXJpYW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSQxIiwiaHRtbENvbmZpZyIsImRvbUVsZW1lbnQiLCJkZWZhdWx0VHlwZSIsImNvbXB1dGVkU3R5bGUiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsInJlc2V0VHJhbnNmb3JtIiwicmVzdG9yZVRyYW5zZm9ybSIsIm11dGFibGVTdGF0ZSIsInBhcnNlZCIsImh0bWxWaXN1YWxFbGVtZW50Iiwic3ZnVmlzdWFsRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsIl9lbGVtZW50IiwiY3JlYXRlRG9tVmlzdWFsRWxlbWVudCIsInBpeGVsc1RvUGVyY2VudCIsInBpeGVscyIsImNvcnJlY3RCb3JkZXJSYWRpdXMiLCJjb3JyZWN0IiwidmFyVG9rZW4iLCJjb3JyZWN0Qm94U2hhZG93Iiwib3JpZ2luYWwiLCJjb250YWluc0NTU1ZhcmlhYmxlcyIsImNzc1ZhcmlhYmxlcyIsInNoYWRvdyIsInRlbXBsYXRlIiwiY3JlYXRlVHJhbnNmb3JtZXIiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJhdmVyYWdlU2NhbGUiLCJvdXRwdXQiLCJpXzEiLCJjc3NWYXJpYWJsZSIsIk1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCIsImNvbXBvbmVudERpZE1vdW50IiwibGF5b3V0R3JvdXAiLCJzd2l0Y2hMYXlvdXRHcm91cCIsImRlZmF1bHRTY2FsZUNvcnJlY3RvcnMiLCJncm91cCIsImRpZFVwZGF0ZSIsInByZXZQcm9wcyIsImxheW91dERlcGVuZGVuY3kiLCJ3aWxsVXBkYXRlIiwicHJvbW90ZSIsInJlbGVnYXRlIiwiZ2V0U3RhY2siLCJtZW1iZXJzIiwiY3VycmVudEFuaW1hdGlvbiIsImlzTGVhZCIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicHJvbW90ZUNvbnRleHQiLCJzY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50IiwiZGVyZWdpc3RlciIsIk1lYXN1cmVMYXlvdXQiLCJhcHBseVRvIiwiYm94U2hhZG93IiwibGF5b3V0RmVhdHVyZXMiLCJib3JkZXJzIiwibnVtQm9yZGVycyIsImFzTnVtYmVyIiwiaXNQeCIsIm1peFZhbHVlcyIsImZvbGxvdyIsImxlYWQiLCJzaG91bGRDcm9zc2ZhZGVPcGFjaXR5IiwiaXNPbmx5TWVtYmVyIiwiZWFzZUNyb3NzZmFkZUluIiwib3BhY2l0eUV4aXQiLCJlYXNlQ3Jvc3NmYWRlT3V0IiwiYm9yZGVyTGFiZWwiLCJmb2xsb3dSYWRpdXMiLCJnZXRSYWRpdXMiLCJsZWFkUmFkaXVzIiwiY2FuTWl4IiwicmFkaXVzTmFtZSIsImNvbXByZXNzIiwiZWFzaW5nIiwiY29weUF4aXNJbnRvIiwib3JpZ2luQXhpcyIsImNvcHlCb3hJbnRvIiwib3JpZ2luQm94IiwicmVtb3ZlUG9pbnREZWx0YSIsInJlbW92ZUF4aXNEZWx0YSIsInNvdXJjZUF4aXMiLCJyZWxhdGl2ZVByb2dyZXNzIiwicmVtb3ZlQXhpc1RyYW5zZm9ybXMiLCJ4S2V5cyIsInlLZXlzIiwicmVtb3ZlQm94VHJhbnNmb3JtcyIsInNvdXJjZUJveCIsImlzQXhpc0RlbHRhWmVybyIsImlzRGVsdGFaZXJvIiwiYm94RXF1YWxzIiwiTm9kZVN0YWNrIiwicHJldkxlYWQiLCJpbmRleE9mTm9kZSIsImZpbmRJbmRleCIsIm1lbWJlciIsInByZXNlcnZlRm9sbG93T3BhY2l0eSIsInNob3ciLCJyZXN1bWVGcm9tIiwicHJlc2VydmVPcGFjaXR5Iiwic25hcHNob3QiLCJhbmltYXRpb25WYWx1ZXMiLCJpc1NoYXJlZCIsImlzVXBkYXRpbmciLCJpc0xheW91dERpcnR5IiwiY3Jvc3NmYWRlIiwiaGlkZSIsImV4aXRBbmltYXRpb25Db21wbGV0ZSIsInJlc3VtaW5nRnJvbSIsInJlbW92ZUxlYWRTbmFwc2hvdCIsImlkZW50aXR5UHJvamVjdGlvbiIsImJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSIsImxhdGVzdFRyYW5zZm9ybSIsInhUcmFuc2xhdGUiLCJ5VHJhbnNsYXRlIiwiZWxlbWVudFNjYWxlWCIsImVsZW1lbnRTY2FsZVkiLCJjb21wYXJlQnlEZXB0aCIsIkZsYXRUcmVlIiwiaXNEaXJ0eSIsImFuaW1hdGlvblRhcmdldCIsImNyZWF0ZVByb2plY3Rpb25Ob2RlIiwiYXR0YWNoUmVzaXplTGlzdGVuZXIiLCJkZWZhdWx0UGFyZW50IiwibWVhc3VyZVNjcm9sbCIsImNoZWNrSXNTY3JvbGxSb290IiwiUHJvamVjdGlvbk5vZGUiLCJpc1RyZWVBbmltYXRpbmciLCJ1cGRhdGVNYW51YWxseUJsb2NrZWQiLCJ1cGRhdGVCbG9ja2VkQnlSZXNpemUiLCJpc1NWRyIsIm5lZWRzUmVzZXQiLCJzaG91bGRSZXNldFRyYW5zZm9ybSIsImV2ZW50SGFuZGxlcnMiLCJwb3RlbnRpYWxOb2RlcyIsImNoZWNrVXBkYXRlRmFpbGVkIiwiY2xlYXJBbGxTbmFwc2hvdHMiLCJ1cGRhdGVQcm9qZWN0aW9uIiwibm9kZXMiLCJyZXNvbHZlVGFyZ2V0RGVsdGEiLCJjYWxjUHJvamVjdGlvbiIsImhhc1Byb2plY3RlZCIsImFuaW1hdGlvblByb2dyZXNzIiwic2hhcmVkTm9kZXMiLCJwYXRoIiwicmVnaXN0ZXJQb3RlbnRpYWxOb2RlIiwibm90aWZ5TGlzdGVuZXJzIiwic3Vic2NyaXB0aW9uTWFuYWdlciIsImhhc0xpc3RlbmVycyIsIlNWR0VsZW1lbnQiLCJ0YWdOYW1lIiwidW5ibG9ja1RpbWVvdXRfMSIsInJlc2l6ZVVuYmxvY2tVcGRhdGVfMSIsImZpbmlzaEFuaW1hdGlvbiIsInJlZ2lzdGVyU2hhcmVkTm9kZSIsImhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCIsIm5ld0xheW91dCIsImlzVHJlZUFuaW1hdGlvbkJsb2NrZWQiLCJyZWxhdGl2ZVRhcmdldCIsImxheW91dFRyYW5zaXRpb24iLCJkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbiIsIl9nIiwib25MYXlvdXRBbmltYXRpb25TdGFydCIsIm9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGUiLCJ0YXJnZXRDaGFuZ2VkIiwidGFyZ2V0TGF5b3V0IiwiaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCIsInNldEFuaW1hdGlvbk9yaWdpbiIsImFuaW1hdGlvbk9wdGlvbnMiLCJvblBsYXkiLCJwcmVSZW5kZXIiLCJibG9ja1VwZGF0ZSIsInVuYmxvY2tVcGRhdGUiLCJpc1VwZGF0ZUJsb2NrZWQiLCJzdGFydFVwZGF0ZSIsInJlc2V0Um90YXRpb24iLCJzaG91bGROb3RpZnlMaXN0ZW5lcnMiLCJwcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSIsInVwZGF0ZVNuYXBzaG90IiwidXBkYXRlV2FzQmxvY2tlZCIsImNsZWFyTWVhc3VyZW1lbnRzIiwibW91bnROb2RlRWFybHkiLCJyZXNldFRyYW5zZm9ybVN0eWxlIiwibm90aWZ5TGF5b3V0VXBkYXRlIiwiZmx1c2hTeW5jIiwiY2xlYXJTbmFwc2hvdCIsInJlbW92ZUxlYWRTbmFwc2hvdHMiLCJzY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24iLCJtZWFzdXJlZCIsIm1lYXN1cmUiLCJyZW1vdmVUcmFuc2Zvcm0iLCJyZW1vdmVFbGVtZW50U2Nyb2xsIiwicm91bmRCb3giLCJwcmV2TGF5b3V0IiwibGF5b3V0Q29ycmVjdGVkIiwibm90aWZ5TGF5b3V0TWVhc3VyZSIsImlzU2Nyb2xsUm9vdCIsImlzUmVzZXRSZXF1ZXN0ZWQiLCJoYXNQcm9qZWN0aW9uIiwidHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSIsInRyYW5zZm9ybVRlbXBsYXRlSGFzQ2hhbmdlZCIsImJveFdpdGhvdXRTY3JvbGwiLCJzY3JvbGxfMSIsInJvb3RTY3JvbGwiLCJhcHBseVRyYW5zZm9ybSIsInRyYW5zZm9ybU9ubHkiLCJ3aXRoVHJhbnNmb3JtcyIsImJveFdpdGhvdXRUcmFuc2Zvcm0iLCJub2RlQm94Iiwic2V0VGFyZ2V0RGVsdGEiLCJ0YXJnZXREZWx0YSIsInJlbGF0aXZlUGFyZW50IiwiZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQiLCJyZWxhdGl2ZVRhcmdldE9yaWdpbiIsInRhcmdldFdpdGhUcmFuc2Zvcm1zIiwiYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0IiwicGVuZGluZ0FuaW1hdGlvbiIsImdldExlYWQiLCJwcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtIiwicHJldlRyZWVTY2FsZVgiLCJwcmV2VHJlZVNjYWxlWSIsInByZXZQcm9qZWN0aW9uVHJhbnNmb3JtIiwicHJvamVjdGlvblRyYW5zZm9ybSIsIm5vdGlmeUFsbCIsInNuYXBzaG90TGF0ZXN0VmFsdWVzIiwibWl4ZWRWYWx1ZXMiLCJyZWxhdGl2ZUxheW91dCIsImlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uIiwiaGFzT3BhY2l0eUNyb3NzZmFkZSIsIm1peFRhcmdldERlbHRhIiwibWl4QXhpc0RlbHRhIiwibWl4Qm94IiwiY29tcGxldGVBbmltYXRpb24iLCJhcHBseVRyYW5zZm9ybXNUb1RhcmdldCIsInN0YWNrIiwic2hvdWxkUHJlc2VydmVGb2xsb3dPcGFjaXR5IiwiZ2V0UHJldkxlYWQiLCJoYXNSb3RhdGUiLCJyZXNldFZhbHVlcyIsInN0eWxlcyIsInBvaW50ZXJFdmVudHMiLCJlbXB0eVN0eWxlcyIsInZhbHVlc1RvUmVuZGVyIiwiX2giLCJjb3JyZWN0ZWQiLCJudW0iLCJyZXNldFRyZWUiLCJsYXlvdXRfMSIsIm1lYXN1cmVkTGF5b3V0IiwiYXhpc1NuYXBzaG90IiwibGF5b3V0RGVsdGEiLCJ2aXN1YWxEZWx0YSIsInBhcmVudFNuYXBzaG90IiwicGFyZW50TGF5b3V0IiwicmVsYXRpdmVTbmFwc2hvdCIsIm9uQmVmb3JlTGF5b3V0TWVhc3VyZSIsIm5vdGlmeUJlZm9yZUxheW91dE1lYXN1cmUiLCJtaXhBeGlzIiwic2VhcmNoTm9kZSIsInNlYXJjaEVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwicm91bmRBeGlzIiwiRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbExlZnQiLCJib2R5Iiwic2Nyb2xsVG9wIiwiSFRNTFByb2plY3Rpb25Ob2RlIiwiZG9jdW1lbnROb2RlIiwicG9zaXRpb24iLCJmZWF0dXJlQnVuZGxlIiwibW90aW9uIiwiY3JlYXRlRG9tTW90aW9uQ29tcG9uZW50IiwibSIsInVzZUlzTW91bnRlZCIsInVzZUZvcmNlVXBkYXRlIiwiZm9yY2VkUmVuZGVyQ291bnQiLCJzZXRGb3JjZWRSZW5kZXJDb3VudCIsImZvcmNlUmVuZGVyIiwiZGVmZXJyZWRGb3JjZVJlbmRlciIsIlByZXNlbmNlQ2hpbGQiLCJwcmVzZW5jZUFmZmVjdHNMYXlvdXQiLCJwcmVzZW5jZUNoaWxkcmVuIiwibmV3Q2hpbGRyZW5NYXAiLCJjaGlsZElkIiwiZV8xIiwiX192YWx1ZXMiLCJkb25lIiwiaXNDb21wbGV0ZSIsImVfMV8xIiwiZXJyb3IiLCJyZXR1cm4iLCJfIiwiZ2V0Q2hpbGRLZXkiLCJ1cGRhdGVDaGlsZExvb2t1cCIsImFsbENoaWxkcmVuIiwib25seUVsZW1lbnRzIiwiZmlsdGVyZWQiLCJDaGlsZHJlbiIsImlzVmFsaWRFbGVtZW50IiwiQW5pbWF0ZVByZXNlbmNlIiwiZXhpdEJlZm9yZUVudGVyIiwiZm9yY2VSZW5kZXJMYXlvdXRHcm91cCIsImZpbHRlcmVkQ2hpbGRyZW4iLCJjaGlsZHJlblRvUmVuZGVyIiwiZXhpdGluZyIsInByZXNlbnRDaGlsZHJlbiIsIkZyYWdtZW50IiwicHJlc2VudEtleXMiLCJ0YXJnZXRLZXlzIiwibnVtUHJlc2VudCIsImluc2VydGlvbkluZGV4Iiwib25FeGl0IiwicmVtb3ZlSW5kZXgiLCJwcmVzZW50Q2hpbGQiLCJjbG9uZUVsZW1lbnQiLCJEZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0Iiwibm9kZUdyb3VwIiwiZGlydHlBbGwiLCJkaXJ0eSIsInNob3VsZEluaGVyaXRHcm91cCIsInNob3VsZEluaGVyaXRJZCIsIkxheW91dEdyb3VwIiwiaW5oZXJpdElkIiwibGF5b3V0R3JvdXBDb250ZXh0IiwiZGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCIsInVwc3RyZWFtSWQiLCJtZW1vaXplZENvbnRleHQiLCJBbmltYXRlU2hhcmVkTGF5b3V0IiwiTW90aW9uQ29uZmlnIiwiTGF6eU1vdGlvbiIsImlzTGF6eUJ1bmRsZSIsInNldElzTG9hZGVkIiwibG9hZGVkUmVuZGVyZXIiLCJsb2FkZWRGZWF0dXJlcyIsIlJlb3JkZXJDb250ZXh0IiwiY2hlY2tSZW9yZGVyIiwibmV4dE9mZnNldCIsIm5leHRJdGVtIiwibmV4dExheW91dCIsIm5leHRJdGVtQ2VudGVyIiwiUmVvcmRlckdyb3VwIiwiYXMiLCJvblJlb3JkZXIiLCJpc1Jlb3JkZXJpbmciLCJyZWdpc3Rlckl0ZW0iLCJjb21wYXJlTWluIiwidXBkYXRlT3JkZXIiLCJuZXdPcmRlciIsIkdyb3VwIiwidXNlTW90aW9uVmFsdWUiLCJzZXRMYXRlc3RfMSIsImlzQ3VzdG9tVmFsdWVUeXBlIiwiZ2V0TWl4ZXIiLCJ1c2VJbW1lZGlhdGUiLCJhcmdPZmZzZXQiLCJpbnB1dFZhbHVlIiwiaW5wdXRSYW5nZSIsIm91dHB1dFJhbmdlIiwiaW50ZXJwb2xhdG9yIiwiaW50ZXJwb2xhdGUiLCJtaXhlciIsInVzZU9uQ2hhbmdlIiwidXNlTXVsdGlPbkNoYW5nZSIsInVuc3Vic2NyaWJlIiwidXNlQ29tYmluZU1vdGlvblZhbHVlcyIsImNvbWJpbmVWYWx1ZXMiLCJ1cGRhdGVWYWx1ZSIsInVzZVRyYW5zZm9ybSIsImlucHV0IiwiaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXIiLCJ0cmFuc2Zvcm1lciIsInVzZUxpc3RUcmFuc2Zvcm0iLCJudW1WYWx1ZXMiLCJ1c2VEZWZhdWx0TW90aW9uVmFsdWUiLCJSZW9yZGVySXRlbSIsImxhdGVzdFgiLCJsYXRlc3RZIiwiZ2VzdHVyZVBvaW50Iiwib25MYXlvdXRNZWFzdXJlIiwiSXRlbSIsIlJlb3JkZXIiLCJkb21BbmltYXRpb24iLCJkb21NYXgiLCJ1c2VNb3Rpb25UZW1wbGF0ZSIsImZyYWdtZW50cyIsIm51bUZyYWdtZW50cyIsImJ1aWxkVmFsdWUiLCJ1c2VTcHJpbmciLCJhY3RpdmVTcHJpbmdBbmltYXRpb24iLCJ1c2VWZWxvY2l0eSIsIm5ld1ZlbG9jaXR5IiwiY3JlYXRlU2Nyb2xsTW90aW9uVmFsdWVzIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJzY3JvbGxYUHJvZ3Jlc3MiLCJzY3JvbGxZUHJvZ3Jlc3MiLCJ1c2VTY3JvbGwiLCJjb250YWluZXIiLCJ1c2VFbGVtZW50U2Nyb2xsIiwidXNlVmlld3BvcnRTY3JvbGwiLCJnZXRDdXJyZW50VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsInVzZUFuaW1hdGlvbkZyYW1lIiwiaW5pdGlhbFRpbWVzdGFtcCIsInByb3ZpZGVUaW1lU2luY2VTdGFydCIsInVzZVRpbWUiLCJ0IiwiYW5pbWF0aW9uQ29udHJvbHMiLCJoYXNNb3VudGVkIiwicGVuZGluZ0FuaW1hdGlvbnMiLCJzdWJzY3JpYmVycyIsImFuaW1hdGlvbnNfMSIsInVzZUFuaW1hdGlvbkNvbnRyb2xzIiwidXNlQW5pbWF0aW9uIiwidXNlQ3ljbGUiLCJpdGVtcyIsInNldEl0ZW0iLCJydW5DeWNsZSIsIndyYXAiLCJ1c2VJblZpZXciLCJzZXRJblZpZXciLCJvbkVudGVyIiwiRHJhZ0NvbnRyb2xzIiwiY29tcG9uZW50Q29udHJvbHMiLCJuYXRpdmVFdmVudCIsImNyZWF0ZURyYWdDb250cm9scyIsInVzZURyYWdDb250cm9scyIsInVzZUluc3RhbnRMYXlvdXRUcmFuc2l0aW9uIiwic3RhcnRUcmFuc2l0aW9uIiwiY2IiLCJ1c2VJbnN0YW50VHJhbnNpdGlvbiIsImZvcmNlVXBkYXRlIiwic3RhcnRJbnN0YW50TGF5b3V0VHJhbnNpdGlvbiIsInVzZVJlc2V0UHJvamVjdGlvbiIsInJlc2V0IiwiY3JlYXRlT2JqZWN0Iiwic3RhdGVWaXN1YWxFbGVtZW50IiwiX3N0YXRlIiwiaW5pdGlhbFN0YXRlIiwidXNlQW5pbWF0ZWRTdGF0ZSIsInNldEFuaW1hdGlvblN0YXRlIiwiYW5pbWF0aW9uRGVmaW5pdGlvbiIsIm1heFNjYWxlIiwiaW52ZXJ0U2NhbGUiLCJoYXNXYXJuZWQiLCJ1c2VJbnZlcnRlZFNjYWxlIiwicGFyZW50U2NhbGVYIiwicGFyZW50U2NhbGVZIiwidXNlRGVwcmVjYXRlZEFuaW1hdGVkU3RhdGUiLCJ1c2VEZXByZWNhdGVkSW52ZXJ0ZWRTY2FsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/framer-motion@6.5.1_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/cjs/index.js\n");

/***/ })

};
;