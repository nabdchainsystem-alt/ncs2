"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jquery@3.7.1";
exports.ids = ["vendor-chunks/jquery@3.7.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/jquery@3.7.1/node_modules/jquery/dist/jquery.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/jquery@3.7.1/node_modules/jquery/dist/jquery.js ***!
  \****************************************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*!\n * jQuery JavaScript Library v3.7.1\n * https://jquery.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2023-08-28T13:37Z\n */ (function(global, factory) {\n    \"use strict\";\n    if ( true && typeof module.exports === \"object\") {\n        // For CommonJS and CommonJS-like environments where a proper `window`\n        // is present, execute the factory and get jQuery.\n        // For environments that do not have a `window` with a `document`\n        // (such as Node.js), expose a factory as module.exports.\n        // This accentuates the need for the creation of a real `window`.\n        // e.g. var jQuery = require(\"jquery\")(window);\n        // See ticket trac-14549 for more info.\n        module.exports = global.document ? factory(global, true) : function(w) {\n            if (!w.document) {\n                throw new Error(\"jQuery requires a window with a document\");\n            }\n            return factory(w);\n        };\n    } else {\n        factory(global);\n    }\n// Pass this if window is not defined yet\n})( false ? 0 : void 0, function(window1, noGlobal) {\n    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n    // enough that all such attempts are guarded in a try block.\n    \"use strict\";\n    var arr = [];\n    var getProto = Object.getPrototypeOf;\n    var slice = arr.slice;\n    var flat = arr.flat ? function(array) {\n        return arr.flat.call(array);\n    } : function(array) {\n        return arr.concat.apply([], array);\n    };\n    var push = arr.push;\n    var indexOf = arr.indexOf;\n    var class2type = {};\n    var toString = class2type.toString;\n    var hasOwn = class2type.hasOwnProperty;\n    var fnToString = hasOwn.toString;\n    var ObjectFunctionString = fnToString.call(Object);\n    var support = {};\n    var isFunction = function isFunction(obj) {\n        // Support: Chrome <=57, Firefox <=52\n        // In some browsers, typeof returns \"function\" for HTML <object> elements\n        // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n        // We don't want to classify *any* DOM node as a function.\n        // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n        // Plus for old WebKit, typeof returns \"function\" for HTML collections\n        // (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n        return typeof obj === \"function\" && typeof obj.nodeType !== \"number\" && typeof obj.item !== \"function\";\n    };\n    var isWindow = function isWindow(obj) {\n        return obj != null && obj === obj.window;\n    };\n    var document = window1.document;\n    var preservedScriptAttributes = {\n        type: true,\n        src: true,\n        nonce: true,\n        noModule: true\n    };\n    function DOMEval(code, node, doc) {\n        doc = doc || document;\n        var i, val, script = doc.createElement(\"script\");\n        script.text = code;\n        if (node) {\n            for(i in preservedScriptAttributes){\n                // Support: Firefox 64+, Edge 18+\n                // Some browsers don't support the \"nonce\" property on scripts.\n                // On the other hand, just using `getAttribute` is not enough as\n                // the `nonce` attribute is reset to an empty string whenever it\n                // becomes browsing-context connected.\n                // See https://github.com/whatwg/html/issues/2369\n                // See https://html.spec.whatwg.org/#nonce-attributes\n                // The `node.getAttribute` check was added for the sake of\n                // `jQuery.globalEval` so that it can fake a nonce-containing node\n                // via an object.\n                val = node[i] || node.getAttribute && node.getAttribute(i);\n                if (val) {\n                    script.setAttribute(i, val);\n                }\n            }\n        }\n        doc.head.appendChild(script).parentNode.removeChild(script);\n    }\n    function toType(obj) {\n        if (obj == null) {\n            return obj + \"\";\n        }\n        // Support: Android <=2.3 only (functionish RegExp)\n        return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : typeof obj;\n    }\n    /* global Symbol */ // Defining this global in .eslintrc.json would create a danger of using the global\n    // unguarded in another place, it seems safer to define global only for this module\n    var version = \"3.7.1\", rhtmlSuffix = /HTML$/i, // Define a local copy of jQuery\n    jQuery = function(selector, context) {\n        // The jQuery object is actually just the init constructor 'enhanced'\n        // Need init if jQuery is called (just allow error to be thrown if not included)\n        return new jQuery.fn.init(selector, context);\n    };\n    jQuery.fn = jQuery.prototype = {\n        // The current version of jQuery being used\n        jquery: version,\n        constructor: jQuery,\n        // The default length of a jQuery object is 0\n        length: 0,\n        toArray: function() {\n            return slice.call(this);\n        },\n        // Get the Nth element in the matched element set OR\n        // Get the whole matched element set as a clean array\n        get: function(num) {\n            // Return all the elements in a clean array\n            if (num == null) {\n                return slice.call(this);\n            }\n            // Return just the one element from the set\n            return num < 0 ? this[num + this.length] : this[num];\n        },\n        // Take an array of elements and push it onto the stack\n        // (returning the new matched element set)\n        pushStack: function(elems) {\n            // Build a new jQuery matched element set\n            var ret = jQuery.merge(this.constructor(), elems);\n            // Add the old object onto the stack (as a reference)\n            ret.prevObject = this;\n            // Return the newly-formed element set\n            return ret;\n        },\n        // Execute a callback for every element in the matched set.\n        each: function(callback) {\n            return jQuery.each(this, callback);\n        },\n        map: function(callback) {\n            return this.pushStack(jQuery.map(this, function(elem, i) {\n                return callback.call(elem, i, elem);\n            }));\n        },\n        slice: function() {\n            return this.pushStack(slice.apply(this, arguments));\n        },\n        first: function() {\n            return this.eq(0);\n        },\n        last: function() {\n            return this.eq(-1);\n        },\n        even: function() {\n            return this.pushStack(jQuery.grep(this, function(_elem, i) {\n                return (i + 1) % 2;\n            }));\n        },\n        odd: function() {\n            return this.pushStack(jQuery.grep(this, function(_elem, i) {\n                return i % 2;\n            }));\n        },\n        eq: function(i) {\n            var len = this.length, j = +i + (i < 0 ? len : 0);\n            return this.pushStack(j >= 0 && j < len ? [\n                this[j]\n            ] : []);\n        },\n        end: function() {\n            return this.prevObject || this.constructor();\n        },\n        // For internal use only.\n        // Behaves like an Array's method, not like a jQuery method.\n        push: push,\n        sort: arr.sort,\n        splice: arr.splice\n    };\n    jQuery.extend = jQuery.fn.extend = function() {\n        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;\n        // Handle a deep copy situation\n        if (typeof target === \"boolean\") {\n            deep = target;\n            // Skip the boolean and the target\n            target = arguments[i] || {};\n            i++;\n        }\n        // Handle case when target is a string or something (possible in deep copy)\n        if (typeof target !== \"object\" && !isFunction(target)) {\n            target = {};\n        }\n        // Extend jQuery itself if only one argument is passed\n        if (i === length) {\n            target = this;\n            i--;\n        }\n        for(; i < length; i++){\n            // Only deal with non-null/undefined values\n            if ((options = arguments[i]) != null) {\n                // Extend the base object\n                for(name in options){\n                    copy = options[name];\n                    // Prevent Object.prototype pollution\n                    // Prevent never-ending loop\n                    if (name === \"__proto__\" || target === copy) {\n                        continue;\n                    }\n                    // Recurse if we're merging plain objects or arrays\n                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n                        src = target[name];\n                        // Ensure proper type for the source value\n                        if (copyIsArray && !Array.isArray(src)) {\n                            clone = [];\n                        } else if (!copyIsArray && !jQuery.isPlainObject(src)) {\n                            clone = {};\n                        } else {\n                            clone = src;\n                        }\n                        copyIsArray = false;\n                        // Never move original objects, clone them\n                        target[name] = jQuery.extend(deep, clone, copy);\n                    // Don't bring in undefined values\n                    } else if (copy !== undefined) {\n                        target[name] = copy;\n                    }\n                }\n            }\n        }\n        // Return the modified object\n        return target;\n    };\n    jQuery.extend({\n        // Unique for each copy of jQuery on the page\n        expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n        // Assume jQuery is ready without the ready module\n        isReady: true,\n        error: function(msg) {\n            throw new Error(msg);\n        },\n        noop: function() {},\n        isPlainObject: function(obj) {\n            var proto, Ctor;\n            // Detect obvious negatives\n            // Use toString instead of jQuery.type to catch host objects\n            if (!obj || toString.call(obj) !== \"[object Object]\") {\n                return false;\n            }\n            proto = getProto(obj);\n            // Objects with no prototype (e.g., `Object.create( null )`) are plain\n            if (!proto) {\n                return true;\n            }\n            // Objects with prototype are plain iff they were constructed by a global Object function\n            Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n            return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n        },\n        isEmptyObject: function(obj) {\n            var name;\n            for(name in obj){\n                return false;\n            }\n            return true;\n        },\n        // Evaluates a script in a provided context; falls back to the global one\n        // if not specified.\n        globalEval: function(code, options, doc) {\n            DOMEval(code, {\n                nonce: options && options.nonce\n            }, doc);\n        },\n        each: function(obj, callback) {\n            var length, i = 0;\n            if (isArrayLike(obj)) {\n                length = obj.length;\n                for(; i < length; i++){\n                    if (callback.call(obj[i], i, obj[i]) === false) {\n                        break;\n                    }\n                }\n            } else {\n                for(i in obj){\n                    if (callback.call(obj[i], i, obj[i]) === false) {\n                        break;\n                    }\n                }\n            }\n            return obj;\n        },\n        // Retrieve the text value of an array of DOM nodes\n        text: function(elem) {\n            var node, ret = \"\", i = 0, nodeType = elem.nodeType;\n            if (!nodeType) {\n                // If no nodeType, this is expected to be an array\n                while(node = elem[i++]){\n                    // Do not traverse comment nodes\n                    ret += jQuery.text(node);\n                }\n            }\n            if (nodeType === 1 || nodeType === 11) {\n                return elem.textContent;\n            }\n            if (nodeType === 9) {\n                return elem.documentElement.textContent;\n            }\n            if (nodeType === 3 || nodeType === 4) {\n                return elem.nodeValue;\n            }\n            // Do not include comment or processing instruction nodes\n            return ret;\n        },\n        // results is for internal usage only\n        makeArray: function(arr, results) {\n            var ret = results || [];\n            if (arr != null) {\n                if (isArrayLike(Object(arr))) {\n                    jQuery.merge(ret, typeof arr === \"string\" ? [\n                        arr\n                    ] : arr);\n                } else {\n                    push.call(ret, arr);\n                }\n            }\n            return ret;\n        },\n        inArray: function(elem, arr, i) {\n            return arr == null ? -1 : indexOf.call(arr, elem, i);\n        },\n        isXMLDoc: function(elem) {\n            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;\n            // Assume HTML when documentElement doesn't yet exist, such as inside\n            // document fragments.\n            return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || \"HTML\");\n        },\n        // Support: Android <=4.0 only, PhantomJS 1 only\n        // push.apply(_, arraylike) throws on ancient WebKit\n        merge: function(first, second) {\n            var len = +second.length, j = 0, i = first.length;\n            for(; j < len; j++){\n                first[i++] = second[j];\n            }\n            first.length = i;\n            return first;\n        },\n        grep: function(elems, callback, invert) {\n            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;\n            // Go through the array, only saving the items\n            // that pass the validator function\n            for(; i < length; i++){\n                callbackInverse = !callback(elems[i], i);\n                if (callbackInverse !== callbackExpect) {\n                    matches.push(elems[i]);\n                }\n            }\n            return matches;\n        },\n        // arg is for internal usage only\n        map: function(elems, callback, arg) {\n            var length, value, i = 0, ret = [];\n            // Go through the array, translating each of the items to their new values\n            if (isArrayLike(elems)) {\n                length = elems.length;\n                for(; i < length; i++){\n                    value = callback(elems[i], i, arg);\n                    if (value != null) {\n                        ret.push(value);\n                    }\n                }\n            // Go through every key on the object,\n            } else {\n                for(i in elems){\n                    value = callback(elems[i], i, arg);\n                    if (value != null) {\n                        ret.push(value);\n                    }\n                }\n            }\n            // Flatten any nested arrays\n            return flat(ret);\n        },\n        // A global GUID counter for objects\n        guid: 1,\n        // jQuery.support is not used in Core but other projects attach their\n        // properties to it so it needs to exist.\n        support: support\n    });\n    if (typeof Symbol === \"function\") {\n        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n    }\n    // Populate the class2type map\n    jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function(_i, name) {\n        class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n    });\n    function isArrayLike(obj) {\n        // Support: real iOS 8.2 only (not reproducible in simulator)\n        // `in` check used to prevent JIT error (gh-2145)\n        // hasOwn isn't used here due to false negatives\n        // regarding Nodelist length in IE\n        var length = !!obj && \"length\" in obj && obj.length, type = toType(obj);\n        if (isFunction(obj) || isWindow(obj)) {\n            return false;\n        }\n        return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n    }\n    function nodeName(elem, name) {\n        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n    }\n    var pop = arr.pop;\n    var sort = arr.sort;\n    var splice = arr.splice;\n    var whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\n    var rtrimCSS = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\");\n    // Note: an element does not contain itself\n    jQuery.contains = function(a, b) {\n        var bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+\n        // IE doesn't have `contains` on SVG.\n        (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n    };\n    // CSS string/identifier serialization\n    // https://drafts.csswg.org/cssom/#common-serializing-idioms\n    var rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g;\n    function fcssescape(ch, asCodePoint) {\n        if (asCodePoint) {\n            // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n            if (ch === \"\\x00\") {\n                return \"ï¿½\";\n            }\n            // Control characters and (dependent upon position) numbers get escaped as code points\n            return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n        }\n        // Other potentially-special ASCII characters get backslash-escaped\n        return \"\\\\\" + ch;\n    }\n    jQuery.escapeSelector = function(sel) {\n        return (sel + \"\").replace(rcssescape, fcssescape);\n    };\n    var preferredDoc = document, pushNative = push;\n    (function() {\n        var i, Expr, outermostContext, sortInput, hasDuplicate, push = pushNative, // Local document vars\n        document, documentElement, documentIsHTML, rbuggyQSA, matches, // Instance-specific data\n        expando = jQuery.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {\n            if (a === b) {\n                hasDuplicate = true;\n            }\n            return 0;\n        }, booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|\" + \"loop|multiple|open|readonly|required|scoped\", // Regular expressions\n        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n        identifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\x00-\\\\x7f])+\", // Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors\n        attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n        \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n        \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\", pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n        // 1. quoted (capture 3; capture 4 or capture 5)\n        \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n        \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n        \".*\" + \")\\\\)|)\", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n        rwhitespace = new RegExp(whitespace + \"+\", \"g\"), rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"), rleadingCombinator = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"), rdescend = new RegExp(whitespace + \"|>\"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp(\"^\" + identifier + \"$\"), matchExpr = {\n            ID: new RegExp(\"^#(\" + identifier + \")\"),\n            CLASS: new RegExp(\"^\\\\.(\" + identifier + \")\"),\n            TAG: new RegExp(\"^(\" + identifier + \"|[*])\"),\n            ATTR: new RegExp(\"^\" + attributes),\n            PSEUDO: new RegExp(\"^\" + pseudos),\n            CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n            bool: new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n            // For use in libraries implementing .is()\n            // We use this for POS matching in `select`\n            needsContext: new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\\d$/i, // Easily-parseable/retrievable ID or TAG or CLASS selectors\n        rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/, rsibling = /[+~]/, // CSS escapes\n        // https://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n        runescape = new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\"), funescape = function(escape, nonHex) {\n            var high = \"0x\" + escape.slice(1) - 0x10000;\n            if (nonHex) {\n                // Strip the backslash prefix from a non-hex escape sequence\n                return nonHex;\n            }\n            // Replace a hexadecimal escape sequence with the encoded Unicode code point\n            // Support: IE <=11+\n            // For values outside the Basic Multilingual Plane (BMP), manually construct a\n            // surrogate pair\n            return high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n        }, // Used for iframes; see `setDocument`.\n        // Support: IE 9 - 11+, Edge 12 - 18+\n        // Removing the function wrapper causes a \"Permission Denied\"\n        // error in IE/Edge.\n        unloadHandler = function() {\n            setDocument();\n        }, inDisabledFieldset = addCombinator(function(elem) {\n            return elem.disabled === true && nodeName(elem, \"fieldset\");\n        }, {\n            dir: \"parentNode\",\n            next: \"legend\"\n        });\n        // Support: IE <=9 only\n        // Accessing document.activeElement can throw unexpectedly\n        // https://bugs.jquery.com/ticket/13393\n        function safeActiveElement() {\n            try {\n                return document.activeElement;\n            } catch (err) {}\n        }\n        // Optimize for push.apply( _, NodeList )\n        try {\n            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\n            // Support: Android <=4.0\n            // Detect silently failing push.apply\n            // eslint-disable-next-line no-unused-expressions\n            arr[preferredDoc.childNodes.length].nodeType;\n        } catch (e) {\n            push = {\n                apply: function(target, els) {\n                    pushNative.apply(target, slice.call(els));\n                },\n                call: function(target) {\n                    pushNative.apply(target, slice.call(arguments, 1));\n                }\n            };\n        }\n        function find(selector, context, results, seed) {\n            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, // nodeType defaults to 9, since context defaults to document\n            nodeType = context ? context.nodeType : 9;\n            results = results || [];\n            // Return early from calls with invalid selector or context\n            if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n                return results;\n            }\n            // Try to shortcut find operations (as opposed to filters) in HTML documents\n            if (!seed) {\n                setDocument(context);\n                context = context || document;\n                if (documentIsHTML) {\n                    // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n                    // (excepting DocumentFragment context, where the methods don't exist)\n                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n                        // ID selector\n                        if (m = match[1]) {\n                            // Document context\n                            if (nodeType === 9) {\n                                if (elem = context.getElementById(m)) {\n                                    // Support: IE 9 only\n                                    // getElementById can match elements by name instead of ID\n                                    if (elem.id === m) {\n                                        push.call(results, elem);\n                                        return results;\n                                    }\n                                } else {\n                                    return results;\n                                }\n                            // Element context\n                            } else {\n                                // Support: IE 9 only\n                                // getElementById can match elements by name instead of ID\n                                if (newContext && (elem = newContext.getElementById(m)) && find.contains(context, elem) && elem.id === m) {\n                                    push.call(results, elem);\n                                    return results;\n                                }\n                            }\n                        // Type selector\n                        } else if (match[2]) {\n                            push.apply(results, context.getElementsByTagName(selector));\n                            return results;\n                        // Class selector\n                        } else if ((m = match[3]) && context.getElementsByClassName) {\n                            push.apply(results, context.getElementsByClassName(m));\n                            return results;\n                        }\n                    }\n                    // Take advantage of querySelectorAll\n                    if (!nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n                        newSelector = selector;\n                        newContext = context;\n                        // qSA considers elements outside a scoping root when evaluating child or\n                        // descendant combinators, which is not what we want.\n                        // In such cases, we work around the behavior by prefixing every selector in the\n                        // list with an ID selector referencing the scope context.\n                        // The technique has to be used as well when a leading combinator is used\n                        // as such selectors are not recognized by querySelectorAll.\n                        // Thanks to Andrew Dupont for this technique.\n                        if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {\n                            // Expand context for sibling selectors\n                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n                            // We can use :scope instead of the ID hack if the browser\n                            // supports it & if we're not changing the context.\n                            // Support: IE 11+, Edge 17 - 18+\n                            // IE/Edge sometimes throw a \"Permission denied\" error when\n                            // strict-comparing two documents; shallow comparisons work.\n                            // eslint-disable-next-line eqeqeq\n                            if (newContext != context || !support.scope) {\n                                // Capture the context ID, setting it first if necessary\n                                if (nid = context.getAttribute(\"id\")) {\n                                    nid = jQuery.escapeSelector(nid);\n                                } else {\n                                    context.setAttribute(\"id\", nid = expando);\n                                }\n                            }\n                            // Prefix every selector in the list\n                            groups = tokenize(selector);\n                            i = groups.length;\n                            while(i--){\n                                groups[i] = (nid ? \"#\" + nid : \":scope\") + \" \" + toSelector(groups[i]);\n                            }\n                            newSelector = groups.join(\",\");\n                        }\n                        try {\n                            push.apply(results, newContext.querySelectorAll(newSelector));\n                            return results;\n                        } catch (qsaError) {\n                            nonnativeSelectorCache(selector, true);\n                        } finally{\n                            if (nid === expando) {\n                                context.removeAttribute(\"id\");\n                            }\n                        }\n                    }\n                }\n            }\n            // All others\n            return select(selector.replace(rtrimCSS, \"$1\"), context, results, seed);\n        }\n        /**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */ function createCache() {\n            var keys = [];\n            function cache(key, value) {\n                // Use (key + \" \") to avoid collision with native prototype properties\n                // (see https://github.com/jquery/sizzle/issues/157)\n                if (keys.push(key + \" \") > Expr.cacheLength) {\n                    // Only keep the most recent entries\n                    delete cache[keys.shift()];\n                }\n                return cache[key + \" \"] = value;\n            }\n            return cache;\n        }\n        /**\n * Mark a function for special use by jQuery selector module\n * @param {Function} fn The function to mark\n */ function markFunction(fn) {\n            fn[expando] = true;\n            return fn;\n        }\n        /**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */ function assert(fn) {\n            var el = document.createElement(\"fieldset\");\n            try {\n                return !!fn(el);\n            } catch (e) {\n                return false;\n            } finally{\n                // Remove from its parent by default\n                if (el.parentNode) {\n                    el.parentNode.removeChild(el);\n                }\n                // release memory in IE\n                el = null;\n            }\n        }\n        /**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */ function createInputPseudo(type) {\n            return function(elem) {\n                return nodeName(elem, \"input\") && elem.type === type;\n            };\n        }\n        /**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */ function createButtonPseudo(type) {\n            return function(elem) {\n                return (nodeName(elem, \"input\") || nodeName(elem, \"button\")) && elem.type === type;\n            };\n        }\n        /**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */ function createDisabledPseudo(disabled) {\n            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n            return function(elem) {\n                // Only certain elements can match :enabled or :disabled\n                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n                if (\"form\" in elem) {\n                    // Check for inherited disabledness on relevant non-disabled elements:\n                    // * listed form-associated elements in a disabled fieldset\n                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n                    // * option elements in a disabled optgroup\n                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n                    // All such elements have a \"form\" property.\n                    if (elem.parentNode && elem.disabled === false) {\n                        // Option elements defer to a parent optgroup if present\n                        if (\"label\" in elem) {\n                            if (\"label\" in elem.parentNode) {\n                                return elem.parentNode.disabled === disabled;\n                            } else {\n                                return elem.disabled === disabled;\n                            }\n                        }\n                        // Support: IE 6 - 11+\n                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n                        return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n                        elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n                    }\n                    return elem.disabled === disabled;\n                // Try to winnow out elements that can't be disabled before trusting the disabled property.\n                // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n                // even exist on them, let alone have a boolean value.\n                } else if (\"label\" in elem) {\n                    return elem.disabled === disabled;\n                }\n                // Remaining elements are neither :enabled nor :disabled\n                return false;\n            };\n        }\n        /**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */ function createPositionalPseudo(fn) {\n            return markFunction(function(argument) {\n                argument = +argument;\n                return markFunction(function(seed, matches) {\n                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;\n                    // Match elements found at the specified indexes\n                    while(i--){\n                        if (seed[j = matchIndexes[i]]) {\n                            seed[j] = !(matches[j] = seed[j]);\n                        }\n                    }\n                });\n            });\n        }\n        /**\n * Checks a node for validity as a jQuery selector context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */ function testContext(context) {\n            return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n        }\n        /**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [node] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */ function setDocument(node) {\n            var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;\n            // Return early if doc is invalid or already selected\n            // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n            if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {\n                return document;\n            }\n            // Update global variables\n            document = doc;\n            documentElement = document.documentElement;\n            documentIsHTML = !jQuery.isXMLDoc(document);\n            // Support: iOS 7 only, IE 9 - 11+\n            // Older browsers didn't support unprefixed `matches`.\n            matches = documentElement.matches || documentElement.webkitMatchesSelector || documentElement.msMatchesSelector;\n            // Support: IE 9 - 11+, Edge 12 - 18+\n            // Accessing iframe documents after unload throws \"permission denied\" errors\n            // (see trac-13936).\n            // Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,\n            // all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.\n            if (documentElement.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n            preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n                // Support: IE 9 - 11+, Edge 12 - 18+\n                subWindow.addEventListener(\"unload\", unloadHandler);\n            }\n            // Support: IE <10\n            // Check if getElementById returns elements by name\n            // The broken getElementById methods don't pick up programmatically-set names,\n            // so use a roundabout getElementsByName test\n            support.getById = assert(function(el) {\n                documentElement.appendChild(el).id = jQuery.expando;\n                return !document.getElementsByName || !document.getElementsByName(jQuery.expando).length;\n            });\n            // Support: IE 9 only\n            // Check to see if it's possible to do matchesSelector\n            // on a disconnected node.\n            support.disconnectedMatch = assert(function(el) {\n                return matches.call(el, \"*\");\n            });\n            // Support: IE 9 - 11+, Edge 12 - 18+\n            // IE/Edge don't support the :scope pseudo-class.\n            support.scope = assert(function() {\n                return document.querySelectorAll(\":scope\");\n            });\n            // Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only\n            // Make sure the `:has()` argument is parsed unforgivingly.\n            // We include `*` in the test to detect buggy implementations that are\n            // _selectively_ forgiving (specifically when the list includes at least\n            // one valid selector).\n            // Note that we treat complete lack of support for `:has()` as if it were\n            // spec-compliant support, which is fine because use of `:has()` in such\n            // environments will fail in the qSA path and fall back to jQuery traversal\n            // anyway.\n            support.cssHas = assert(function() {\n                try {\n                    document.querySelector(\":has(*,:jqfake)\");\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            });\n            // ID filter and find\n            if (support.getById) {\n                Expr.filter.ID = function(id) {\n                    var attrId = id.replace(runescape, funescape);\n                    return function(elem) {\n                        return elem.getAttribute(\"id\") === attrId;\n                    };\n                };\n                Expr.find.ID = function(id, context) {\n                    if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n                        var elem = context.getElementById(id);\n                        return elem ? [\n                            elem\n                        ] : [];\n                    }\n                };\n            } else {\n                Expr.filter.ID = function(id) {\n                    var attrId = id.replace(runescape, funescape);\n                    return function(elem) {\n                        var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n                        return node && node.value === attrId;\n                    };\n                };\n                // Support: IE 6 - 7 only\n                // getElementById is not reliable as a find shortcut\n                Expr.find.ID = function(id, context) {\n                    if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n                        var node, i, elems, elem = context.getElementById(id);\n                        if (elem) {\n                            // Verify the id attribute\n                            node = elem.getAttributeNode(\"id\");\n                            if (node && node.value === id) {\n                                return [\n                                    elem\n                                ];\n                            }\n                            // Fall back on getElementsByName\n                            elems = context.getElementsByName(id);\n                            i = 0;\n                            while(elem = elems[i++]){\n                                node = elem.getAttributeNode(\"id\");\n                                if (node && node.value === id) {\n                                    return [\n                                        elem\n                                    ];\n                                }\n                            }\n                        }\n                        return [];\n                    }\n                };\n            }\n            // Tag\n            Expr.find.TAG = function(tag, context) {\n                if (typeof context.getElementsByTagName !== \"undefined\") {\n                    return context.getElementsByTagName(tag);\n                // DocumentFragment nodes don't have gEBTN\n                } else {\n                    return context.querySelectorAll(tag);\n                }\n            };\n            // Class\n            Expr.find.CLASS = function(className, context) {\n                if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n                    return context.getElementsByClassName(className);\n                }\n            };\n            /* QSA/matchesSelector\n\t---------------------------------------------------------------------- */ // QSA and matchesSelector support\n            rbuggyQSA = [];\n            // Build QSA regex\n            // Regex strategy adopted from Diego Perini\n            assert(function(el) {\n                var input;\n                documentElement.appendChild(el).innerHTML = \"<a id='\" + expando + \"' href='' disabled='disabled'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' disabled='disabled'>\" + \"<option selected=''></option></select>\";\n                // Support: iOS <=7 - 8 only\n                // Boolean attributes and \"value\" are not treated correctly in some XML documents\n                if (!el.querySelectorAll(\"[selected]\").length) {\n                    rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n                }\n                // Support: iOS <=7 - 8 only\n                if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n                    rbuggyQSA.push(\"~=\");\n                }\n                // Support: iOS 8 only\n                // https://bugs.webkit.org/show_bug.cgi?id=136851\n                // In-page `selector#id sibling-combinator selector` fails\n                if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n                    rbuggyQSA.push(\".#.+[+~]\");\n                }\n                // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+\n                // In some of the document kinds, these selectors wouldn't work natively.\n                // This is probably OK but for backwards compatibility we want to maintain\n                // handling them through jQuery traversal in jQuery 3.x.\n                if (!el.querySelectorAll(\":checked\").length) {\n                    rbuggyQSA.push(\":checked\");\n                }\n                // Support: Windows 8 Native Apps\n                // The type and name attributes are restricted during .innerHTML assignment\n                input = document.createElement(\"input\");\n                input.setAttribute(\"type\", \"hidden\");\n                el.appendChild(input).setAttribute(\"name\", \"D\");\n                // Support: IE 9 - 11+\n                // IE's :disabled selector does not pick up the children of disabled fieldsets\n                // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+\n                // In some of the document kinds, these selectors wouldn't work natively.\n                // This is probably OK but for backwards compatibility we want to maintain\n                // handling them through jQuery traversal in jQuery 3.x.\n                documentElement.appendChild(el).disabled = true;\n                if (el.querySelectorAll(\":disabled\").length !== 2) {\n                    rbuggyQSA.push(\":enabled\", \":disabled\");\n                }\n                // Support: IE 11+, Edge 15 - 18+\n                // IE 11/Edge don't find elements on a `[name='']` query in some cases.\n                // Adding a temporary attribute to the document before the selection works\n                // around the issue.\n                // Interestingly, IE 10 & older don't seem to have the issue.\n                input = document.createElement(\"input\");\n                input.setAttribute(\"name\", \"\");\n                el.appendChild(input);\n                if (!el.querySelectorAll(\"[name='']\").length) {\n                    rbuggyQSA.push(\"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" + whitespace + \"*(?:''|\\\"\\\")\");\n                }\n            });\n            if (!support.cssHas) {\n                // Support: Chrome 105 - 110+, Safari 15.4 - 16.3+\n                // Our regular `try-catch` mechanism fails to detect natively-unsupported\n                // pseudo-classes inside `:has()` (such as `:has(:contains(\"Foo\"))`)\n                // in browsers that parse the `:has()` argument as a forgiving selector list.\n                // https://drafts.csswg.org/selectors/#relational now requires the argument\n                // to be parsed unforgivingly, but browsers have not yet fully adjusted.\n                rbuggyQSA.push(\":has\");\n            }\n            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n            /* Sorting\n\t---------------------------------------------------------------------- */ // Document order sorting\n            sortOrder = function(a, b) {\n                // Flag for duplicate removal\n                if (a === b) {\n                    hasDuplicate = true;\n                    return 0;\n                }\n                // Sort on method existence if only one input has compareDocumentPosition\n                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n                if (compare) {\n                    return compare;\n                }\n                // Calculate position if both inputs belong to the same document\n                // Support: IE 11+, Edge 17 - 18+\n                // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                // two documents; shallow comparisons work.\n                // eslint-disable-next-line eqeqeq\n                compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n                1;\n                // Disconnected nodes\n                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n                    // Choose the first element that is related to our preferred document\n                    // Support: IE 11+, Edge 17 - 18+\n                    // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                    // two documents; shallow comparisons work.\n                    // eslint-disable-next-line eqeqeq\n                    if (a === document || a.ownerDocument == preferredDoc && find.contains(preferredDoc, a)) {\n                        return -1;\n                    }\n                    // Support: IE 11+, Edge 17 - 18+\n                    // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                    // two documents; shallow comparisons work.\n                    // eslint-disable-next-line eqeqeq\n                    if (b === document || b.ownerDocument == preferredDoc && find.contains(preferredDoc, b)) {\n                        return 1;\n                    }\n                    // Maintain original order\n                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;\n                }\n                return compare & 4 ? -1 : 1;\n            };\n            return document;\n        }\n        find.matches = function(expr, elements) {\n            return find(expr, null, null, elements);\n        };\n        find.matchesSelector = function(elem, expr) {\n            setDocument(elem);\n            if (documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n                try {\n                    var ret = matches.call(elem, expr);\n                    // IE 9's matchesSelector returns false on disconnected nodes\n                    if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n                    // fragment in IE 9\n                    elem.document && elem.document.nodeType !== 11) {\n                        return ret;\n                    }\n                } catch (e) {\n                    nonnativeSelectorCache(expr, true);\n                }\n            }\n            return find(expr, document, null, [\n                elem\n            ]).length > 0;\n        };\n        find.contains = function(context, elem) {\n            // Set document vars if needed\n            // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n            if ((context.ownerDocument || context) != document) {\n                setDocument(context);\n            }\n            return jQuery.contains(context, elem);\n        };\n        find.attr = function(elem, name) {\n            // Set document vars if needed\n            // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n            if ((elem.ownerDocument || elem) != document) {\n                setDocument(elem);\n            }\n            var fn = Expr.attrHandle[name.toLowerCase()], // Don't get fooled by Object.prototype properties (see trac-13807)\n            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n            if (val !== undefined) {\n                return val;\n            }\n            return elem.getAttribute(name);\n        };\n        find.error = function(msg) {\n            throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n        };\n        /**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */ jQuery.uniqueSort = function(results) {\n            var elem, duplicates = [], j = 0, i = 0;\n            // Unless we *know* we can detect duplicates, assume their presence\n            //\n            // Support: Android <=4.0+\n            // Testing for detecting duplicates is unpredictable so instead assume we can't\n            // depend on duplicate detection in all browsers without a stable sort.\n            hasDuplicate = !support.sortStable;\n            sortInput = !support.sortStable && slice.call(results, 0);\n            sort.call(results, sortOrder);\n            if (hasDuplicate) {\n                while(elem = results[i++]){\n                    if (elem === results[i]) {\n                        j = duplicates.push(i);\n                    }\n                }\n                while(j--){\n                    splice.call(results, duplicates[j], 1);\n                }\n            }\n            // Clear input after sorting to release objects\n            // See https://github.com/jquery/sizzle/pull/225\n            sortInput = null;\n            return results;\n        };\n        jQuery.fn.uniqueSort = function() {\n            return this.pushStack(jQuery.uniqueSort(slice.apply(this)));\n        };\n        Expr = jQuery.expr = {\n            // Can be adjusted by the user\n            cacheLength: 50,\n            createPseudo: markFunction,\n            match: matchExpr,\n            attrHandle: {},\n            find: {},\n            relative: {\n                \">\": {\n                    dir: \"parentNode\",\n                    first: true\n                },\n                \" \": {\n                    dir: \"parentNode\"\n                },\n                \"+\": {\n                    dir: \"previousSibling\",\n                    first: true\n                },\n                \"~\": {\n                    dir: \"previousSibling\"\n                }\n            },\n            preFilter: {\n                ATTR: function(match) {\n                    match[1] = match[1].replace(runescape, funescape);\n                    // Move the given value to match[3] whether quoted or unquoted\n                    match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n                    if (match[2] === \"~=\") {\n                        match[3] = \" \" + match[3] + \" \";\n                    }\n                    return match.slice(0, 4);\n                },\n                CHILD: function(match) {\n                    /* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/ match[1] = match[1].toLowerCase();\n                    if (match[1].slice(0, 3) === \"nth\") {\n                        // nth-* requires argument\n                        if (!match[3]) {\n                            find.error(match[0]);\n                        }\n                        // numeric x and y parameters for Expr.filter.CHILD\n                        // remember that false/true cast respectively to 0/1\n                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n                        match[5] = +(match[7] + match[8] || match[3] === \"odd\");\n                    // other types prohibit arguments\n                    } else if (match[3]) {\n                        find.error(match[0]);\n                    }\n                    return match;\n                },\n                PSEUDO: function(match) {\n                    var excess, unquoted = !match[6] && match[2];\n                    if (matchExpr.CHILD.test(match[0])) {\n                        return null;\n                    }\n                    // Accept quoted arguments as-is\n                    if (match[3]) {\n                        match[2] = match[4] || match[5] || \"\";\n                    // Strip excess characters from unquoted arguments\n                    } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)\n                    (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis\n                    (excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n                        // excess is a negative index\n                        match[0] = match[0].slice(0, excess);\n                        match[2] = unquoted.slice(0, excess);\n                    }\n                    // Return only captures needed by the pseudo filter method (type and argument)\n                    return match.slice(0, 3);\n                }\n            },\n            filter: {\n                TAG: function(nodeNameSelector) {\n                    var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n                    return nodeNameSelector === \"*\" ? function() {\n                        return true;\n                    } : function(elem) {\n                        return nodeName(elem, expectedNodeName);\n                    };\n                },\n                CLASS: function(className) {\n                    var pattern = classCache[className + \" \"];\n                    return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function(elem) {\n                        return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n                    });\n                },\n                ATTR: function(name, operator, check) {\n                    return function(elem) {\n                        var result = find.attr(elem, name);\n                        if (result == null) {\n                            return operator === \"!=\";\n                        }\n                        if (!operator) {\n                            return true;\n                        }\n                        result += \"\";\n                        if (operator === \"=\") {\n                            return result === check;\n                        }\n                        if (operator === \"!=\") {\n                            return result !== check;\n                        }\n                        if (operator === \"^=\") {\n                            return check && result.indexOf(check) === 0;\n                        }\n                        if (operator === \"*=\") {\n                            return check && result.indexOf(check) > -1;\n                        }\n                        if (operator === \"$=\") {\n                            return check && result.slice(-check.length) === check;\n                        }\n                        if (operator === \"~=\") {\n                            return (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1;\n                        }\n                        if (operator === \"|=\") {\n                            return result === check || result.slice(0, check.length + 1) === check + \"-\";\n                        }\n                        return false;\n                    };\n                },\n                CHILD: function(type, what, _argument, first, last) {\n                    var simple = type.slice(0, 3) !== \"nth\", forward = type.slice(-4) !== \"last\", ofType = what === \"of-type\";\n                    return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n                    function(elem) {\n                        return !!elem.parentNode;\n                    } : function(elem, _context, xml) {\n                        var cache, outerCache, node, nodeIndex, start, dir = simple !== forward ? \"nextSibling\" : \"previousSibling\", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;\n                        if (parent) {\n                            // :(first|last|only)-(child|of-type)\n                            if (simple) {\n                                while(dir){\n                                    node = elem;\n                                    while(node = node[dir]){\n                                        if (ofType ? nodeName(node, name) : node.nodeType === 1) {\n                                            return false;\n                                        }\n                                    }\n                                    // Reverse direction for :only-* (if we haven't yet done so)\n                                    start = dir = type === \"only\" && !start && \"nextSibling\";\n                                }\n                                return true;\n                            }\n                            start = [\n                                forward ? parent.firstChild : parent.lastChild\n                            ];\n                            // non-xml :nth-child(...) stores cache data on `parent`\n                            if (forward && useCache) {\n                                // Seek `elem` from a previously-cached index\n                                outerCache = parent[expando] || (parent[expando] = {});\n                                cache = outerCache[type] || [];\n                                nodeIndex = cache[0] === dirruns && cache[1];\n                                diff = nodeIndex && cache[2];\n                                node = nodeIndex && parent.childNodes[nodeIndex];\n                                while(node = ++nodeIndex && node && node[dir] || // Fallback to seeking `elem` from the start\n                                (diff = nodeIndex = 0) || start.pop()){\n                                    // When found, cache indexes on `parent` and break\n                                    if (node.nodeType === 1 && ++diff && node === elem) {\n                                        outerCache[type] = [\n                                            dirruns,\n                                            nodeIndex,\n                                            diff\n                                        ];\n                                        break;\n                                    }\n                                }\n                            } else {\n                                // Use previously-cached element index if available\n                                if (useCache) {\n                                    outerCache = elem[expando] || (elem[expando] = {});\n                                    cache = outerCache[type] || [];\n                                    nodeIndex = cache[0] === dirruns && cache[1];\n                                    diff = nodeIndex;\n                                }\n                                // xml :nth-child(...)\n                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n                                if (diff === false) {\n                                    // Use the same loop as above to seek `elem` from the start\n                                    while(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()){\n                                        if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {\n                                            // Cache the index of each encountered element\n                                            if (useCache) {\n                                                outerCache = node[expando] || (node[expando] = {});\n                                                outerCache[type] = [\n                                                    dirruns,\n                                                    diff\n                                                ];\n                                            }\n                                            if (node === elem) {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            // Incorporate the offset, then check against cycle size\n                            diff -= last;\n                            return diff === first || diff % first === 0 && diff / first >= 0;\n                        }\n                    };\n                },\n                PSEUDO: function(pseudo, argument) {\n                    // pseudo-class names are case-insensitive\n                    // https://www.w3.org/TR/selectors/#pseudo-classes\n                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n                    // Remember that setFilters inherits from pseudos\n                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error(\"unsupported pseudo: \" + pseudo);\n                    // The user may use createPseudo to indicate that\n                    // arguments are needed to create the filter function\n                    // just as jQuery does\n                    if (fn[expando]) {\n                        return fn(argument);\n                    }\n                    // But maintain support for old signatures\n                    if (fn.length > 1) {\n                        args = [\n                            pseudo,\n                            pseudo,\n                            \"\",\n                            argument\n                        ];\n                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {\n                            var idx, matched = fn(seed, argument), i = matched.length;\n                            while(i--){\n                                idx = indexOf.call(seed, matched[i]);\n                                seed[idx] = !(matches[idx] = matched[i]);\n                            }\n                        }) : function(elem) {\n                            return fn(elem, 0, args);\n                        };\n                    }\n                    return fn;\n                }\n            },\n            pseudos: {\n                // Potentially complex pseudos\n                not: markFunction(function(selector) {\n                    // Trim the selector passed to compile\n                    // to avoid treating leading and trailing\n                    // spaces as combinators\n                    var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, \"$1\"));\n                    return matcher[expando] ? markFunction(function(seed, matches, _context, xml) {\n                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;\n                        // Match elements unmatched by `matcher`\n                        while(i--){\n                            if (elem = unmatched[i]) {\n                                seed[i] = !(matches[i] = elem);\n                            }\n                        }\n                    }) : function(elem, _context, xml) {\n                        input[0] = elem;\n                        matcher(input, null, xml, results);\n                        // Don't keep the element\n                        // (see https://github.com/jquery/sizzle/issues/299)\n                        input[0] = null;\n                        return !results.pop();\n                    };\n                }),\n                has: markFunction(function(selector) {\n                    return function(elem) {\n                        return find(selector, elem).length > 0;\n                    };\n                }),\n                contains: markFunction(function(text) {\n                    text = text.replace(runescape, funescape);\n                    return function(elem) {\n                        return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;\n                    };\n                }),\n                // \"Whether an element is represented by a :lang() selector\n                // is based solely on the element's language value\n                // being equal to the identifier C,\n                // or beginning with the identifier C immediately followed by \"-\".\n                // The matching of C against the element's language value is performed case-insensitively.\n                // The identifier C does not have to be a valid language name.\"\n                // https://www.w3.org/TR/selectors/#lang-pseudo\n                lang: markFunction(function(lang) {\n                    // lang value must be a valid identifier\n                    if (!ridentifier.test(lang || \"\")) {\n                        find.error(\"unsupported lang: \" + lang);\n                    }\n                    lang = lang.replace(runescape, funescape).toLowerCase();\n                    return function(elem) {\n                        var elemLang;\n                        do {\n                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                                elemLang = elemLang.toLowerCase();\n                                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n                            }\n                        }while ((elem = elem.parentNode) && elem.nodeType === 1);\n                        return false;\n                    };\n                }),\n                // Miscellaneous\n                target: function(elem) {\n                    var hash = window1.location && window1.location.hash;\n                    return hash && hash.slice(1) === elem.id;\n                },\n                root: function(elem) {\n                    return elem === documentElement;\n                },\n                focus: function(elem) {\n                    return elem === safeActiveElement() && document.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);\n                },\n                // Boolean properties\n                enabled: createDisabledPseudo(false),\n                disabled: createDisabledPseudo(true),\n                checked: function(elem) {\n                    // In CSS3, :checked should return both checked and selected elements\n                    // https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n                    return nodeName(elem, \"input\") && !!elem.checked || nodeName(elem, \"option\") && !!elem.selected;\n                },\n                selected: function(elem) {\n                    // Support: IE <=11+\n                    // Accessing the selectedIndex property\n                    // forces the browser to treat the default option as\n                    // selected when in an optgroup.\n                    if (elem.parentNode) {\n                        // eslint-disable-next-line no-unused-expressions\n                        elem.parentNode.selectedIndex;\n                    }\n                    return elem.selected === true;\n                },\n                // Contents\n                empty: function(elem) {\n                    // https://www.w3.org/TR/selectors/#empty-pseudo\n                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n                    //   but not by others (comment: 8; processing instruction: 7; etc.)\n                    // nodeType < 6 works because attributes (2) do not appear as children\n                    for(elem = elem.firstChild; elem; elem = elem.nextSibling){\n                        if (elem.nodeType < 6) {\n                            return false;\n                        }\n                    }\n                    return true;\n                },\n                parent: function(elem) {\n                    return !Expr.pseudos.empty(elem);\n                },\n                // Element/input types\n                header: function(elem) {\n                    return rheader.test(elem.nodeName);\n                },\n                input: function(elem) {\n                    return rinputs.test(elem.nodeName);\n                },\n                button: function(elem) {\n                    return nodeName(elem, \"input\") && elem.type === \"button\" || nodeName(elem, \"button\");\n                },\n                text: function(elem) {\n                    var attr;\n                    return nodeName(elem, \"input\") && elem.type === \"text\" && // Support: IE <10 only\n                    // New HTML5 attribute values (e.g., \"search\") appear\n                    // with elem.type === \"text\"\n                    ((attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n                },\n                // Position-in-collection\n                first: createPositionalPseudo(function() {\n                    return [\n                        0\n                    ];\n                }),\n                last: createPositionalPseudo(function(_matchIndexes, length) {\n                    return [\n                        length - 1\n                    ];\n                }),\n                eq: createPositionalPseudo(function(_matchIndexes, length, argument) {\n                    return [\n                        argument < 0 ? argument + length : argument\n                    ];\n                }),\n                even: createPositionalPseudo(function(matchIndexes, length) {\n                    var i = 0;\n                    for(; i < length; i += 2){\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                }),\n                odd: createPositionalPseudo(function(matchIndexes, length) {\n                    var i = 1;\n                    for(; i < length; i += 2){\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                }),\n                lt: createPositionalPseudo(function(matchIndexes, length, argument) {\n                    var i;\n                    if (argument < 0) {\n                        i = argument + length;\n                    } else if (argument > length) {\n                        i = length;\n                    } else {\n                        i = argument;\n                    }\n                    for(; --i >= 0;){\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                }),\n                gt: createPositionalPseudo(function(matchIndexes, length, argument) {\n                    var i = argument < 0 ? argument + length : argument;\n                    for(; ++i < length;){\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                })\n            }\n        };\n        Expr.pseudos.nth = Expr.pseudos.eq;\n        // Add button/input type pseudos\n        for(i in {\n            radio: true,\n            checkbox: true,\n            file: true,\n            password: true,\n            image: true\n        }){\n            Expr.pseudos[i] = createInputPseudo(i);\n        }\n        for(i in {\n            submit: true,\n            reset: true\n        }){\n            Expr.pseudos[i] = createButtonPseudo(i);\n        }\n        // Easy API for creating new setFilters\n        function setFilters() {}\n        setFilters.prototype = Expr.filters = Expr.pseudos;\n        Expr.setFilters = new setFilters();\n        function tokenize(selector, parseOnly) {\n            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + \" \"];\n            if (cached) {\n                return parseOnly ? 0 : cached.slice(0);\n            }\n            soFar = selector;\n            groups = [];\n            preFilters = Expr.preFilter;\n            while(soFar){\n                // Comma and first run\n                if (!matched || (match = rcomma.exec(soFar))) {\n                    if (match) {\n                        // Don't consume trailing commas as valid\n                        soFar = soFar.slice(match[0].length) || soFar;\n                    }\n                    groups.push(tokens = []);\n                }\n                matched = false;\n                // Combinators\n                if (match = rleadingCombinator.exec(soFar)) {\n                    matched = match.shift();\n                    tokens.push({\n                        value: matched,\n                        // Cast descendant combinators to space\n                        type: match[0].replace(rtrimCSS, \" \")\n                    });\n                    soFar = soFar.slice(matched.length);\n                }\n                // Filters\n                for(type in Expr.filter){\n                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n                        matched = match.shift();\n                        tokens.push({\n                            value: matched,\n                            type: type,\n                            matches: match\n                        });\n                        soFar = soFar.slice(matched.length);\n                    }\n                }\n                if (!matched) {\n                    break;\n                }\n            }\n            // Return the length of the invalid excess\n            // if we're just parsing\n            // Otherwise, throw an error or return tokens\n            if (parseOnly) {\n                return soFar.length;\n            }\n            return soFar ? find.error(selector) : // Cache the tokens\n            tokenCache(selector, groups).slice(0);\n        }\n        function toSelector(tokens) {\n            var i = 0, len = tokens.length, selector = \"\";\n            for(; i < len; i++){\n                selector += tokens[i].value;\n            }\n            return selector;\n        }\n        function addCombinator(matcher, combinator, base) {\n            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === \"parentNode\", doneName = done++;\n            return combinator.first ? // Check against closest ancestor/preceding element\n            function(elem, context, xml) {\n                while(elem = elem[dir]){\n                    if (elem.nodeType === 1 || checkNonElements) {\n                        return matcher(elem, context, xml);\n                    }\n                }\n                return false;\n            } : // Check against all ancestor/preceding elements\n            function(elem, context, xml) {\n                var oldCache, outerCache, newCache = [\n                    dirruns,\n                    doneName\n                ];\n                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n                if (xml) {\n                    while(elem = elem[dir]){\n                        if (elem.nodeType === 1 || checkNonElements) {\n                            if (matcher(elem, context, xml)) {\n                                return true;\n                            }\n                        }\n                    }\n                } else {\n                    while(elem = elem[dir]){\n                        if (elem.nodeType === 1 || checkNonElements) {\n                            outerCache = elem[expando] || (elem[expando] = {});\n                            if (skip && nodeName(elem, skip)) {\n                                elem = elem[dir] || elem;\n                            } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                                // Assign to newCache so results back-propagate to previous elements\n                                return newCache[2] = oldCache[2];\n                            } else {\n                                // Reuse newcache so results back-propagate to previous elements\n                                outerCache[key] = newCache;\n                                // A match means we're done; a fail means we have to keep checking\n                                if (newCache[2] = matcher(elem, context, xml)) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n                return false;\n            };\n        }\n        function elementMatcher(matchers) {\n            return matchers.length > 1 ? function(elem, context, xml) {\n                var i = matchers.length;\n                while(i--){\n                    if (!matchers[i](elem, context, xml)) {\n                        return false;\n                    }\n                }\n                return true;\n            } : matchers[0];\n        }\n        function multipleContexts(selector, contexts, results) {\n            var i = 0, len = contexts.length;\n            for(; i < len; i++){\n                find(selector, contexts[i], results);\n            }\n            return results;\n        }\n        function condense(unmatched, map, filter, context, xml) {\n            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;\n            for(; i < len; i++){\n                if (elem = unmatched[i]) {\n                    if (!filter || filter(elem, context, xml)) {\n                        newUnmatched.push(elem);\n                        if (mapped) {\n                            map.push(i);\n                        }\n                    }\n                }\n            }\n            return newUnmatched;\n        }\n        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n            if (postFilter && !postFilter[expando]) {\n                postFilter = setMatcher(postFilter);\n            }\n            if (postFinder && !postFinder[expando]) {\n                postFinder = setMatcher(postFinder, postSelector);\n            }\n            return markFunction(function(seed, results, context, xml) {\n                var temp, i, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context\n                elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [\n                    context\n                ] : context, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization\n                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;\n                if (matcher) {\n                    // If we have a postFinder, or filtered seed, or non-seed postFilter\n                    // or preexisting results,\n                    matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n                    [] : // ...otherwise use results directly\n                    results;\n                    // Find primary matches\n                    matcher(matcherIn, matcherOut, context, xml);\n                } else {\n                    matcherOut = matcherIn;\n                }\n                // Apply postFilter\n                if (postFilter) {\n                    temp = condense(matcherOut, postMap);\n                    postFilter(temp, [], context, xml);\n                    // Un-match failing elements by moving them back to matcherIn\n                    i = temp.length;\n                    while(i--){\n                        if (elem = temp[i]) {\n                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n                        }\n                    }\n                }\n                if (seed) {\n                    if (postFinder || preFilter) {\n                        if (postFinder) {\n                            // Get the final matcherOut by condensing this intermediate into postFinder contexts\n                            temp = [];\n                            i = matcherOut.length;\n                            while(i--){\n                                if (elem = matcherOut[i]) {\n                                    // Restore matcherIn since elem is not yet a final match\n                                    temp.push(matcherIn[i] = elem);\n                                }\n                            }\n                            postFinder(null, matcherOut = [], temp, xml);\n                        }\n                        // Move matched elements from seed to results to keep them synchronized\n                        i = matcherOut.length;\n                        while(i--){\n                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {\n                                seed[temp] = !(results[temp] = elem);\n                            }\n                        }\n                    }\n                // Add elements to results, through postFinder if defined\n                } else {\n                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n                    if (postFinder) {\n                        postFinder(null, results, matcherOut, xml);\n                    } else {\n                        push.apply(results, matcherOut);\n                    }\n                }\n            });\n        }\n        function matcherFromTokens(tokens) {\n            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[\" \"], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)\n            matchContext = addCombinator(function(elem) {\n                return elem === checkContext;\n            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {\n                return indexOf.call(checkContext, elem) > -1;\n            }, implicitRelative, true), matchers = [\n                function(elem, context, xml) {\n                    // Support: IE 11+, Edge 17 - 18+\n                    // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                    // two documents; shallow comparisons work.\n                    // eslint-disable-next-line eqeqeq\n                    var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n                    // Avoid hanging onto element\n                    // (see https://github.com/jquery/sizzle/issues/299)\n                    checkContext = null;\n                    return ret;\n                }\n            ];\n            for(; i < len; i++){\n                if (matcher = Expr.relative[tokens[i].type]) {\n                    matchers = [\n                        addCombinator(elementMatcher(matchers), matcher)\n                    ];\n                } else {\n                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n                    // Return special upon seeing a positional matcher\n                    if (matcher[expando]) {\n                        // Find the next relative operator (if any) for proper handling\n                        j = ++i;\n                        for(; j < len; j++){\n                            if (Expr.relative[tokens[j].type]) {\n                                break;\n                            }\n                        }\n                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n                        tokens.slice(0, i - 1).concat({\n                            value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n                        })).replace(rtrimCSS, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n                    }\n                    matchers.push(matcher);\n                }\n            }\n            return elementMatcher(matchers);\n        }\n        function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {\n                var elem, j, matcher, matchedCount = 0, i = \"0\", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context\n                elems = seed || byElement && Expr.find.TAG(\"*\", outermost), // Use integer dirruns iff this is the outermost matcher\n                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;\n                if (outermost) {\n                    // Support: IE 11+, Edge 17 - 18+\n                    // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                    // two documents; shallow comparisons work.\n                    // eslint-disable-next-line eqeqeq\n                    outermostContext = context == document || context || outermost;\n                }\n                // Add elements passing elementMatchers directly to results\n                // Support: iOS <=7 - 9 only\n                // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching\n                // elements by id. (see trac-14142)\n                for(; i !== len && (elem = elems[i]) != null; i++){\n                    if (byElement && elem) {\n                        j = 0;\n                        // Support: IE 11+, Edge 17 - 18+\n                        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                        // two documents; shallow comparisons work.\n                        // eslint-disable-next-line eqeqeq\n                        if (!context && elem.ownerDocument != document) {\n                            setDocument(elem);\n                            xml = !documentIsHTML;\n                        }\n                        while(matcher = elementMatchers[j++]){\n                            if (matcher(elem, context || document, xml)) {\n                                push.call(results, elem);\n                                break;\n                            }\n                        }\n                        if (outermost) {\n                            dirruns = dirrunsUnique;\n                        }\n                    }\n                    // Track unmatched elements for set filters\n                    if (bySet) {\n                        // They will have gone through all possible matchers\n                        if (elem = !matcher && elem) {\n                            matchedCount--;\n                        }\n                        // Lengthen the array for every element, matched or not\n                        if (seed) {\n                            unmatched.push(elem);\n                        }\n                    }\n                }\n                // `i` is now the count of elements visited above, and adding it to `matchedCount`\n                // makes the latter nonnegative.\n                matchedCount += i;\n                // Apply set filters to unmatched elements\n                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n                // no element matchers and no seed.\n                // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n                // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n                // numerically zero.\n                if (bySet && i !== matchedCount) {\n                    j = 0;\n                    while(matcher = setMatchers[j++]){\n                        matcher(unmatched, setMatched, context, xml);\n                    }\n                    if (seed) {\n                        // Reintegrate element matches to eliminate the need for sorting\n                        if (matchedCount > 0) {\n                            while(i--){\n                                if (!(unmatched[i] || setMatched[i])) {\n                                    setMatched[i] = pop.call(results);\n                                }\n                            }\n                        }\n                        // Discard index placeholder values to get only actual matches\n                        setMatched = condense(setMatched);\n                    }\n                    // Add matches to results\n                    push.apply(results, setMatched);\n                    // Seedless set matches succeeding multiple successful matchers stipulate sorting\n                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n                        jQuery.uniqueSort(results);\n                    }\n                }\n                // Override manipulation of globals by nested matchers\n                if (outermost) {\n                    dirruns = dirrunsUnique;\n                    outermostContext = contextBackup;\n                }\n                return unmatched;\n            };\n            return bySet ? markFunction(superMatcher) : superMatcher;\n        }\n        function compile(selector, match /* Internal Use Only */ ) {\n            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + \" \"];\n            if (!cached) {\n                // Generate a function of recursive functions that can be used to check each element\n                if (!match) {\n                    match = tokenize(selector);\n                }\n                i = match.length;\n                while(i--){\n                    cached = matcherFromTokens(match[i]);\n                    if (cached[expando]) {\n                        setMatchers.push(cached);\n                    } else {\n                        elementMatchers.push(cached);\n                    }\n                }\n                // Cache the compiled function\n                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n                // Save selector and tokenization\n                cached.selector = selector;\n            }\n            return cached;\n        }\n        /**\n * A low-level selection function that works with jQuery's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with jQuery selector compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */ function select(selector, context, results, seed) {\n            var i, tokens, token, type, find, compiled = typeof selector === \"function\" && selector, match = !seed && tokenize(selector = compiled.selector || selector);\n            results = results || [];\n            // Try to minimize operations if there is only one selector in the list and no seed\n            // (the latter of which guarantees us context)\n            if (match.length === 1) {\n                // Reduce context if the leading compound selector is an ID\n                tokens = match[0] = match[0].slice(0);\n                if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n                    context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0];\n                    if (!context) {\n                        return results;\n                    // Precompiled matchers will still verify ancestry, so step up a level\n                    } else if (compiled) {\n                        context = context.parentNode;\n                    }\n                    selector = selector.slice(tokens.shift().value.length);\n                }\n                // Fetch a seed set for right-to-left matching\n                i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;\n                while(i--){\n                    token = tokens[i];\n                    // Abort if we hit a combinator\n                    if (Expr.relative[type = token.type]) {\n                        break;\n                    }\n                    if (find = Expr.find[type]) {\n                        // Search, expanding context for leading sibling combinators\n                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n                            // If seed is empty or no tokens remain, we can return early\n                            tokens.splice(i, 1);\n                            selector = seed.length && toSelector(tokens);\n                            if (!selector) {\n                                push.apply(results, seed);\n                                return results;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            // Compile and execute a filtering function if one is not provided\n            // Provide `match` to avoid retokenization if we modified the selector above\n            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n            return results;\n        }\n        // One-time assignments\n        // Support: Android <=4.0 - 4.1+\n        // Sort stability\n        support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\n        // Initialize against the default document\n        setDocument();\n        // Support: Android <=4.0 - 4.1+\n        // Detached nodes confoundingly follow *each other*\n        support.sortDetached = assert(function(el) {\n            // Should return 1, but returns 4 (following)\n            return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n        });\n        jQuery.find = find;\n        // Deprecated\n        jQuery.expr[\":\"] = jQuery.expr.pseudos;\n        jQuery.unique = jQuery.uniqueSort;\n        // These have always been private, but they used to be documented as part of\n        // Sizzle so let's maintain them for now for backwards compatibility purposes.\n        find.compile = compile;\n        find.select = select;\n        find.setDocument = setDocument;\n        find.tokenize = tokenize;\n        find.escape = jQuery.escapeSelector;\n        find.getText = jQuery.text;\n        find.isXML = jQuery.isXMLDoc;\n        find.selectors = jQuery.expr;\n        find.support = jQuery.support;\n        find.uniqueSort = jQuery.uniqueSort;\n    /* eslint-enable */ })();\n    var dir = function(elem, dir, until) {\n        var matched = [], truncate = until !== undefined;\n        while((elem = elem[dir]) && elem.nodeType !== 9){\n            if (elem.nodeType === 1) {\n                if (truncate && jQuery(elem).is(until)) {\n                    break;\n                }\n                matched.push(elem);\n            }\n        }\n        return matched;\n    };\n    var siblings = function(n, elem) {\n        var matched = [];\n        for(; n; n = n.nextSibling){\n            if (n.nodeType === 1 && n !== elem) {\n                matched.push(n);\n            }\n        }\n        return matched;\n    };\n    var rneedsContext = jQuery.expr.match.needsContext;\n    var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;\n    // Implement the identical functionality for filter and not\n    function winnow(elements, qualifier, not) {\n        if (isFunction(qualifier)) {\n            return jQuery.grep(elements, function(elem, i) {\n                return !!qualifier.call(elem, i, elem) !== not;\n            });\n        }\n        // Single element\n        if (qualifier.nodeType) {\n            return jQuery.grep(elements, function(elem) {\n                return elem === qualifier !== not;\n            });\n        }\n        // Arraylike of elements (jQuery, arguments, Array)\n        if (typeof qualifier !== \"string\") {\n            return jQuery.grep(elements, function(elem) {\n                return indexOf.call(qualifier, elem) > -1 !== not;\n            });\n        }\n        // Filtered directly for both simple and complex selectors\n        return jQuery.filter(qualifier, elements, not);\n    }\n    jQuery.filter = function(expr, elems, not) {\n        var elem = elems[0];\n        if (not) {\n            expr = \":not(\" + expr + \")\";\n        }\n        if (elems.length === 1 && elem.nodeType === 1) {\n            return jQuery.find.matchesSelector(elem, expr) ? [\n                elem\n            ] : [];\n        }\n        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {\n            return elem.nodeType === 1;\n        }));\n    };\n    jQuery.fn.extend({\n        find: function(selector) {\n            var i, ret, len = this.length, self = this;\n            if (typeof selector !== \"string\") {\n                return this.pushStack(jQuery(selector).filter(function() {\n                    for(i = 0; i < len; i++){\n                        if (jQuery.contains(self[i], this)) {\n                            return true;\n                        }\n                    }\n                }));\n            }\n            ret = this.pushStack([]);\n            for(i = 0; i < len; i++){\n                jQuery.find(selector, self[i], ret);\n            }\n            return len > 1 ? jQuery.uniqueSort(ret) : ret;\n        },\n        filter: function(selector) {\n            return this.pushStack(winnow(this, selector || [], false));\n        },\n        not: function(selector) {\n            return this.pushStack(winnow(this, selector || [], true));\n        },\n        is: function(selector) {\n            return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set\n            // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n            typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n        }\n    });\n    // Initialize a jQuery object\n    // A central reference to the root jQuery(document)\n    var rootjQuery, // A simple way to check for HTML strings\n    // Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n    // Strict HTML recognition (trac-11290: must start with <)\n    // Shortcut simple #id case for speed\n    rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {\n        var match, elem;\n        // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n        if (!selector) {\n            return this;\n        }\n        // Method init() accepts an alternate rootjQuery\n        // so migrate can support jQuery.sub (gh-2101)\n        root = root || rootjQuery;\n        // Handle HTML strings\n        if (typeof selector === \"string\") {\n            if (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n                // Assume that strings that start and end with <> are HTML and skip the regex check\n                match = [\n                    null,\n                    selector,\n                    null\n                ];\n            } else {\n                match = rquickExpr.exec(selector);\n            }\n            // Match html or make sure no context is specified for #id\n            if (match && (match[1] || !context)) {\n                // HANDLE: $(html) -> $(array)\n                if (match[1]) {\n                    context = context instanceof jQuery ? context[0] : context;\n                    // Option to run scripts is true for back-compat\n                    // Intentionally let the error be thrown if parseHTML is not present\n                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\n                    // HANDLE: $(html, props)\n                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n                        for(match in context){\n                            // Properties of context are called as methods if possible\n                            if (isFunction(this[match])) {\n                                this[match](context[match]);\n                            // ...and otherwise set as attributes\n                            } else {\n                                this.attr(match, context[match]);\n                            }\n                        }\n                    }\n                    return this;\n                // HANDLE: $(#id)\n                } else {\n                    elem = document.getElementById(match[2]);\n                    if (elem) {\n                        // Inject the element directly into the jQuery object\n                        this[0] = elem;\n                        this.length = 1;\n                    }\n                    return this;\n                }\n            // HANDLE: $(expr, $(...))\n            } else if (!context || context.jquery) {\n                return (context || root).find(selector);\n            // HANDLE: $(expr, context)\n            // (which is just equivalent to: $(context).find(expr)\n            } else {\n                return this.constructor(context).find(selector);\n            }\n        // HANDLE: $(DOMElement)\n        } else if (selector.nodeType) {\n            this[0] = selector;\n            this.length = 1;\n            return this;\n        // HANDLE: $(function)\n        // Shortcut for document ready\n        } else if (isFunction(selector)) {\n            return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present\n            selector(jQuery);\n        }\n        return jQuery.makeArray(selector, this);\n    };\n    // Give the init function the jQuery prototype for later instantiation\n    init.prototype = jQuery.fn;\n    // Initialize central reference\n    rootjQuery = jQuery(document);\n    var rparentsprev = /^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set\n    guaranteedUnique = {\n        children: true,\n        contents: true,\n        next: true,\n        prev: true\n    };\n    jQuery.fn.extend({\n        has: function(target) {\n            var targets = jQuery(target, this), l = targets.length;\n            return this.filter(function() {\n                var i = 0;\n                for(; i < l; i++){\n                    if (jQuery.contains(this, targets[i])) {\n                        return true;\n                    }\n                }\n            });\n        },\n        closest: function(selectors, context) {\n            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== \"string\" && jQuery(selectors);\n            // Positional selectors never match, since there's no _selection_ context\n            if (!rneedsContext.test(selectors)) {\n                for(; i < l; i++){\n                    for(cur = this[i]; cur && cur !== context; cur = cur.parentNode){\n                        // Always skip document fragments\n                        if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to jQuery#find\n                        cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n                            matched.push(cur);\n                            break;\n                        }\n                    }\n                }\n            }\n            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n        },\n        // Determine the position of an element within the set\n        index: function(elem) {\n            // No argument, return index in parent\n            if (!elem) {\n                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n            }\n            // Index in selector\n            if (typeof elem === \"string\") {\n                return indexOf.call(jQuery(elem), this[0]);\n            }\n            // Locate the position of the desired element\n            return indexOf.call(this, // If it receives a jQuery object, the first element is used\n            elem.jquery ? elem[0] : elem);\n        },\n        add: function(selector, context) {\n            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n        },\n        addBack: function(selector) {\n            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n        }\n    });\n    function sibling(cur, dir) {\n        while((cur = cur[dir]) && cur.nodeType !== 1){}\n        return cur;\n    }\n    jQuery.each({\n        parent: function(elem) {\n            var parent = elem.parentNode;\n            return parent && parent.nodeType !== 11 ? parent : null;\n        },\n        parents: function(elem) {\n            return dir(elem, \"parentNode\");\n        },\n        parentsUntil: function(elem, _i, until) {\n            return dir(elem, \"parentNode\", until);\n        },\n        next: function(elem) {\n            return sibling(elem, \"nextSibling\");\n        },\n        prev: function(elem) {\n            return sibling(elem, \"previousSibling\");\n        },\n        nextAll: function(elem) {\n            return dir(elem, \"nextSibling\");\n        },\n        prevAll: function(elem) {\n            return dir(elem, \"previousSibling\");\n        },\n        nextUntil: function(elem, _i, until) {\n            return dir(elem, \"nextSibling\", until);\n        },\n        prevUntil: function(elem, _i, until) {\n            return dir(elem, \"previousSibling\", until);\n        },\n        siblings: function(elem) {\n            return siblings((elem.parentNode || {}).firstChild, elem);\n        },\n        children: function(elem) {\n            return siblings(elem.firstChild);\n        },\n        contents: function(elem) {\n            if (elem.contentDocument != null && // Support: IE 11+\n            // <object> elements with no `data` attribute has an object\n            // `contentDocument` with a `null` prototype.\n            getProto(elem.contentDocument)) {\n                return elem.contentDocument;\n            }\n            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n            // Treat the template element as a regular one in browsers that\n            // don't support it.\n            if (nodeName(elem, \"template\")) {\n                elem = elem.content || elem;\n            }\n            return jQuery.merge([], elem.childNodes);\n        }\n    }, function(name, fn) {\n        jQuery.fn[name] = function(until, selector) {\n            var matched = jQuery.map(this, fn, until);\n            if (name.slice(-5) !== \"Until\") {\n                selector = until;\n            }\n            if (selector && typeof selector === \"string\") {\n                matched = jQuery.filter(selector, matched);\n            }\n            if (this.length > 1) {\n                // Remove duplicates\n                if (!guaranteedUnique[name]) {\n                    jQuery.uniqueSort(matched);\n                }\n                // Reverse order for parents* and prev-derivatives\n                if (rparentsprev.test(name)) {\n                    matched.reverse();\n                }\n            }\n            return this.pushStack(matched);\n        };\n    });\n    var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n    // Convert String-formatted options into Object-formatted ones\n    function createOptions(options) {\n        var object = {};\n        jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {\n            object[flag] = true;\n        });\n        return object;\n    }\n    /*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */ jQuery.Callbacks = function(options) {\n        // Convert options from String-formatted to Object-formatted if needed\n        // (we check in cache first)\n        options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n        var firing, // Last fire value for non-forgettable lists\n        memory, // Flag to know if list was already fired\n        fired, // Flag to prevent firing\n        locked, // Actual callback list\n        list = [], // Queue of execution data for repeatable lists\n        queue = [], // Index of currently firing callback (modified by add/remove as needed)\n        firingIndex = -1, // Fire callbacks\n        fire = function() {\n            // Enforce single-firing\n            locked = locked || options.once;\n            // Execute callbacks for all pending executions,\n            // respecting firingIndex overrides and runtime changes\n            fired = firing = true;\n            for(; queue.length; firingIndex = -1){\n                memory = queue.shift();\n                while(++firingIndex < list.length){\n                    // Run callback and check for early termination\n                    if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n                        // Jump to end and forget the data so .add doesn't re-fire\n                        firingIndex = list.length;\n                        memory = false;\n                    }\n                }\n            }\n            // Forget the data if we're done with it\n            if (!options.memory) {\n                memory = false;\n            }\n            firing = false;\n            // Clean up if we're done firing for good\n            if (locked) {\n                // Keep an empty list if we have data for future add calls\n                if (memory) {\n                    list = [];\n                // Otherwise, this object is spent\n                } else {\n                    list = \"\";\n                }\n            }\n        }, // Actual Callbacks object\n        self = {\n            // Add a callback or a collection of callbacks to the list\n            add: function() {\n                if (list) {\n                    // If we have memory from a past run, we should fire after adding\n                    if (memory && !firing) {\n                        firingIndex = list.length - 1;\n                        queue.push(memory);\n                    }\n                    (function add(args) {\n                        jQuery.each(args, function(_, arg) {\n                            if (isFunction(arg)) {\n                                if (!options.unique || !self.has(arg)) {\n                                    list.push(arg);\n                                }\n                            } else if (arg && arg.length && toType(arg) !== \"string\") {\n                                // Inspect recursively\n                                add(arg);\n                            }\n                        });\n                    })(arguments);\n                    if (memory && !firing) {\n                        fire();\n                    }\n                }\n                return this;\n            },\n            // Remove a callback from the list\n            remove: function() {\n                jQuery.each(arguments, function(_, arg) {\n                    var index;\n                    while((index = jQuery.inArray(arg, list, index)) > -1){\n                        list.splice(index, 1);\n                        // Handle firing indexes\n                        if (index <= firingIndex) {\n                            firingIndex--;\n                        }\n                    }\n                });\n                return this;\n            },\n            // Check if a given callback is in the list.\n            // If no argument is given, return whether or not list has callbacks attached.\n            has: function(fn) {\n                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n            },\n            // Remove all callbacks from the list\n            empty: function() {\n                if (list) {\n                    list = [];\n                }\n                return this;\n            },\n            // Disable .fire and .add\n            // Abort any current/pending executions\n            // Clear all callbacks and values\n            disable: function() {\n                locked = queue = [];\n                list = memory = \"\";\n                return this;\n            },\n            disabled: function() {\n                return !list;\n            },\n            // Disable .fire\n            // Also disable .add unless we have memory (since it would have no effect)\n            // Abort any pending executions\n            lock: function() {\n                locked = queue = [];\n                if (!memory && !firing) {\n                    list = memory = \"\";\n                }\n                return this;\n            },\n            locked: function() {\n                return !!locked;\n            },\n            // Call all callbacks with the given context and arguments\n            fireWith: function(context, args) {\n                if (!locked) {\n                    args = args || [];\n                    args = [\n                        context,\n                        args.slice ? args.slice() : args\n                    ];\n                    queue.push(args);\n                    if (!firing) {\n                        fire();\n                    }\n                }\n                return this;\n            },\n            // Call all the callbacks with the given arguments\n            fire: function() {\n                self.fireWith(this, arguments);\n                return this;\n            },\n            // To know if the callbacks have already been called at least once\n            fired: function() {\n                return !!fired;\n            }\n        };\n        return self;\n    };\n    function Identity(v) {\n        return v;\n    }\n    function Thrower(ex) {\n        throw ex;\n    }\n    function adoptValue(value, resolve, reject, noValue) {\n        var method;\n        try {\n            // Check for promise aspect first to privilege synchronous behavior\n            if (value && isFunction(method = value.promise)) {\n                method.call(value).done(resolve).fail(reject);\n            // Other thenables\n            } else if (value && isFunction(method = value.then)) {\n                method.call(value, resolve, reject);\n            // Other non-thenables\n            } else {\n                // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n                // * false: [ value ].slice( 0 ) => resolve( value )\n                // * true: [ value ].slice( 1 ) => resolve()\n                resolve.apply(undefined, [\n                    value\n                ].slice(noValue));\n            }\n        // For Promises/A+, convert exceptions into rejections\n        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n        // Deferred#then to conditionally suppress rejection.\n        } catch (value) {\n            // Support: Android 4.0 only\n            // Strict mode functions invoked without .call/.apply get global-object context\n            reject.apply(undefined, [\n                value\n            ]);\n        }\n    }\n    jQuery.extend({\n        Deferred: function(func) {\n            var tuples = [\n                // action, add listener, callbacks,\n                // ... .then handlers, argument index, [final state]\n                [\n                    \"notify\",\n                    \"progress\",\n                    jQuery.Callbacks(\"memory\"),\n                    jQuery.Callbacks(\"memory\"),\n                    2\n                ],\n                [\n                    \"resolve\",\n                    \"done\",\n                    jQuery.Callbacks(\"once memory\"),\n                    jQuery.Callbacks(\"once memory\"),\n                    0,\n                    \"resolved\"\n                ],\n                [\n                    \"reject\",\n                    \"fail\",\n                    jQuery.Callbacks(\"once memory\"),\n                    jQuery.Callbacks(\"once memory\"),\n                    1,\n                    \"rejected\"\n                ]\n            ], state = \"pending\", promise = {\n                state: function() {\n                    return state;\n                },\n                always: function() {\n                    deferred.done(arguments).fail(arguments);\n                    return this;\n                },\n                \"catch\": function(fn) {\n                    return promise.then(null, fn);\n                },\n                // Keep pipe for back-compat\n                pipe: function() {\n                    var fns = arguments;\n                    return jQuery.Deferred(function(newDefer) {\n                        jQuery.each(tuples, function(_i, tuple) {\n                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n                            var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];\n                            // deferred.progress(function() { bind to newDefer or newDefer.notify })\n                            // deferred.done(function() { bind to newDefer or newDefer.resolve })\n                            // deferred.fail(function() { bind to newDefer or newDefer.reject })\n                            deferred[tuple[1]](function() {\n                                var returned = fn && fn.apply(this, arguments);\n                                if (returned && isFunction(returned.promise)) {\n                                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                                } else {\n                                    newDefer[tuple[0] + \"With\"](this, fn ? [\n                                        returned\n                                    ] : arguments);\n                                }\n                            });\n                        });\n                        fns = null;\n                    }).promise();\n                },\n                then: function(onFulfilled, onRejected, onProgress) {\n                    var maxDepth = 0;\n                    function resolve(depth, deferred, handler, special) {\n                        return function() {\n                            var that = this, args = arguments, mightThrow = function() {\n                                var returned, then;\n                                // Support: Promises/A+ section 2.3.3.3.3\n                                // https://promisesaplus.com/#point-59\n                                // Ignore double-resolution attempts\n                                if (depth < maxDepth) {\n                                    return;\n                                }\n                                returned = handler.apply(that, args);\n                                // Support: Promises/A+ section 2.3.1\n                                // https://promisesaplus.com/#point-48\n                                if (returned === deferred.promise()) {\n                                    throw new TypeError(\"Thenable self-resolution\");\n                                }\n                                // Support: Promises/A+ sections 2.3.3.1, 3.5\n                                // https://promisesaplus.com/#point-54\n                                // https://promisesaplus.com/#point-75\n                                // Retrieve `then` only once\n                                then = returned && // Support: Promises/A+ section 2.3.4\n                                // https://promisesaplus.com/#point-64\n                                // Only check objects and functions for thenability\n                                (typeof returned === \"object\" || typeof returned === \"function\") && returned.then;\n                                // Handle a returned thenable\n                                if (isFunction(then)) {\n                                    // Special processors (notify) just wait for resolution\n                                    if (special) {\n                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));\n                                    // Normal processors (resolve) also hook into progress\n                                    } else {\n                                        // ...and disregard older resolution values\n                                        maxDepth++;\n                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                                    }\n                                // Handle all other returned values\n                                } else {\n                                    // Only substitute handlers pass on context\n                                    // and multiple values (non-spec behavior)\n                                    if (handler !== Identity) {\n                                        that = undefined;\n                                        args = [\n                                            returned\n                                        ];\n                                    }\n                                    // Process the value(s)\n                                    // Default process is resolve\n                                    (special || deferred.resolveWith)(that, args);\n                                }\n                            }, // Only normal processors (resolve) catch and reject exceptions\n                            process = special ? mightThrow : function() {\n                                try {\n                                    mightThrow();\n                                } catch (e) {\n                                    if (jQuery.Deferred.exceptionHook) {\n                                        jQuery.Deferred.exceptionHook(e, process.error);\n                                    }\n                                    // Support: Promises/A+ section 2.3.3.3.4.1\n                                    // https://promisesaplus.com/#point-61\n                                    // Ignore post-resolution exceptions\n                                    if (depth + 1 >= maxDepth) {\n                                        // Only substitute handlers pass on context\n                                        // and multiple values (non-spec behavior)\n                                        if (handler !== Thrower) {\n                                            that = undefined;\n                                            args = [\n                                                e\n                                            ];\n                                        }\n                                        deferred.rejectWith(that, args);\n                                    }\n                                }\n                            };\n                            // Support: Promises/A+ section 2.3.3.3.1\n                            // https://promisesaplus.com/#point-57\n                            // Re-resolve promises immediately to dodge false rejection from\n                            // subsequent errors\n                            if (depth) {\n                                process();\n                            } else {\n                                // Call an optional hook to record the error, in case of exception\n                                // since it's otherwise lost when execution goes async\n                                if (jQuery.Deferred.getErrorHook) {\n                                    process.error = jQuery.Deferred.getErrorHook();\n                                // The deprecated alias of the above. While the name suggests\n                                // returning the stack, not an error instance, jQuery just passes\n                                // it directly to `console.warn` so both will work; an instance\n                                // just better cooperates with source maps.\n                                } else if (jQuery.Deferred.getStackHook) {\n                                    process.error = jQuery.Deferred.getStackHook();\n                                }\n                                window1.setTimeout(process);\n                            }\n                        };\n                    }\n                    return jQuery.Deferred(function(newDefer) {\n                        // progress_handlers.add( ... )\n                        tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));\n                        // fulfilled_handlers.add( ... )\n                        tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));\n                        // rejected_handlers.add( ... )\n                        tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n                    }).promise();\n                },\n                // Get a promise for this deferred\n                // If obj is provided, the promise aspect is added to the object\n                promise: function(obj) {\n                    return obj != null ? jQuery.extend(obj, promise) : promise;\n                }\n            }, deferred = {};\n            // Add list-specific methods\n            jQuery.each(tuples, function(i, tuple) {\n                var list = tuple[2], stateString = tuple[5];\n                // promise.progress = list.add\n                // promise.done = list.add\n                // promise.fail = list.add\n                promise[tuple[1]] = list.add;\n                // Handle state\n                if (stateString) {\n                    list.add(function() {\n                        // state = \"resolved\" (i.e., fulfilled)\n                        // state = \"rejected\"\n                        state = stateString;\n                    }, // rejected_callbacks.disable\n                    // fulfilled_callbacks.disable\n                    tuples[3 - i][2].disable, // rejected_handlers.disable\n                    // fulfilled_handlers.disable\n                    tuples[3 - i][3].disable, // progress_callbacks.lock\n                    tuples[0][2].lock, // progress_handlers.lock\n                    tuples[0][3].lock);\n                }\n                // progress_handlers.fire\n                // fulfilled_handlers.fire\n                // rejected_handlers.fire\n                list.add(tuple[3].fire);\n                // deferred.notify = function() { deferred.notifyWith(...) }\n                // deferred.resolve = function() { deferred.resolveWith(...) }\n                // deferred.reject = function() { deferred.rejectWith(...) }\n                deferred[tuple[0]] = function() {\n                    deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n                    return this;\n                };\n                // deferred.notifyWith = list.fireWith\n                // deferred.resolveWith = list.fireWith\n                // deferred.rejectWith = list.fireWith\n                deferred[tuple[0] + \"With\"] = list.fireWith;\n            });\n            // Make the deferred a promise\n            promise.promise(deferred);\n            // Call given func if any\n            if (func) {\n                func.call(deferred, deferred);\n            }\n            // All done!\n            return deferred;\n        },\n        // Deferred helper\n        when: function(singleValue) {\n            var // count of uncompleted subordinates\n            remaining = arguments.length, // count of unprocessed arguments\n            i = remaining, // subordinate fulfillment data\n            resolveContexts = Array(i), resolveValues = slice.call(arguments), // the primary Deferred\n            primary = jQuery.Deferred(), // subordinate callback factory\n            updateFunc = function(i) {\n                return function(value) {\n                    resolveContexts[i] = this;\n                    resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;\n                    if (!--remaining) {\n                        primary.resolveWith(resolveContexts, resolveValues);\n                    }\n                };\n            };\n            // Single- and empty arguments are adopted like Promise.resolve\n            if (remaining <= 1) {\n                adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining);\n                // Use .then() to unwrap secondary thenables (cf. gh-3000)\n                if (primary.state() === \"pending\" || isFunction(resolveValues[i] && resolveValues[i].then)) {\n                    return primary.then();\n                }\n            }\n            // Multiple arguments are aggregated like Promise.all array elements\n            while(i--){\n                adoptValue(resolveValues[i], updateFunc(i), primary.reject);\n            }\n            return primary.promise();\n        }\n    });\n    // These usually indicate a programmer mistake during development,\n    // warn about them ASAP rather than swallowing them by default.\n    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n    // If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error\n    // captured before the async barrier to get the original error cause\n    // which may otherwise be hidden.\n    jQuery.Deferred.exceptionHook = function(error, asyncError) {\n        // Support: IE 8 - 9 only\n        // Console exists when dev tools are open, which can happen at any time\n        if (window1.console && window1.console.warn && error && rerrorNames.test(error.name)) {\n            window1.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, asyncError);\n        }\n    };\n    jQuery.readyException = function(error) {\n        window1.setTimeout(function() {\n            throw error;\n        });\n    };\n    // The deferred used on DOM ready\n    var readyList = jQuery.Deferred();\n    jQuery.fn.ready = function(fn) {\n        readyList.then(fn)// Wrap jQuery.readyException in a function so that the lookup\n        // happens at the time of error handling instead of callback\n        // registration.\n        .catch(function(error) {\n            jQuery.readyException(error);\n        });\n        return this;\n    };\n    jQuery.extend({\n        // Is the DOM ready to be used? Set to true once it occurs.\n        isReady: false,\n        // A counter to track how many items to wait for before\n        // the ready event fires. See trac-6781\n        readyWait: 1,\n        // Handle when the DOM is ready\n        ready: function(wait) {\n            // Abort if there are pending holds or we're already ready\n            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n                return;\n            }\n            // Remember that the DOM is ready\n            jQuery.isReady = true;\n            // If a normal DOM Ready event fired, decrement, and wait if need be\n            if (wait !== true && --jQuery.readyWait > 0) {\n                return;\n            }\n            // If there are functions bound, to execute\n            readyList.resolveWith(document, [\n                jQuery\n            ]);\n        }\n    });\n    jQuery.ready.then = readyList.then;\n    // The ready event handler and self cleanup method\n    function completed() {\n        document.removeEventListener(\"DOMContentLoaded\", completed);\n        window1.removeEventListener(\"load\", completed);\n        jQuery.ready();\n    }\n    // Catch cases where $(document).ready() is called\n    // after the browser event has already occurred.\n    // Support: IE <=9 - 10 only\n    // Older IE sometimes signals \"interactive\" too soon\n    if (document.readyState === \"complete\" || document.readyState !== \"loading\" && !document.documentElement.doScroll) {\n        // Handle it asynchronously to allow scripts the opportunity to delay ready\n        window1.setTimeout(jQuery.ready);\n    } else {\n        // Use the handy event callback\n        document.addEventListener(\"DOMContentLoaded\", completed);\n        // A fallback to window.onload, that will always work\n        window1.addEventListener(\"load\", completed);\n    }\n    // Multifunctional method to get and set values of a collection\n    // The value/s can optionally be executed if it's a function\n    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {\n        var i = 0, len = elems.length, bulk = key == null;\n        // Sets many values\n        if (toType(key) === \"object\") {\n            chainable = true;\n            for(i in key){\n                access(elems, fn, i, key[i], true, emptyGet, raw);\n            }\n        // Sets one value\n        } else if (value !== undefined) {\n            chainable = true;\n            if (!isFunction(value)) {\n                raw = true;\n            }\n            if (bulk) {\n                // Bulk operations run against the entire set\n                if (raw) {\n                    fn.call(elems, value);\n                    fn = null;\n                // ...except when executing function values\n                } else {\n                    bulk = fn;\n                    fn = function(elem, _key, value) {\n                        return bulk.call(jQuery(elem), value);\n                    };\n                }\n            }\n            if (fn) {\n                for(; i < len; i++){\n                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n                }\n            }\n        }\n        if (chainable) {\n            return elems;\n        }\n        // Gets\n        if (bulk) {\n            return fn.call(elems);\n        }\n        return len ? fn(elems[0], key) : emptyGet;\n    };\n    // Matches dashed string for camelizing\n    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;\n    // Used by camelCase as callback to replace()\n    function fcamelCase(_all, letter) {\n        return letter.toUpperCase();\n    }\n    // Convert dashed to camelCase; used by the css and data modules\n    // Support: IE <=9 - 11, Edge 12 - 15\n    // Microsoft forgot to hump their vendor prefix (trac-9572)\n    function camelCase(string) {\n        return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n    }\n    var acceptData = function(owner) {\n        // Accepts only:\n        //  - Node\n        //    - Node.ELEMENT_NODE\n        //    - Node.DOCUMENT_NODE\n        //  - Object\n        //    - Any\n        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n    };\n    function Data() {\n        this.expando = jQuery.expando + Data.uid++;\n    }\n    Data.uid = 1;\n    Data.prototype = {\n        cache: function(owner) {\n            // Check if the owner object already has a cache\n            var value = owner[this.expando];\n            // If not, create one\n            if (!value) {\n                value = {};\n                // We can accept data for non-element nodes in modern browsers,\n                // but we should not, see trac-8335.\n                // Always return an empty object.\n                if (acceptData(owner)) {\n                    // If it is a node unlikely to be stringify-ed or looped over\n                    // use plain assignment\n                    if (owner.nodeType) {\n                        owner[this.expando] = value;\n                    // Otherwise secure it in a non-enumerable property\n                    // configurable must be true to allow the property to be\n                    // deleted when data is removed\n                    } else {\n                        Object.defineProperty(owner, this.expando, {\n                            value: value,\n                            configurable: true\n                        });\n                    }\n                }\n            }\n            return value;\n        },\n        set: function(owner, data, value) {\n            var prop, cache = this.cache(owner);\n            // Handle: [ owner, key, value ] args\n            // Always use camelCase key (gh-2257)\n            if (typeof data === \"string\") {\n                cache[camelCase(data)] = value;\n            // Handle: [ owner, { properties } ] args\n            } else {\n                // Copy the properties one-by-one to the cache object\n                for(prop in data){\n                    cache[camelCase(prop)] = data[prop];\n                }\n            }\n            return cache;\n        },\n        get: function(owner, key) {\n            return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)\n            owner[this.expando] && owner[this.expando][camelCase(key)];\n        },\n        access: function(owner, key, value) {\n            // In cases where either:\n            //\n            //   1. No key was specified\n            //   2. A string key was specified, but no value provided\n            //\n            // Take the \"read\" path and allow the get method to determine\n            // which value to return, respectively either:\n            //\n            //   1. The entire cache object\n            //   2. The data stored at the key\n            //\n            if (key === undefined || key && typeof key === \"string\" && value === undefined) {\n                return this.get(owner, key);\n            }\n            // When the key is not a string, or both a key and value\n            // are specified, set or extend (existing objects) with either:\n            //\n            //   1. An object of properties\n            //   2. A key and value\n            //\n            this.set(owner, key, value);\n            // Since the \"set\" path can have two possible entry points\n            // return the expected data based on which path was taken[*]\n            return value !== undefined ? value : key;\n        },\n        remove: function(owner, key) {\n            var i, cache = owner[this.expando];\n            if (cache === undefined) {\n                return;\n            }\n            if (key !== undefined) {\n                // Support array or space separated string of keys\n                if (Array.isArray(key)) {\n                    // If key is an array of keys...\n                    // We always set camelCase keys, so remove that.\n                    key = key.map(camelCase);\n                } else {\n                    key = camelCase(key);\n                    // If a key with the spaces exists, use it.\n                    // Otherwise, create an array by matching non-whitespace\n                    key = key in cache ? [\n                        key\n                    ] : key.match(rnothtmlwhite) || [];\n                }\n                i = key.length;\n                while(i--){\n                    delete cache[key[i]];\n                }\n            }\n            // Remove the expando if there's no more data\n            if (key === undefined || jQuery.isEmptyObject(cache)) {\n                // Support: Chrome <=35 - 45\n                // Webkit & Blink performance suffers when deleting properties\n                // from DOM nodes, so set to undefined instead\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n                if (owner.nodeType) {\n                    owner[this.expando] = undefined;\n                } else {\n                    delete owner[this.expando];\n                }\n            }\n        },\n        hasData: function(owner) {\n            var cache = owner[this.expando];\n            return cache !== undefined && !jQuery.isEmptyObject(cache);\n        }\n    };\n    var dataPriv = new Data();\n    var dataUser = new Data();\n    //\tImplementation Summary\n    //\n    //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n    //\t2. Improve the module's maintainability by reducing the storage\n    //\t\tpaths to a single mechanism.\n    //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n    //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n    //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n    //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n    var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/, rmultiDash = /[A-Z]/g;\n    function getData(data) {\n        if (data === \"true\") {\n            return true;\n        }\n        if (data === \"false\") {\n            return false;\n        }\n        if (data === \"null\") {\n            return null;\n        }\n        // Only convert to a number if it doesn't change the string\n        if (data === +data + \"\") {\n            return +data;\n        }\n        if (rbrace.test(data)) {\n            return JSON.parse(data);\n        }\n        return data;\n    }\n    function dataAttr(elem, key, data) {\n        var name;\n        // If nothing was found internally, try to fetch any\n        // data from the HTML5 data-* attribute\n        if (data === undefined && elem.nodeType === 1) {\n            name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n            data = elem.getAttribute(name);\n            if (typeof data === \"string\") {\n                try {\n                    data = getData(data);\n                } catch (e) {}\n                // Make sure we set the data so it isn't changed later\n                dataUser.set(elem, key, data);\n            } else {\n                data = undefined;\n            }\n        }\n        return data;\n    }\n    jQuery.extend({\n        hasData: function(elem) {\n            return dataUser.hasData(elem) || dataPriv.hasData(elem);\n        },\n        data: function(elem, name, data) {\n            return dataUser.access(elem, name, data);\n        },\n        removeData: function(elem, name) {\n            dataUser.remove(elem, name);\n        },\n        // TODO: Now that all calls to _data and _removeData have been replaced\n        // with direct calls to dataPriv methods, these can be deprecated.\n        _data: function(elem, name, data) {\n            return dataPriv.access(elem, name, data);\n        },\n        _removeData: function(elem, name) {\n            dataPriv.remove(elem, name);\n        }\n    });\n    jQuery.fn.extend({\n        data: function(key, value) {\n            var i, name, data, elem = this[0], attrs = elem && elem.attributes;\n            // Gets all values\n            if (key === undefined) {\n                if (this.length) {\n                    data = dataUser.get(elem);\n                    if (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\n                        i = attrs.length;\n                        while(i--){\n                            // Support: IE 11 only\n                            // The attrs elements can be null (trac-14894)\n                            if (attrs[i]) {\n                                name = attrs[i].name;\n                                if (name.indexOf(\"data-\") === 0) {\n                                    name = camelCase(name.slice(5));\n                                    dataAttr(elem, name, data[name]);\n                                }\n                            }\n                        }\n                        dataPriv.set(elem, \"hasDataAttrs\", true);\n                    }\n                }\n                return data;\n            }\n            // Sets multiple values\n            if (typeof key === \"object\") {\n                return this.each(function() {\n                    dataUser.set(this, key);\n                });\n            }\n            return access(this, function(value) {\n                var data;\n                // The calling jQuery object (element matches) is not empty\n                // (and therefore has an element appears at this[ 0 ]) and the\n                // `value` parameter was not undefined. An empty jQuery object\n                // will result in `undefined` for elem = this[ 0 ] which will\n                // throw an exception if an attempt to read a data cache is made.\n                if (elem && value === undefined) {\n                    // Attempt to get data from the cache\n                    // The key will always be camelCased in Data\n                    data = dataUser.get(elem, key);\n                    if (data !== undefined) {\n                        return data;\n                    }\n                    // Attempt to \"discover\" the data in\n                    // HTML5 custom data-* attrs\n                    data = dataAttr(elem, key);\n                    if (data !== undefined) {\n                        return data;\n                    }\n                    // We tried really hard, but the data doesn't exist.\n                    return;\n                }\n                // Set the data...\n                this.each(function() {\n                    // We always store the camelCased key\n                    dataUser.set(this, key, value);\n                });\n            }, null, value, arguments.length > 1, null, true);\n        },\n        removeData: function(key) {\n            return this.each(function() {\n                dataUser.remove(this, key);\n            });\n        }\n    });\n    jQuery.extend({\n        queue: function(elem, type, data) {\n            var queue;\n            if (elem) {\n                type = (type || \"fx\") + \"queue\";\n                queue = dataPriv.get(elem, type);\n                // Speed up dequeue by getting out quickly if this is just a lookup\n                if (data) {\n                    if (!queue || Array.isArray(data)) {\n                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n                    } else {\n                        queue.push(data);\n                    }\n                }\n                return queue || [];\n            }\n        },\n        dequeue: function(elem, type) {\n            type = type || \"fx\";\n            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {\n                jQuery.dequeue(elem, type);\n            };\n            // If the fx queue is dequeued, always remove the progress sentinel\n            if (fn === \"inprogress\") {\n                fn = queue.shift();\n                startLength--;\n            }\n            if (fn) {\n                // Add a progress sentinel to prevent the fx queue from being\n                // automatically dequeued\n                if (type === \"fx\") {\n                    queue.unshift(\"inprogress\");\n                }\n                // Clear up the last queue stop function\n                delete hooks.stop;\n                fn.call(elem, next, hooks);\n            }\n            if (!startLength && hooks) {\n                hooks.empty.fire();\n            }\n        },\n        // Not public - generate a queueHooks object, or return the current one\n        _queueHooks: function(elem, type) {\n            var key = type + \"queueHooks\";\n            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n                empty: jQuery.Callbacks(\"once memory\").add(function() {\n                    dataPriv.remove(elem, [\n                        type + \"queue\",\n                        key\n                    ]);\n                })\n            });\n        }\n    });\n    jQuery.fn.extend({\n        queue: function(type, data) {\n            var setter = 2;\n            if (typeof type !== \"string\") {\n                data = type;\n                type = \"fx\";\n                setter--;\n            }\n            if (arguments.length < setter) {\n                return jQuery.queue(this[0], type);\n            }\n            return data === undefined ? this : this.each(function() {\n                var queue = jQuery.queue(this, type, data);\n                // Ensure a hooks for this queue\n                jQuery._queueHooks(this, type);\n                if (type === \"fx\" && queue[0] !== \"inprogress\") {\n                    jQuery.dequeue(this, type);\n                }\n            });\n        },\n        dequeue: function(type) {\n            return this.each(function() {\n                jQuery.dequeue(this, type);\n            });\n        },\n        clearQueue: function(type) {\n            return this.queue(type || \"fx\", []);\n        },\n        // Get a promise resolved when queues of a certain type\n        // are emptied (fx is the type by default)\n        promise: function(type, obj) {\n            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {\n                if (!--count) {\n                    defer.resolveWith(elements, [\n                        elements\n                    ]);\n                }\n            };\n            if (typeof type !== \"string\") {\n                obj = type;\n                type = undefined;\n            }\n            type = type || \"fx\";\n            while(i--){\n                tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n                if (tmp && tmp.empty) {\n                    count++;\n                    tmp.empty.add(resolve);\n                }\n            }\n            resolve();\n            return defer.promise(obj);\n        }\n    });\n    var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n    var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n    var cssExpand = [\n        \"Top\",\n        \"Right\",\n        \"Bottom\",\n        \"Left\"\n    ];\n    var documentElement = document.documentElement;\n    var isAttached = function(elem) {\n        return jQuery.contains(elem.ownerDocument, elem);\n    }, composed = {\n        composed: true\n    };\n    // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n    // Check attachment across shadow DOM boundaries when possible (gh-3504)\n    // Support: iOS 10.0-10.2 only\n    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n    // leading to errors. We need to check for `getRootNode`.\n    if (documentElement.getRootNode) {\n        isAttached = function(elem) {\n            return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;\n        };\n    }\n    var isHiddenWithinTree = function(elem, el) {\n        // isHiddenWithinTree might be called from jQuery#filter function;\n        // in that case, element will be second argument\n        elem = el || elem;\n        // Inline style trumps all\n        return elem.style.display === \"none\" || elem.style.display === \"\" && // Otherwise, check computed style\n        // Support: Firefox <=43 - 45\n        // Disconnected elements can have computed display: none, so first confirm that elem is\n        // in the document.\n        isAttached(elem) && jQuery.css(elem, \"display\") === \"none\";\n    };\n    function adjustCSS(elem, prop, valueParts, tween) {\n        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {\n            return tween.cur();\n        } : function() {\n            return jQuery.css(elem, prop, \"\");\n        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"), // Starting value computation is required for potential unit mismatches\n        initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n        if (initialInUnit && initialInUnit[3] !== unit) {\n            // Support: Firefox <=54\n            // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n            initial = initial / 2;\n            // Trust units reported by jQuery.css\n            unit = unit || initialInUnit[3];\n            // Iteratively approximate from a nonzero starting point\n            initialInUnit = +initial || 1;\n            while(maxIterations--){\n                // Evaluate and update our best guess (doubling guesses that zero out).\n                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n                jQuery.style(elem, prop, initialInUnit + unit);\n                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\n                    maxIterations = 0;\n                }\n                initialInUnit = initialInUnit / scale;\n            }\n            initialInUnit = initialInUnit * 2;\n            jQuery.style(elem, prop, initialInUnit + unit);\n            // Make sure we update the tween properties later on\n            valueParts = valueParts || [];\n        }\n        if (valueParts) {\n            initialInUnit = +initialInUnit || +initial || 0;\n            // Apply relative offset (+=/-=) if specified\n            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n            if (tween) {\n                tween.unit = unit;\n                tween.start = initialInUnit;\n                tween.end = adjusted;\n            }\n        }\n        return adjusted;\n    }\n    var defaultDisplayMap = {};\n    function getDefaultDisplay(elem) {\n        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];\n        if (display) {\n            return display;\n        }\n        temp = doc.body.appendChild(doc.createElement(nodeName));\n        display = jQuery.css(temp, \"display\");\n        temp.parentNode.removeChild(temp);\n        if (display === \"none\") {\n            display = \"block\";\n        }\n        defaultDisplayMap[nodeName] = display;\n        return display;\n    }\n    function showHide(elements, show) {\n        var display, elem, values = [], index = 0, length = elements.length;\n        // Determine new display value for elements that need to change\n        for(; index < length; index++){\n            elem = elements[index];\n            if (!elem.style) {\n                continue;\n            }\n            display = elem.style.display;\n            if (show) {\n                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n                // check is required in this first loop unless we have a nonempty display value (either\n                // inline or about-to-be-restored)\n                if (display === \"none\") {\n                    values[index] = dataPriv.get(elem, \"display\") || null;\n                    if (!values[index]) {\n                        elem.style.display = \"\";\n                    }\n                }\n                if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n                    values[index] = getDefaultDisplay(elem);\n                }\n            } else {\n                if (display !== \"none\") {\n                    values[index] = \"none\";\n                    // Remember what we're overwriting\n                    dataPriv.set(elem, \"display\", display);\n                }\n            }\n        }\n        // Set the display of the elements in a second loop to avoid constant reflow\n        for(index = 0; index < length; index++){\n            if (values[index] != null) {\n                elements[index].style.display = values[index];\n            }\n        }\n        return elements;\n    }\n    jQuery.fn.extend({\n        show: function() {\n            return showHide(this, true);\n        },\n        hide: function() {\n            return showHide(this);\n        },\n        toggle: function(state) {\n            if (typeof state === \"boolean\") {\n                return state ? this.show() : this.hide();\n            }\n            return this.each(function() {\n                if (isHiddenWithinTree(this)) {\n                    jQuery(this).show();\n                } else {\n                    jQuery(this).hide();\n                }\n            });\n        }\n    });\n    var rcheckableType = /^(?:checkbox|radio)$/i;\n    var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;\n    var rscriptType = /^$|^module$|\\/(?:java|ecma)script/i;\n    (function() {\n        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement(\"div\")), input = document.createElement(\"input\");\n        // Support: Android 4.0 - 4.3 only\n        // Check state lost if the name is set (trac-11217)\n        // Support: Windows Web Apps (WWA)\n        // `name` and `type` must use .setAttribute for WWA (trac-14901)\n        input.setAttribute(\"type\", \"radio\");\n        input.setAttribute(\"checked\", \"checked\");\n        input.setAttribute(\"name\", \"t\");\n        div.appendChild(input);\n        // Support: Android <=4.1 only\n        // Older WebKit doesn't clone checked state correctly in fragments\n        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\n        // Support: IE <=11 only\n        // Make sure textarea (and checkbox) defaultValue is properly cloned\n        div.innerHTML = \"<textarea>x</textarea>\";\n        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n        // Support: IE <=9 only\n        // IE <=9 replaces <option> tags with their contents when inserted outside of\n        // the select element.\n        div.innerHTML = \"<option></option>\";\n        support.option = !!div.lastChild;\n    })();\n    // We have to close these tags to support XHTML (trac-13200)\n    var wrapMap = {\n        // XHTML parsers do not magically insert elements in the\n        // same way that tag soup parsers do. So we cannot shorten\n        // this by omitting <tbody> or other required elements.\n        thead: [\n            1,\n            \"<table>\",\n            \"</table>\"\n        ],\n        col: [\n            2,\n            \"<table><colgroup>\",\n            \"</colgroup></table>\"\n        ],\n        tr: [\n            2,\n            \"<table><tbody>\",\n            \"</tbody></table>\"\n        ],\n        td: [\n            3,\n            \"<table><tbody><tr>\",\n            \"</tr></tbody></table>\"\n        ],\n        _default: [\n            0,\n            \"\",\n            \"\"\n        ]\n    };\n    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n    wrapMap.th = wrapMap.td;\n    // Support: IE <=9 only\n    if (!support.option) {\n        wrapMap.optgroup = wrapMap.option = [\n            1,\n            \"<select multiple='multiple'>\",\n            \"</select>\"\n        ];\n    }\n    function getAll(context, tag) {\n        // Support: IE <=9 - 11 only\n        // Use typeof to avoid zero-argument method invocation on host objects (trac-15151)\n        var ret;\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n            ret = context.getElementsByTagName(tag || \"*\");\n        } else if (typeof context.querySelectorAll !== \"undefined\") {\n            ret = context.querySelectorAll(tag || \"*\");\n        } else {\n            ret = [];\n        }\n        if (tag === undefined || tag && nodeName(context, tag)) {\n            return jQuery.merge([\n                context\n            ], ret);\n        }\n        return ret;\n    }\n    // Mark scripts as having already been evaluated\n    function setGlobalEval(elems, refElements) {\n        var i = 0, l = elems.length;\n        for(; i < l; i++){\n            dataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\n        }\n    }\n    var rhtml = /<|&#?\\w+;/;\n    function buildFragment(elems, context, scripts, selection, ignored) {\n        var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;\n        for(; i < l; i++){\n            elem = elems[i];\n            if (elem || elem === 0) {\n                // Add nodes directly\n                if (toType(elem) === \"object\") {\n                    // Support: Android <=4.0 only, PhantomJS 1 only\n                    // push.apply(_, arraylike) throws on ancient WebKit\n                    jQuery.merge(nodes, elem.nodeType ? [\n                        elem\n                    ] : elem);\n                // Convert non-html into a text node\n                } else if (!rhtml.test(elem)) {\n                    nodes.push(context.createTextNode(elem));\n                // Convert html into DOM nodes\n                } else {\n                    tmp = tmp || fragment.appendChild(context.createElement(\"div\"));\n                    // Deserialize a standard representation\n                    tag = (rtagName.exec(elem) || [\n                        \"\",\n                        \"\"\n                    ])[1].toLowerCase();\n                    wrap = wrapMap[tag] || wrapMap._default;\n                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];\n                    // Descend through wrappers to the right content\n                    j = wrap[0];\n                    while(j--){\n                        tmp = tmp.lastChild;\n                    }\n                    // Support: Android <=4.0 only, PhantomJS 1 only\n                    // push.apply(_, arraylike) throws on ancient WebKit\n                    jQuery.merge(nodes, tmp.childNodes);\n                    // Remember the top-level container\n                    tmp = fragment.firstChild;\n                    // Ensure the created nodes are orphaned (trac-12392)\n                    tmp.textContent = \"\";\n                }\n            }\n        }\n        // Remove wrapper from fragment\n        fragment.textContent = \"\";\n        i = 0;\n        while(elem = nodes[i++]){\n            // Skip elements already in the context collection (trac-4087)\n            if (selection && jQuery.inArray(elem, selection) > -1) {\n                if (ignored) {\n                    ignored.push(elem);\n                }\n                continue;\n            }\n            attached = isAttached(elem);\n            // Append to fragment\n            tmp = getAll(fragment.appendChild(elem), \"script\");\n            // Preserve script evaluation history\n            if (attached) {\n                setGlobalEval(tmp);\n            }\n            // Capture executables\n            if (scripts) {\n                j = 0;\n                while(elem = tmp[j++]){\n                    if (rscriptType.test(elem.type || \"\")) {\n                        scripts.push(elem);\n                    }\n                }\n            }\n        }\n        return fragment;\n    }\n    var rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n    function returnTrue() {\n        return true;\n    }\n    function returnFalse() {\n        return false;\n    }\n    function on(elem, types, selector, data, fn, one) {\n        var origFn, type;\n        // Types can be a map of types/handlers\n        if (typeof types === \"object\") {\n            // ( types-Object, selector, data )\n            if (typeof selector !== \"string\") {\n                // ( types-Object, data )\n                data = data || selector;\n                selector = undefined;\n            }\n            for(type in types){\n                on(elem, type, selector, data, types[type], one);\n            }\n            return elem;\n        }\n        if (data == null && fn == null) {\n            // ( types, fn )\n            fn = selector;\n            data = selector = undefined;\n        } else if (fn == null) {\n            if (typeof selector === \"string\") {\n                // ( types, selector, fn )\n                fn = data;\n                data = undefined;\n            } else {\n                // ( types, data, fn )\n                fn = data;\n                data = selector;\n                selector = undefined;\n            }\n        }\n        if (fn === false) {\n            fn = returnFalse;\n        } else if (!fn) {\n            return elem;\n        }\n        if (one === 1) {\n            origFn = fn;\n            fn = function(event) {\n                // Can use an empty set, since event contains the info\n                jQuery().off(event);\n                return origFn.apply(this, arguments);\n            };\n            // Use same guid so caller can remove using origFn\n            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n        }\n        return elem.each(function() {\n            jQuery.event.add(this, types, fn, data, selector);\n        });\n    }\n    /*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */ jQuery.event = {\n        global: {},\n        add: function(elem, types, handler, data, selector) {\n            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);\n            // Only attach events to objects that accept data\n            if (!acceptData(elem)) {\n                return;\n            }\n            // Caller can pass in an object of custom data in lieu of the handler\n            if (handler.handler) {\n                handleObjIn = handler;\n                handler = handleObjIn.handler;\n                selector = handleObjIn.selector;\n            }\n            // Ensure that invalid selectors throw exceptions at attach time\n            // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n            if (selector) {\n                jQuery.find.matchesSelector(documentElement, selector);\n            }\n            // Make sure that the handler has a unique ID, used to find/remove it later\n            if (!handler.guid) {\n                handler.guid = jQuery.guid++;\n            }\n            // Init the element's event structure and main handler, if this is the first\n            if (!(events = elemData.events)) {\n                events = elemData.events = Object.create(null);\n            }\n            if (!(eventHandle = elemData.handle)) {\n                eventHandle = elemData.handle = function(e) {\n                    // Discard the second event of a jQuery.event.trigger() and\n                    // when an event is called after a page has unloaded\n                    return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n                };\n            }\n            // Handle multiple events separated by a space\n            types = (types || \"\").match(rnothtmlwhite) || [\n                \"\"\n            ];\n            t = types.length;\n            while(t--){\n                tmp = rtypenamespace.exec(types[t]) || [];\n                type = origType = tmp[1];\n                namespaces = (tmp[2] || \"\").split(\".\").sort();\n                // There *must* be a type, no attaching namespace-only handlers\n                if (!type) {\n                    continue;\n                }\n                // If event changes its type, use the special event handlers for the changed type\n                special = jQuery.event.special[type] || {};\n                // If selector defined, determine special event api type, otherwise given type\n                type = (selector ? special.delegateType : special.bindType) || type;\n                // Update special based on newly reset type\n                special = jQuery.event.special[type] || {};\n                // handleObj is passed to all event handlers\n                handleObj = jQuery.extend({\n                    type: type,\n                    origType: origType,\n                    data: data,\n                    handler: handler,\n                    guid: handler.guid,\n                    selector: selector,\n                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n                    namespace: namespaces.join(\".\")\n                }, handleObjIn);\n                // Init the event handler queue if we're the first\n                if (!(handlers = events[type])) {\n                    handlers = events[type] = [];\n                    handlers.delegateCount = 0;\n                    // Only use addEventListener if the special events handler returns false\n                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n                        if (elem.addEventListener) {\n                            elem.addEventListener(type, eventHandle);\n                        }\n                    }\n                }\n                if (special.add) {\n                    special.add.call(elem, handleObj);\n                    if (!handleObj.handler.guid) {\n                        handleObj.handler.guid = handler.guid;\n                    }\n                }\n                // Add to the element's handler list, delegates in front\n                if (selector) {\n                    handlers.splice(handlers.delegateCount++, 0, handleObj);\n                } else {\n                    handlers.push(handleObj);\n                }\n                // Keep track of which events have ever been used, for event optimization\n                jQuery.event.global[type] = true;\n            }\n        },\n        // Detach an event or set of events from an element\n        remove: function(elem, types, handler, selector, mappedTypes) {\n            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n            if (!elemData || !(events = elemData.events)) {\n                return;\n            }\n            // Once for each type.namespace in types; type may be omitted\n            types = (types || \"\").match(rnothtmlwhite) || [\n                \"\"\n            ];\n            t = types.length;\n            while(t--){\n                tmp = rtypenamespace.exec(types[t]) || [];\n                type = origType = tmp[1];\n                namespaces = (tmp[2] || \"\").split(\".\").sort();\n                // Unbind all events (on this namespace, if provided) for the element\n                if (!type) {\n                    for(type in events){\n                        jQuery.event.remove(elem, type + types[t], handler, selector, true);\n                    }\n                    continue;\n                }\n                special = jQuery.event.special[type] || {};\n                type = (selector ? special.delegateType : special.bindType) || type;\n                handlers = events[type] || [];\n                tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\");\n                // Remove matching events\n                origCount = j = handlers.length;\n                while(j--){\n                    handleObj = handlers[j];\n                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n                        handlers.splice(j, 1);\n                        if (handleObj.selector) {\n                            handlers.delegateCount--;\n                        }\n                        if (special.remove) {\n                            special.remove.call(elem, handleObj);\n                        }\n                    }\n                }\n                // Remove generic event handler if we removed something and no more handlers exist\n                // (avoids potential for endless recursion during removal of special event handlers)\n                if (origCount && !handlers.length) {\n                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n                        jQuery.removeEvent(elem, type, elemData.handle);\n                    }\n                    delete events[type];\n                }\n            }\n            // Remove data and the expando if it's no longer used\n            if (jQuery.isEmptyObject(events)) {\n                dataPriv.remove(elem, \"handle events\");\n            }\n        },\n        dispatch: function(nativeEvent) {\n            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), // Make a writable jQuery.Event from the native event object\n            event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, \"events\") || Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};\n            // Use the fix-ed jQuery.Event rather than the (read-only) native event\n            args[0] = event;\n            for(i = 1; i < arguments.length; i++){\n                args[i] = arguments[i];\n            }\n            event.delegateTarget = this;\n            // Call the preDispatch hook for the mapped type, and let it bail if desired\n            if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n                return;\n            }\n            // Determine handlers\n            handlerQueue = jQuery.event.handlers.call(this, event, handlers);\n            // Run delegates first; they may want to stop propagation beneath us\n            i = 0;\n            while((matched = handlerQueue[i++]) && !event.isPropagationStopped()){\n                event.currentTarget = matched.elem;\n                j = 0;\n                while((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()){\n                    // If the event is namespaced, then each handler is only invoked if it is\n                    // specially universal or its namespaces are a superset of the event's.\n                    if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {\n                        event.handleObj = handleObj;\n                        event.data = handleObj.data;\n                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n                        if (ret !== undefined) {\n                            if ((event.result = ret) === false) {\n                                event.preventDefault();\n                                event.stopPropagation();\n                            }\n                        }\n                    }\n                }\n            }\n            // Call the postDispatch hook for the mapped type\n            if (special.postDispatch) {\n                special.postDispatch.call(this, event);\n            }\n            return event.result;\n        },\n        handlers: function(event, handlers) {\n            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;\n            // Find delegate handlers\n            if (delegateCount && // Support: IE <=9\n            // Black-hole SVG <use> instance trees (trac-13180)\n            cur.nodeType && // Support: Firefox <=42\n            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n            // Support: IE 11 only\n            // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n            !(event.type === \"click\" && event.button >= 1)) {\n                for(; cur !== this; cur = cur.parentNode || this){\n                    // Don't check non-elements (trac-13208)\n                    // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n                    if (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\n                        matchedHandlers = [];\n                        matchedSelectors = {};\n                        for(i = 0; i < delegateCount; i++){\n                            handleObj = handlers[i];\n                            // Don't conflict with Object.prototype properties (trac-13203)\n                            sel = handleObj.selector + \" \";\n                            if (matchedSelectors[sel] === undefined) {\n                                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [\n                                    cur\n                                ]).length;\n                            }\n                            if (matchedSelectors[sel]) {\n                                matchedHandlers.push(handleObj);\n                            }\n                        }\n                        if (matchedHandlers.length) {\n                            handlerQueue.push({\n                                elem: cur,\n                                handlers: matchedHandlers\n                            });\n                        }\n                    }\n                }\n            }\n            // Add the remaining (directly-bound) handlers\n            cur = this;\n            if (delegateCount < handlers.length) {\n                handlerQueue.push({\n                    elem: cur,\n                    handlers: handlers.slice(delegateCount)\n                });\n            }\n            return handlerQueue;\n        },\n        addProp: function(name, hook) {\n            Object.defineProperty(jQuery.Event.prototype, name, {\n                enumerable: true,\n                configurable: true,\n                get: isFunction(hook) ? function() {\n                    if (this.originalEvent) {\n                        return hook(this.originalEvent);\n                    }\n                } : function() {\n                    if (this.originalEvent) {\n                        return this.originalEvent[name];\n                    }\n                },\n                set: function(value) {\n                    Object.defineProperty(this, name, {\n                        enumerable: true,\n                        configurable: true,\n                        writable: true,\n                        value: value\n                    });\n                }\n            });\n        },\n        fix: function(originalEvent) {\n            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n        },\n        special: {\n            load: {\n                // Prevent triggered image.load events from bubbling to window.load\n                noBubble: true\n            },\n            click: {\n                // Utilize native event to ensure correct state for checkable inputs\n                setup: function(data) {\n                    // For mutual compressibility with _default, replace `this` access with a local var.\n                    // `|| data` is dead code meant only to preserve the variable through minification.\n                    var el = this || data;\n                    // Claim the first handler\n                    if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n                        // dataPriv.set( el, \"click\", ... )\n                        leverageNative(el, \"click\", true);\n                    }\n                    // Return false to allow normal processing in the caller\n                    return false;\n                },\n                trigger: function(data) {\n                    // For mutual compressibility with _default, replace `this` access with a local var.\n                    // `|| data` is dead code meant only to preserve the variable through minification.\n                    var el = this || data;\n                    // Force setup before triggering a click\n                    if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n                        leverageNative(el, \"click\");\n                    }\n                    // Return non-false to allow normal event-path propagation\n                    return true;\n                },\n                // For cross-browser consistency, suppress native .click() on links\n                // Also prevent it if we're currently inside a leveraged native-event stack\n                _default: function(event) {\n                    var target = event.target;\n                    return rcheckableType.test(target.type) && target.click && nodeName(target, \"input\") && dataPriv.get(target, \"click\") || nodeName(target, \"a\");\n                }\n            },\n            beforeunload: {\n                postDispatch: function(event) {\n                    // Support: Firefox 20+\n                    // Firefox doesn't alert if the returnValue field is not set.\n                    if (event.result !== undefined && event.originalEvent) {\n                        event.originalEvent.returnValue = event.result;\n                    }\n                }\n            }\n        }\n    };\n    // Ensure the presence of an event listener that handles manually-triggered\n    // synthetic events by interrupting progress until reinvoked in response to\n    // *native* events that it fires directly, ensuring that state changes have\n    // already occurred before other listeners are invoked.\n    function leverageNative(el, type, isSetup) {\n        // Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add\n        if (!isSetup) {\n            if (dataPriv.get(el, type) === undefined) {\n                jQuery.event.add(el, type, returnTrue);\n            }\n            return;\n        }\n        // Register the controller as a special universal handler for all event namespaces\n        dataPriv.set(el, type, false);\n        jQuery.event.add(el, type, {\n            namespace: false,\n            handler: function(event) {\n                var result, saved = dataPriv.get(this, type);\n                if (event.isTrigger & 1 && this[type]) {\n                    // Interrupt processing of the outer synthetic .trigger()ed event\n                    if (!saved) {\n                        // Store arguments for use when handling the inner native event\n                        // There will always be at least one argument (an event object), so this array\n                        // will not be confused with a leftover capture object.\n                        saved = slice.call(arguments);\n                        dataPriv.set(this, type, saved);\n                        // Trigger the native event and capture its result\n                        this[type]();\n                        result = dataPriv.get(this, type);\n                        dataPriv.set(this, type, false);\n                        if (saved !== result) {\n                            // Cancel the outer synthetic event\n                            event.stopImmediatePropagation();\n                            event.preventDefault();\n                            return result;\n                        }\n                    // If this is an inner synthetic event for an event with a bubbling surrogate\n                    // (focus or blur), assume that the surrogate already propagated from triggering\n                    // the native event and prevent that from happening again here.\n                    // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n                    // bubbling surrogate propagates *after* the non-bubbling base), but that seems\n                    // less bad than duplication.\n                    } else if ((jQuery.event.special[type] || {}).delegateType) {\n                        event.stopPropagation();\n                    }\n                // If this is a native event triggered above, everything is now in order\n                // Fire an inner synthetic event with the original arguments\n                } else if (saved) {\n                    // ...and capture the result\n                    dataPriv.set(this, type, jQuery.event.trigger(saved[0], saved.slice(1), this));\n                    // Abort handling of the native event by all jQuery handlers while allowing\n                    // native handlers on the same element to run. On target, this is achieved\n                    // by stopping immediate propagation just on the jQuery event. However,\n                    // the native event is re-wrapped by a jQuery one on each level of the\n                    // propagation so the only way to stop it for jQuery is to stop it for\n                    // everyone via native `stopPropagation()`. This is not a problem for\n                    // focus/blur which don't bubble, but it does also stop click on checkboxes\n                    // and radios. We accept this limitation.\n                    event.stopPropagation();\n                    event.isImmediatePropagationStopped = returnTrue;\n                }\n            }\n        });\n    }\n    jQuery.removeEvent = function(elem, type, handle) {\n        // This \"if\" is needed for plain objects\n        if (elem.removeEventListener) {\n            elem.removeEventListener(type, handle);\n        }\n    };\n    jQuery.Event = function(src, props) {\n        // Allow instantiation without the 'new' keyword\n        if (!(this instanceof jQuery.Event)) {\n            return new jQuery.Event(src, props);\n        }\n        // Event object\n        if (src && src.type) {\n            this.originalEvent = src;\n            this.type = src.type;\n            // Events bubbling up the document may have been marked as prevented\n            // by a handler lower down the tree; reflect the correct value.\n            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only\n            src.returnValue === false ? returnTrue : returnFalse;\n            // Create target properties\n            // Support: Safari <=6 - 7 only\n            // Target should not be a text node (trac-504, trac-13143)\n            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n            this.currentTarget = src.currentTarget;\n            this.relatedTarget = src.relatedTarget;\n        // Event type\n        } else {\n            this.type = src;\n        }\n        // Put explicitly provided properties onto the event object\n        if (props) {\n            jQuery.extend(this, props);\n        }\n        // Create a timestamp if incoming event doesn't have one\n        this.timeStamp = src && src.timeStamp || Date.now();\n        // Mark it as fixed\n        this[jQuery.expando] = true;\n    };\n    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n    jQuery.Event.prototype = {\n        constructor: jQuery.Event,\n        isDefaultPrevented: returnFalse,\n        isPropagationStopped: returnFalse,\n        isImmediatePropagationStopped: returnFalse,\n        isSimulated: false,\n        preventDefault: function() {\n            var e = this.originalEvent;\n            this.isDefaultPrevented = returnTrue;\n            if (e && !this.isSimulated) {\n                e.preventDefault();\n            }\n        },\n        stopPropagation: function() {\n            var e = this.originalEvent;\n            this.isPropagationStopped = returnTrue;\n            if (e && !this.isSimulated) {\n                e.stopPropagation();\n            }\n        },\n        stopImmediatePropagation: function() {\n            var e = this.originalEvent;\n            this.isImmediatePropagationStopped = returnTrue;\n            if (e && !this.isSimulated) {\n                e.stopImmediatePropagation();\n            }\n            this.stopPropagation();\n        }\n    };\n    // Includes all common event props including KeyEvent and MouseEvent specific props\n    jQuery.each({\n        altKey: true,\n        bubbles: true,\n        cancelable: true,\n        changedTouches: true,\n        ctrlKey: true,\n        detail: true,\n        eventPhase: true,\n        metaKey: true,\n        pageX: true,\n        pageY: true,\n        shiftKey: true,\n        view: true,\n        \"char\": true,\n        code: true,\n        charCode: true,\n        key: true,\n        keyCode: true,\n        button: true,\n        buttons: true,\n        clientX: true,\n        clientY: true,\n        offsetX: true,\n        offsetY: true,\n        pointerId: true,\n        pointerType: true,\n        screenX: true,\n        screenY: true,\n        targetTouches: true,\n        toElement: true,\n        touches: true,\n        which: true\n    }, jQuery.event.addProp);\n    jQuery.each({\n        focus: \"focusin\",\n        blur: \"focusout\"\n    }, function(type, delegateType) {\n        function focusMappedHandler(nativeEvent) {\n            if (document.documentMode) {\n                // Support: IE 11+\n                // Attach a single focusin/focusout handler on the document while someone wants\n                // focus/blur. This is because the former are synchronous in IE while the latter\n                // are async. In other browsers, all those handlers are invoked synchronously.\n                // `handle` from private data would already wrap the event, but we need\n                // to change the `type` here.\n                var handle = dataPriv.get(this, \"handle\"), event = jQuery.event.fix(nativeEvent);\n                event.type = nativeEvent.type === \"focusin\" ? \"focus\" : \"blur\";\n                event.isSimulated = true;\n                // First, handle focusin/focusout\n                handle(nativeEvent);\n                // ...then, handle focus/blur\n                //\n                // focus/blur don't bubble while focusin/focusout do; simulate the former by only\n                // invoking the handler at the lower level.\n                if (event.target === event.currentTarget) {\n                    // The setup part calls `leverageNative`, which, in turn, calls\n                    // `jQuery.event.add`, so event handle will already have been set\n                    // by this point.\n                    handle(event);\n                }\n            } else {\n                // For non-IE browsers, attach a single capturing handler on the document\n                // while someone wants focusin/focusout.\n                jQuery.event.simulate(delegateType, nativeEvent.target, jQuery.event.fix(nativeEvent));\n            }\n        }\n        jQuery.event.special[type] = {\n            // Utilize native event if possible so blur/focus sequence is correct\n            setup: function() {\n                var attaches;\n                // Claim the first handler\n                // dataPriv.set( this, \"focus\", ... )\n                // dataPriv.set( this, \"blur\", ... )\n                leverageNative(this, type, true);\n                if (document.documentMode) {\n                    // Support: IE 9 - 11+\n                    // We use the same native handler for focusin & focus (and focusout & blur)\n                    // so we need to coordinate setup & teardown parts between those events.\n                    // Use `delegateType` as the key as `type` is already used by `leverageNative`.\n                    attaches = dataPriv.get(this, delegateType);\n                    if (!attaches) {\n                        this.addEventListener(delegateType, focusMappedHandler);\n                    }\n                    dataPriv.set(this, delegateType, (attaches || 0) + 1);\n                } else {\n                    // Return false to allow normal processing in the caller\n                    return false;\n                }\n            },\n            trigger: function() {\n                // Force setup before trigger\n                leverageNative(this, type);\n                // Return non-false to allow normal event-path propagation\n                return true;\n            },\n            teardown: function() {\n                var attaches;\n                if (document.documentMode) {\n                    attaches = dataPriv.get(this, delegateType) - 1;\n                    if (!attaches) {\n                        this.removeEventListener(delegateType, focusMappedHandler);\n                        dataPriv.remove(this, delegateType);\n                    } else {\n                        dataPriv.set(this, delegateType, attaches);\n                    }\n                } else {\n                    // Return false to indicate standard teardown should be applied\n                    return false;\n                }\n            },\n            // Suppress native focus or blur if we're currently inside\n            // a leveraged native-event stack\n            _default: function(event) {\n                return dataPriv.get(event.target, type);\n            },\n            delegateType: delegateType\n        };\n        // Support: Firefox <=44\n        // Firefox doesn't have focus(in | out) events\n        // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n        //\n        // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n        // focus(in | out) events fire after focus & blur events,\n        // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n        // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n        //\n        // Support: IE 9 - 11+\n        // To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,\n        // attach a single handler for both events in IE.\n        jQuery.event.special[delegateType] = {\n            setup: function() {\n                // Handle: regular nodes (via `this.ownerDocument`), window\n                // (via `this.document`) & document (via `this`).\n                var doc = this.ownerDocument || this.document || this, dataHolder = document.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);\n                // Support: IE 9 - 11+\n                // We use the same native handler for focusin & focus (and focusout & blur)\n                // so we need to coordinate setup & teardown parts between those events.\n                // Use `delegateType` as the key as `type` is already used by `leverageNative`.\n                if (!attaches) {\n                    if (document.documentMode) {\n                        this.addEventListener(delegateType, focusMappedHandler);\n                    } else {\n                        doc.addEventListener(type, focusMappedHandler, true);\n                    }\n                }\n                dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);\n            },\n            teardown: function() {\n                var doc = this.ownerDocument || this.document || this, dataHolder = document.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;\n                if (!attaches) {\n                    if (document.documentMode) {\n                        this.removeEventListener(delegateType, focusMappedHandler);\n                    } else {\n                        doc.removeEventListener(type, focusMappedHandler, true);\n                    }\n                    dataPriv.remove(dataHolder, delegateType);\n                } else {\n                    dataPriv.set(dataHolder, delegateType, attaches);\n                }\n            }\n        };\n    });\n    // Create mouseenter/leave events using mouseover/out and event-time checks\n    // so that event delegation works in jQuery.\n    // Do the same for pointerenter/pointerleave and pointerover/pointerout\n    //\n    // Support: Safari 7 only\n    // Safari sends mouseenter too often; see:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n    // for the description of the bug (it existed in older Chrome versions as well).\n    jQuery.each({\n        mouseenter: \"mouseover\",\n        mouseleave: \"mouseout\",\n        pointerenter: \"pointerover\",\n        pointerleave: \"pointerout\"\n    }, function(orig, fix) {\n        jQuery.event.special[orig] = {\n            delegateType: fix,\n            bindType: fix,\n            handle: function(event) {\n                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;\n                // For mouseenter/leave call the handler if related is outside the target.\n                // NB: No relatedTarget if the mouse left/entered the browser window\n                if (!related || related !== target && !jQuery.contains(target, related)) {\n                    event.type = handleObj.origType;\n                    ret = handleObj.handler.apply(this, arguments);\n                    event.type = fix;\n                }\n                return ret;\n            }\n        };\n    });\n    jQuery.fn.extend({\n        on: function(types, selector, data, fn) {\n            return on(this, types, selector, data, fn);\n        },\n        one: function(types, selector, data, fn) {\n            return on(this, types, selector, data, fn, 1);\n        },\n        off: function(types, selector, fn) {\n            var handleObj, type;\n            if (types && types.preventDefault && types.handleObj) {\n                // ( event )  dispatched jQuery.Event\n                handleObj = types.handleObj;\n                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n                return this;\n            }\n            if (typeof types === \"object\") {\n                // ( types-object [, selector] )\n                for(type in types){\n                    this.off(type, selector, types[type]);\n                }\n                return this;\n            }\n            if (selector === false || typeof selector === \"function\") {\n                // ( types [, fn] )\n                fn = selector;\n                selector = undefined;\n            }\n            if (fn === false) {\n                fn = returnFalse;\n            }\n            return this.each(function() {\n                jQuery.event.remove(this, types, fn, selector);\n            });\n        }\n    });\n    var // Support: IE <=10 - 11, Edge 12 - 13 only\n    // In IE/Edge using regex groups here causes severe slowdowns.\n    // See https://connect.microsoft.com/IE/feedback/details/1736512/\n    rnoInnerhtml = /<script|<style|<link/i, // checked=\"checked\" or checked\n    rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i, rcleanScript = /^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g;\n    // Prefer a tbody over its parent table for containing new rows\n    function manipulationTarget(elem, content) {\n        if (nodeName(elem, \"table\") && nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\n            return jQuery(elem).children(\"tbody\")[0] || elem;\n        }\n        return elem;\n    }\n    // Replace/restore the type attribute of script elements for safe DOM manipulation\n    function disableScript(elem) {\n        elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n        return elem;\n    }\n    function restoreScript(elem) {\n        if ((elem.type || \"\").slice(0, 5) === \"true/\") {\n            elem.type = elem.type.slice(5);\n        } else {\n            elem.removeAttribute(\"type\");\n        }\n        return elem;\n    }\n    function cloneCopyEvent(src, dest) {\n        var i, l, type, pdataOld, udataOld, udataCur, events;\n        if (dest.nodeType !== 1) {\n            return;\n        }\n        // 1. Copy private data: events, handlers, etc.\n        if (dataPriv.hasData(src)) {\n            pdataOld = dataPriv.get(src);\n            events = pdataOld.events;\n            if (events) {\n                dataPriv.remove(dest, \"handle events\");\n                for(type in events){\n                    for(i = 0, l = events[type].length; i < l; i++){\n                        jQuery.event.add(dest, type, events[type][i]);\n                    }\n                }\n            }\n        }\n        // 2. Copy user data\n        if (dataUser.hasData(src)) {\n            udataOld = dataUser.access(src);\n            udataCur = jQuery.extend({}, udataOld);\n            dataUser.set(dest, udataCur);\n        }\n    }\n    // Fix IE bugs, see support tests\n    function fixInput(src, dest) {\n        var nodeName = dest.nodeName.toLowerCase();\n        // Fails to persist the checked state of a cloned checkbox or radio button.\n        if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n            dest.checked = src.checked;\n        // Fails to return the selected option to the default selected state when cloning options\n        } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n            dest.defaultValue = src.defaultValue;\n        }\n    }\n    function domManip(collection, args, callback, ignored) {\n        // Flatten any nested arrays\n        args = flat(args);\n        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);\n        // We can't cloneNode fragments that contain checked, in WebKit\n        if (valueIsFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n            return collection.each(function(index) {\n                var self = collection.eq(index);\n                if (valueIsFunction) {\n                    args[0] = value.call(this, index, self.html());\n                }\n                domManip(self, args, callback, ignored);\n            });\n        }\n        if (l) {\n            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n            first = fragment.firstChild;\n            if (fragment.childNodes.length === 1) {\n                fragment = first;\n            }\n            // Require either new content or an interest in ignored elements to invoke the callback\n            if (first || ignored) {\n                scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n                hasScripts = scripts.length;\n                // Use the original fragment for the last item\n                // instead of the first because it can end up\n                // being emptied incorrectly in certain situations (trac-8070).\n                for(; i < l; i++){\n                    node = fragment;\n                    if (i !== iNoClone) {\n                        node = jQuery.clone(node, true, true);\n                        // Keep references to cloned scripts for later restoration\n                        if (hasScripts) {\n                            // Support: Android <=4.0 only, PhantomJS 1 only\n                            // push.apply(_, arraylike) throws on ancient WebKit\n                            jQuery.merge(scripts, getAll(node, \"script\"));\n                        }\n                    }\n                    callback.call(collection[i], node, i);\n                }\n                if (hasScripts) {\n                    doc = scripts[scripts.length - 1].ownerDocument;\n                    // Re-enable scripts\n                    jQuery.map(scripts, restoreScript);\n                    // Evaluate executable scripts on first document insertion\n                    for(i = 0; i < hasScripts; i++){\n                        node = scripts[i];\n                        if (rscriptType.test(node.type || \"\") && !dataPriv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n                            if (node.src && (node.type || \"\").toLowerCase() !== \"module\") {\n                                // Optional AJAX dependency, but won't run scripts if not present\n                                if (jQuery._evalUrl && !node.noModule) {\n                                    jQuery._evalUrl(node.src, {\n                                        nonce: node.nonce || node.getAttribute(\"nonce\")\n                                    }, doc);\n                                }\n                            } else {\n                                // Unwrap a CDATA section containing script contents. This shouldn't be\n                                // needed as in XML documents they're already not visible when\n                                // inspecting element contents and in HTML documents they have no\n                                // meaning but we're preserving that logic for backwards compatibility.\n                                // This will be removed completely in 4.0. See gh-4904.\n                                DOMEval(node.textContent.replace(rcleanScript, \"\"), node, doc);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return collection;\n    }\n    function remove(elem, selector, keepData) {\n        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;\n        for(; (node = nodes[i]) != null; i++){\n            if (!keepData && node.nodeType === 1) {\n                jQuery.cleanData(getAll(node));\n            }\n            if (node.parentNode) {\n                if (keepData && isAttached(node)) {\n                    setGlobalEval(getAll(node, \"script\"));\n                }\n                node.parentNode.removeChild(node);\n            }\n        }\n        return elem;\n    }\n    jQuery.extend({\n        htmlPrefilter: function(html) {\n            return html;\n        },\n        clone: function(elem, dataAndEvents, deepDataAndEvents) {\n            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);\n            // Fix IE cloning issues\n            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n                // We eschew jQuery#find here for performance reasons:\n                // https://jsperf.com/getall-vs-sizzle/2\n                destElements = getAll(clone);\n                srcElements = getAll(elem);\n                for(i = 0, l = srcElements.length; i < l; i++){\n                    fixInput(srcElements[i], destElements[i]);\n                }\n            }\n            // Copy the events from the original to the clone\n            if (dataAndEvents) {\n                if (deepDataAndEvents) {\n                    srcElements = srcElements || getAll(elem);\n                    destElements = destElements || getAll(clone);\n                    for(i = 0, l = srcElements.length; i < l; i++){\n                        cloneCopyEvent(srcElements[i], destElements[i]);\n                    }\n                } else {\n                    cloneCopyEvent(elem, clone);\n                }\n            }\n            // Preserve script evaluation history\n            destElements = getAll(clone, \"script\");\n            if (destElements.length > 0) {\n                setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n            }\n            // Return the cloned set\n            return clone;\n        },\n        cleanData: function(elems) {\n            var data, elem, type, special = jQuery.event.special, i = 0;\n            for(; (elem = elems[i]) !== undefined; i++){\n                if (acceptData(elem)) {\n                    if (data = elem[dataPriv.expando]) {\n                        if (data.events) {\n                            for(type in data.events){\n                                if (special[type]) {\n                                    jQuery.event.remove(elem, type);\n                                // This is a shortcut to avoid jQuery.event.remove's overhead\n                                } else {\n                                    jQuery.removeEvent(elem, type, data.handle);\n                                }\n                            }\n                        }\n                        // Support: Chrome <=35 - 45+\n                        // Assign undefined instead of using delete, see Data#remove\n                        elem[dataPriv.expando] = undefined;\n                    }\n                    if (elem[dataUser.expando]) {\n                        // Support: Chrome <=35 - 45+\n                        // Assign undefined instead of using delete, see Data#remove\n                        elem[dataUser.expando] = undefined;\n                    }\n                }\n            }\n        }\n    });\n    jQuery.fn.extend({\n        detach: function(selector) {\n            return remove(this, selector, true);\n        },\n        remove: function(selector) {\n            return remove(this, selector);\n        },\n        text: function(value) {\n            return access(this, function(value) {\n                return value === undefined ? jQuery.text(this) : this.empty().each(function() {\n                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n                        this.textContent = value;\n                    }\n                });\n            }, null, value, arguments.length);\n        },\n        append: function() {\n            return domManip(this, arguments, function(elem) {\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n                    var target = manipulationTarget(this, elem);\n                    target.appendChild(elem);\n                }\n            });\n        },\n        prepend: function() {\n            return domManip(this, arguments, function(elem) {\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n                    var target = manipulationTarget(this, elem);\n                    target.insertBefore(elem, target.firstChild);\n                }\n            });\n        },\n        before: function() {\n            return domManip(this, arguments, function(elem) {\n                if (this.parentNode) {\n                    this.parentNode.insertBefore(elem, this);\n                }\n            });\n        },\n        after: function() {\n            return domManip(this, arguments, function(elem) {\n                if (this.parentNode) {\n                    this.parentNode.insertBefore(elem, this.nextSibling);\n                }\n            });\n        },\n        empty: function() {\n            var elem, i = 0;\n            for(; (elem = this[i]) != null; i++){\n                if (elem.nodeType === 1) {\n                    // Prevent memory leaks\n                    jQuery.cleanData(getAll(elem, false));\n                    // Remove any remaining nodes\n                    elem.textContent = \"\";\n                }\n            }\n            return this;\n        },\n        clone: function(dataAndEvents, deepDataAndEvents) {\n            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n            return this.map(function() {\n                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n            });\n        },\n        html: function(value) {\n            return access(this, function(value) {\n                var elem = this[0] || {}, i = 0, l = this.length;\n                if (value === undefined && elem.nodeType === 1) {\n                    return elem.innerHTML;\n                }\n                // See if we can take a shortcut and just use innerHTML\n                if (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\n                    \"\",\n                    \"\"\n                ])[1].toLowerCase()]) {\n                    value = jQuery.htmlPrefilter(value);\n                    try {\n                        for(; i < l; i++){\n                            elem = this[i] || {};\n                            // Remove element nodes and prevent memory leaks\n                            if (elem.nodeType === 1) {\n                                jQuery.cleanData(getAll(elem, false));\n                                elem.innerHTML = value;\n                            }\n                        }\n                        elem = 0;\n                    // If using innerHTML throws an exception, use the fallback method\n                    } catch (e) {}\n                }\n                if (elem) {\n                    this.empty().append(value);\n                }\n            }, null, value, arguments.length);\n        },\n        replaceWith: function() {\n            var ignored = [];\n            // Make the changes, replacing each non-ignored context element with the new content\n            return domManip(this, arguments, function(elem) {\n                var parent = this.parentNode;\n                if (jQuery.inArray(this, ignored) < 0) {\n                    jQuery.cleanData(getAll(this));\n                    if (parent) {\n                        parent.replaceChild(elem, this);\n                    }\n                }\n            // Force callback invocation\n            }, ignored);\n        }\n    });\n    jQuery.each({\n        appendTo: \"append\",\n        prependTo: \"prepend\",\n        insertBefore: \"before\",\n        insertAfter: \"after\",\n        replaceAll: \"replaceWith\"\n    }, function(name, original) {\n        jQuery.fn[name] = function(selector) {\n            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;\n            for(; i <= last; i++){\n                elems = i === last ? this : this.clone(true);\n                jQuery(insert[i])[original](elems);\n                // Support: Android <=4.0 only, PhantomJS 1 only\n                // .get() because push.apply(_, arraylike) throws on ancient WebKit\n                push.apply(ret, elems.get());\n            }\n            return this.pushStack(ret);\n        };\n    });\n    var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n    var rcustomProp = /^--/;\n    var getStyles = function(elem) {\n        // Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)\n        // IE throws on elements created in popups\n        // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n        var view = elem.ownerDocument.defaultView;\n        if (!view || !view.opener) {\n            view = window1;\n        }\n        return view.getComputedStyle(elem);\n    };\n    var swap = function(elem, options, callback) {\n        var ret, name, old = {};\n        // Remember the old values, and insert the new ones\n        for(name in options){\n            old[name] = elem.style[name];\n            elem.style[name] = options[name];\n        }\n        ret = callback.call(elem);\n        // Revert the old values\n        for(name in options){\n            elem.style[name] = old[name];\n        }\n        return ret;\n    };\n    var rboxStyle = new RegExp(cssExpand.join(\"|\"), \"i\");\n    (function() {\n        // Executing both pixelPosition & boxSizingReliable tests require only one layout\n        // so they're executed at the same time to save the second computation.\n        function computeStyleTests() {\n            // This is a singleton, we need to execute it only once\n            if (!div) {\n                return;\n            }\n            container.style.cssText = \"position:absolute;left:-11111px;width:60px;\" + \"margin-top:1px;padding:0;border:0\";\n            div.style.cssText = \"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" + \"margin:auto;border:1px;padding:1px;\" + \"width:60%;top:1%\";\n            documentElement.appendChild(container).appendChild(div);\n            var divStyle = window1.getComputedStyle(div);\n            pixelPositionVal = divStyle.top !== \"1%\";\n            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;\n            // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n            // Some styles come back with percentage values, even though they shouldn't\n            div.style.right = \"60%\";\n            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;\n            // Support: IE 9 - 11 only\n            // Detect misreporting of content dimensions for box-sizing:border-box elements\n            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;\n            // Support: IE 9 only\n            // Detect overflow:scroll screwiness (gh-3699)\n            // Support: Chrome <=64\n            // Don't get tricked when zoom affects offsetWidth (gh-4029)\n            div.style.position = \"absolute\";\n            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;\n            documentElement.removeChild(container);\n            // Nullify the div so it wouldn't be stored in the memory and\n            // it will also be a sign that checks already performed\n            div = null;\n        }\n        function roundPixelMeasures(measure) {\n            return Math.round(parseFloat(measure));\n        }\n        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document.createElement(\"div\"), div = document.createElement(\"div\");\n        // Finish early in limited (non-browser) environments\n        if (!div.style) {\n            return;\n        }\n        // Support: IE <=9 - 11 only\n        // Style of cloned element affects source element cloned (trac-8908)\n        div.style.backgroundClip = \"content-box\";\n        div.cloneNode(true).style.backgroundClip = \"\";\n        support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n        jQuery.extend(support, {\n            boxSizingReliable: function() {\n                computeStyleTests();\n                return boxSizingReliableVal;\n            },\n            pixelBoxStyles: function() {\n                computeStyleTests();\n                return pixelBoxStylesVal;\n            },\n            pixelPosition: function() {\n                computeStyleTests();\n                return pixelPositionVal;\n            },\n            reliableMarginLeft: function() {\n                computeStyleTests();\n                return reliableMarginLeftVal;\n            },\n            scrollboxSize: function() {\n                computeStyleTests();\n                return scrollboxSizeVal;\n            },\n            // Support: IE 9 - 11+, Edge 15 - 18+\n            // IE/Edge misreport `getComputedStyle` of table rows with width/height\n            // set in CSS while `offset*` properties report correct values.\n            // Behavior in IE 9 is more subtle than in newer versions & it passes\n            // some versions of this test; make sure not to make it pass there!\n            //\n            // Support: Firefox 70+\n            // Only Firefox includes border widths\n            // in computed dimensions. (gh-4529)\n            reliableTrDimensions: function() {\n                var table, tr, trChild, trStyle;\n                if (reliableTrDimensionsVal == null) {\n                    table = document.createElement(\"table\");\n                    tr = document.createElement(\"tr\");\n                    trChild = document.createElement(\"div\");\n                    table.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n                    tr.style.cssText = \"box-sizing:content-box;border:1px solid\";\n                    // Support: Chrome 86+\n                    // Height set through cssText does not get applied.\n                    // Computed height then comes back as 0.\n                    tr.style.height = \"1px\";\n                    trChild.style.height = \"9px\";\n                    // Support: Android 8 Chrome 86+\n                    // In our bodyBackground.html iframe,\n                    // display for all div elements is set to \"inline\",\n                    // which causes a problem only in Android 8 Chrome 86.\n                    // Ensuring the div is `display: block`\n                    // gets around this issue.\n                    trChild.style.display = \"block\";\n                    documentElement.appendChild(table).appendChild(tr).appendChild(trChild);\n                    trStyle = window1.getComputedStyle(tr);\n                    reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;\n                    documentElement.removeChild(table);\n                }\n                return reliableTrDimensionsVal;\n            }\n        });\n    })();\n    function curCSS(elem, name, computed) {\n        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), // Support: Firefox 51+\n        // Retrieving style before computed somehow\n        // fixes an issue with getting wrong values\n        // on detached elements\n        style = elem.style;\n        computed = computed || getStyles(elem);\n        // getPropertyValue is needed for:\n        //   .css('filter') (IE 9 only, trac-12537)\n        //   .css('--customProperty) (gh-3144)\n        if (computed) {\n            // Support: IE <=9 - 11+\n            // IE only supports `\"float\"` in `getPropertyValue`; in computed styles\n            // it's only available as `\"cssFloat\"`. We no longer modify properties\n            // sent to `.css()` apart from camelCasing, so we need to check both.\n            // Normally, this would create difference in behavior: if\n            // `getPropertyValue` returns an empty string, the value returned\n            // by `.css()` would be `undefined`. This is usually the case for\n            // disconnected elements. However, in IE even disconnected elements\n            // with no styles return `\"none\"` for `getPropertyValue( \"float\" )`\n            ret = computed.getPropertyValue(name) || computed[name];\n            if (isCustomProp && ret) {\n                // Support: Firefox 105+, Chrome <=105+\n                // Spec requires trimming whitespace for custom properties (gh-4926).\n                // Firefox only trims leading whitespace. Chrome just collapses\n                // both leading & trailing whitespace to a single space.\n                //\n                // Fall back to `undefined` if empty string returned.\n                // This collapses a missing definition with property defined\n                // and set to an empty string but there's no standard API\n                // allowing us to differentiate them without a performance penalty\n                // and returning `undefined` aligns with older jQuery.\n                //\n                // rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED\n                // as whitespace while CSS does not, but this is not a problem\n                // because CSS preprocessing replaces them with U+000A LINE FEED\n                // (which *is* CSS whitespace)\n                // https://www.w3.org/TR/css-syntax-3/#input-preprocessing\n                ret = ret.replace(rtrimCSS, \"$1\") || undefined;\n            }\n            if (ret === \"\" && !isAttached(elem)) {\n                ret = jQuery.style(elem, name);\n            }\n            // A tribute to the \"awesome hack by Dean Edwards\"\n            // Android Browser returns percentage for some values,\n            // but width seems to be reliably pixels.\n            // This is against the CSSOM draft spec:\n            // https://drafts.csswg.org/cssom/#resolved-values\n            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\n                // Remember the original values\n                width = style.width;\n                minWidth = style.minWidth;\n                maxWidth = style.maxWidth;\n                // Put in the new values to get a computed value out\n                style.minWidth = style.maxWidth = style.width = ret;\n                ret = computed.width;\n                // Revert the changed values\n                style.width = width;\n                style.minWidth = minWidth;\n                style.maxWidth = maxWidth;\n            }\n        }\n        return ret !== undefined ? // Support: IE <=9 - 11 only\n        // IE returns zIndex value as an integer.\n        ret + \"\" : ret;\n    }\n    function addGetHookIf(conditionFn, hookFn) {\n        // Define the hook, we'll check on the first run if it's really needed.\n        return {\n            get: function() {\n                if (conditionFn()) {\n                    // Hook not needed (or it's not possible to use it due\n                    // to missing dependency), remove it.\n                    delete this.get;\n                    return;\n                }\n                // Hook needed; redefine it so that the support test is not executed again.\n                return (this.get = hookFn).apply(this, arguments);\n            }\n        };\n    }\n    var cssPrefixes = [\n        \"Webkit\",\n        \"Moz\",\n        \"ms\"\n    ], emptyStyle = document.createElement(\"div\").style, vendorProps = {};\n    // Return a vendor-prefixed property or undefined\n    function vendorPropName(name) {\n        // Check for vendor prefixed names\n        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;\n        while(i--){\n            name = cssPrefixes[i] + capName;\n            if (name in emptyStyle) {\n                return name;\n            }\n        }\n    }\n    // Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n    function finalPropName(name) {\n        var final = jQuery.cssProps[name] || vendorProps[name];\n        if (final) {\n            return final;\n        }\n        if (name in emptyStyle) {\n            return name;\n        }\n        return vendorProps[name] = vendorPropName(name) || name;\n    }\n    var // Swappable if display is none or starts with table\n    // except \"table\", \"table-cell\", or \"table-caption\"\n    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {\n        position: \"absolute\",\n        visibility: \"hidden\",\n        display: \"block\"\n    }, cssNormalTransform = {\n        letterSpacing: \"0\",\n        fontWeight: \"400\"\n    };\n    function setPositiveNumber(_elem, value, subtract) {\n        // Any relative (+/-) values have already been\n        // normalized at this point\n        var matches = rcssNum.exec(value);\n        return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") : value;\n    }\n    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\n        var i = dimension === \"width\" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;\n        // Adjustment may not be necessary\n        if (box === (isBorderBox ? \"border\" : \"content\")) {\n            return 0;\n        }\n        for(; i < 4; i += 2){\n            // Both box models exclude margin\n            // Count margin delta separately to only add it after scroll gutter adjustment.\n            // This is needed to make negative margins work with `outerHeight( true )` (gh-3982).\n            if (box === \"margin\") {\n                marginDelta += jQuery.css(elem, box + cssExpand[i], true, styles);\n            }\n            // If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n            if (!isBorderBox) {\n                // Add padding\n                delta += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n                // For \"border\" or \"margin\", add border\n                if (box !== \"padding\") {\n                    delta += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n                // But still keep track of it otherwise\n                } else {\n                    extra += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n                }\n            // If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n            // \"padding\" or \"margin\"\n            } else {\n                // For \"content\", subtract padding\n                if (box === \"content\") {\n                    delta -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n                }\n                // For \"content\" or \"padding\", subtract border\n                if (box !== \"margin\") {\n                    delta -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n                }\n            }\n        }\n        // Account for positive content-box scroll gutter when requested by providing computedVal\n        if (!isBorderBox && computedVal >= 0) {\n            // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n            // Assuming integer scroll gutter, subtract the rest and round down\n            delta += Math.max(0, Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5)) || 0;\n        }\n        return delta + marginDelta;\n    }\n    function getWidthOrHeight(elem, dimension, extra) {\n        // Start with computed style\n        var styles = getStyles(elem), // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n        // Fake content-box until we know it's needed to know the true value.\n        boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = \"offset\" + dimension[0].toUpperCase() + dimension.slice(1);\n        // Support: Firefox <=54\n        // Return a confounding non-pixel value or feign ignorance, as appropriate.\n        if (rnumnonpx.test(val)) {\n            if (!extra) {\n                return val;\n            }\n            val = \"auto\";\n        }\n        // Support: IE 9 - 11 only\n        // Use offsetWidth/offsetHeight for when box sizing is unreliable.\n        // In those cases, the computed value can be trusted to be border-box.\n        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+\n        // IE/Edge misreport `getComputedStyle` of table rows with width/height\n        // set in CSS while `offset*` properties report correct values.\n        // Interestingly, in some cases IE 9 doesn't suffer from this issue.\n        !support.reliableTrDimensions() && nodeName(elem, \"tr\") || // Fall back to offsetWidth/offsetHeight when value is \"auto\"\n        // This happens for inline elements with no explicit setting (gh-3571)\n        val === \"auto\" || // Support: Android <=4.1 - 4.3 only\n        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n        !parseFloat(val) && jQuery.css(elem, \"display\", false, styles) === \"inline\") && // Make sure the element is visible & connected\n        elem.getClientRects().length) {\n            isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\";\n            // Where available, offsetWidth/offsetHeight approximate border box dimensions.\n            // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n            // retrieved value as a content box dimension.\n            valueIsBorderBox = offsetProp in elem;\n            if (valueIsBorderBox) {\n                val = elem[offsetProp];\n            }\n        }\n        // Normalize \"\" and auto\n        val = parseFloat(val) || 0;\n        // Adjust for the element's box model\n        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)\n        val) + \"px\";\n    }\n    jQuery.extend({\n        // Add in style property hooks for overriding the default\n        // behavior of getting and setting a style property\n        cssHooks: {\n            opacity: {\n                get: function(elem, computed) {\n                    if (computed) {\n                        // We should always get a number back from opacity\n                        var ret = curCSS(elem, \"opacity\");\n                        return ret === \"\" ? \"1\" : ret;\n                    }\n                }\n            }\n        },\n        // Don't automatically add \"px\" to these possibly-unitless properties\n        cssNumber: {\n            animationIterationCount: true,\n            aspectRatio: true,\n            borderImageSlice: true,\n            columnCount: true,\n            flexGrow: true,\n            flexShrink: true,\n            fontWeight: true,\n            gridArea: true,\n            gridColumn: true,\n            gridColumnEnd: true,\n            gridColumnStart: true,\n            gridRow: true,\n            gridRowEnd: true,\n            gridRowStart: true,\n            lineHeight: true,\n            opacity: true,\n            order: true,\n            orphans: true,\n            scale: true,\n            widows: true,\n            zIndex: true,\n            zoom: true,\n            // SVG-related\n            fillOpacity: true,\n            floodOpacity: true,\n            stopOpacity: true,\n            strokeMiterlimit: true,\n            strokeOpacity: true\n        },\n        // Add in properties whose names you wish to fix before\n        // setting or getting the value\n        cssProps: {},\n        // Get and set the style property on a DOM Node\n        style: function(elem, name, value, extra) {\n            // Don't set styles on text and comment nodes\n            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n                return;\n            }\n            // Make sure that we're working with the right name\n            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;\n            // Make sure that we're working with the right name. We don't\n            // want to query the value if it is a CSS custom property\n            // since they are user-defined.\n            if (!isCustomProp) {\n                name = finalPropName(origName);\n            }\n            // Gets hook for the prefixed version, then unprefixed version\n            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n            // Check if we're setting a value\n            if (value !== undefined) {\n                type = typeof value;\n                // Convert \"+=\" or \"-=\" to relative numbers (trac-7345)\n                if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n                    value = adjustCSS(elem, name, ret);\n                    // Fixes bug trac-9237\n                    type = \"number\";\n                }\n                // Make sure that null and NaN values aren't set (trac-7116)\n                if (value == null || value !== value) {\n                    return;\n                }\n                // If a number was passed in, add the unit (except for certain CSS properties)\n                // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n                // \"px\" to a few hardcoded values.\n                if (type === \"number\" && !isCustomProp) {\n                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n                }\n                // background-* props affect original clone's values\n                if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n                    style[name] = \"inherit\";\n                }\n                // If a hook was provided, use that value, otherwise just set the specified value\n                if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n                    if (isCustomProp) {\n                        style.setProperty(name, value);\n                    } else {\n                        style[name] = value;\n                    }\n                }\n            } else {\n                // If a hook was provided get the non-computed value from there\n                if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n                    return ret;\n                }\n                // Otherwise just get the value from the style object\n                return style[name];\n            }\n        },\n        css: function(elem, name, extra, styles) {\n            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);\n            // Make sure that we're working with the right name. We don't\n            // want to modify the value if it is a CSS custom property\n            // since they are user-defined.\n            if (!isCustomProp) {\n                name = finalPropName(origName);\n            }\n            // Try prefixed name followed by the unprefixed name\n            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n            // If a hook was provided get the computed value from there\n            if (hooks && \"get\" in hooks) {\n                val = hooks.get(elem, true, extra);\n            }\n            // Otherwise, if a way to get the computed value exists, use that\n            if (val === undefined) {\n                val = curCSS(elem, name, styles);\n            }\n            // Convert \"normal\" to computed value\n            if (val === \"normal\" && name in cssNormalTransform) {\n                val = cssNormalTransform[name];\n            }\n            // Make numeric if forced or a qualifier was provided and val looks numeric\n            if (extra === \"\" || extra) {\n                num = parseFloat(val);\n                return extra === true || isFinite(num) ? num || 0 : val;\n            }\n            return val;\n        }\n    });\n    jQuery.each([\n        \"height\",\n        \"width\"\n    ], function(_i, dimension) {\n        jQuery.cssHooks[dimension] = {\n            get: function(elem, computed, extra) {\n                if (computed) {\n                    // Certain elements can have dimension info if we invisibly show them\n                    // but it must have a current display style that would benefit\n                    return rdisplayswap.test(jQuery.css(elem, \"display\")) && // Support: Safari 8+\n                    // Table columns in Safari have non-zero offsetWidth & zero\n                    // getBoundingClientRect().width unless display is changed.\n                    // Support: IE <=11 only\n                    // Running getBoundingClientRect on a disconnected node\n                    // in IE throws an error.\n                    (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {\n                        return getWidthOrHeight(elem, dimension, extra);\n                    }) : getWidthOrHeight(elem, dimension, extra);\n                }\n            },\n            set: function(elem, value, extra) {\n                var matches, styles = getStyles(elem), // Only read styles.position if the test has a chance to fail\n                // to avoid forcing a reflow.\n                scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === \"absolute\", // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n                boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;\n                // Account for unreliable border-box dimensions by comparing offset* to computed and\n                // faking a content-box to get border and padding (gh-3699)\n                if (isBorderBox && scrollboxSizeBuggy) {\n                    subtract -= Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, \"border\", false, styles) - 0.5);\n                }\n                // Convert to pixels if value adjustment is needed\n                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || \"px\") !== \"px\") {\n                    elem.style[dimension] = value;\n                    value = jQuery.css(elem, dimension);\n                }\n                return setPositiveNumber(elem, value, subtract);\n            }\n        };\n    });\n    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {\n        if (computed) {\n            return (parseFloat(curCSS(elem, \"marginLeft\")) || elem.getBoundingClientRect().left - swap(elem, {\n                marginLeft: 0\n            }, function() {\n                return elem.getBoundingClientRect().left;\n            })) + \"px\";\n        }\n    });\n    // These hooks are used by animate to expand properties\n    jQuery.each({\n        margin: \"\",\n        padding: \"\",\n        border: \"Width\"\n    }, function(prefix, suffix) {\n        jQuery.cssHooks[prefix + suffix] = {\n            expand: function(value) {\n                var i = 0, expanded = {}, // Assumes a single number if not a string\n                parts = typeof value === \"string\" ? value.split(\" \") : [\n                    value\n                ];\n                for(; i < 4; i++){\n                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n                }\n                return expanded;\n            }\n        };\n        if (prefix !== \"margin\") {\n            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n        }\n    });\n    jQuery.fn.extend({\n        css: function(name, value) {\n            return access(this, function(elem, name, value) {\n                var styles, len, map = {}, i = 0;\n                if (Array.isArray(name)) {\n                    styles = getStyles(elem);\n                    len = name.length;\n                    for(; i < len; i++){\n                        map[name[i]] = jQuery.css(elem, name[i], false, styles);\n                    }\n                    return map;\n                }\n                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n            }, name, value, arguments.length > 1);\n        }\n    });\n    function Tween(elem, options, prop, end, easing) {\n        return new Tween.prototype.init(elem, options, prop, end, easing);\n    }\n    jQuery.Tween = Tween;\n    Tween.prototype = {\n        constructor: Tween,\n        init: function(elem, options, prop, end, easing, unit) {\n            this.elem = elem;\n            this.prop = prop;\n            this.easing = easing || jQuery.easing._default;\n            this.options = options;\n            this.start = this.now = this.cur();\n            this.end = end;\n            this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n        },\n        cur: function() {\n            var hooks = Tween.propHooks[this.prop];\n            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n        },\n        run: function(percent) {\n            var eased, hooks = Tween.propHooks[this.prop];\n            if (this.options.duration) {\n                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n            } else {\n                this.pos = eased = percent;\n            }\n            this.now = (this.end - this.start) * eased + this.start;\n            if (this.options.step) {\n                this.options.step.call(this.elem, this.now, this);\n            }\n            if (hooks && hooks.set) {\n                hooks.set(this);\n            } else {\n                Tween.propHooks._default.set(this);\n            }\n            return this;\n        }\n    };\n    Tween.prototype.init.prototype = Tween.prototype;\n    Tween.propHooks = {\n        _default: {\n            get: function(tween) {\n                var result;\n                // Use a property on the element directly when it is not a DOM element,\n                // or when there is no matching style property that exists.\n                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n                    return tween.elem[tween.prop];\n                }\n                // Passing an empty string as a 3rd parameter to .css will automatically\n                // attempt a parseFloat and fallback to a string if the parse fails.\n                // Simple values such as \"10px\" are parsed to Float;\n                // complex values such as \"rotate(1rad)\" are returned as-is.\n                result = jQuery.css(tween.elem, tween.prop, \"\");\n                // Empty strings, null, undefined and \"auto\" are converted to 0.\n                return !result || result === \"auto\" ? 0 : result;\n            },\n            set: function(tween) {\n                // Use step hook for back compat.\n                // Use cssHook if its there.\n                // Use .style if available and use plain properties where available.\n                if (jQuery.fx.step[tween.prop]) {\n                    jQuery.fx.step[tween.prop](tween);\n                } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {\n                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n                } else {\n                    tween.elem[tween.prop] = tween.now;\n                }\n            }\n        }\n    };\n    // Support: IE <=9 only\n    // Panic based approach to setting things on disconnected nodes\n    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n        set: function(tween) {\n            if (tween.elem.nodeType && tween.elem.parentNode) {\n                tween.elem[tween.prop] = tween.now;\n            }\n        }\n    };\n    jQuery.easing = {\n        linear: function(p) {\n            return p;\n        },\n        swing: function(p) {\n            return 0.5 - Math.cos(p * Math.PI) / 2;\n        },\n        _default: \"swing\"\n    };\n    jQuery.fx = Tween.prototype.init;\n    // Back compat <1.8 extension point\n    jQuery.fx.step = {};\n    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;\n    function schedule() {\n        if (inProgress) {\n            if (document.hidden === false && window1.requestAnimationFrame) {\n                window1.requestAnimationFrame(schedule);\n            } else {\n                window1.setTimeout(schedule, jQuery.fx.interval);\n            }\n            jQuery.fx.tick();\n        }\n    }\n    // Animations created synchronously will run synchronously\n    function createFxNow() {\n        window1.setTimeout(function() {\n            fxNow = undefined;\n        });\n        return fxNow = Date.now();\n    }\n    // Generate parameters to create a standard animation\n    function genFx(type, includeWidth) {\n        var which, i = 0, attrs = {\n            height: type\n        };\n        // If we include width, step value is 1 to do all cssExpand values,\n        // otherwise step value is 2 to skip over Left and Right\n        includeWidth = includeWidth ? 1 : 0;\n        for(; i < 4; i += 2 - includeWidth){\n            which = cssExpand[i];\n            attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n        }\n        if (includeWidth) {\n            attrs.opacity = attrs.width = type;\n        }\n        return attrs;\n    }\n    function createTween(value, prop, animation) {\n        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]), index = 0, length = collection.length;\n        for(; index < length; index++){\n            if (tween = collection[index].call(animation, prop, value)) {\n                // We're done with this property\n                return tween;\n            }\n        }\n    }\n    function defaultPrefilter(elem, props, opts) {\n        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = \"width\" in props || \"height\" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, \"fxshow\");\n        // Queue-skipping animations hijack the fx hooks\n        if (!opts.queue) {\n            hooks = jQuery._queueHooks(elem, \"fx\");\n            if (hooks.unqueued == null) {\n                hooks.unqueued = 0;\n                oldfire = hooks.empty.fire;\n                hooks.empty.fire = function() {\n                    if (!hooks.unqueued) {\n                        oldfire();\n                    }\n                };\n            }\n            hooks.unqueued++;\n            anim.always(function() {\n                // Ensure the complete handler is called before this completes\n                anim.always(function() {\n                    hooks.unqueued--;\n                    if (!jQuery.queue(elem, \"fx\").length) {\n                        hooks.empty.fire();\n                    }\n                });\n            });\n        }\n        // Detect show/hide animations\n        for(prop in props){\n            value = props[prop];\n            if (rfxtypes.test(value)) {\n                delete props[prop];\n                toggle = toggle || value === \"toggle\";\n                if (value === (hidden ? \"hide\" : \"show\")) {\n                    // Pretend to be hidden if this is a \"show\" and\n                    // there is still data from a stopped show/hide\n                    if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n                        hidden = true;\n                    // Ignore all other no-op show/hide data\n                    } else {\n                        continue;\n                    }\n                }\n                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n            }\n        }\n        // Bail out if this is a no-op like .hide().hide()\n        propTween = !jQuery.isEmptyObject(props);\n        if (!propTween && jQuery.isEmptyObject(orig)) {\n            return;\n        }\n        // Restrict \"overflow\" and \"display\" styles during box animations\n        if (isBox && elem.nodeType === 1) {\n            // Support: IE <=9 - 11, Edge 12 - 15\n            // Record all 3 overflow attributes because IE does not infer the shorthand\n            // from identically-valued overflowX and overflowY and Edge just mirrors\n            // the overflowX value there.\n            opts.overflow = [\n                style.overflow,\n                style.overflowX,\n                style.overflowY\n            ];\n            // Identify a display type, preferring old show/hide data over the CSS cascade\n            restoreDisplay = dataShow && dataShow.display;\n            if (restoreDisplay == null) {\n                restoreDisplay = dataPriv.get(elem, \"display\");\n            }\n            display = jQuery.css(elem, \"display\");\n            if (display === \"none\") {\n                if (restoreDisplay) {\n                    display = restoreDisplay;\n                } else {\n                    // Get nonempty value(s) by temporarily forcing visibility\n                    showHide([\n                        elem\n                    ], true);\n                    restoreDisplay = elem.style.display || restoreDisplay;\n                    display = jQuery.css(elem, \"display\");\n                    showHide([\n                        elem\n                    ]);\n                }\n            }\n            // Animate inline elements as inline-block\n            if (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\n                if (jQuery.css(elem, \"float\") === \"none\") {\n                    // Restore the original display value at the end of pure show/hide animations\n                    if (!propTween) {\n                        anim.done(function() {\n                            style.display = restoreDisplay;\n                        });\n                        if (restoreDisplay == null) {\n                            display = style.display;\n                            restoreDisplay = display === \"none\" ? \"\" : display;\n                        }\n                    }\n                    style.display = \"inline-block\";\n                }\n            }\n        }\n        if (opts.overflow) {\n            style.overflow = \"hidden\";\n            anim.always(function() {\n                style.overflow = opts.overflow[0];\n                style.overflowX = opts.overflow[1];\n                style.overflowY = opts.overflow[2];\n            });\n        }\n        // Implement show/hide animations\n        propTween = false;\n        for(prop in orig){\n            // General show/hide setup for this element animation\n            if (!propTween) {\n                if (dataShow) {\n                    if (\"hidden\" in dataShow) {\n                        hidden = dataShow.hidden;\n                    }\n                } else {\n                    dataShow = dataPriv.access(elem, \"fxshow\", {\n                        display: restoreDisplay\n                    });\n                }\n                // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n                if (toggle) {\n                    dataShow.hidden = !hidden;\n                }\n                // Show elements before animating them\n                if (hidden) {\n                    showHide([\n                        elem\n                    ], true);\n                }\n                /* eslint-disable no-loop-func */ anim.done(function() {\n                    /* eslint-enable no-loop-func */ // The final step of a \"hide\" animation is actually hiding the element\n                    if (!hidden) {\n                        showHide([\n                            elem\n                        ]);\n                    }\n                    dataPriv.remove(elem, \"fxshow\");\n                    for(prop in orig){\n                        jQuery.style(elem, prop, orig[prop]);\n                    }\n                });\n            }\n            // Per-property setup\n            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n            if (!(prop in dataShow)) {\n                dataShow[prop] = propTween.start;\n                if (hidden) {\n                    propTween.end = propTween.start;\n                    propTween.start = 0;\n                }\n            }\n        }\n    }\n    function propFilter(props, specialEasing) {\n        var index, name, easing, value, hooks;\n        // camelCase, specialEasing and expand cssHook pass\n        for(index in props){\n            name = camelCase(index);\n            easing = specialEasing[name];\n            value = props[index];\n            if (Array.isArray(value)) {\n                easing = value[1];\n                value = props[index] = value[0];\n            }\n            if (index !== name) {\n                props[name] = value;\n                delete props[index];\n            }\n            hooks = jQuery.cssHooks[name];\n            if (hooks && \"expand\" in hooks) {\n                value = hooks.expand(value);\n                delete props[name];\n                // Not quite $.extend, this won't overwrite existing keys.\n                // Reusing 'index' because we have the correct \"name\"\n                for(index in value){\n                    if (!(index in props)) {\n                        props[index] = value[index];\n                        specialEasing[index] = easing;\n                    }\n                }\n            } else {\n                specialEasing[name] = easing;\n            }\n        }\n    }\n    function Animation(elem, properties, options) {\n        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {\n            // Don't match elem in the :animated selector\n            delete tick.elem;\n        }), tick = function() {\n            if (stopped) {\n                return false;\n            }\n            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), // Support: Android 2.3 only\n            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)\n            temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;\n            for(; index < length; index++){\n                animation.tweens[index].run(percent);\n            }\n            deferred.notifyWith(elem, [\n                animation,\n                percent,\n                remaining\n            ]);\n            // If there's more to do, yield\n            if (percent < 1 && length) {\n                return remaining;\n            }\n            // If this was an empty animation, synthesize a final progress notification\n            if (!length) {\n                deferred.notifyWith(elem, [\n                    animation,\n                    1,\n                    0\n                ]);\n            }\n            // Resolve the animation and report its conclusion\n            deferred.resolveWith(elem, [\n                animation\n            ]);\n            return false;\n        }, animation = deferred.promise({\n            elem: elem,\n            props: jQuery.extend({}, properties),\n            opts: jQuery.extend(true, {\n                specialEasing: {},\n                easing: jQuery.easing._default\n            }, options),\n            originalProperties: properties,\n            originalOptions: options,\n            startTime: fxNow || createFxNow(),\n            duration: options.duration,\n            tweens: [],\n            createTween: function(prop, end) {\n                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n                animation.tweens.push(tween);\n                return tween;\n            },\n            stop: function(gotoEnd) {\n                var index = 0, // If we are going to the end, we want to run all the tweens\n                // otherwise we skip this part\n                length = gotoEnd ? animation.tweens.length : 0;\n                if (stopped) {\n                    return this;\n                }\n                stopped = true;\n                for(; index < length; index++){\n                    animation.tweens[index].run(1);\n                }\n                // Resolve when we played the last frame; otherwise, reject\n                if (gotoEnd) {\n                    deferred.notifyWith(elem, [\n                        animation,\n                        1,\n                        0\n                    ]);\n                    deferred.resolveWith(elem, [\n                        animation,\n                        gotoEnd\n                    ]);\n                } else {\n                    deferred.rejectWith(elem, [\n                        animation,\n                        gotoEnd\n                    ]);\n                }\n                return this;\n            }\n        }), props = animation.props;\n        propFilter(props, animation.opts.specialEasing);\n        for(; index < length; index++){\n            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n            if (result) {\n                if (isFunction(result.stop)) {\n                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\n                }\n                return result;\n            }\n        }\n        jQuery.map(props, createTween, animation);\n        if (isFunction(animation.opts.start)) {\n            animation.opts.start.call(elem, animation);\n        }\n        // Attach callbacks from options\n        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n        jQuery.fx.timer(jQuery.extend(tick, {\n            elem: elem,\n            anim: animation,\n            queue: animation.opts.queue\n        }));\n        return animation;\n    }\n    jQuery.Animation = jQuery.extend(Animation, {\n        tweeners: {\n            \"*\": [\n                function(prop, value) {\n                    var tween = this.createTween(prop, value);\n                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n                    return tween;\n                }\n            ]\n        },\n        tweener: function(props, callback) {\n            if (isFunction(props)) {\n                callback = props;\n                props = [\n                    \"*\"\n                ];\n            } else {\n                props = props.match(rnothtmlwhite);\n            }\n            var prop, index = 0, length = props.length;\n            for(; index < length; index++){\n                prop = props[index];\n                Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n                Animation.tweeners[prop].unshift(callback);\n            }\n        },\n        prefilters: [\n            defaultPrefilter\n        ],\n        prefilter: function(callback, prepend) {\n            if (prepend) {\n                Animation.prefilters.unshift(callback);\n            } else {\n                Animation.prefilters.push(callback);\n            }\n        }\n    });\n    jQuery.speed = function(speed, easing, fn) {\n        var opt = speed && typeof speed === \"object\" ? jQuery.extend({}, speed) : {\n            complete: fn || !fn && easing || isFunction(speed) && speed,\n            duration: speed,\n            easing: fn && easing || easing && !isFunction(easing) && easing\n        };\n        // Go to the end state if fx are off\n        if (jQuery.fx.off) {\n            opt.duration = 0;\n        } else {\n            if (typeof opt.duration !== \"number\") {\n                if (opt.duration in jQuery.fx.speeds) {\n                    opt.duration = jQuery.fx.speeds[opt.duration];\n                } else {\n                    opt.duration = jQuery.fx.speeds._default;\n                }\n            }\n        }\n        // Normalize opt.queue - true/undefined/null -> \"fx\"\n        if (opt.queue == null || opt.queue === true) {\n            opt.queue = \"fx\";\n        }\n        // Queueing\n        opt.old = opt.complete;\n        opt.complete = function() {\n            if (isFunction(opt.old)) {\n                opt.old.call(this);\n            }\n            if (opt.queue) {\n                jQuery.dequeue(this, opt.queue);\n            }\n        };\n        return opt;\n    };\n    jQuery.fn.extend({\n        fadeTo: function(speed, to, easing, callback) {\n            // Show any hidden elements after setting opacity to 0\n            return this.filter(isHiddenWithinTree).css(\"opacity\", 0).show()// Animate to the value specified\n            .end().animate({\n                opacity: to\n            }, speed, easing, callback);\n        },\n        animate: function(prop, speed, easing, callback) {\n            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {\n                // Operate on a copy of prop so per-property easing won't be lost\n                var anim = Animation(this, jQuery.extend({}, prop), optall);\n                // Empty animations, or finishing resolves immediately\n                if (empty || dataPriv.get(this, \"finish\")) {\n                    anim.stop(true);\n                }\n            };\n            doAnimation.finish = doAnimation;\n            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n        },\n        stop: function(type, clearQueue, gotoEnd) {\n            var stopQueue = function(hooks) {\n                var stop = hooks.stop;\n                delete hooks.stop;\n                stop(gotoEnd);\n            };\n            if (typeof type !== \"string\") {\n                gotoEnd = clearQueue;\n                clearQueue = type;\n                type = undefined;\n            }\n            if (clearQueue) {\n                this.queue(type || \"fx\", []);\n            }\n            return this.each(function() {\n                var dequeue = true, index = type != null && type + \"queueHooks\", timers = jQuery.timers, data = dataPriv.get(this);\n                if (index) {\n                    if (data[index] && data[index].stop) {\n                        stopQueue(data[index]);\n                    }\n                } else {\n                    for(index in data){\n                        if (data[index] && data[index].stop && rrun.test(index)) {\n                            stopQueue(data[index]);\n                        }\n                    }\n                }\n                for(index = timers.length; index--;){\n                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n                        timers[index].anim.stop(gotoEnd);\n                        dequeue = false;\n                        timers.splice(index, 1);\n                    }\n                }\n                // Start the next in the queue if the last step wasn't forced.\n                // Timers currently will call their complete callbacks, which\n                // will dequeue but only if they were gotoEnd.\n                if (dequeue || !gotoEnd) {\n                    jQuery.dequeue(this, type);\n                }\n            });\n        },\n        finish: function(type) {\n            if (type !== false) {\n                type = type || \"fx\";\n            }\n            return this.each(function() {\n                var index, data = dataPriv.get(this), queue = data[type + \"queue\"], hooks = data[type + \"queueHooks\"], timers = jQuery.timers, length = queue ? queue.length : 0;\n                // Enable finishing flag on private data\n                data.finish = true;\n                // Empty the queue first\n                jQuery.queue(this, type, []);\n                if (hooks && hooks.stop) {\n                    hooks.stop.call(this, true);\n                }\n                // Look for any active animations, and finish them\n                for(index = timers.length; index--;){\n                    if (timers[index].elem === this && timers[index].queue === type) {\n                        timers[index].anim.stop(true);\n                        timers.splice(index, 1);\n                    }\n                }\n                // Look for any animations in the old queue and finish them\n                for(index = 0; index < length; index++){\n                    if (queue[index] && queue[index].finish) {\n                        queue[index].finish.call(this);\n                    }\n                }\n                // Turn off finishing flag\n                delete data.finish;\n            });\n        }\n    });\n    jQuery.each([\n        \"toggle\",\n        \"show\",\n        \"hide\"\n    ], function(_i, name) {\n        var cssFn = jQuery.fn[name];\n        jQuery.fn[name] = function(speed, easing, callback) {\n            return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n        };\n    });\n    // Generate shortcuts for custom animations\n    jQuery.each({\n        slideDown: genFx(\"show\"),\n        slideUp: genFx(\"hide\"),\n        slideToggle: genFx(\"toggle\"),\n        fadeIn: {\n            opacity: \"show\"\n        },\n        fadeOut: {\n            opacity: \"hide\"\n        },\n        fadeToggle: {\n            opacity: \"toggle\"\n        }\n    }, function(name, props) {\n        jQuery.fn[name] = function(speed, easing, callback) {\n            return this.animate(props, speed, easing, callback);\n        };\n    });\n    jQuery.timers = [];\n    jQuery.fx.tick = function() {\n        var timer, i = 0, timers = jQuery.timers;\n        fxNow = Date.now();\n        for(; i < timers.length; i++){\n            timer = timers[i];\n            // Run the timer and safely remove it when done (allowing for external removal)\n            if (!timer() && timers[i] === timer) {\n                timers.splice(i--, 1);\n            }\n        }\n        if (!timers.length) {\n            jQuery.fx.stop();\n        }\n        fxNow = undefined;\n    };\n    jQuery.fx.timer = function(timer) {\n        jQuery.timers.push(timer);\n        jQuery.fx.start();\n    };\n    jQuery.fx.interval = 13;\n    jQuery.fx.start = function() {\n        if (inProgress) {\n            return;\n        }\n        inProgress = true;\n        schedule();\n    };\n    jQuery.fx.stop = function() {\n        inProgress = null;\n    };\n    jQuery.fx.speeds = {\n        slow: 600,\n        fast: 200,\n        // Default speed\n        _default: 400\n    };\n    // Based off of the plugin by Clint Helfers, with permission.\n    jQuery.fn.delay = function(time, type) {\n        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n        type = type || \"fx\";\n        return this.queue(type, function(next, hooks) {\n            var timeout = window1.setTimeout(next, time);\n            hooks.stop = function() {\n                window1.clearTimeout(timeout);\n            };\n        });\n    };\n    (function() {\n        var input = document.createElement(\"input\"), select = document.createElement(\"select\"), opt = select.appendChild(document.createElement(\"option\"));\n        input.type = \"checkbox\";\n        // Support: Android <=4.3 only\n        // Default value for a checkbox should be \"on\"\n        support.checkOn = input.value !== \"\";\n        // Support: IE <=11 only\n        // Must access selectedIndex to make default options select\n        support.optSelected = opt.selected;\n        // Support: IE <=11 only\n        // An input loses its value after becoming a radio\n        input = document.createElement(\"input\");\n        input.value = \"t\";\n        input.type = \"radio\";\n        support.radioValue = input.value === \"t\";\n    })();\n    var boolHook, attrHandle = jQuery.expr.attrHandle;\n    jQuery.fn.extend({\n        attr: function(name, value) {\n            return access(this, jQuery.attr, name, value, arguments.length > 1);\n        },\n        removeAttr: function(name) {\n            return this.each(function() {\n                jQuery.removeAttr(this, name);\n            });\n        }\n    });\n    jQuery.extend({\n        attr: function(elem, name, value) {\n            var ret, hooks, nType = elem.nodeType;\n            // Don't get/set attributes on text, comment and attribute nodes\n            if (nType === 3 || nType === 8 || nType === 2) {\n                return;\n            }\n            // Fallback to prop when attributes are not supported\n            if (typeof elem.getAttribute === \"undefined\") {\n                return jQuery.prop(elem, name, value);\n            }\n            // Attribute hooks are determined by the lowercase version\n            // Grab necessary hook if one is defined\n            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n                hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n            }\n            if (value !== undefined) {\n                if (value === null) {\n                    jQuery.removeAttr(elem, name);\n                    return;\n                }\n                if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n                    return ret;\n                }\n                elem.setAttribute(name, value + \"\");\n                return value;\n            }\n            if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n                return ret;\n            }\n            ret = jQuery.find.attr(elem, name);\n            // Non-existent attributes return null, we normalize to undefined\n            return ret == null ? undefined : ret;\n        },\n        attrHooks: {\n            type: {\n                set: function(elem, value) {\n                    if (!support.radioValue && value === \"radio\" && nodeName(elem, \"input\")) {\n                        var val = elem.value;\n                        elem.setAttribute(\"type\", value);\n                        if (val) {\n                            elem.value = val;\n                        }\n                        return value;\n                    }\n                }\n            }\n        },\n        removeAttr: function(elem, value) {\n            var name, i = 0, // Attribute names can contain non-HTML whitespace characters\n            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n            attrNames = value && value.match(rnothtmlwhite);\n            if (attrNames && elem.nodeType === 1) {\n                while(name = attrNames[i++]){\n                    elem.removeAttribute(name);\n                }\n            }\n        }\n    });\n    // Hooks for boolean attributes\n    boolHook = {\n        set: function(elem, value, name) {\n            if (value === false) {\n                // Remove boolean attributes when set to false\n                jQuery.removeAttr(elem, name);\n            } else {\n                elem.setAttribute(name, name);\n            }\n            return name;\n        }\n    };\n    jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function(_i, name) {\n        var getter = attrHandle[name] || jQuery.find.attr;\n        attrHandle[name] = function(elem, name, isXML) {\n            var ret, handle, lowercaseName = name.toLowerCase();\n            if (!isXML) {\n                // Avoid an infinite loop by temporarily removing this function from the getter\n                handle = attrHandle[lowercaseName];\n                attrHandle[lowercaseName] = ret;\n                ret = getter(elem, name, isXML) != null ? lowercaseName : null;\n                attrHandle[lowercaseName] = handle;\n            }\n            return ret;\n        };\n    });\n    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;\n    jQuery.fn.extend({\n        prop: function(name, value) {\n            return access(this, jQuery.prop, name, value, arguments.length > 1);\n        },\n        removeProp: function(name) {\n            return this.each(function() {\n                delete this[jQuery.propFix[name] || name];\n            });\n        }\n    });\n    jQuery.extend({\n        prop: function(elem, name, value) {\n            var ret, hooks, nType = elem.nodeType;\n            // Don't get/set properties on text, comment and attribute nodes\n            if (nType === 3 || nType === 8 || nType === 2) {\n                return;\n            }\n            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n                // Fix name and attach hooks\n                name = jQuery.propFix[name] || name;\n                hooks = jQuery.propHooks[name];\n            }\n            if (value !== undefined) {\n                if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n                    return ret;\n                }\n                return elem[name] = value;\n            }\n            if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n                return ret;\n            }\n            return elem[name];\n        },\n        propHooks: {\n            tabIndex: {\n                get: function(elem) {\n                    // Support: IE <=9 - 11 only\n                    // elem.tabIndex doesn't always return the\n                    // correct value when it hasn't been explicitly set\n                    // Use proper attribute retrieval (trac-12072)\n                    var tabindex = jQuery.find.attr(elem, \"tabindex\");\n                    if (tabindex) {\n                        return parseInt(tabindex, 10);\n                    }\n                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n                        return 0;\n                    }\n                    return -1;\n                }\n            }\n        },\n        propFix: {\n            \"for\": \"htmlFor\",\n            \"class\": \"className\"\n        }\n    });\n    // Support: IE <=11 only\n    // Accessing the selectedIndex property\n    // forces the browser to respect setting selected\n    // on the option\n    // The getter ensures a default option is selected\n    // when in an optgroup\n    // eslint rule \"no-unused-expressions\" is disabled for this code\n    // since it considers such accessions noop\n    if (!support.optSelected) {\n        jQuery.propHooks.selected = {\n            get: function(elem) {\n                /* eslint no-unused-expressions: \"off\" */ var parent = elem.parentNode;\n                if (parent && parent.parentNode) {\n                    parent.parentNode.selectedIndex;\n                }\n                return null;\n            },\n            set: function(elem) {\n                /* eslint no-unused-expressions: \"off\" */ var parent = elem.parentNode;\n                if (parent) {\n                    parent.selectedIndex;\n                    if (parent.parentNode) {\n                        parent.parentNode.selectedIndex;\n                    }\n                }\n            }\n        };\n    }\n    jQuery.each([\n        \"tabIndex\",\n        \"readOnly\",\n        \"maxLength\",\n        \"cellSpacing\",\n        \"cellPadding\",\n        \"rowSpan\",\n        \"colSpan\",\n        \"useMap\",\n        \"frameBorder\",\n        \"contentEditable\"\n    ], function() {\n        jQuery.propFix[this.toLowerCase()] = this;\n    });\n    // Strip and collapse whitespace according to HTML spec\n    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n    function stripAndCollapse(value) {\n        var tokens = value.match(rnothtmlwhite) || [];\n        return tokens.join(\" \");\n    }\n    function getClass(elem) {\n        return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n    }\n    function classesToArray(value) {\n        if (Array.isArray(value)) {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            return value.match(rnothtmlwhite) || [];\n        }\n        return [];\n    }\n    jQuery.fn.extend({\n        addClass: function(value) {\n            var classNames, cur, curValue, className, i, finalValue;\n            if (isFunction(value)) {\n                return this.each(function(j) {\n                    jQuery(this).addClass(value.call(this, j, getClass(this)));\n                });\n            }\n            classNames = classesToArray(value);\n            if (classNames.length) {\n                return this.each(function() {\n                    curValue = getClass(this);\n                    cur = this.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n                    if (cur) {\n                        for(i = 0; i < classNames.length; i++){\n                            className = classNames[i];\n                            if (cur.indexOf(\" \" + className + \" \") < 0) {\n                                cur += className + \" \";\n                            }\n                        }\n                        // Only assign if different to avoid unneeded rendering.\n                        finalValue = stripAndCollapse(cur);\n                        if (curValue !== finalValue) {\n                            this.setAttribute(\"class\", finalValue);\n                        }\n                    }\n                });\n            }\n            return this;\n        },\n        removeClass: function(value) {\n            var classNames, cur, curValue, className, i, finalValue;\n            if (isFunction(value)) {\n                return this.each(function(j) {\n                    jQuery(this).removeClass(value.call(this, j, getClass(this)));\n                });\n            }\n            if (!arguments.length) {\n                return this.attr(\"class\", \"\");\n            }\n            classNames = classesToArray(value);\n            if (classNames.length) {\n                return this.each(function() {\n                    curValue = getClass(this);\n                    // This expression is here for better compressibility (see addClass)\n                    cur = this.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n                    if (cur) {\n                        for(i = 0; i < classNames.length; i++){\n                            className = classNames[i];\n                            // Remove *all* instances\n                            while(cur.indexOf(\" \" + className + \" \") > -1){\n                                cur = cur.replace(\" \" + className + \" \", \" \");\n                            }\n                        }\n                        // Only assign if different to avoid unneeded rendering.\n                        finalValue = stripAndCollapse(cur);\n                        if (curValue !== finalValue) {\n                            this.setAttribute(\"class\", finalValue);\n                        }\n                    }\n                });\n            }\n            return this;\n        },\n        toggleClass: function(value, stateVal) {\n            var classNames, className, i, self, type = typeof value, isValidValue = type === \"string\" || Array.isArray(value);\n            if (isFunction(value)) {\n                return this.each(function(i) {\n                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n                });\n            }\n            if (typeof stateVal === \"boolean\" && isValidValue) {\n                return stateVal ? this.addClass(value) : this.removeClass(value);\n            }\n            classNames = classesToArray(value);\n            return this.each(function() {\n                if (isValidValue) {\n                    // Toggle individual class names\n                    self = jQuery(this);\n                    for(i = 0; i < classNames.length; i++){\n                        className = classNames[i];\n                        // Check each className given, space separated list\n                        if (self.hasClass(className)) {\n                            self.removeClass(className);\n                        } else {\n                            self.addClass(className);\n                        }\n                    }\n                // Toggle whole class name\n                } else if (value === undefined || type === \"boolean\") {\n                    className = getClass(this);\n                    if (className) {\n                        // Store className if set\n                        dataPriv.set(this, \"__className__\", className);\n                    }\n                    // If the element has a class name or if we're passed `false`,\n                    // then remove the whole classname (if there was one, the above saved it).\n                    // Otherwise bring back whatever was previously saved (if anything),\n                    // falling back to the empty string if nothing was stored.\n                    if (this.setAttribute) {\n                        this.setAttribute(\"class\", className || value === false ? \"\" : dataPriv.get(this, \"__className__\") || \"\");\n                    }\n                }\n            });\n        },\n        hasClass: function(selector) {\n            var className, elem, i = 0;\n            className = \" \" + selector + \" \";\n            while(elem = this[i++]){\n                if (elem.nodeType === 1 && (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    });\n    var rreturn = /\\r/g;\n    jQuery.fn.extend({\n        val: function(value) {\n            var hooks, ret, valueIsFunction, elem = this[0];\n            if (!arguments.length) {\n                if (elem) {\n                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n                    if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n                        return ret;\n                    }\n                    ret = elem.value;\n                    // Handle most common string cases\n                    if (typeof ret === \"string\") {\n                        return ret.replace(rreturn, \"\");\n                    }\n                    // Handle cases where value is null/undef or number\n                    return ret == null ? \"\" : ret;\n                }\n                return;\n            }\n            valueIsFunction = isFunction(value);\n            return this.each(function(i) {\n                var val;\n                if (this.nodeType !== 1) {\n                    return;\n                }\n                if (valueIsFunction) {\n                    val = value.call(this, i, jQuery(this).val());\n                } else {\n                    val = value;\n                }\n                // Treat null/undefined as \"\"; convert numbers to string\n                if (val == null) {\n                    val = \"\";\n                } else if (typeof val === \"number\") {\n                    val += \"\";\n                } else if (Array.isArray(val)) {\n                    val = jQuery.map(val, function(value) {\n                        return value == null ? \"\" : value + \"\";\n                    });\n                }\n                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\n                // If set returns undefined, fall back to normal setting\n                if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n                    this.value = val;\n                }\n            });\n        }\n    });\n    jQuery.extend({\n        valHooks: {\n            option: {\n                get: function(elem) {\n                    var val = jQuery.find.attr(elem, \"value\");\n                    return val != null ? val : // Support: IE <=10 - 11 only\n                    // option.text throws exceptions (trac-14686, trac-14858)\n                    // Strip and collapse whitespace\n                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n                    stripAndCollapse(jQuery.text(elem));\n                }\n            },\n            select: {\n                get: function(elem) {\n                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === \"select-one\", values = one ? null : [], max = one ? index + 1 : options.length;\n                    if (index < 0) {\n                        i = max;\n                    } else {\n                        i = one ? index : 0;\n                    }\n                    // Loop through all the selected options\n                    for(; i < max; i++){\n                        option = options[i];\n                        // Support: IE <=9 only\n                        // IE8-9 doesn't update selected after form reset (trac-2551)\n                        if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup\n                        !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, \"optgroup\"))) {\n                            // Get the specific value for the option\n                            value = jQuery(option).val();\n                            // We don't need an array for one selects\n                            if (one) {\n                                return value;\n                            }\n                            // Multi-Selects return an array\n                            values.push(value);\n                        }\n                    }\n                    return values;\n                },\n                set: function(elem, value) {\n                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;\n                    while(i--){\n                        option = options[i];\n                        /* eslint-disable no-cond-assign */ if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n                            optionSet = true;\n                        }\n                    /* eslint-enable no-cond-assign */ }\n                    // Force browsers to behave consistently when non-matching value is set\n                    if (!optionSet) {\n                        elem.selectedIndex = -1;\n                    }\n                    return values;\n                }\n            }\n        }\n    });\n    // Radios and checkboxes getter/setter\n    jQuery.each([\n        \"radio\",\n        \"checkbox\"\n    ], function() {\n        jQuery.valHooks[this] = {\n            set: function(elem, value) {\n                if (Array.isArray(value)) {\n                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n                }\n            }\n        };\n        if (!support.checkOn) {\n            jQuery.valHooks[this].get = function(elem) {\n                return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n            };\n        }\n    });\n    // Return jQuery for attributes-only inclusion\n    var location = window1.location;\n    var nonce = {\n        guid: Date.now()\n    };\n    var rquery = /\\?/;\n    // Cross-browser xml parsing\n    jQuery.parseXML = function(data) {\n        var xml, parserErrorElem;\n        if (!data || typeof data !== \"string\") {\n            return null;\n        }\n        // Support: IE 9 - 11 only\n        // IE throws on parseFromString with invalid input.\n        try {\n            xml = new window1.DOMParser().parseFromString(data, \"text/xml\");\n        } catch (e) {}\n        parserErrorElem = xml && xml.getElementsByTagName(\"parsererror\")[0];\n        if (!xml || parserErrorElem) {\n            jQuery.error(\"Invalid XML: \" + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {\n                return el.textContent;\n            }).join(\"\\n\") : data));\n        }\n        return xml;\n    };\n    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {\n        e.stopPropagation();\n    };\n    jQuery.extend(jQuery.event, {\n        trigger: function(event, data, elem, onlyHandlers) {\n            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [\n                elem || document\n            ], type = hasOwn.call(event, \"type\") ? event.type : event, namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n            cur = lastElement = tmp = elem = elem || document;\n            // Don't do events on text and comment nodes\n            if (elem.nodeType === 3 || elem.nodeType === 8) {\n                return;\n            }\n            // focus/blur morphs to focusin/out; ensure we're not firing them right now\n            if (rfocusMorph.test(type + jQuery.event.triggered)) {\n                return;\n            }\n            if (type.indexOf(\".\") > -1) {\n                // Namespaced trigger; create a regexp to match event type in handle()\n                namespaces = type.split(\".\");\n                type = namespaces.shift();\n                namespaces.sort();\n            }\n            ontype = type.indexOf(\":\") < 0 && \"on\" + type;\n            // Caller can pass in a jQuery.Event object, Object, or just an event type string\n            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === \"object\" && event);\n            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n            event.isTrigger = onlyHandlers ? 2 : 3;\n            event.namespace = namespaces.join(\".\");\n            event.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null;\n            // Clean up the event in case it is being reused\n            event.result = undefined;\n            if (!event.target) {\n                event.target = elem;\n            }\n            // Clone any incoming data and prepend the event, creating the handler arg list\n            data = data == null ? [\n                event\n            ] : jQuery.makeArray(data, [\n                event\n            ]);\n            // Allow special events to draw outside the lines\n            special = jQuery.event.special[type] || {};\n            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n                return;\n            }\n            // Determine event propagation path in advance, per W3C events spec (trac-9951)\n            // Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)\n            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\n                bubbleType = special.delegateType || type;\n                if (!rfocusMorph.test(bubbleType + type)) {\n                    cur = cur.parentNode;\n                }\n                for(; cur; cur = cur.parentNode){\n                    eventPath.push(cur);\n                    tmp = cur;\n                }\n                // Only add window if we got to document (e.g., not plain obj or detached DOM)\n                if (tmp === (elem.ownerDocument || document)) {\n                    eventPath.push(tmp.defaultView || tmp.parentWindow || window1);\n                }\n            }\n            // Fire handlers on the event path\n            i = 0;\n            while((cur = eventPath[i++]) && !event.isPropagationStopped()){\n                lastElement = cur;\n                event.type = i > 1 ? bubbleType : special.bindType || type;\n                // jQuery handler\n                handle = (dataPriv.get(cur, \"events\") || Object.create(null))[event.type] && dataPriv.get(cur, \"handle\");\n                if (handle) {\n                    handle.apply(cur, data);\n                }\n                // Native handler\n                handle = ontype && cur[ontype];\n                if (handle && handle.apply && acceptData(cur)) {\n                    event.result = handle.apply(cur, data);\n                    if (event.result === false) {\n                        event.preventDefault();\n                    }\n                }\n            }\n            event.type = type;\n            // If nobody prevented the default action, do it now\n            if (!onlyHandlers && !event.isDefaultPrevented()) {\n                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n                    // Call a native DOM method on the target with the same name as the event.\n                    // Don't do default actions on window, that's where global variables be (trac-6170)\n                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {\n                        // Don't re-trigger an onFOO event when we call its FOO() method\n                        tmp = elem[ontype];\n                        if (tmp) {\n                            elem[ontype] = null;\n                        }\n                        // Prevent re-triggering of the same event, since we already bubbled it above\n                        jQuery.event.triggered = type;\n                        if (event.isPropagationStopped()) {\n                            lastElement.addEventListener(type, stopPropagationCallback);\n                        }\n                        elem[type]();\n                        if (event.isPropagationStopped()) {\n                            lastElement.removeEventListener(type, stopPropagationCallback);\n                        }\n                        jQuery.event.triggered = undefined;\n                        if (tmp) {\n                            elem[ontype] = tmp;\n                        }\n                    }\n                }\n            }\n            return event.result;\n        },\n        // Piggyback on a donor event to simulate a different one\n        // Used only for `focus(in | out)` events\n        simulate: function(type, elem, event) {\n            var e = jQuery.extend(new jQuery.Event(), event, {\n                type: type,\n                isSimulated: true\n            });\n            jQuery.event.trigger(e, null, elem);\n        }\n    });\n    jQuery.fn.extend({\n        trigger: function(type, data) {\n            return this.each(function() {\n                jQuery.event.trigger(type, data, this);\n            });\n        },\n        triggerHandler: function(type, data) {\n            var elem = this[0];\n            if (elem) {\n                return jQuery.event.trigger(type, data, elem, true);\n            }\n        }\n    });\n    var rbracket = /\\[\\]$/, rCRLF = /\\r?\\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;\n    function buildParams(prefix, obj, traditional, add) {\n        var name;\n        if (Array.isArray(obj)) {\n            // Serialize array item.\n            jQuery.each(obj, function(i, v) {\n                if (traditional || rbracket.test(prefix)) {\n                    // Treat each array item as a scalar.\n                    add(prefix, v);\n                } else {\n                    // Item is non-scalar (array or object), encode its numeric index.\n                    buildParams(prefix + \"[\" + (typeof v === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n                }\n            });\n        } else if (!traditional && toType(obj) === \"object\") {\n            // Serialize object item.\n            for(name in obj){\n                buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n            }\n        } else {\n            // Serialize scalar item.\n            add(prefix, obj);\n        }\n    }\n    // Serialize an array of form elements or a set of\n    // key/values into a query string\n    jQuery.param = function(a, traditional) {\n        var prefix, s = [], add = function(key, valueOrFunction) {\n            // If value is a function, invoke it and use its return value\n            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n            s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value == null ? \"\" : value);\n        };\n        if (a == null) {\n            return \"\";\n        }\n        // If an array was passed in, assume that it is an array of form elements.\n        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n            // Serialize the form elements\n            jQuery.each(a, function() {\n                add(this.name, this.value);\n            });\n        } else {\n            // If traditional, encode the \"old\" way (the way 1.3.2 or older\n            // did it), otherwise encode params recursively.\n            for(prefix in a){\n                buildParams(prefix, a[prefix], traditional, add);\n            }\n        }\n        // Return the resulting serialization\n        return s.join(\"&\");\n    };\n    jQuery.fn.extend({\n        serialize: function() {\n            return jQuery.param(this.serializeArray());\n        },\n        serializeArray: function() {\n            return this.map(function() {\n                // Can add propHook for \"elements\" to filter or add form elements\n                var elements = jQuery.prop(this, \"elements\");\n                return elements ? jQuery.makeArray(elements) : this;\n            }).filter(function() {\n                var type = this.type;\n                // Use .is( \":disabled\" ) so that fieldset[disabled] works\n                return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n            }).map(function(_i, elem) {\n                var val = jQuery(this).val();\n                if (val == null) {\n                    return null;\n                }\n                if (Array.isArray(val)) {\n                    return jQuery.map(val, function(val) {\n                        return {\n                            name: elem.name,\n                            value: val.replace(rCRLF, \"\\r\\n\")\n                        };\n                    });\n                }\n                return {\n                    name: elem.name,\n                    value: val.replace(rCRLF, \"\\r\\n\")\n                };\n            }).get();\n        }\n    });\n    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg, // trac-7653, trac-8125, trac-8152: local protocol detection\n    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\\/\\//, /* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */ prefilters = {}, /* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */ transports = {}, // Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression\n    allTypes = \"*/\".concat(\"*\"), // Anchor tag for parsing the document origin\n    originAnchor = document.createElement(\"a\");\n    originAnchor.href = location.href;\n    // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n    function addToPrefiltersOrTransports(structure) {\n        // dataTypeExpression is optional and defaults to \"*\"\n        return function(dataTypeExpression, func) {\n            if (typeof dataTypeExpression !== \"string\") {\n                func = dataTypeExpression;\n                dataTypeExpression = \"*\";\n            }\n            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n            if (isFunction(func)) {\n                // For each dataType in the dataTypeExpression\n                while(dataType = dataTypes[i++]){\n                    // Prepend if requested\n                    if (dataType[0] === \"+\") {\n                        dataType = dataType.slice(1) || \"*\";\n                        (structure[dataType] = structure[dataType] || []).unshift(func);\n                    // Otherwise append\n                    } else {\n                        (structure[dataType] = structure[dataType] || []).push(func);\n                    }\n                }\n            }\n        };\n    }\n    // Base inspection function for prefilters and transports\n    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n        var inspected = {}, seekingTransport = structure === transports;\n        function inspect(dataType) {\n            var selected;\n            inspected[dataType] = true;\n            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {\n                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n                if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n                    options.dataTypes.unshift(dataTypeOrTransport);\n                    inspect(dataTypeOrTransport);\n                    return false;\n                } else if (seekingTransport) {\n                    return !(selected = dataTypeOrTransport);\n                }\n            });\n            return selected;\n        }\n        return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n    }\n    // A special extend for ajax options\n    // that takes \"flat\" options (not to be deep extended)\n    // Fixes trac-9887\n    function ajaxExtend(target, src) {\n        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};\n        for(key in src){\n            if (src[key] !== undefined) {\n                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n            }\n        }\n        if (deep) {\n            jQuery.extend(true, target, deep);\n        }\n        return target;\n    }\n    /* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */ function ajaxHandleResponses(s, jqXHR, responses) {\n        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;\n        // Remove auto dataType and get content-type in the process\n        while(dataTypes[0] === \"*\"){\n            dataTypes.shift();\n            if (ct === undefined) {\n                ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n            }\n        }\n        // Check if we're dealing with a known content-type\n        if (ct) {\n            for(type in contents){\n                if (contents[type] && contents[type].test(ct)) {\n                    dataTypes.unshift(type);\n                    break;\n                }\n            }\n        }\n        // Check to see if we have a response for the expected dataType\n        if (dataTypes[0] in responses) {\n            finalDataType = dataTypes[0];\n        } else {\n            // Try convertible dataTypes\n            for(type in responses){\n                if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n                    finalDataType = type;\n                    break;\n                }\n                if (!firstDataType) {\n                    firstDataType = type;\n                }\n            }\n            // Or just use first one\n            finalDataType = finalDataType || firstDataType;\n        }\n        // If we found a dataType\n        // We add the dataType to the list if needed\n        // and return the corresponding response\n        if (finalDataType) {\n            if (finalDataType !== dataTypes[0]) {\n                dataTypes.unshift(finalDataType);\n            }\n            return responses[finalDataType];\n        }\n    }\n    /* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */ function ajaxConvert(s, response, jqXHR, isSuccess) {\n        var conv2, current, conv, tmp, prev, converters = {}, // Work with a copy of dataTypes in case we need to modify it for conversion\n        dataTypes = s.dataTypes.slice();\n        // Create converters map with lowercased keys\n        if (dataTypes[1]) {\n            for(conv in s.converters){\n                converters[conv.toLowerCase()] = s.converters[conv];\n            }\n        }\n        current = dataTypes.shift();\n        // Convert to each sequential dataType\n        while(current){\n            if (s.responseFields[current]) {\n                jqXHR[s.responseFields[current]] = response;\n            }\n            // Apply the dataFilter if provided\n            if (!prev && isSuccess && s.dataFilter) {\n                response = s.dataFilter(response, s.dataType);\n            }\n            prev = current;\n            current = dataTypes.shift();\n            if (current) {\n                // There's only work to do if current dataType is non-auto\n                if (current === \"*\") {\n                    current = prev;\n                // Convert response if prev dataType is non-auto and differs from current\n                } else if (prev !== \"*\" && prev !== current) {\n                    // Seek a direct converter\n                    conv = converters[prev + \" \" + current] || converters[\"* \" + current];\n                    // If none found, seek a pair\n                    if (!conv) {\n                        for(conv2 in converters){\n                            // If conv2 outputs current\n                            tmp = conv2.split(\" \");\n                            if (tmp[1] === current) {\n                                // If prev can be converted to accepted input\n                                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n                                if (conv) {\n                                    // Condense equivalence converters\n                                    if (conv === true) {\n                                        conv = converters[conv2];\n                                    // Otherwise, insert the intermediate dataType\n                                    } else if (converters[conv2] !== true) {\n                                        current = tmp[0];\n                                        dataTypes.unshift(tmp[1]);\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // Apply converter (if not an equivalence)\n                    if (conv !== true) {\n                        // Unless errors are allowed to bubble, catch and return them\n                        if (conv && s.throws) {\n                            response = conv(response);\n                        } else {\n                            try {\n                                response = conv(response);\n                            } catch (e) {\n                                return {\n                                    state: \"parsererror\",\n                                    error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                                };\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return {\n            state: \"success\",\n            data: response\n        };\n    }\n    jQuery.extend({\n        // Counter for holding the number of active queries\n        active: 0,\n        // Last-Modified header cache for next request\n        lastModified: {},\n        etag: {},\n        ajaxSettings: {\n            url: location.href,\n            type: \"GET\",\n            isLocal: rlocalProtocol.test(location.protocol),\n            global: true,\n            processData: true,\n            async: true,\n            contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n            /*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/ accepts: {\n                \"*\": allTypes,\n                text: \"text/plain\",\n                html: \"text/html\",\n                xml: \"application/xml, text/xml\",\n                json: \"application/json, text/javascript\"\n            },\n            contents: {\n                xml: /\\bxml\\b/,\n                html: /\\bhtml/,\n                json: /\\bjson\\b/\n            },\n            responseFields: {\n                xml: \"responseXML\",\n                text: \"responseText\",\n                json: \"responseJSON\"\n            },\n            // Data converters\n            // Keys separate source (or catchall \"*\") and destination types with a single space\n            converters: {\n                // Convert anything to text\n                \"* text\": String,\n                // Text to html (true = no transformation)\n                \"text html\": true,\n                // Evaluate text as a json expression\n                \"text json\": JSON.parse,\n                // Parse text as xml\n                \"text xml\": jQuery.parseXML\n            },\n            // For options that shouldn't be deep extended:\n            // you can add your own custom options here if\n            // and when you create one that shouldn't be\n            // deep extended (see ajaxExtend)\n            flatOptions: {\n                url: true,\n                context: true\n            }\n        },\n        // Creates a full fledged settings object into target\n        // with both ajaxSettings and settings fields.\n        // If target is omitted, writes into ajaxSettings.\n        ajaxSetup: function(target, settings) {\n            return settings ? // Building a settings object\n            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n            ajaxExtend(jQuery.ajaxSettings, target);\n        },\n        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n        ajaxTransport: addToPrefiltersOrTransports(transports),\n        // Main method\n        ajax: function(url, options) {\n            // If url is an object, simulate pre-1.5 signature\n            if (typeof url === \"object\") {\n                options = url;\n                url = undefined;\n            }\n            // Force options to be an object\n            options = options || {};\n            var transport, // URL without anti-cache param\n            cacheURL, // Response headers\n            responseHeadersString, responseHeaders, // timeout handle\n            timeoutTimer, // Url cleanup var\n            urlAnchor, // Request state (becomes false upon send and true upon completion)\n            completed, // To know if global events are to be dispatched\n            fireGlobals, // Loop variable\n            i, // uncached part of the url\n            uncached, // Create the final options object\n            s = jQuery.ajaxSetup({}, options), // Callbacks context\n            callbackContext = s.context || s, // Context for global events is callbackContext if it is a DOM node or jQuery collection\n            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, // Deferreds\n            deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks(\"once memory\"), // Status-dependent callbacks\n            statusCode = s.statusCode || {}, // Headers (they are sent all at once)\n            requestHeaders = {}, requestHeadersNames = {}, // Default abort message\n            strAbort = \"canceled\", // Fake xhr\n            jqXHR = {\n                readyState: 0,\n                // Builds headers hashtable if needed\n                getResponseHeader: function(key) {\n                    var match;\n                    if (completed) {\n                        if (!responseHeaders) {\n                            responseHeaders = {};\n                            while(match = rheaders.exec(responseHeadersString)){\n                                responseHeaders[match[1].toLowerCase() + \" \"] = (responseHeaders[match[1].toLowerCase() + \" \"] || []).concat(match[2]);\n                            }\n                        }\n                        match = responseHeaders[key.toLowerCase() + \" \"];\n                    }\n                    return match == null ? null : match.join(\", \");\n                },\n                // Raw string\n                getAllResponseHeaders: function() {\n                    return completed ? responseHeadersString : null;\n                },\n                // Caches the header\n                setRequestHeader: function(name, value) {\n                    if (completed == null) {\n                        name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n                        requestHeaders[name] = value;\n                    }\n                    return this;\n                },\n                // Overrides response content-type header\n                overrideMimeType: function(type) {\n                    if (completed == null) {\n                        s.mimeType = type;\n                    }\n                    return this;\n                },\n                // Status-dependent callbacks\n                statusCode: function(map) {\n                    var code;\n                    if (map) {\n                        if (completed) {\n                            // Execute the appropriate callbacks\n                            jqXHR.always(map[jqXHR.status]);\n                        } else {\n                            // Lazy-add the new callbacks in a way that preserves old ones\n                            for(code in map){\n                                statusCode[code] = [\n                                    statusCode[code],\n                                    map[code]\n                                ];\n                            }\n                        }\n                    }\n                    return this;\n                },\n                // Cancel the request\n                abort: function(statusText) {\n                    var finalText = statusText || strAbort;\n                    if (transport) {\n                        transport.abort(finalText);\n                    }\n                    done(0, finalText);\n                    return this;\n                }\n            };\n            // Attach deferreds\n            deferred.promise(jqXHR);\n            // Add protocol if not provided (prefilters might expect it)\n            // Handle falsy url in the settings object (trac-10093: consistency with old signature)\n            // We also use the url parameter if available\n            s.url = ((url || s.url || location.href) + \"\").replace(rprotocol, location.protocol + \"//\");\n            // Alias method option to type as per ticket trac-12004\n            s.type = options.method || options.type || s.method || s.type;\n            // Extract dataTypes list\n            s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\n                \"\"\n            ];\n            // A cross-domain request is in order when the origin doesn't match the current origin.\n            if (s.crossDomain == null) {\n                urlAnchor = document.createElement(\"a\");\n                // Support: IE <=8 - 11, Edge 12 - 15\n                // IE throws exception on accessing the href property if url is malformed,\n                // e.g. http://example.com:80x/\n                try {\n                    urlAnchor.href = s.url;\n                    // Support: IE <=8 - 11 only\n                    // Anchor's host property isn't correctly set when s.url is relative\n                    urlAnchor.href = urlAnchor.href;\n                    s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !== urlAnchor.protocol + \"//\" + urlAnchor.host;\n                } catch (e) {\n                    // If there is an error parsing the URL, assume it is crossDomain,\n                    // it can be rejected by the transport if it is invalid\n                    s.crossDomain = true;\n                }\n            }\n            // Convert data if not already a string\n            if (s.data && s.processData && typeof s.data !== \"string\") {\n                s.data = jQuery.param(s.data, s.traditional);\n            }\n            // Apply prefilters\n            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\n            // If request was aborted inside a prefilter, stop there\n            if (completed) {\n                return jqXHR;\n            }\n            // We can fire global events as of now if asked to\n            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)\n            fireGlobals = jQuery.event && s.global;\n            // Watch for a new set of requests\n            if (fireGlobals && jQuery.active++ === 0) {\n                jQuery.event.trigger(\"ajaxStart\");\n            }\n            // Uppercase the type\n            s.type = s.type.toUpperCase();\n            // Determine if request has content\n            s.hasContent = !rnoContent.test(s.type);\n            // Save the URL in case we're toying with the If-Modified-Since\n            // and/or If-None-Match header later on\n            // Remove hash to simplify url manipulation\n            cacheURL = s.url.replace(rhash, \"\");\n            // More options handling for requests with no content\n            if (!s.hasContent) {\n                // Remember the hash so we can put it back\n                uncached = s.url.slice(cacheURL.length);\n                // If data is available and should be processed, append data to url\n                if (s.data && (s.processData || typeof s.data === \"string\")) {\n                    cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data;\n                    // trac-9682: remove data so that it's not used in an eventual retry\n                    delete s.data;\n                }\n                // Add or update anti-cache param if needed\n                if (s.cache === false) {\n                    cacheURL = cacheURL.replace(rantiCache, \"$1\");\n                    uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce.guid++ + uncached;\n                }\n                // Put hash and anti-cache on the URL that will be requested (gh-1732)\n                s.url = cacheURL + uncached;\n            // Change '%20' to '+' if this is encoded form body content (gh-2658)\n            } else if (s.data && s.processData && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n                s.data = s.data.replace(r20, \"+\");\n            }\n            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n            if (s.ifModified) {\n                if (jQuery.lastModified[cacheURL]) {\n                    jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n                }\n                if (jQuery.etag[cacheURL]) {\n                    jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n                }\n            }\n            // Set the correct header, if data is being sent\n            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n                jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n            }\n            // Set the Accepts header for the server, depending on the dataType\n            jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]);\n            // Check for headers option\n            for(i in s.headers){\n                jqXHR.setRequestHeader(i, s.headers[i]);\n            }\n            // Allow custom headers/mimetypes and early abort\n            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n                // Abort if not done already and return\n                return jqXHR.abort();\n            }\n            // Aborting is no longer a cancellation\n            strAbort = \"abort\";\n            // Install callbacks on deferreds\n            completeDeferred.add(s.complete);\n            jqXHR.done(s.success);\n            jqXHR.fail(s.error);\n            // Get transport\n            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\n            // If no transport, we auto-abort\n            if (!transport) {\n                done(-1, \"No Transport\");\n            } else {\n                jqXHR.readyState = 1;\n                // Send global event\n                if (fireGlobals) {\n                    globalEventContext.trigger(\"ajaxSend\", [\n                        jqXHR,\n                        s\n                    ]);\n                }\n                // If request was aborted inside ajaxSend, stop there\n                if (completed) {\n                    return jqXHR;\n                }\n                // Timeout\n                if (s.async && s.timeout > 0) {\n                    timeoutTimer = window1.setTimeout(function() {\n                        jqXHR.abort(\"timeout\");\n                    }, s.timeout);\n                }\n                try {\n                    completed = false;\n                    transport.send(requestHeaders, done);\n                } catch (e) {\n                    // Rethrow post-completion exceptions\n                    if (completed) {\n                        throw e;\n                    }\n                    // Propagate others as results\n                    done(-1, e);\n                }\n            }\n            // Callback for when everything is done\n            function done(status, nativeStatusText, responses, headers) {\n                var isSuccess, success, error, response, modified, statusText = nativeStatusText;\n                // Ignore repeat invocations\n                if (completed) {\n                    return;\n                }\n                completed = true;\n                // Clear timeout if it exists\n                if (timeoutTimer) {\n                    window1.clearTimeout(timeoutTimer);\n                }\n                // Dereference transport for early garbage collection\n                // (no matter how long the jqXHR object will be used)\n                transport = undefined;\n                // Cache response headers\n                responseHeadersString = headers || \"\";\n                // Set readyState\n                jqXHR.readyState = status > 0 ? 4 : 0;\n                // Determine if successful\n                isSuccess = status >= 200 && status < 300 || status === 304;\n                // Get response data\n                if (responses) {\n                    response = ajaxHandleResponses(s, jqXHR, responses);\n                }\n                // Use a noop converter for missing script but not if jsonp\n                if (!isSuccess && jQuery.inArray(\"script\", s.dataTypes) > -1 && jQuery.inArray(\"json\", s.dataTypes) < 0) {\n                    s.converters[\"text script\"] = function() {};\n                }\n                // Convert no matter what (that way responseXXX fields are always set)\n                response = ajaxConvert(s, response, jqXHR, isSuccess);\n                // If successful, handle type chaining\n                if (isSuccess) {\n                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n                    if (s.ifModified) {\n                        modified = jqXHR.getResponseHeader(\"Last-Modified\");\n                        if (modified) {\n                            jQuery.lastModified[cacheURL] = modified;\n                        }\n                        modified = jqXHR.getResponseHeader(\"etag\");\n                        if (modified) {\n                            jQuery.etag[cacheURL] = modified;\n                        }\n                    }\n                    // if no content\n                    if (status === 204 || s.type === \"HEAD\") {\n                        statusText = \"nocontent\";\n                    // if not modified\n                    } else if (status === 304) {\n                        statusText = \"notmodified\";\n                    // If we have data, let's convert it\n                    } else {\n                        statusText = response.state;\n                        success = response.data;\n                        error = response.error;\n                        isSuccess = !error;\n                    }\n                } else {\n                    // Extract error from statusText and normalize for non-aborts\n                    error = statusText;\n                    if (status || !statusText) {\n                        statusText = \"error\";\n                        if (status < 0) {\n                            status = 0;\n                        }\n                    }\n                }\n                // Set data for the fake xhr object\n                jqXHR.status = status;\n                jqXHR.statusText = (nativeStatusText || statusText) + \"\";\n                // Success/Error\n                if (isSuccess) {\n                    deferred.resolveWith(callbackContext, [\n                        success,\n                        statusText,\n                        jqXHR\n                    ]);\n                } else {\n                    deferred.rejectWith(callbackContext, [\n                        jqXHR,\n                        statusText,\n                        error\n                    ]);\n                }\n                // Status-dependent callbacks\n                jqXHR.statusCode(statusCode);\n                statusCode = undefined;\n                if (fireGlobals) {\n                    globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [\n                        jqXHR,\n                        s,\n                        isSuccess ? success : error\n                    ]);\n                }\n                // Complete\n                completeDeferred.fireWith(callbackContext, [\n                    jqXHR,\n                    statusText\n                ]);\n                if (fireGlobals) {\n                    globalEventContext.trigger(\"ajaxComplete\", [\n                        jqXHR,\n                        s\n                    ]);\n                    // Handle the global AJAX counter\n                    if (!--jQuery.active) {\n                        jQuery.event.trigger(\"ajaxStop\");\n                    }\n                }\n            }\n            return jqXHR;\n        },\n        getJSON: function(url, data, callback) {\n            return jQuery.get(url, data, callback, \"json\");\n        },\n        getScript: function(url, callback) {\n            return jQuery.get(url, undefined, callback, \"script\");\n        }\n    });\n    jQuery.each([\n        \"get\",\n        \"post\"\n    ], function(_i, method) {\n        jQuery[method] = function(url, data, callback, type) {\n            // Shift arguments if data argument was omitted\n            if (isFunction(data)) {\n                type = type || callback;\n                callback = data;\n                data = undefined;\n            }\n            // The url can be an options object (which then must have .url)\n            return jQuery.ajax(jQuery.extend({\n                url: url,\n                type: method,\n                dataType: type,\n                data: data,\n                success: callback\n            }, jQuery.isPlainObject(url) && url));\n        };\n    });\n    jQuery.ajaxPrefilter(function(s) {\n        var i;\n        for(i in s.headers){\n            if (i.toLowerCase() === \"content-type\") {\n                s.contentType = s.headers[i] || \"\";\n            }\n        }\n    });\n    jQuery._evalUrl = function(url, options, doc) {\n        return jQuery.ajax({\n            url: url,\n            // Make this explicit, since user can override this through ajaxSetup (trac-11264)\n            type: \"GET\",\n            dataType: \"script\",\n            cache: true,\n            async: false,\n            global: false,\n            // Only evaluate the response if it is successful (gh-4126)\n            // dataFilter is not invoked for failure responses, so using it instead\n            // of the default converter is kludgy but it works.\n            converters: {\n                \"text script\": function() {}\n            },\n            dataFilter: function(response) {\n                jQuery.globalEval(response, options, doc);\n            }\n        });\n    };\n    jQuery.fn.extend({\n        wrapAll: function(html) {\n            var wrap;\n            if (this[0]) {\n                if (isFunction(html)) {\n                    html = html.call(this[0]);\n                }\n                // The elements to wrap the target around\n                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n                if (this[0].parentNode) {\n                    wrap.insertBefore(this[0]);\n                }\n                wrap.map(function() {\n                    var elem = this;\n                    while(elem.firstElementChild){\n                        elem = elem.firstElementChild;\n                    }\n                    return elem;\n                }).append(this);\n            }\n            return this;\n        },\n        wrapInner: function(html) {\n            if (isFunction(html)) {\n                return this.each(function(i) {\n                    jQuery(this).wrapInner(html.call(this, i));\n                });\n            }\n            return this.each(function() {\n                var self = jQuery(this), contents = self.contents();\n                if (contents.length) {\n                    contents.wrapAll(html);\n                } else {\n                    self.append(html);\n                }\n            });\n        },\n        wrap: function(html) {\n            var htmlIsFunction = isFunction(html);\n            return this.each(function(i) {\n                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\n            });\n        },\n        unwrap: function(selector) {\n            this.parent(selector).not(\"body\").each(function() {\n                jQuery(this).replaceWith(this.childNodes);\n            });\n            return this;\n        }\n    });\n    jQuery.expr.pseudos.hidden = function(elem) {\n        return !jQuery.expr.pseudos.visible(elem);\n    };\n    jQuery.expr.pseudos.visible = function(elem) {\n        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n    };\n    jQuery.ajaxSettings.xhr = function() {\n        try {\n            return new window1.XMLHttpRequest();\n        } catch (e) {}\n    };\n    var xhrSuccessStatus = {\n        // File protocol always yields status code 0, assume 200\n        0: 200,\n        // Support: IE <=9 only\n        // trac-1450: sometimes IE returns 1223 when it should be 204\n        1223: 204\n    }, xhrSupported = jQuery.ajaxSettings.xhr();\n    support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n    support.ajax = xhrSupported = !!xhrSupported;\n    jQuery.ajaxTransport(function(options) {\n        var callback, errorCallback;\n        // Cross domain only allowed if supported through XMLHttpRequest\n        if (support.cors || xhrSupported && !options.crossDomain) {\n            return {\n                send: function(headers, complete) {\n                    var i, xhr = options.xhr();\n                    xhr.open(options.type, options.url, options.async, options.username, options.password);\n                    // Apply custom fields if provided\n                    if (options.xhrFields) {\n                        for(i in options.xhrFields){\n                            xhr[i] = options.xhrFields[i];\n                        }\n                    }\n                    // Override mime type if needed\n                    if (options.mimeType && xhr.overrideMimeType) {\n                        xhr.overrideMimeType(options.mimeType);\n                    }\n                    // X-Requested-With header\n                    // For cross-domain requests, seeing as conditions for a preflight are\n                    // akin to a jigsaw puzzle, we simply never set it to be sure.\n                    // (it can always be set on a per-request basis or even using ajaxSetup)\n                    // For same-domain requests, won't change header if already provided.\n                    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n                        headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n                    }\n                    // Set headers\n                    for(i in headers){\n                        xhr.setRequestHeader(i, headers[i]);\n                    }\n                    // Callback\n                    callback = function(type) {\n                        return function() {\n                            if (callback) {\n                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;\n                                if (type === \"abort\") {\n                                    xhr.abort();\n                                } else if (type === \"error\") {\n                                    // Support: IE <=9 only\n                                    // On a manual native abort, IE9 throws\n                                    // errors on any property access that is not readyState\n                                    if (typeof xhr.status !== \"number\") {\n                                        complete(0, \"error\");\n                                    } else {\n                                        complete(// File: protocol always yields status 0; see trac-8605, trac-14207\n                                        xhr.status, xhr.statusText);\n                                    }\n                                } else {\n                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only\n                                    // IE9 has no XHR2 but throws on binary (trac-11426)\n                                    // For XHR2 non-text, let the caller handle it (gh-2498)\n                                    (xhr.responseType || \"text\") !== \"text\" || typeof xhr.responseText !== \"string\" ? {\n                                        binary: xhr.response\n                                    } : {\n                                        text: xhr.responseText\n                                    }, xhr.getAllResponseHeaders());\n                                }\n                            }\n                        };\n                    };\n                    // Listen to events\n                    xhr.onload = callback();\n                    errorCallback = xhr.onerror = xhr.ontimeout = callback(\"error\");\n                    // Support: IE 9 only\n                    // Use onreadystatechange to replace onabort\n                    // to handle uncaught aborts\n                    if (xhr.onabort !== undefined) {\n                        xhr.onabort = errorCallback;\n                    } else {\n                        xhr.onreadystatechange = function() {\n                            // Check readyState before timeout as it changes\n                            if (xhr.readyState === 4) {\n                                // Allow onerror to be called first,\n                                // but that will not handle a native abort\n                                // Also, save errorCallback to a variable\n                                // as xhr.onerror cannot be accessed\n                                window1.setTimeout(function() {\n                                    if (callback) {\n                                        errorCallback();\n                                    }\n                                });\n                            }\n                        };\n                    }\n                    // Create the abort callback\n                    callback = callback(\"abort\");\n                    try {\n                        // Do send the request (this may raise an exception)\n                        xhr.send(options.hasContent && options.data || null);\n                    } catch (e) {\n                        // trac-14683: Only rethrow if this hasn't been notified as an error yet\n                        if (callback) {\n                            throw e;\n                        }\n                    }\n                },\n                abort: function() {\n                    if (callback) {\n                        callback();\n                    }\n                }\n            };\n        }\n    });\n    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n    jQuery.ajaxPrefilter(function(s) {\n        if (s.crossDomain) {\n            s.contents.script = false;\n        }\n    });\n    // Install script dataType\n    jQuery.ajaxSetup({\n        accepts: {\n            script: \"text/javascript, application/javascript, \" + \"application/ecmascript, application/x-ecmascript\"\n        },\n        contents: {\n            script: /\\b(?:java|ecma)script\\b/\n        },\n        converters: {\n            \"text script\": function(text) {\n                jQuery.globalEval(text);\n                return text;\n            }\n        }\n    });\n    // Handle cache's special case and crossDomain\n    jQuery.ajaxPrefilter(\"script\", function(s) {\n        if (s.cache === undefined) {\n            s.cache = false;\n        }\n        if (s.crossDomain) {\n            s.type = \"GET\";\n        }\n    });\n    // Bind script tag hack transport\n    jQuery.ajaxTransport(\"script\", function(s) {\n        // This transport only deals with cross domain or forced-by-attrs requests\n        if (s.crossDomain || s.scriptAttrs) {\n            var script, callback;\n            return {\n                send: function(_, complete) {\n                    script = jQuery(\"<script>\").attr(s.scriptAttrs || {}).prop({\n                        charset: s.scriptCharset,\n                        src: s.url\n                    }).on(\"load error\", callback = function(evt) {\n                        script.remove();\n                        callback = null;\n                        if (evt) {\n                            complete(evt.type === \"error\" ? 404 : 200, evt.type);\n                        }\n                    });\n                    // Use native DOM manipulation to avoid our domManip AJAX trickery\n                    document.head.appendChild(script[0]);\n                },\n                abort: function() {\n                    if (callback) {\n                        callback();\n                    }\n                }\n            };\n        }\n    });\n    var oldCallbacks = [], rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n    // Default jsonp settings\n    jQuery.ajaxSetup({\n        jsonp: \"callback\",\n        jsonpCallback: function() {\n            var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce.guid++;\n            this[callback] = true;\n            return callback;\n        }\n    });\n    // Detect, normalize options and install callbacks for jsonp requests\n    jQuery.ajaxPrefilter(\"json jsonp\", function(s, originalSettings, jqXHR) {\n        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0 && rjsonp.test(s.data) && \"data\");\n        // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n        if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n            // Get callback name, remembering preexisting value associated with it\n            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;\n            // Insert callback into url or form data\n            if (jsonProp) {\n                s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n            } else if (s.jsonp !== false) {\n                s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n            }\n            // Use data converter to retrieve json after script execution\n            s.converters[\"script json\"] = function() {\n                if (!responseContainer) {\n                    jQuery.error(callbackName + \" was not called\");\n                }\n                return responseContainer[0];\n            };\n            // Force json dataType\n            s.dataTypes[0] = \"json\";\n            // Install callback\n            overwritten = window1[callbackName];\n            window1[callbackName] = function() {\n                responseContainer = arguments;\n            };\n            // Clean-up function (fires after converters)\n            jqXHR.always(function() {\n                // If previous value didn't exist - remove it\n                if (overwritten === undefined) {\n                    jQuery(window1).removeProp(callbackName);\n                // Otherwise restore preexisting value\n                } else {\n                    window1[callbackName] = overwritten;\n                }\n                // Save back as free\n                if (s[callbackName]) {\n                    // Make sure that re-using the options doesn't screw things around\n                    s.jsonpCallback = originalSettings.jsonpCallback;\n                    // Save the callback name for future use\n                    oldCallbacks.push(callbackName);\n                }\n                // Call if it was a function and we have a response\n                if (responseContainer && isFunction(overwritten)) {\n                    overwritten(responseContainer[0]);\n                }\n                responseContainer = overwritten = undefined;\n            });\n            // Delegate to script\n            return \"script\";\n        }\n    });\n    // Support: Safari 8 only\n    // In Safari 8 documents created via document.implementation.createHTMLDocument\n    // collapse sibling forms: the second one becomes a child of the first one.\n    // Because of that, this security measure has to be disabled in Safari 8.\n    // https://bugs.webkit.org/show_bug.cgi?id=137337\n    support.createHTMLDocument = function() {\n        var body = document.implementation.createHTMLDocument(\"\").body;\n        body.innerHTML = \"<form></form><form></form>\";\n        return body.childNodes.length === 2;\n    }();\n    // Argument \"data\" should be string of html\n    // context (optional): If specified, the fragment will be created in this context,\n    // defaults to document\n    // keepScripts (optional): If true, will include scripts passed in the html string\n    jQuery.parseHTML = function(data, context, keepScripts) {\n        if (typeof data !== \"string\") {\n            return [];\n        }\n        if (typeof context === \"boolean\") {\n            keepScripts = context;\n            context = false;\n        }\n        var base, parsed, scripts;\n        if (!context) {\n            // Stop scripts or inline event handlers from being executed immediately\n            // by using document.implementation\n            if (support.createHTMLDocument) {\n                context = document.implementation.createHTMLDocument(\"\");\n                // Set the base href for the created document\n                // so any parsed elements with URLs\n                // are based on the document's URL (gh-2965)\n                base = context.createElement(\"base\");\n                base.href = document.location.href;\n                context.head.appendChild(base);\n            } else {\n                context = document;\n            }\n        }\n        parsed = rsingleTag.exec(data);\n        scripts = !keepScripts && [];\n        // Single tag\n        if (parsed) {\n            return [\n                context.createElement(parsed[1])\n            ];\n        }\n        parsed = buildFragment([\n            data\n        ], context, scripts);\n        if (scripts && scripts.length) {\n            jQuery(scripts).remove();\n        }\n        return jQuery.merge([], parsed.childNodes);\n    };\n    /**\n * Load a url into a page\n */ jQuery.fn.load = function(url, params, callback) {\n        var selector, type, response, self = this, off = url.indexOf(\" \");\n        if (off > -1) {\n            selector = stripAndCollapse(url.slice(off));\n            url = url.slice(0, off);\n        }\n        // If it's a function\n        if (isFunction(params)) {\n            // We assume that it's the callback\n            callback = params;\n            params = undefined;\n        // Otherwise, build a param string\n        } else if (params && typeof params === \"object\") {\n            type = \"POST\";\n        }\n        // If we have elements to modify, make the request\n        if (self.length > 0) {\n            jQuery.ajax({\n                url: url,\n                // If \"type\" variable is undefined, then \"GET\" method will be used.\n                // Make value of this field explicit since\n                // user can override it through ajaxSetup method\n                type: type || \"GET\",\n                dataType: \"html\",\n                data: params\n            }).done(function(responseText) {\n                // Save response for use in complete callback\n                response = arguments;\n                self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n                // Exclude scripts to avoid IE 'Permission Denied' errors\n                jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n                responseText);\n            // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n            // but they are ignored because response was set above.\n            // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n            }).always(callback && function(jqXHR, status) {\n                self.each(function() {\n                    callback.apply(this, response || [\n                        jqXHR.responseText,\n                        status,\n                        jqXHR\n                    ]);\n                });\n            });\n        }\n        return this;\n    };\n    jQuery.expr.pseudos.animated = function(elem) {\n        return jQuery.grep(jQuery.timers, function(fn) {\n            return elem === fn.elem;\n        }).length;\n    };\n    jQuery.offset = {\n        setOffset: function(elem, options, i) {\n            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, \"position\"), curElem = jQuery(elem), props = {};\n            // Set position first, in-case top/left are set even on static elem\n            if (position === \"static\") {\n                elem.style.position = \"relative\";\n            }\n            curOffset = curElem.offset();\n            curCSSTop = jQuery.css(elem, \"top\");\n            curCSSLeft = jQuery.css(elem, \"left\");\n            calculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1;\n            // Need to be able to calculate position if either\n            // top or left is auto and position is either absolute or fixed\n            if (calculatePosition) {\n                curPosition = curElem.position();\n                curTop = curPosition.top;\n                curLeft = curPosition.left;\n            } else {\n                curTop = parseFloat(curCSSTop) || 0;\n                curLeft = parseFloat(curCSSLeft) || 0;\n            }\n            if (isFunction(options)) {\n                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n                options = options.call(elem, i, jQuery.extend({}, curOffset));\n            }\n            if (options.top != null) {\n                props.top = options.top - curOffset.top + curTop;\n            }\n            if (options.left != null) {\n                props.left = options.left - curOffset.left + curLeft;\n            }\n            if (\"using\" in options) {\n                options.using.call(elem, props);\n            } else {\n                curElem.css(props);\n            }\n        }\n    };\n    jQuery.fn.extend({\n        // offset() relates an element's border box to the document origin\n        offset: function(options) {\n            // Preserve chaining for setter\n            if (arguments.length) {\n                return options === undefined ? this : this.each(function(i) {\n                    jQuery.offset.setOffset(this, options, i);\n                });\n            }\n            var rect, win, elem = this[0];\n            if (!elem) {\n                return;\n            }\n            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n            // Support: IE <=11 only\n            // Running getBoundingClientRect on a\n            // disconnected node in IE throws an error\n            if (!elem.getClientRects().length) {\n                return {\n                    top: 0,\n                    left: 0\n                };\n            }\n            // Get document-relative position by adding viewport scroll to viewport-relative gBCR\n            rect = elem.getBoundingClientRect();\n            win = elem.ownerDocument.defaultView;\n            return {\n                top: rect.top + win.pageYOffset,\n                left: rect.left + win.pageXOffset\n            };\n        },\n        // position() relates an element's margin box to its offset parent's padding box\n        // This corresponds to the behavior of CSS absolute positioning\n        position: function() {\n            if (!this[0]) {\n                return;\n            }\n            var offsetParent, offset, doc, elem = this[0], parentOffset = {\n                top: 0,\n                left: 0\n            };\n            // position:fixed elements are offset from the viewport, which itself always has zero offset\n            if (jQuery.css(elem, \"position\") === \"fixed\") {\n                // Assume position:fixed implies availability of getBoundingClientRect\n                offset = elem.getBoundingClientRect();\n            } else {\n                offset = this.offset();\n                // Account for the *real* offset parent, which can be the document or its root element\n                // when a statically positioned element is identified\n                doc = elem.ownerDocument;\n                offsetParent = elem.offsetParent || doc.documentElement;\n                while(offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, \"position\") === \"static\"){\n                    offsetParent = offsetParent.parentNode;\n                }\n                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n                    // Incorporate borders into its offset, since they are outside its content origin\n                    parentOffset = jQuery(offsetParent).offset();\n                    parentOffset.top += jQuery.css(offsetParent, \"borderTopWidth\", true);\n                    parentOffset.left += jQuery.css(offsetParent, \"borderLeftWidth\", true);\n                }\n            }\n            // Subtract parent offsets and element margins\n            return {\n                top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n                left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n            };\n        },\n        // This method will return documentElement in the following cases:\n        // 1) For the element inside the iframe without offsetParent, this method will return\n        //    documentElement of the parent window\n        // 2) For the hidden or detached element\n        // 3) For body or html element, i.e. in case of the html node - it will return itself\n        //\n        // but those exceptions were never presented as a real life use-cases\n        // and might be considered as more preferable results.\n        //\n        // This logic, however, is not guaranteed and can change at any point in the future\n        offsetParent: function() {\n            return this.map(function() {\n                var offsetParent = this.offsetParent;\n                while(offsetParent && jQuery.css(offsetParent, \"position\") === \"static\"){\n                    offsetParent = offsetParent.offsetParent;\n                }\n                return offsetParent || documentElement;\n            });\n        }\n    });\n    // Create scrollLeft and scrollTop methods\n    jQuery.each({\n        scrollLeft: \"pageXOffset\",\n        scrollTop: \"pageYOffset\"\n    }, function(method, prop) {\n        var top = \"pageYOffset\" === prop;\n        jQuery.fn[method] = function(val) {\n            return access(this, function(elem, method, val) {\n                // Coalesce documents and windows\n                var win;\n                if (isWindow(elem)) {\n                    win = elem;\n                } else if (elem.nodeType === 9) {\n                    win = elem.defaultView;\n                }\n                if (val === undefined) {\n                    return win ? win[prop] : elem[method];\n                }\n                if (win) {\n                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n                } else {\n                    elem[method] = val;\n                }\n            }, method, val, arguments.length);\n        };\n    });\n    // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n    // Add the top/left cssHooks using jQuery.fn.position\n    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n    // getComputedStyle returns percent when specified for top/left/bottom/right;\n    // rather than make the css module depend on the offset module, just check for it here\n    jQuery.each([\n        \"top\",\n        \"left\"\n    ], function(_i, prop) {\n        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {\n            if (computed) {\n                computed = curCSS(elem, prop);\n                // If curCSS returns percentage, fallback to offset\n                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n            }\n        });\n    });\n    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n    jQuery.each({\n        Height: \"height\",\n        Width: \"width\"\n    }, function(name, type) {\n        jQuery.each({\n            padding: \"inner\" + name,\n            content: type,\n            \"\": \"outer\" + name\n        }, function(defaultExtra, funcName) {\n            // Margin is only for outerHeight, outerWidth\n            jQuery.fn[funcName] = function(margin, value) {\n                var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"), extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n                return access(this, function(elem, type, value) {\n                    var doc;\n                    if (isWindow(elem)) {\n                        // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n                        return funcName.indexOf(\"outer\") === 0 ? elem[\"inner\" + name] : elem.document.documentElement[\"client\" + name];\n                    }\n                    // Get document width or height\n                    if (elem.nodeType === 9) {\n                        doc = elem.documentElement;\n                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n                        // whichever is greatest\n                        return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n                    }\n                    return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n                    jQuery.css(elem, type, extra) : // Set width or height on the element\n                    jQuery.style(elem, type, value, extra);\n                }, type, chainable ? margin : undefined, chainable);\n            };\n        });\n    });\n    jQuery.each([\n        \"ajaxStart\",\n        \"ajaxStop\",\n        \"ajaxComplete\",\n        \"ajaxError\",\n        \"ajaxSuccess\",\n        \"ajaxSend\"\n    ], function(_i, type) {\n        jQuery.fn[type] = function(fn) {\n            return this.on(type, fn);\n        };\n    });\n    jQuery.fn.extend({\n        bind: function(types, data, fn) {\n            return this.on(types, null, data, fn);\n        },\n        unbind: function(types, fn) {\n            return this.off(types, null, fn);\n        },\n        delegate: function(selector, types, data, fn) {\n            return this.on(types, selector, data, fn);\n        },\n        undelegate: function(selector, types, fn) {\n            // ( namespace ) or ( selector, types [, fn] )\n            return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n        },\n        hover: function(fnOver, fnOut) {\n            return this.on(\"mouseenter\", fnOver).on(\"mouseleave\", fnOut || fnOver);\n        }\n    });\n    jQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function(_i, name) {\n        // Handle event binding\n        jQuery.fn[name] = function(data, fn) {\n            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n        };\n    });\n    // Support: Android <=4.0 only\n    // Make sure we trim BOM and NBSP\n    // Require that the \"whitespace run\" starts from a non-whitespace\n    // to avoid O(N^2) behavior when the engine would try matching \"\\s+$\" at each space position.\n    var rtrim = /^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$/g;\n    // Bind a function to a context, optionally partially applying any\n    // arguments.\n    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n    // However, it is not slated for removal any time soon\n    jQuery.proxy = function(fn, context) {\n        var tmp, args, proxy;\n        if (typeof context === \"string\") {\n            tmp = fn[context];\n            context = fn;\n            fn = tmp;\n        }\n        // Quick check to determine if target is callable, in the spec\n        // this throws a TypeError, but we will just return undefined.\n        if (!isFunction(fn)) {\n            return undefined;\n        }\n        // Simulated bind\n        args = slice.call(arguments, 2);\n        proxy = function() {\n            return fn.apply(context || this, args.concat(slice.call(arguments)));\n        };\n        // Set the guid of unique handler to the same of original handler, so it can be removed\n        proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n        return proxy;\n    };\n    jQuery.holdReady = function(hold) {\n        if (hold) {\n            jQuery.readyWait++;\n        } else {\n            jQuery.ready(true);\n        }\n    };\n    jQuery.isArray = Array.isArray;\n    jQuery.parseJSON = JSON.parse;\n    jQuery.nodeName = nodeName;\n    jQuery.isFunction = isFunction;\n    jQuery.isWindow = isWindow;\n    jQuery.camelCase = camelCase;\n    jQuery.type = toType;\n    jQuery.now = Date.now;\n    jQuery.isNumeric = function(obj) {\n        // As of jQuery 3.0, isNumeric is limited to\n        // strings and numbers (primitives or objects)\n        // that can be coerced to finite numbers (gh-2662)\n        var type = jQuery.type(obj);\n        return (type === \"number\" || type === \"string\") && // parseFloat NaNs numeric-cast false positives (\"\")\n        // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n        // subtraction forces infinities to NaN\n        !isNaN(obj - parseFloat(obj));\n    };\n    jQuery.trim = function(text) {\n        return text == null ? \"\" : (text + \"\").replace(rtrim, \"$1\");\n    };\n    // Register as a named AMD module, since jQuery can be concatenated with other\n    // files that may use define, but not via a proper concatenation script that\n    // understands anonymous AMD modules. A named AMD is safest and most robust\n    // way to register. Lowercase jquery is used because AMD module names are\n    // derived from file names, and jQuery is normally delivered in a lowercase\n    // file name. Do this after creating the global so that if an AMD module wants\n    // to call noConflict to hide this version of jQuery, it will work.\n    // Note that for maximum portability, libraries that are not jQuery should\n    // declare themselves as anonymous modules, and avoid setting a global if an\n    // AMD loader is present. jQuery is a special case. For more information, see\n    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return jQuery;\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    var // Map over jQuery in case of overwrite\n    _jQuery = window1.jQuery, // Map over the $ in case of overwrite\n    _$ = window1.$;\n    jQuery.noConflict = function(deep) {\n        if (window1.$ === jQuery) {\n            window1.$ = _$;\n        }\n        if (deep && window1.jQuery === jQuery) {\n            window1.jQuery = _jQuery;\n        }\n        return jQuery;\n    };\n    // Expose jQuery and $ identifiers, even in AMD\n    // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)\n    // and CommonJS for browser emulators (trac-13566)\n    if (typeof noGlobal === \"undefined\") {\n        window1.jQuery = window1.$ = jQuery;\n    }\n    return jQuery;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vanF1ZXJ5QDMuNy4xL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUNDLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUUxQjtJQUVBLElBQUssS0FBMEIsSUFBSSxPQUFPQyxPQUFPQyxPQUFPLEtBQUssVUFBVztRQUV2RSxzRUFBc0U7UUFDdEUsa0RBQWtEO1FBQ2xELGlFQUFpRTtRQUNqRSx5REFBeUQ7UUFDekQsaUVBQWlFO1FBQ2pFLCtDQUErQztRQUMvQyx1Q0FBdUM7UUFDdkNELE9BQU9DLE9BQU8sR0FBR0gsT0FBT0ksUUFBUSxHQUMvQkgsUUFBU0QsUUFBUSxRQUNqQixTQUFVSyxDQUFDO1lBQ1YsSUFBSyxDQUFDQSxFQUFFRCxRQUFRLEVBQUc7Z0JBQ2xCLE1BQU0sSUFBSUUsTUFBTztZQUNsQjtZQUNBLE9BQU9MLFFBQVNJO1FBQ2pCO0lBQ0YsT0FBTztRQUNOSixRQUFTRDtJQUNWO0FBRUQseUNBQXlDO0FBQ3pDLEdBQUssTUFBNkIsR0FBR08sQ0FBTUEsR0FBRyxRQUFNLFNBQVVBLE9BQU0sRUFBRUMsUUFBUTtJQUU5RSxpRkFBaUY7SUFDakYsaUZBQWlGO0lBQ2pGLGtHQUFrRztJQUNsRyw0REFBNEQ7SUFDNUQ7SUFFQSxJQUFJQyxNQUFNLEVBQUU7SUFFWixJQUFJQyxXQUFXQyxPQUFPQyxjQUFjO0lBRXBDLElBQUlDLFFBQVFKLElBQUlJLEtBQUs7SUFFckIsSUFBSUMsT0FBT0wsSUFBSUssSUFBSSxHQUFHLFNBQVVDLEtBQUs7UUFDcEMsT0FBT04sSUFBSUssSUFBSSxDQUFDRSxJQUFJLENBQUVEO0lBQ3ZCLElBQUksU0FBVUEsS0FBSztRQUNsQixPQUFPTixJQUFJUSxNQUFNLENBQUNDLEtBQUssQ0FBRSxFQUFFLEVBQUVIO0lBQzlCO0lBR0EsSUFBSUksT0FBT1YsSUFBSVUsSUFBSTtJQUVuQixJQUFJQyxVQUFVWCxJQUFJVyxPQUFPO0lBRXpCLElBQUlDLGFBQWEsQ0FBQztJQUVsQixJQUFJQyxXQUFXRCxXQUFXQyxRQUFRO0lBRWxDLElBQUlDLFNBQVNGLFdBQVdHLGNBQWM7SUFFdEMsSUFBSUMsYUFBYUYsT0FBT0QsUUFBUTtJQUVoQyxJQUFJSSx1QkFBdUJELFdBQVdULElBQUksQ0FBRUw7SUFFNUMsSUFBSWdCLFVBQVUsQ0FBQztJQUVmLElBQUlDLGFBQWEsU0FBU0EsV0FBWUMsR0FBRztRQUV2QyxxQ0FBcUM7UUFDckMseUVBQXlFO1FBQ3pFLHNFQUFzRTtRQUN0RSwwREFBMEQ7UUFDMUQscUVBQXFFO1FBQ3JFLHNFQUFzRTtRQUN0RSxrRkFBa0Y7UUFDbEYsT0FBTyxPQUFPQSxRQUFRLGNBQWMsT0FBT0EsSUFBSUMsUUFBUSxLQUFLLFlBQzNELE9BQU9ELElBQUlFLElBQUksS0FBSztJQUN0QjtJQUdELElBQUlDLFdBQVcsU0FBU0EsU0FBVUgsR0FBRztRQUNuQyxPQUFPQSxPQUFPLFFBQVFBLFFBQVFBLElBQUl0QixNQUFNO0lBQ3pDO0lBR0QsSUFBSUgsV0FBV0csUUFBT0gsUUFBUTtJQUk3QixJQUFJNkIsNEJBQTRCO1FBQy9CQyxNQUFNO1FBQ05DLEtBQUs7UUFDTEMsT0FBTztRQUNQQyxVQUFVO0lBQ1g7SUFFQSxTQUFTQyxRQUFTQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsR0FBRztRQUNoQ0EsTUFBTUEsT0FBT3JDO1FBRWIsSUFBSXNDLEdBQUdDLEtBQ05DLFNBQVNILElBQUlJLGFBQWEsQ0FBRTtRQUU3QkQsT0FBT0UsSUFBSSxHQUFHUDtRQUNkLElBQUtDLE1BQU87WUFDWCxJQUFNRSxLQUFLVCwwQkFBNEI7Z0JBRXRDLGlDQUFpQztnQkFDakMsK0RBQStEO2dCQUMvRCxnRUFBZ0U7Z0JBQ2hFLGdFQUFnRTtnQkFDaEUsc0NBQXNDO2dCQUN0QyxpREFBaUQ7Z0JBQ2pELHFEQUFxRDtnQkFDckQsMERBQTBEO2dCQUMxRCxrRUFBa0U7Z0JBQ2xFLGlCQUFpQjtnQkFDakJVLE1BQU1ILElBQUksQ0FBRUUsRUFBRyxJQUFJRixLQUFLTyxZQUFZLElBQUlQLEtBQUtPLFlBQVksQ0FBRUw7Z0JBQzNELElBQUtDLEtBQU07b0JBQ1ZDLE9BQU9JLFlBQVksQ0FBRU4sR0FBR0M7Z0JBQ3pCO1lBQ0Q7UUFDRDtRQUNBRixJQUFJUSxJQUFJLENBQUNDLFdBQVcsQ0FBRU4sUUFBU08sVUFBVSxDQUFDQyxXQUFXLENBQUVSO0lBQ3hEO0lBR0QsU0FBU1MsT0FBUXhCLEdBQUc7UUFDbkIsSUFBS0EsT0FBTyxNQUFPO1lBQ2xCLE9BQU9BLE1BQU07UUFDZDtRQUVBLG1EQUFtRDtRQUNuRCxPQUFPLE9BQU9BLFFBQVEsWUFBWSxPQUFPQSxRQUFRLGFBQ2hEUixVQUFVLENBQUVDLFNBQVNOLElBQUksQ0FBRWEsS0FBTyxJQUFJLFdBQ3RDLE9BQU9BO0lBQ1Q7SUFDQSxpQkFBaUIsR0FDakIsbUZBQW1GO0lBQ25GLG1GQUFtRjtJQUluRixJQUFJeUIsVUFBVSxTQUViQyxjQUFjLFVBRWQsZ0NBQWdDO0lBQ2hDQyxTQUFTLFNBQVVDLFFBQVEsRUFBRUMsT0FBTztRQUVuQyxxRUFBcUU7UUFDckUsZ0ZBQWdGO1FBQ2hGLE9BQU8sSUFBSUYsT0FBT0csRUFBRSxDQUFDQyxJQUFJLENBQUVILFVBQVVDO0lBQ3RDO0lBRURGLE9BQU9HLEVBQUUsR0FBR0gsT0FBT0ssU0FBUyxHQUFHO1FBRTlCLDJDQUEyQztRQUMzQ0MsUUFBUVI7UUFFUlMsYUFBYVA7UUFFYiw2Q0FBNkM7UUFDN0NRLFFBQVE7UUFFUkMsU0FBUztZQUNSLE9BQU9wRCxNQUFNRyxJQUFJLENBQUUsSUFBSTtRQUN4QjtRQUVBLG9EQUFvRDtRQUNwRCxxREFBcUQ7UUFDckRrRCxLQUFLLFNBQVVDLEdBQUc7WUFFakIsMkNBQTJDO1lBQzNDLElBQUtBLE9BQU8sTUFBTztnQkFDbEIsT0FBT3RELE1BQU1HLElBQUksQ0FBRSxJQUFJO1lBQ3hCO1lBRUEsMkNBQTJDO1lBQzNDLE9BQU9tRCxNQUFNLElBQUksSUFBSSxDQUFFQSxNQUFNLElBQUksQ0FBQ0gsTUFBTSxDQUFFLEdBQUcsSUFBSSxDQUFFRyxJQUFLO1FBQ3pEO1FBRUEsdURBQXVEO1FBQ3ZELDBDQUEwQztRQUMxQ0MsV0FBVyxTQUFVQyxLQUFLO1lBRXpCLHlDQUF5QztZQUN6QyxJQUFJQyxNQUFNZCxPQUFPZSxLQUFLLENBQUUsSUFBSSxDQUFDUixXQUFXLElBQUlNO1lBRTVDLHFEQUFxRDtZQUNyREMsSUFBSUUsVUFBVSxHQUFHLElBQUk7WUFFckIsc0NBQXNDO1lBQ3RDLE9BQU9GO1FBQ1I7UUFFQSwyREFBMkQ7UUFDM0RHLE1BQU0sU0FBVUMsUUFBUTtZQUN2QixPQUFPbEIsT0FBT2lCLElBQUksQ0FBRSxJQUFJLEVBQUVDO1FBQzNCO1FBRUFDLEtBQUssU0FBVUQsUUFBUTtZQUN0QixPQUFPLElBQUksQ0FBQ04sU0FBUyxDQUFFWixPQUFPbUIsR0FBRyxDQUFFLElBQUksRUFBRSxTQUFVQyxJQUFJLEVBQUVsQyxDQUFDO2dCQUN6RCxPQUFPZ0MsU0FBUzFELElBQUksQ0FBRTRELE1BQU1sQyxHQUFHa0M7WUFDaEM7UUFDRDtRQUVBL0QsT0FBTztZQUNOLE9BQU8sSUFBSSxDQUFDdUQsU0FBUyxDQUFFdkQsTUFBTUssS0FBSyxDQUFFLElBQUksRUFBRTJEO1FBQzNDO1FBRUFDLE9BQU87WUFDTixPQUFPLElBQUksQ0FBQ0MsRUFBRSxDQUFFO1FBQ2pCO1FBRUFDLE1BQU07WUFDTCxPQUFPLElBQUksQ0FBQ0QsRUFBRSxDQUFFLENBQUM7UUFDbEI7UUFFQUUsTUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDYixTQUFTLENBQUVaLE9BQU8wQixJQUFJLENBQUUsSUFBSSxFQUFFLFNBQVVDLEtBQUssRUFBRXpDLENBQUM7Z0JBQzNELE9BQU8sQ0FBRUEsSUFBSSxLQUFNO1lBQ3BCO1FBQ0Q7UUFFQTBDLEtBQUs7WUFDSixPQUFPLElBQUksQ0FBQ2hCLFNBQVMsQ0FBRVosT0FBTzBCLElBQUksQ0FBRSxJQUFJLEVBQUUsU0FBVUMsS0FBSyxFQUFFekMsQ0FBQztnQkFDM0QsT0FBT0EsSUFBSTtZQUNaO1FBQ0Q7UUFFQXFDLElBQUksU0FBVXJDLENBQUM7WUFDZCxJQUFJMkMsTUFBTSxJQUFJLENBQUNyQixNQUFNLEVBQ3BCc0IsSUFBSSxDQUFDNUMsSUFBTUEsQ0FBQUEsSUFBSSxJQUFJMkMsTUFBTTtZQUMxQixPQUFPLElBQUksQ0FBQ2pCLFNBQVMsQ0FBRWtCLEtBQUssS0FBS0EsSUFBSUQsTUFBTTtnQkFBRSxJQUFJLENBQUVDLEVBQUc7YUFBRSxHQUFHLEVBQUU7UUFDOUQ7UUFFQUMsS0FBSztZQUNKLE9BQU8sSUFBSSxDQUFDZixVQUFVLElBQUksSUFBSSxDQUFDVCxXQUFXO1FBQzNDO1FBRUEseUJBQXlCO1FBQ3pCLDREQUE0RDtRQUM1RDVDLE1BQU1BO1FBQ05xRSxNQUFNL0UsSUFBSStFLElBQUk7UUFDZEMsUUFBUWhGLElBQUlnRixNQUFNO0lBQ25CO0lBRUFqQyxPQUFPa0MsTUFBTSxHQUFHbEMsT0FBT0csRUFBRSxDQUFDK0IsTUFBTSxHQUFHO1FBQ2xDLElBQUlDLFNBQVNDLE1BQU16RCxLQUFLMEQsTUFBTUMsYUFBYUMsT0FDMUNDLFNBQVNuQixTQUFTLENBQUUsRUFBRyxJQUFJLENBQUMsR0FDNUJuQyxJQUFJLEdBQ0pzQixTQUFTYSxVQUFVYixNQUFNLEVBQ3pCaUMsT0FBTztRQUVSLCtCQUErQjtRQUMvQixJQUFLLE9BQU9ELFdBQVcsV0FBWTtZQUNsQ0MsT0FBT0Q7WUFFUCxrQ0FBa0M7WUFDbENBLFNBQVNuQixTQUFTLENBQUVuQyxFQUFHLElBQUksQ0FBQztZQUM1QkE7UUFDRDtRQUVBLDJFQUEyRTtRQUMzRSxJQUFLLE9BQU9zRCxXQUFXLFlBQVksQ0FBQ3BFLFdBQVlvRSxTQUFXO1lBQzFEQSxTQUFTLENBQUM7UUFDWDtRQUVBLHNEQUFzRDtRQUN0RCxJQUFLdEQsTUFBTXNCLFFBQVM7WUFDbkJnQyxTQUFTLElBQUk7WUFDYnREO1FBQ0Q7UUFFQSxNQUFRQSxJQUFJc0IsUUFBUXRCLElBQU07WUFFekIsMkNBQTJDO1lBQzNDLElBQUssQ0FBRWlELFVBQVVkLFNBQVMsQ0FBRW5DLEVBQUcsS0FBTSxNQUFPO2dCQUUzQyx5QkFBeUI7Z0JBQ3pCLElBQU1rRCxRQUFRRCxRQUFVO29CQUN2QkUsT0FBT0YsT0FBTyxDQUFFQyxLQUFNO29CQUV0QixxQ0FBcUM7b0JBQ3JDLDRCQUE0QjtvQkFDNUIsSUFBS0EsU0FBUyxlQUFlSSxXQUFXSCxNQUFPO3dCQUM5QztvQkFDRDtvQkFFQSxtREFBbUQ7b0JBQ25ELElBQUtJLFFBQVFKLFFBQVVyQyxDQUFBQSxPQUFPMEMsYUFBYSxDQUFFTCxTQUMxQ0MsQ0FBQUEsY0FBY0ssTUFBTUMsT0FBTyxDQUFFUCxLQUFLLENBQUUsR0FBTTt3QkFDNUMxRCxNQUFNNkQsTUFBTSxDQUFFSixLQUFNO3dCQUVwQiwwQ0FBMEM7d0JBQzFDLElBQUtFLGVBQWUsQ0FBQ0ssTUFBTUMsT0FBTyxDQUFFakUsTUFBUTs0QkFDM0M0RCxRQUFRLEVBQUU7d0JBQ1gsT0FBTyxJQUFLLENBQUNELGVBQWUsQ0FBQ3RDLE9BQU8wQyxhQUFhLENBQUUvRCxNQUFROzRCQUMxRDRELFFBQVEsQ0FBQzt3QkFDVixPQUFPOzRCQUNOQSxRQUFRNUQ7d0JBQ1Q7d0JBQ0EyRCxjQUFjO3dCQUVkLDBDQUEwQzt3QkFDMUNFLE1BQU0sQ0FBRUosS0FBTSxHQUFHcEMsT0FBT2tDLE1BQU0sQ0FBRU8sTUFBTUYsT0FBT0Y7b0JBRTlDLGtDQUFrQztvQkFDbEMsT0FBTyxJQUFLQSxTQUFTUSxXQUFZO3dCQUNoQ0wsTUFBTSxDQUFFSixLQUFNLEdBQUdDO29CQUNsQjtnQkFDRDtZQUNEO1FBQ0Q7UUFFQSw2QkFBNkI7UUFDN0IsT0FBT0c7SUFDUjtJQUVBeEMsT0FBT2tDLE1BQU0sQ0FBRTtRQUVkLDZDQUE2QztRQUM3Q1ksU0FBUyxXQUFXLENBQUVoRCxVQUFVaUQsS0FBS0MsTUFBTSxFQUFDLEVBQUlDLE9BQU8sQ0FBRSxPQUFPO1FBRWhFLGtEQUFrRDtRQUNsREMsU0FBUztRQUVUQyxPQUFPLFNBQVVDLEdBQUc7WUFDbkIsTUFBTSxJQUFJdEcsTUFBT3NHO1FBQ2xCO1FBRUFDLE1BQU0sWUFBWTtRQUVsQlgsZUFBZSxTQUFVckUsR0FBRztZQUMzQixJQUFJaUYsT0FBT0M7WUFFWCwyQkFBMkI7WUFDM0IsNERBQTREO1lBQzVELElBQUssQ0FBQ2xGLE9BQU9QLFNBQVNOLElBQUksQ0FBRWEsU0FBVSxtQkFBb0I7Z0JBQ3pELE9BQU87WUFDUjtZQUVBaUYsUUFBUXBHLFNBQVVtQjtZQUVsQixzRUFBc0U7WUFDdEUsSUFBSyxDQUFDaUYsT0FBUTtnQkFDYixPQUFPO1lBQ1I7WUFFQSx5RkFBeUY7WUFDekZDLE9BQU94RixPQUFPUCxJQUFJLENBQUU4RixPQUFPLGtCQUFtQkEsTUFBTS9DLFdBQVc7WUFDL0QsT0FBTyxPQUFPZ0QsU0FBUyxjQUFjdEYsV0FBV1QsSUFBSSxDQUFFK0YsVUFBV3JGO1FBQ2xFO1FBRUFzRixlQUFlLFNBQVVuRixHQUFHO1lBQzNCLElBQUkrRDtZQUVKLElBQU1BLFFBQVEvRCxJQUFNO2dCQUNuQixPQUFPO1lBQ1I7WUFDQSxPQUFPO1FBQ1I7UUFFQSx5RUFBeUU7UUFDekUsb0JBQW9CO1FBQ3BCb0YsWUFBWSxTQUFVMUUsSUFBSSxFQUFFb0QsT0FBTyxFQUFFbEQsR0FBRztZQUN2Q0gsUUFBU0MsTUFBTTtnQkFBRUgsT0FBT3VELFdBQVdBLFFBQVF2RCxLQUFLO1lBQUMsR0FBR0s7UUFDckQ7UUFFQWdDLE1BQU0sU0FBVTVDLEdBQUcsRUFBRTZDLFFBQVE7WUFDNUIsSUFBSVYsUUFBUXRCLElBQUk7WUFFaEIsSUFBS3dFLFlBQWFyRixNQUFRO2dCQUN6Qm1DLFNBQVNuQyxJQUFJbUMsTUFBTTtnQkFDbkIsTUFBUXRCLElBQUlzQixRQUFRdEIsSUFBTTtvQkFDekIsSUFBS2dDLFNBQVMxRCxJQUFJLENBQUVhLEdBQUcsQ0FBRWEsRUFBRyxFQUFFQSxHQUFHYixHQUFHLENBQUVhLEVBQUcsTUFBTyxPQUFRO3dCQUN2RDtvQkFDRDtnQkFDRDtZQUNELE9BQU87Z0JBQ04sSUFBTUEsS0FBS2IsSUFBTTtvQkFDaEIsSUFBSzZDLFNBQVMxRCxJQUFJLENBQUVhLEdBQUcsQ0FBRWEsRUFBRyxFQUFFQSxHQUFHYixHQUFHLENBQUVhLEVBQUcsTUFBTyxPQUFRO3dCQUN2RDtvQkFDRDtnQkFDRDtZQUNEO1lBRUEsT0FBT2I7UUFDUjtRQUdBLG1EQUFtRDtRQUNuRGlCLE1BQU0sU0FBVThCLElBQUk7WUFDbkIsSUFBSXBDLE1BQ0g4QixNQUFNLElBQ041QixJQUFJLEdBQ0paLFdBQVc4QyxLQUFLOUMsUUFBUTtZQUV6QixJQUFLLENBQUNBLFVBQVc7Z0JBRWhCLGtEQUFrRDtnQkFDbEQsTUFBVVUsT0FBT29DLElBQUksQ0FBRWxDLElBQUssQ0FBSztvQkFFaEMsZ0NBQWdDO29CQUNoQzRCLE9BQU9kLE9BQU9WLElBQUksQ0FBRU47Z0JBQ3JCO1lBQ0Q7WUFDQSxJQUFLVixhQUFhLEtBQUtBLGFBQWEsSUFBSztnQkFDeEMsT0FBTzhDLEtBQUt1QyxXQUFXO1lBQ3hCO1lBQ0EsSUFBS3JGLGFBQWEsR0FBSTtnQkFDckIsT0FBTzhDLEtBQUt3QyxlQUFlLENBQUNELFdBQVc7WUFDeEM7WUFDQSxJQUFLckYsYUFBYSxLQUFLQSxhQUFhLEdBQUk7Z0JBQ3ZDLE9BQU84QyxLQUFLeUMsU0FBUztZQUN0QjtZQUVBLHlEQUF5RDtZQUV6RCxPQUFPL0M7UUFDUjtRQUVBLHFDQUFxQztRQUNyQ2dELFdBQVcsU0FBVTdHLEdBQUcsRUFBRThHLE9BQU87WUFDaEMsSUFBSWpELE1BQU1pRCxXQUFXLEVBQUU7WUFFdkIsSUFBSzlHLE9BQU8sTUFBTztnQkFDbEIsSUFBS3lHLFlBQWF2RyxPQUFRRixPQUFVO29CQUNuQytDLE9BQU9lLEtBQUssQ0FBRUQsS0FDYixPQUFPN0QsUUFBUSxXQUNkO3dCQUFFQTtxQkFBSyxHQUFHQTtnQkFFYixPQUFPO29CQUNOVSxLQUFLSCxJQUFJLENBQUVzRCxLQUFLN0Q7Z0JBQ2pCO1lBQ0Q7WUFFQSxPQUFPNkQ7UUFDUjtRQUVBa0QsU0FBUyxTQUFVNUMsSUFBSSxFQUFFbkUsR0FBRyxFQUFFaUMsQ0FBQztZQUM5QixPQUFPakMsT0FBTyxPQUFPLENBQUMsSUFBSVcsUUFBUUosSUFBSSxDQUFFUCxLQUFLbUUsTUFBTWxDO1FBQ3BEO1FBRUErRSxVQUFVLFNBQVU3QyxJQUFJO1lBQ3ZCLElBQUk4QyxZQUFZOUMsUUFBUUEsS0FBSytDLFlBQVksRUFDeENDLFVBQVVoRCxRQUFRLENBQUVBLEtBQUtpRCxhQUFhLElBQUlqRCxJQUFHLEVBQUl3QyxlQUFlO1lBRWpFLHFFQUFxRTtZQUNyRSxzQkFBc0I7WUFDdEIsT0FBTyxDQUFDN0QsWUFBWXVFLElBQUksQ0FBRUosYUFBYUUsV0FBV0EsUUFBUUcsUUFBUSxJQUFJO1FBQ3ZFO1FBRUEsZ0RBQWdEO1FBQ2hELG9EQUFvRDtRQUNwRHhELE9BQU8sU0FBVU8sS0FBSyxFQUFFa0QsTUFBTTtZQUM3QixJQUFJM0MsTUFBTSxDQUFDMkMsT0FBT2hFLE1BQU0sRUFDdkJzQixJQUFJLEdBQ0o1QyxJQUFJb0MsTUFBTWQsTUFBTTtZQUVqQixNQUFRc0IsSUFBSUQsS0FBS0MsSUFBTTtnQkFDdEJSLEtBQUssQ0FBRXBDLElBQUssR0FBR3NGLE1BQU0sQ0FBRTFDLEVBQUc7WUFDM0I7WUFFQVIsTUFBTWQsTUFBTSxHQUFHdEI7WUFFZixPQUFPb0M7UUFDUjtRQUVBSSxNQUFNLFNBQVViLEtBQUssRUFBRUssUUFBUSxFQUFFdUQsTUFBTTtZQUN0QyxJQUFJQyxpQkFDSEMsVUFBVSxFQUFFLEVBQ1p6RixJQUFJLEdBQ0pzQixTQUFTSyxNQUFNTCxNQUFNLEVBQ3JCb0UsaUJBQWlCLENBQUNIO1lBRW5CLDhDQUE4QztZQUM5QyxtQ0FBbUM7WUFDbkMsTUFBUXZGLElBQUlzQixRQUFRdEIsSUFBTTtnQkFDekJ3RixrQkFBa0IsQ0FBQ3hELFNBQVVMLEtBQUssQ0FBRTNCLEVBQUcsRUFBRUE7Z0JBQ3pDLElBQUt3RixvQkFBb0JFLGdCQUFpQjtvQkFDekNELFFBQVFoSCxJQUFJLENBQUVrRCxLQUFLLENBQUUzQixFQUFHO2dCQUN6QjtZQUNEO1lBRUEsT0FBT3lGO1FBQ1I7UUFFQSxpQ0FBaUM7UUFDakN4RCxLQUFLLFNBQVVOLEtBQUssRUFBRUssUUFBUSxFQUFFMkQsR0FBRztZQUNsQyxJQUFJckUsUUFBUXNFLE9BQ1g1RixJQUFJLEdBQ0o0QixNQUFNLEVBQUU7WUFFVCwwRUFBMEU7WUFDMUUsSUFBSzRDLFlBQWE3QyxRQUFVO2dCQUMzQkwsU0FBU0ssTUFBTUwsTUFBTTtnQkFDckIsTUFBUXRCLElBQUlzQixRQUFRdEIsSUFBTTtvQkFDekI0RixRQUFRNUQsU0FBVUwsS0FBSyxDQUFFM0IsRUFBRyxFQUFFQSxHQUFHMkY7b0JBRWpDLElBQUtDLFNBQVMsTUFBTzt3QkFDcEJoRSxJQUFJbkQsSUFBSSxDQUFFbUg7b0JBQ1g7Z0JBQ0Q7WUFFRCxzQ0FBc0M7WUFDdEMsT0FBTztnQkFDTixJQUFNNUYsS0FBSzJCLE1BQVE7b0JBQ2xCaUUsUUFBUTVELFNBQVVMLEtBQUssQ0FBRTNCLEVBQUcsRUFBRUEsR0FBRzJGO29CQUVqQyxJQUFLQyxTQUFTLE1BQU87d0JBQ3BCaEUsSUFBSW5ELElBQUksQ0FBRW1IO29CQUNYO2dCQUNEO1lBQ0Q7WUFFQSw0QkFBNEI7WUFDNUIsT0FBT3hILEtBQU13RDtRQUNkO1FBRUEsb0NBQW9DO1FBQ3BDaUUsTUFBTTtRQUVOLHFFQUFxRTtRQUNyRSx5Q0FBeUM7UUFDekM1RyxTQUFTQTtJQUNWO0lBRUEsSUFBSyxPQUFPNkcsV0FBVyxZQUFhO1FBQ25DaEYsT0FBT0csRUFBRSxDQUFFNkUsT0FBT0MsUUFBUSxDQUFFLEdBQUdoSSxHQUFHLENBQUUrSCxPQUFPQyxRQUFRLENBQUU7SUFDdEQ7SUFFQSw4QkFBOEI7SUFDOUJqRixPQUFPaUIsSUFBSSxDQUFFLHVFQUF1RWlFLEtBQUssQ0FBRSxNQUMxRixTQUFVQyxFQUFFLEVBQUUvQyxJQUFJO1FBQ2pCdkUsVUFBVSxDQUFFLGFBQWF1RSxPQUFPLElBQUssR0FBR0EsS0FBS2dELFdBQVc7SUFDekQ7SUFFRCxTQUFTMUIsWUFBYXJGLEdBQUc7UUFFeEIsNkRBQTZEO1FBQzdELGlEQUFpRDtRQUNqRCxnREFBZ0Q7UUFDaEQsa0NBQWtDO1FBQ2xDLElBQUltQyxTQUFTLENBQUMsQ0FBQ25DLE9BQU8sWUFBWUEsT0FBT0EsSUFBSW1DLE1BQU0sRUFDbEQ5QixPQUFPbUIsT0FBUXhCO1FBRWhCLElBQUtELFdBQVlDLFFBQVNHLFNBQVVILE1BQVE7WUFDM0MsT0FBTztRQUNSO1FBRUEsT0FBT0ssU0FBUyxXQUFXOEIsV0FBVyxLQUNyQyxPQUFPQSxXQUFXLFlBQVlBLFNBQVMsS0FBSyxTQUFXLEtBQU9uQztJQUNoRTtJQUdBLFNBQVNrRyxTQUFVbkQsSUFBSSxFQUFFZ0IsSUFBSTtRQUU1QixPQUFPaEIsS0FBS21ELFFBQVEsSUFBSW5ELEtBQUttRCxRQUFRLENBQUNhLFdBQVcsT0FBT2hELEtBQUtnRCxXQUFXO0lBRXpFO0lBQ0EsSUFBSUMsTUFBTXBJLElBQUlvSSxHQUFHO0lBR2pCLElBQUlyRCxPQUFPL0UsSUFBSStFLElBQUk7SUFHbkIsSUFBSUMsU0FBU2hGLElBQUlnRixNQUFNO0lBR3ZCLElBQUlxRCxhQUFhO0lBR2pCLElBQUlDLFdBQVcsSUFBSUMsT0FDbEIsTUFBTUYsYUFBYSxnQ0FBZ0NBLGFBQWEsTUFDaEU7SUFNRCwyQ0FBMkM7SUFDM0N0RixPQUFPeUYsUUFBUSxHQUFHLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztRQUMvQixJQUFJQyxNQUFNRCxLQUFLQSxFQUFFaEcsVUFBVTtRQUUzQixPQUFPK0YsTUFBTUUsT0FBTyxDQUFDLENBQUdBLENBQUFBLE9BQU9BLElBQUl0SCxRQUFRLEtBQUssS0FFL0Msc0JBQXNCO1FBQ3RCLHFDQUFxQztRQUNyQ29ILENBQUFBLEVBQUVELFFBQVEsR0FDVEMsRUFBRUQsUUFBUSxDQUFFRyxPQUNaRixFQUFFRyx1QkFBdUIsSUFBSUgsRUFBRUcsdUJBQXVCLENBQUVELE9BQVEsRUFBQyxDQUNuRTtJQUNEO0lBS0Esc0NBQXNDO0lBQ3RDLDREQUE0RDtJQUM1RCxJQUFJRSxhQUFhO0lBRWpCLFNBQVNDLFdBQVlDLEVBQUUsRUFBRUMsV0FBVztRQUNuQyxJQUFLQSxhQUFjO1lBRWxCLG1EQUFtRDtZQUNuRCxJQUFLRCxPQUFPLFFBQU87Z0JBQ2xCLE9BQU87WUFDUjtZQUVBLHNGQUFzRjtZQUN0RixPQUFPQSxHQUFHM0ksS0FBSyxDQUFFLEdBQUcsQ0FBQyxLQUFNLE9BQU8ySSxHQUFHRSxVQUFVLENBQUVGLEdBQUd4RixNQUFNLEdBQUcsR0FBSTFDLFFBQVEsQ0FBRSxNQUFPO1FBQ25GO1FBRUEsbUVBQW1FO1FBQ25FLE9BQU8sT0FBT2tJO0lBQ2Y7SUFFQWhHLE9BQU9tRyxjQUFjLEdBQUcsU0FBVUMsR0FBRztRQUNwQyxPQUFPLENBQUVBLE1BQU0sRUFBQyxFQUFJbkQsT0FBTyxDQUFFNkMsWUFBWUM7SUFDMUM7SUFLQSxJQUFJTSxlQUFlekosVUFDbEIwSixhQUFhM0k7SUFFWjtRQUVGLElBQUl1QixHQUNIcUgsTUFDQUMsa0JBQ0FDLFdBQ0FDLGNBQ0EvSSxPQUFPMkksWUFFUCxzQkFBc0I7UUFDdEIxSixVQUNBZ0gsaUJBQ0ErQyxnQkFDQUMsV0FDQWpDLFNBRUEseUJBQXlCO1FBQ3pCN0IsVUFBVTlDLE9BQU84QyxPQUFPLEVBQ3hCK0QsVUFBVSxHQUNWQyxPQUFPLEdBQ1BDLGFBQWFDLGVBQ2JDLGFBQWFELGVBQ2JFLGdCQUFnQkYsZUFDaEJHLHlCQUF5QkgsZUFDekJJLFlBQVksU0FBVTFCLENBQUMsRUFBRUMsQ0FBQztZQUN6QixJQUFLRCxNQUFNQyxHQUFJO2dCQUNkZSxlQUFlO1lBQ2hCO1lBQ0EsT0FBTztRQUNSLEdBRUFXLFdBQVcsb0ZBQ1YsK0NBRUQsc0JBQXNCO1FBRXRCLDBEQUEwRDtRQUMxREMsYUFBYSw0QkFBNEJoQyxhQUN4Qyw2Q0FFRCw0RUFBNEU7UUFDNUVpQyxhQUFhLFFBQVFqQyxhQUFhLE9BQU9nQyxhQUFhLFNBQVNoQyxhQUU5RCx1QkFBdUI7UUFDdkIsa0JBQWtCQSxhQUVsQiw2RkFBNkY7UUFDN0YsNkRBQTZEZ0MsYUFBYSxTQUMxRWhDLGFBQWEsUUFFZGtDLFVBQVUsT0FBT0YsYUFBYSxhQUU3Qix5RkFBeUY7UUFDekYsZ0RBQWdEO1FBQ2hELDBEQUVBLHdCQUF3QjtRQUN4Qiw2QkFBNkJDLGFBQWEsU0FFMUMsK0JBQStCO1FBQy9CLE9BQ0EsVUFFRCw2R0FBNkc7UUFDN0dFLGNBQWMsSUFBSWpDLE9BQVFGLGFBQWEsS0FBSyxNQUU1Q29DLFNBQVMsSUFBSWxDLE9BQVEsTUFBTUYsYUFBYSxPQUFPQSxhQUFhLE1BQzVEcUMscUJBQXFCLElBQUluQyxPQUFRLE1BQU1GLGFBQWEsYUFBYUEsYUFBYSxNQUM3RUEsYUFBYSxNQUNkc0MsV0FBVyxJQUFJcEMsT0FBUUYsYUFBYSxPQUVwQ3VDLFVBQVUsSUFBSXJDLE9BQVFnQyxVQUN0Qk0sY0FBYyxJQUFJdEMsT0FBUSxNQUFNOEIsYUFBYSxNQUU3Q1MsWUFBWTtZQUNYQyxJQUFJLElBQUl4QyxPQUFRLFFBQVE4QixhQUFhO1lBQ3JDVyxPQUFPLElBQUl6QyxPQUFRLFVBQVU4QixhQUFhO1lBQzFDWSxLQUFLLElBQUkxQyxPQUFRLE9BQU84QixhQUFhO1lBQ3JDYSxNQUFNLElBQUkzQyxPQUFRLE1BQU0rQjtZQUN4QmEsUUFBUSxJQUFJNUMsT0FBUSxNQUFNZ0M7WUFDMUJhLE9BQU8sSUFBSTdDLE9BQ1YsMkRBQ0NGLGFBQWEsaUNBQWlDQSxhQUFhLGdCQUMzREEsYUFBYSxlQUFlQSxhQUFhLFVBQVU7WUFDckRnRCxNQUFNLElBQUk5QyxPQUFRLFNBQVM2QixXQUFXLE1BQU07WUFFNUMsMENBQTBDO1lBQzFDLDJDQUEyQztZQUMzQ2tCLGNBQWMsSUFBSS9DLE9BQVEsTUFBTUYsYUFDL0IscURBQXFEQSxhQUNyRCxxQkFBcUJBLGFBQWEsb0JBQW9CO1FBQ3hELEdBRUFrRCxVQUFVLHVDQUNWQyxVQUFVLFVBRVYsNERBQTREO1FBQzVEQyxhQUFhLG9DQUViQyxXQUFXLFFBRVgsY0FBYztRQUNkLDhEQUE4RDtRQUM5REMsWUFBWSxJQUFJcEQsT0FBUSx5QkFBeUJGLGFBQ2hELHdCQUF3QixNQUN6QnVELFlBQVksU0FBVUMsTUFBTSxFQUFFQyxNQUFNO1lBQ25DLElBQUlDLE9BQU8sT0FBT0YsT0FBT3pMLEtBQUssQ0FBRSxLQUFNO1lBRXRDLElBQUswTCxRQUFTO2dCQUViLDREQUE0RDtnQkFDNUQsT0FBT0E7WUFDUjtZQUVBLDRFQUE0RTtZQUM1RSxvQkFBb0I7WUFDcEIsOEVBQThFO1lBQzlFLGlCQUFpQjtZQUNqQixPQUFPQyxPQUFPLElBQ2JDLE9BQU9DLFlBQVksQ0FBRUYsT0FBTyxXQUM1QkMsT0FBT0MsWUFBWSxDQUFFRixRQUFRLEtBQUssUUFBUUEsT0FBTyxRQUFRO1FBQzNELEdBRUEsdUNBQXVDO1FBQ3ZDLHFDQUFxQztRQUNyQyw2REFBNkQ7UUFDN0Qsb0JBQW9CO1FBQ3BCRyxnQkFBZ0I7WUFDZkM7UUFDRCxHQUVBQyxxQkFBcUJDLGNBQ3BCLFNBQVVsSSxJQUFJO1lBQ2IsT0FBT0EsS0FBS21JLFFBQVEsS0FBSyxRQUFRaEYsU0FBVW5ELE1BQU07UUFDbEQsR0FDQTtZQUFFb0ksS0FBSztZQUFjQyxNQUFNO1FBQVM7UUFHdEMsdUJBQXVCO1FBQ3ZCLDBEQUEwRDtRQUMxRCx1Q0FBdUM7UUFDdkMsU0FBU0M7WUFDUixJQUFJO2dCQUNILE9BQU85TSxTQUFTK00sYUFBYTtZQUM5QixFQUFFLE9BQVFDLEtBQU0sQ0FBRTtRQUNuQjtRQUVBLHlDQUF5QztRQUN6QyxJQUFJO1lBQ0hqTSxLQUFLRCxLQUFLLENBQ1BULE1BQU1JLE1BQU1HLElBQUksQ0FBRTZJLGFBQWF3RCxVQUFVLEdBQzNDeEQsYUFBYXdELFVBQVU7WUFHeEIseUJBQXlCO1lBQ3pCLHFDQUFxQztZQUNyQyxpREFBaUQ7WUFDakQ1TSxHQUFHLENBQUVvSixhQUFhd0QsVUFBVSxDQUFDckosTUFBTSxDQUFFLENBQUNsQyxRQUFRO1FBQy9DLEVBQUUsT0FBUXdMLEdBQUk7WUFDYm5NLE9BQU87Z0JBQ05ELE9BQU8sU0FBVThFLE1BQU0sRUFBRXVILEdBQUc7b0JBQzNCekQsV0FBVzVJLEtBQUssQ0FBRThFLFFBQVFuRixNQUFNRyxJQUFJLENBQUV1TTtnQkFDdkM7Z0JBQ0F2TSxNQUFNLFNBQVVnRixNQUFNO29CQUNyQjhELFdBQVc1SSxLQUFLLENBQUU4RSxRQUFRbkYsTUFBTUcsSUFBSSxDQUFFNkQsV0FBVztnQkFDbEQ7WUFDRDtRQUNEO1FBRUEsU0FBUzJJLEtBQU0vSixRQUFRLEVBQUVDLE9BQU8sRUFBRTZELE9BQU8sRUFBRWtHLElBQUk7WUFDOUMsSUFBSUMsR0FBR2hMLEdBQUdrQyxNQUFNK0ksS0FBS0MsT0FBT0MsUUFBUUMsYUFDbkNDLGFBQWFySyxXQUFXQSxRQUFRbUUsYUFBYSxFQUU3Qyw2REFBNkQ7WUFDN0QvRixXQUFXNEIsVUFBVUEsUUFBUTVCLFFBQVEsR0FBRztZQUV6Q3lGLFVBQVVBLFdBQVcsRUFBRTtZQUV2QiwyREFBMkQ7WUFDM0QsSUFBSyxPQUFPOUQsYUFBYSxZQUFZLENBQUNBLFlBQ3JDM0IsYUFBYSxLQUFLQSxhQUFhLEtBQUtBLGFBQWEsSUFBSztnQkFFdEQsT0FBT3lGO1lBQ1I7WUFFQSw0RUFBNEU7WUFDNUUsSUFBSyxDQUFDa0csTUFBTztnQkFDWmIsWUFBYWxKO2dCQUNiQSxVQUFVQSxXQUFXdEQ7Z0JBRXJCLElBQUsrSixnQkFBaUI7b0JBRXJCLDJFQUEyRTtvQkFDM0Usc0VBQXNFO29CQUN0RSxJQUFLckksYUFBYSxNQUFROEwsQ0FBQUEsUUFBUTFCLFdBQVc4QixJQUFJLENBQUV2SyxTQUFTLEdBQU07d0JBRWpFLGNBQWM7d0JBQ2QsSUFBT2lLLElBQUlFLEtBQUssQ0FBRSxFQUFHLEVBQUs7NEJBRXpCLG1CQUFtQjs0QkFDbkIsSUFBSzlMLGFBQWEsR0FBSTtnQ0FDckIsSUFBTzhDLE9BQU9sQixRQUFRdUssY0FBYyxDQUFFUCxJQUFRO29DQUU3QyxxQkFBcUI7b0NBQ3JCLDBEQUEwRDtvQ0FDMUQsSUFBSzlJLEtBQUtzSixFQUFFLEtBQUtSLEdBQUk7d0NBQ3BCdk0sS0FBS0gsSUFBSSxDQUFFdUcsU0FBUzNDO3dDQUNwQixPQUFPMkM7b0NBQ1I7Z0NBQ0QsT0FBTztvQ0FDTixPQUFPQTtnQ0FDUjs0QkFFRCxrQkFBa0I7NEJBQ2xCLE9BQU87Z0NBRU4scUJBQXFCO2dDQUNyQiwwREFBMEQ7Z0NBQzFELElBQUt3RyxjQUFnQm5KLENBQUFBLE9BQU9tSixXQUFXRSxjQUFjLENBQUVQLEVBQUUsS0FDeERGLEtBQUt2RSxRQUFRLENBQUV2RixTQUFTa0IsU0FDeEJBLEtBQUtzSixFQUFFLEtBQUtSLEdBQUk7b0NBRWhCdk0sS0FBS0gsSUFBSSxDQUFFdUcsU0FBUzNDO29DQUNwQixPQUFPMkM7Z0NBQ1I7NEJBQ0Q7d0JBRUQsZ0JBQWdCO3dCQUNoQixPQUFPLElBQUtxRyxLQUFLLENBQUUsRUFBRyxFQUFHOzRCQUN4QnpNLEtBQUtELEtBQUssQ0FBRXFHLFNBQVM3RCxRQUFReUssb0JBQW9CLENBQUUxSzs0QkFDbkQsT0FBTzhEO3dCQUVSLGlCQUFpQjt3QkFDakIsT0FBTyxJQUFLLENBQUVtRyxJQUFJRSxLQUFLLENBQUUsRUFBRyxLQUFNbEssUUFBUTBLLHNCQUFzQixFQUFHOzRCQUNsRWpOLEtBQUtELEtBQUssQ0FBRXFHLFNBQVM3RCxRQUFRMEssc0JBQXNCLENBQUVWOzRCQUNyRCxPQUFPbkc7d0JBQ1I7b0JBQ0Q7b0JBRUEscUNBQXFDO29CQUNyQyxJQUFLLENBQUNvRCxzQkFBc0IsQ0FBRWxILFdBQVcsSUFBSyxJQUMzQyxFQUFDMkcsYUFBYSxDQUFDQSxVQUFVdEMsSUFBSSxDQUFFckUsU0FBUyxHQUFNO3dCQUVoRHFLLGNBQWNySzt3QkFDZHNLLGFBQWFySzt3QkFFYix5RUFBeUU7d0JBQ3pFLHFEQUFxRDt3QkFDckQsZ0ZBQWdGO3dCQUNoRiwwREFBMEQ7d0JBQzFELHlFQUF5RTt3QkFDekUsNERBQTREO3dCQUM1RCw4Q0FBOEM7d0JBQzlDLElBQUs1QixhQUFhLEtBQ2ZzSixDQUFBQSxTQUFTdEQsSUFBSSxDQUFFckUsYUFBYzBILG1CQUFtQnJELElBQUksQ0FBRXJFLFNBQVMsR0FBTTs0QkFFdkUsdUNBQXVDOzRCQUN2Q3NLLGFBQWE1QixTQUFTckUsSUFBSSxDQUFFckUsYUFBYzRLLFlBQWEzSyxRQUFRUCxVQUFVLEtBQ3hFTzs0QkFFRCwwREFBMEQ7NEJBQzFELG1EQUFtRDs0QkFDbkQsaUNBQWlDOzRCQUNqQywyREFBMkQ7NEJBQzNELDREQUE0RDs0QkFDNUQsa0NBQWtDOzRCQUNsQyxJQUFLcUssY0FBY3JLLFdBQVcsQ0FBQy9CLFFBQVEyTSxLQUFLLEVBQUc7Z0NBRTlDLHdEQUF3RDtnQ0FDeEQsSUFBT1gsTUFBTWpLLFFBQVFYLFlBQVksQ0FBRSxPQUFXO29DQUM3QzRLLE1BQU1uSyxPQUFPbUcsY0FBYyxDQUFFZ0U7Z0NBQzlCLE9BQU87b0NBQ05qSyxRQUFRVixZQUFZLENBQUUsTUFBUTJLLE1BQU1ySDtnQ0FDckM7NEJBQ0Q7NEJBRUEsb0NBQW9DOzRCQUNwQ3VILFNBQVNVLFNBQVU5Szs0QkFDbkJmLElBQUltTCxPQUFPN0osTUFBTTs0QkFDakIsTUFBUXRCLElBQU07Z0NBQ2JtTCxNQUFNLENBQUVuTCxFQUFHLEdBQUcsQ0FBRWlMLE1BQU0sTUFBTUEsTUFBTSxRQUFPLElBQU0sTUFDOUNhLFdBQVlYLE1BQU0sQ0FBRW5MLEVBQUc7NEJBQ3pCOzRCQUNBb0wsY0FBY0QsT0FBT1ksSUFBSSxDQUFFO3dCQUM1Qjt3QkFFQSxJQUFJOzRCQUNIdE4sS0FBS0QsS0FBSyxDQUFFcUcsU0FDWHdHLFdBQVdXLGdCQUFnQixDQUFFWjs0QkFFOUIsT0FBT3ZHO3dCQUNSLEVBQUUsT0FBUW9ILFVBQVc7NEJBQ3BCaEUsdUJBQXdCbEgsVUFBVTt3QkFDbkMsU0FBVTs0QkFDVCxJQUFLa0ssUUFBUXJILFNBQVU7Z0NBQ3RCNUMsUUFBUWtMLGVBQWUsQ0FBRTs0QkFDMUI7d0JBQ0Q7b0JBQ0Q7Z0JBQ0Q7WUFDRDtZQUVBLGFBQWE7WUFDYixPQUFPQyxPQUFRcEwsU0FBU2dELE9BQU8sQ0FBRXNDLFVBQVUsT0FBUXJGLFNBQVM2RCxTQUFTa0c7UUFDdEU7UUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNqRDtZQUNSLElBQUlzRSxPQUFPLEVBQUU7WUFFYixTQUFTQyxNQUFPQyxHQUFHLEVBQUUxRyxLQUFLO2dCQUV6QixzRUFBc0U7Z0JBQ3RFLG9EQUFvRDtnQkFDcEQsSUFBS3dHLEtBQUszTixJQUFJLENBQUU2TixNQUFNLE9BQVFqRixLQUFLa0YsV0FBVyxFQUFHO29CQUVoRCxvQ0FBb0M7b0JBQ3BDLE9BQU9GLEtBQUssQ0FBRUQsS0FBS0ksS0FBSyxHQUFJO2dCQUM3QjtnQkFDQSxPQUFTSCxLQUFLLENBQUVDLE1BQU0sSUFBSyxHQUFHMUc7WUFDL0I7WUFDQSxPQUFPeUc7UUFDUjtRQUVBOzs7Q0FHQyxHQUNELFNBQVNJLGFBQWN4TCxFQUFFO1lBQ3hCQSxFQUFFLENBQUUyQyxRQUFTLEdBQUc7WUFDaEIsT0FBTzNDO1FBQ1I7UUFFQTs7O0NBR0MsR0FDRCxTQUFTeUwsT0FBUXpMLEVBQUU7WUFDbEIsSUFBSTBMLEtBQUtqUCxTQUFTeUMsYUFBYSxDQUFFO1lBRWpDLElBQUk7Z0JBQ0gsT0FBTyxDQUFDLENBQUNjLEdBQUkwTDtZQUNkLEVBQUUsT0FBUS9CLEdBQUk7Z0JBQ2IsT0FBTztZQUNSLFNBQVU7Z0JBRVQsb0NBQW9DO2dCQUNwQyxJQUFLK0IsR0FBR2xNLFVBQVUsRUFBRztvQkFDcEJrTSxHQUFHbE0sVUFBVSxDQUFDQyxXQUFXLENBQUVpTTtnQkFDNUI7Z0JBRUEsdUJBQXVCO2dCQUN2QkEsS0FBSztZQUNOO1FBQ0Q7UUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxrQkFBbUJwTixJQUFJO1lBQy9CLE9BQU8sU0FBVTBDLElBQUk7Z0JBQ3BCLE9BQU9tRCxTQUFVbkQsTUFBTSxZQUFhQSxLQUFLMUMsSUFBSSxLQUFLQTtZQUNuRDtRQUNEO1FBRUE7OztDQUdDLEdBQ0QsU0FBU3FOLG1CQUFvQnJOLElBQUk7WUFDaEMsT0FBTyxTQUFVMEMsSUFBSTtnQkFDcEIsT0FBTyxDQUFFbUQsU0FBVW5ELE1BQU0sWUFBYW1ELFNBQVVuRCxNQUFNLFNBQVMsS0FDOURBLEtBQUsxQyxJQUFJLEtBQUtBO1lBQ2hCO1FBQ0Q7UUFFQTs7O0NBR0MsR0FDRCxTQUFTc04scUJBQXNCekMsUUFBUTtZQUV0Qyw2RkFBNkY7WUFDN0YsT0FBTyxTQUFVbkksSUFBSTtnQkFFcEIsd0RBQXdEO2dCQUN4RCx5RUFBeUU7Z0JBQ3pFLDBFQUEwRTtnQkFDMUUsSUFBSyxVQUFVQSxNQUFPO29CQUVyQixzRUFBc0U7b0JBQ3RFLDJEQUEyRDtvQkFDM0Qsc0VBQXNFO29CQUN0RSwwRUFBMEU7b0JBQzFFLDJDQUEyQztvQkFDM0MsOEVBQThFO29CQUM5RSw0Q0FBNEM7b0JBQzVDLElBQUtBLEtBQUt6QixVQUFVLElBQUl5QixLQUFLbUksUUFBUSxLQUFLLE9BQVE7d0JBRWpELHdEQUF3RDt3QkFDeEQsSUFBSyxXQUFXbkksTUFBTzs0QkFDdEIsSUFBSyxXQUFXQSxLQUFLekIsVUFBVSxFQUFHO2dDQUNqQyxPQUFPeUIsS0FBS3pCLFVBQVUsQ0FBQzRKLFFBQVEsS0FBS0E7NEJBQ3JDLE9BQU87Z0NBQ04sT0FBT25JLEtBQUttSSxRQUFRLEtBQUtBOzRCQUMxQjt3QkFDRDt3QkFFQSxzQkFBc0I7d0JBQ3RCLGdGQUFnRjt3QkFDaEYsT0FBT25JLEtBQUs2SyxVQUFVLEtBQUsxQyxZQUUxQiwrQ0FBK0M7d0JBQy9DbkksS0FBSzZLLFVBQVUsS0FBSyxDQUFDMUMsWUFDcEJGLG1CQUFvQmpJLFVBQVdtSTtvQkFDbEM7b0JBRUEsT0FBT25JLEtBQUttSSxRQUFRLEtBQUtBO2dCQUUxQiwyRkFBMkY7Z0JBQzNGLG9GQUFvRjtnQkFDcEYsc0RBQXNEO2dCQUN0RCxPQUFPLElBQUssV0FBV25JLE1BQU87b0JBQzdCLE9BQU9BLEtBQUttSSxRQUFRLEtBQUtBO2dCQUMxQjtnQkFFQSx3REFBd0Q7Z0JBQ3hELE9BQU87WUFDUjtRQUNEO1FBRUE7OztDQUdDLEdBQ0QsU0FBUzJDLHVCQUF3Qi9MLEVBQUU7WUFDbEMsT0FBT3dMLGFBQWMsU0FBVVEsUUFBUTtnQkFDdENBLFdBQVcsQ0FBQ0E7Z0JBQ1osT0FBT1IsYUFBYyxTQUFVMUIsSUFBSSxFQUFFdEYsT0FBTztvQkFDM0MsSUFBSTdDLEdBQ0hzSyxlQUFlak0sR0FBSSxFQUFFLEVBQUU4SixLQUFLekosTUFBTSxFQUFFMkwsV0FDcENqTixJQUFJa04sYUFBYTVMLE1BQU07b0JBRXhCLGdEQUFnRDtvQkFDaEQsTUFBUXRCLElBQU07d0JBQ2IsSUFBSytLLElBQUksQ0FBSW5JLElBQUlzSyxZQUFZLENBQUVsTixFQUFHLENBQUksRUFBRzs0QkFDeEMrSyxJQUFJLENBQUVuSSxFQUFHLEdBQUcsQ0FBRzZDLENBQUFBLE9BQU8sQ0FBRTdDLEVBQUcsR0FBR21JLElBQUksQ0FBRW5JLEVBQUc7d0JBQ3hDO29CQUNEO2dCQUNEO1lBQ0Q7UUFDRDtRQUVBOzs7O0NBSUMsR0FDRCxTQUFTK0ksWUFBYTNLLE9BQU87WUFDNUIsT0FBT0EsV0FBVyxPQUFPQSxRQUFReUssb0JBQW9CLEtBQUssZUFBZXpLO1FBQzFFO1FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNrSixZQUFhcEssSUFBSTtZQUN6QixJQUFJcU4sV0FDSHBOLE1BQU1ELE9BQU9BLEtBQUtxRixhQUFhLElBQUlyRixPQUFPcUg7WUFFM0MscURBQXFEO1lBQ3JELGlDQUFpQztZQUNqQyw0RUFBNEU7WUFDNUUsMkNBQTJDO1lBQzNDLGtDQUFrQztZQUNsQyxJQUFLcEgsT0FBT3JDLFlBQVlxQyxJQUFJWCxRQUFRLEtBQUssS0FBSyxDQUFDVyxJQUFJMkUsZUFBZSxFQUFHO2dCQUNwRSxPQUFPaEg7WUFDUjtZQUVBLDBCQUEwQjtZQUMxQkEsV0FBV3FDO1lBQ1gyRSxrQkFBa0JoSCxTQUFTZ0gsZUFBZTtZQUMxQytDLGlCQUFpQixDQUFDM0csT0FBT2lFLFFBQVEsQ0FBRXJIO1lBRW5DLGtDQUFrQztZQUNsQyxzREFBc0Q7WUFDdEQrSCxVQUFVZixnQkFBZ0JlLE9BQU8sSUFDaENmLGdCQUFnQjBJLHFCQUFxQixJQUNyQzFJLGdCQUFnQjJJLGlCQUFpQjtZQUVsQyxxQ0FBcUM7WUFDckMsNEVBQTRFO1lBQzVFLG9CQUFvQjtZQUNwQiw4RUFBOEU7WUFDOUUsNEVBQTRFO1lBQzVFLElBQUszSSxnQkFBZ0IySSxpQkFBaUIsSUFFckMsaUNBQWlDO1lBQ2pDLDRFQUE0RTtZQUM1RSwyQ0FBMkM7WUFDM0Msa0NBQWtDO1lBQ2xDbEcsZ0JBQWdCekosWUFDZHlQLENBQUFBLFlBQVl6UCxTQUFTNFAsV0FBVyxLQUFNSCxVQUFVSSxHQUFHLEtBQUtKLFdBQVk7Z0JBRXRFLHFDQUFxQztnQkFDckNBLFVBQVVLLGdCQUFnQixDQUFFLFVBQVV2RDtZQUN2QztZQUVBLGtCQUFrQjtZQUNsQixtREFBbUQ7WUFDbkQsOEVBQThFO1lBQzlFLDZDQUE2QztZQUM3Q2hMLFFBQVF3TyxPQUFPLEdBQUdmLE9BQVEsU0FBVUMsRUFBRTtnQkFDckNqSSxnQkFBZ0JsRSxXQUFXLENBQUVtTSxJQUFLbkIsRUFBRSxHQUFHMUssT0FBTzhDLE9BQU87Z0JBQ3JELE9BQU8sQ0FBQ2xHLFNBQVNnUSxpQkFBaUIsSUFDakMsQ0FBQ2hRLFNBQVNnUSxpQkFBaUIsQ0FBRTVNLE9BQU84QyxPQUFPLEVBQUd0QyxNQUFNO1lBQ3REO1lBRUEscUJBQXFCO1lBQ3JCLHNEQUFzRDtZQUN0RCwwQkFBMEI7WUFDMUJyQyxRQUFRME8saUJBQWlCLEdBQUdqQixPQUFRLFNBQVVDLEVBQUU7Z0JBQy9DLE9BQU9sSCxRQUFRbkgsSUFBSSxDQUFFcU8sSUFBSTtZQUMxQjtZQUVBLHFDQUFxQztZQUNyQyxpREFBaUQ7WUFDakQxTixRQUFRMk0sS0FBSyxHQUFHYyxPQUFRO2dCQUN2QixPQUFPaFAsU0FBU3NPLGdCQUFnQixDQUFFO1lBQ25DO1lBRUEsMERBQTBEO1lBQzFELDJEQUEyRDtZQUMzRCxzRUFBc0U7WUFDdEUsd0VBQXdFO1lBQ3hFLHVCQUF1QjtZQUN2Qix5RUFBeUU7WUFDekUsd0VBQXdFO1lBQ3hFLDJFQUEyRTtZQUMzRSxVQUFVO1lBQ1YvTSxRQUFRMk8sTUFBTSxHQUFHbEIsT0FBUTtnQkFDeEIsSUFBSTtvQkFDSGhQLFNBQVNtUSxhQUFhLENBQUU7b0JBQ3hCLE9BQU87Z0JBQ1IsRUFBRSxPQUFRakQsR0FBSTtvQkFDYixPQUFPO2dCQUNSO1lBQ0Q7WUFFQSxxQkFBcUI7WUFDckIsSUFBSzNMLFFBQVF3TyxPQUFPLEVBQUc7Z0JBQ3RCcEcsS0FBS3lHLE1BQU0sQ0FBQ2hGLEVBQUUsR0FBRyxTQUFVMEMsRUFBRTtvQkFDNUIsSUFBSXVDLFNBQVN2QyxHQUFHekgsT0FBTyxDQUFFMkYsV0FBV0M7b0JBQ3BDLE9BQU8sU0FBVXpILElBQUk7d0JBQ3BCLE9BQU9BLEtBQUs3QixZQUFZLENBQUUsVUFBVzBOO29CQUN0QztnQkFDRDtnQkFDQTFHLEtBQUt5RCxJQUFJLENBQUNoQyxFQUFFLEdBQUcsU0FBVTBDLEVBQUUsRUFBRXhLLE9BQU87b0JBQ25DLElBQUssT0FBT0EsUUFBUXVLLGNBQWMsS0FBSyxlQUFlOUQsZ0JBQWlCO3dCQUN0RSxJQUFJdkYsT0FBT2xCLFFBQVF1SyxjQUFjLENBQUVDO3dCQUNuQyxPQUFPdEosT0FBTzs0QkFBRUE7eUJBQU0sR0FBRyxFQUFFO29CQUM1QjtnQkFDRDtZQUNELE9BQU87Z0JBQ05tRixLQUFLeUcsTUFBTSxDQUFDaEYsRUFBRSxHQUFJLFNBQVUwQyxFQUFFO29CQUM3QixJQUFJdUMsU0FBU3ZDLEdBQUd6SCxPQUFPLENBQUUyRixXQUFXQztvQkFDcEMsT0FBTyxTQUFVekgsSUFBSTt3QkFDcEIsSUFBSXBDLE9BQU8sT0FBT29DLEtBQUs4TCxnQkFBZ0IsS0FBSyxlQUMzQzlMLEtBQUs4TCxnQkFBZ0IsQ0FBRTt3QkFDeEIsT0FBT2xPLFFBQVFBLEtBQUs4RixLQUFLLEtBQUttSTtvQkFDL0I7Z0JBQ0Q7Z0JBRUEseUJBQXlCO2dCQUN6QixvREFBb0Q7Z0JBQ3BEMUcsS0FBS3lELElBQUksQ0FBQ2hDLEVBQUUsR0FBRyxTQUFVMEMsRUFBRSxFQUFFeEssT0FBTztvQkFDbkMsSUFBSyxPQUFPQSxRQUFRdUssY0FBYyxLQUFLLGVBQWU5RCxnQkFBaUI7d0JBQ3RFLElBQUkzSCxNQUFNRSxHQUFHMkIsT0FDWk8sT0FBT2xCLFFBQVF1SyxjQUFjLENBQUVDO3dCQUVoQyxJQUFLdEosTUFBTzs0QkFFWCwwQkFBMEI7NEJBQzFCcEMsT0FBT29DLEtBQUs4TCxnQkFBZ0IsQ0FBRTs0QkFDOUIsSUFBS2xPLFFBQVFBLEtBQUs4RixLQUFLLEtBQUs0RixJQUFLO2dDQUNoQyxPQUFPO29DQUFFdEo7aUNBQU07NEJBQ2hCOzRCQUVBLGlDQUFpQzs0QkFDakNQLFFBQVFYLFFBQVEwTSxpQkFBaUIsQ0FBRWxDOzRCQUNuQ3hMLElBQUk7NEJBQ0osTUFBVWtDLE9BQU9QLEtBQUssQ0FBRTNCLElBQUssQ0FBSztnQ0FDakNGLE9BQU9vQyxLQUFLOEwsZ0JBQWdCLENBQUU7Z0NBQzlCLElBQUtsTyxRQUFRQSxLQUFLOEYsS0FBSyxLQUFLNEYsSUFBSztvQ0FDaEMsT0FBTzt3Q0FBRXRKO3FDQUFNO2dDQUNoQjs0QkFDRDt3QkFDRDt3QkFFQSxPQUFPLEVBQUU7b0JBQ1Y7Z0JBQ0Q7WUFDRDtZQUVBLE1BQU07WUFDTm1GLEtBQUt5RCxJQUFJLENBQUM5QixHQUFHLEdBQUcsU0FBVWlGLEdBQUcsRUFBRWpOLE9BQU87Z0JBQ3JDLElBQUssT0FBT0EsUUFBUXlLLG9CQUFvQixLQUFLLGFBQWM7b0JBQzFELE9BQU96SyxRQUFReUssb0JBQW9CLENBQUV3QztnQkFFdEMsMENBQTBDO2dCQUMxQyxPQUFPO29CQUNOLE9BQU9qTixRQUFRZ0wsZ0JBQWdCLENBQUVpQztnQkFDbEM7WUFDRDtZQUVBLFFBQVE7WUFDUjVHLEtBQUt5RCxJQUFJLENBQUMvQixLQUFLLEdBQUcsU0FBVW1GLFNBQVMsRUFBRWxOLE9BQU87Z0JBQzdDLElBQUssT0FBT0EsUUFBUTBLLHNCQUFzQixLQUFLLGVBQWVqRSxnQkFBaUI7b0JBQzlFLE9BQU96RyxRQUFRMEssc0JBQXNCLENBQUV3QztnQkFDeEM7WUFDRDtZQUVBO3dFQUN1RSxHQUV2RSxrQ0FBa0M7WUFFbEN4RyxZQUFZLEVBQUU7WUFFZCxrQkFBa0I7WUFDbEIsMkNBQTJDO1lBQzNDZ0YsT0FBUSxTQUFVQyxFQUFFO2dCQUVuQixJQUFJd0I7Z0JBRUp6SixnQkFBZ0JsRSxXQUFXLENBQUVtTSxJQUFLeUIsU0FBUyxHQUMxQyxZQUFZeEssVUFBVSx1Q0FDdEIsaUJBQWlCQSxVQUFVLGdDQUMzQjtnQkFFRCw0QkFBNEI7Z0JBQzVCLGlGQUFpRjtnQkFDakYsSUFBSyxDQUFDK0ksR0FBR1gsZ0JBQWdCLENBQUUsY0FBZTFLLE1BQU0sRUFBRztvQkFDbERvRyxVQUFVakosSUFBSSxDQUFFLFFBQVEySCxhQUFhLGVBQWUrQixXQUFXO2dCQUNoRTtnQkFFQSw0QkFBNEI7Z0JBQzVCLElBQUssQ0FBQ3dFLEdBQUdYLGdCQUFnQixDQUFFLFVBQVVwSSxVQUFVLE1BQU90QyxNQUFNLEVBQUc7b0JBQzlEb0csVUFBVWpKLElBQUksQ0FBRTtnQkFDakI7Z0JBRUEsc0JBQXNCO2dCQUN0QixpREFBaUQ7Z0JBQ2pELDBEQUEwRDtnQkFDMUQsSUFBSyxDQUFDa08sR0FBR1gsZ0JBQWdCLENBQUUsT0FBT3BJLFVBQVUsTUFBT3RDLE1BQU0sRUFBRztvQkFDM0RvRyxVQUFVakosSUFBSSxDQUFFO2dCQUNqQjtnQkFFQSx5REFBeUQ7Z0JBQ3pELHlFQUF5RTtnQkFDekUsMEVBQTBFO2dCQUMxRSx3REFBd0Q7Z0JBQ3hELElBQUssQ0FBQ2tPLEdBQUdYLGdCQUFnQixDQUFFLFlBQWExSyxNQUFNLEVBQUc7b0JBQ2hEb0csVUFBVWpKLElBQUksQ0FBRTtnQkFDakI7Z0JBRUEsaUNBQWlDO2dCQUNqQywyRUFBMkU7Z0JBQzNFMFAsUUFBUXpRLFNBQVN5QyxhQUFhLENBQUU7Z0JBQ2hDZ08sTUFBTTdOLFlBQVksQ0FBRSxRQUFRO2dCQUM1QnFNLEdBQUduTSxXQUFXLENBQUUyTixPQUFRN04sWUFBWSxDQUFFLFFBQVE7Z0JBRTlDLHNCQUFzQjtnQkFDdEIsOEVBQThFO2dCQUM5RSx5REFBeUQ7Z0JBQ3pELHlFQUF5RTtnQkFDekUsMEVBQTBFO2dCQUMxRSx3REFBd0Q7Z0JBQ3hEb0UsZ0JBQWdCbEUsV0FBVyxDQUFFbU0sSUFBS3RDLFFBQVEsR0FBRztnQkFDN0MsSUFBS3NDLEdBQUdYLGdCQUFnQixDQUFFLGFBQWMxSyxNQUFNLEtBQUssR0FBSTtvQkFDdERvRyxVQUFVakosSUFBSSxDQUFFLFlBQVk7Z0JBQzdCO2dCQUVBLGlDQUFpQztnQkFDakMsdUVBQXVFO2dCQUN2RSwwRUFBMEU7Z0JBQzFFLG9CQUFvQjtnQkFDcEIsNkRBQTZEO2dCQUM3RDBQLFFBQVF6USxTQUFTeUMsYUFBYSxDQUFFO2dCQUNoQ2dPLE1BQU03TixZQUFZLENBQUUsUUFBUTtnQkFDNUJxTSxHQUFHbk0sV0FBVyxDQUFFMk47Z0JBQ2hCLElBQUssQ0FBQ3hCLEdBQUdYLGdCQUFnQixDQUFFLGFBQWMxSyxNQUFNLEVBQUc7b0JBQ2pEb0csVUFBVWpKLElBQUksQ0FBRSxRQUFRMkgsYUFBYSxVQUFVQSxhQUFhLE9BQzNEQSxhQUFhO2dCQUNmO1lBQ0Q7WUFFQSxJQUFLLENBQUNuSCxRQUFRMk8sTUFBTSxFQUFHO2dCQUV0QixrREFBa0Q7Z0JBQ2xELHlFQUF5RTtnQkFDekUsb0VBQW9FO2dCQUNwRSw2RUFBNkU7Z0JBQzdFLDJFQUEyRTtnQkFDM0Usd0VBQXdFO2dCQUN4RWxHLFVBQVVqSixJQUFJLENBQUU7WUFDakI7WUFFQWlKLFlBQVlBLFVBQVVwRyxNQUFNLElBQUksSUFBSWdGLE9BQVFvQixVQUFVcUUsSUFBSSxDQUFFO1lBRTVEO3dFQUN1RSxHQUV2RSx5QkFBeUI7WUFDekI3RCxZQUFZLFNBQVUxQixDQUFDLEVBQUVDLENBQUM7Z0JBRXpCLDZCQUE2QjtnQkFDN0IsSUFBS0QsTUFBTUMsR0FBSTtvQkFDZGUsZUFBZTtvQkFDZixPQUFPO2dCQUNSO2dCQUVBLHlFQUF5RTtnQkFDekUsSUFBSTZHLFVBQVUsQ0FBQzdILEVBQUVHLHVCQUF1QixHQUFHLENBQUNGLEVBQUVFLHVCQUF1QjtnQkFDckUsSUFBSzBILFNBQVU7b0JBQ2QsT0FBT0E7Z0JBQ1I7Z0JBRUEsZ0VBQWdFO2dCQUNoRSxpQ0FBaUM7Z0JBQ2pDLDRFQUE0RTtnQkFDNUUsMkNBQTJDO2dCQUMzQyxrQ0FBa0M7Z0JBQ2xDQSxVQUFVLENBQUU3SCxFQUFFckIsYUFBYSxJQUFJcUIsQ0FBQUEsS0FBU0MsQ0FBQUEsRUFBRXRCLGFBQWEsSUFBSXNCLENBQUFBLElBQzFERCxFQUFFRyx1QkFBdUIsQ0FBRUYsS0FFM0IsMENBQTBDO2dCQUMxQztnQkFFRCxxQkFBcUI7Z0JBQ3JCLElBQUs0SCxVQUFVLEtBQ1osQ0FBQ3BQLFFBQVFxUCxZQUFZLElBQUk3SCxFQUFFRSx1QkFBdUIsQ0FBRUgsT0FBUTZILFNBQVk7b0JBRTFFLHFFQUFxRTtvQkFDckUsaUNBQWlDO29CQUNqQyw0RUFBNEU7b0JBQzVFLDJDQUEyQztvQkFDM0Msa0NBQWtDO29CQUNsQyxJQUFLN0gsTUFBTTlJLFlBQVk4SSxFQUFFckIsYUFBYSxJQUFJZ0MsZ0JBQ3pDMkQsS0FBS3ZFLFFBQVEsQ0FBRVksY0FBY1gsSUFBTTt3QkFDbkMsT0FBTyxDQUFDO29CQUNUO29CQUVBLGlDQUFpQztvQkFDakMsNEVBQTRFO29CQUM1RSwyQ0FBMkM7b0JBQzNDLGtDQUFrQztvQkFDbEMsSUFBS0MsTUFBTS9JLFlBQVkrSSxFQUFFdEIsYUFBYSxJQUFJZ0MsZ0JBQ3pDMkQsS0FBS3ZFLFFBQVEsQ0FBRVksY0FBY1YsSUFBTTt3QkFDbkMsT0FBTztvQkFDUjtvQkFFQSwwQkFBMEI7b0JBQzFCLE9BQU9jLFlBQ0o3SSxRQUFRSixJQUFJLENBQUVpSixXQUFXZixLQUFNOUgsUUFBUUosSUFBSSxDQUFFaUosV0FBV2QsS0FDMUQ7Z0JBQ0Y7Z0JBRUEsT0FBTzRILFVBQVUsSUFBSSxDQUFDLElBQUk7WUFDM0I7WUFFQSxPQUFPM1E7UUFDUjtRQUVBb04sS0FBS3JGLE9BQU8sR0FBRyxTQUFVOEksSUFBSSxFQUFFQyxRQUFRO1lBQ3RDLE9BQU8xRCxLQUFNeUQsTUFBTSxNQUFNLE1BQU1DO1FBQ2hDO1FBRUExRCxLQUFLMkQsZUFBZSxHQUFHLFNBQVV2TSxJQUFJLEVBQUVxTSxJQUFJO1lBQzFDckUsWUFBYWhJO1lBRWIsSUFBS3VGLGtCQUNKLENBQUNRLHNCQUFzQixDQUFFc0csT0FBTyxJQUFLLElBQ25DLEVBQUM3RyxhQUFhLENBQUNBLFVBQVV0QyxJQUFJLENBQUVtSixLQUFLLEdBQU07Z0JBRTVDLElBQUk7b0JBQ0gsSUFBSTNNLE1BQU02RCxRQUFRbkgsSUFBSSxDQUFFNEQsTUFBTXFNO29CQUU5Qiw2REFBNkQ7b0JBQzdELElBQUszTSxPQUFPM0MsUUFBUTBPLGlCQUFpQixJQUVuQywyREFBMkQ7b0JBQzNELG1CQUFtQjtvQkFDbkJ6TCxLQUFLeEUsUUFBUSxJQUFJd0UsS0FBS3hFLFFBQVEsQ0FBQzBCLFFBQVEsS0FBSyxJQUFLO3dCQUNsRCxPQUFPd0M7b0JBQ1I7Z0JBQ0QsRUFBRSxPQUFRZ0osR0FBSTtvQkFDYjNDLHVCQUF3QnNHLE1BQU07Z0JBQy9CO1lBQ0Q7WUFFQSxPQUFPekQsS0FBTXlELE1BQU03USxVQUFVLE1BQU07Z0JBQUV3RTthQUFNLEVBQUdaLE1BQU0sR0FBRztRQUN4RDtRQUVBd0osS0FBS3ZFLFFBQVEsR0FBRyxTQUFVdkYsT0FBTyxFQUFFa0IsSUFBSTtZQUV0Qyw4QkFBOEI7WUFDOUIsaUNBQWlDO1lBQ2pDLDRFQUE0RTtZQUM1RSwyQ0FBMkM7WUFDM0Msa0NBQWtDO1lBQ2xDLElBQUssQ0FBRWxCLFFBQVFtRSxhQUFhLElBQUluRSxPQUFNLEtBQU90RCxVQUFXO2dCQUN2RHdNLFlBQWFsSjtZQUNkO1lBQ0EsT0FBT0YsT0FBT3lGLFFBQVEsQ0FBRXZGLFNBQVNrQjtRQUNsQztRQUdBNEksS0FBSzRELElBQUksR0FBRyxTQUFVeE0sSUFBSSxFQUFFZ0IsSUFBSTtZQUUvQiw4QkFBOEI7WUFDOUIsaUNBQWlDO1lBQ2pDLDRFQUE0RTtZQUM1RSwyQ0FBMkM7WUFDM0Msa0NBQWtDO1lBQ2xDLElBQUssQ0FBRWhCLEtBQUtpRCxhQUFhLElBQUlqRCxJQUFHLEtBQU94RSxVQUFXO2dCQUNqRHdNLFlBQWFoSTtZQUNkO1lBRUEsSUFBSWpCLEtBQUtvRyxLQUFLc0gsVUFBVSxDQUFFekwsS0FBS2dELFdBQVcsR0FBSSxFQUU3QyxtRUFBbUU7WUFDbkVqRyxNQUFNZ0IsTUFBTXBDLE9BQU9QLElBQUksQ0FBRStJLEtBQUtzSCxVQUFVLEVBQUV6TCxLQUFLZ0QsV0FBVyxNQUN6RGpGLEdBQUlpQixNQUFNZ0IsTUFBTSxDQUFDdUUsa0JBQ2pCOUQ7WUFFRixJQUFLMUQsUUFBUTBELFdBQVk7Z0JBQ3hCLE9BQU8xRDtZQUNSO1lBRUEsT0FBT2lDLEtBQUs3QixZQUFZLENBQUU2QztRQUMzQjtRQUVBNEgsS0FBSzdHLEtBQUssR0FBRyxTQUFVQyxHQUFHO1lBQ3pCLE1BQU0sSUFBSXRHLE1BQU8sNENBQTRDc0c7UUFDOUQ7UUFFQTs7O0NBR0MsR0FDRHBELE9BQU84TixVQUFVLEdBQUcsU0FBVS9KLE9BQU87WUFDcEMsSUFBSTNDLE1BQ0gyTSxhQUFhLEVBQUUsRUFDZmpNLElBQUksR0FDSjVDLElBQUk7WUFFTCxtRUFBbUU7WUFDbkUsRUFBRTtZQUNGLDBCQUEwQjtZQUMxQiwrRUFBK0U7WUFDL0UsdUVBQXVFO1lBQ3ZFd0gsZUFBZSxDQUFDdkksUUFBUTZQLFVBQVU7WUFDbEN2SCxZQUFZLENBQUN0SSxRQUFRNlAsVUFBVSxJQUFJM1EsTUFBTUcsSUFBSSxDQUFFdUcsU0FBUztZQUN4RC9CLEtBQUt4RSxJQUFJLENBQUV1RyxTQUFTcUQ7WUFFcEIsSUFBS1YsY0FBZTtnQkFDbkIsTUFBVXRGLE9BQU8yQyxPQUFPLENBQUU3RSxJQUFLLENBQUs7b0JBQ25DLElBQUtrQyxTQUFTMkMsT0FBTyxDQUFFN0UsRUFBRyxFQUFHO3dCQUM1QjRDLElBQUlpTSxXQUFXcFEsSUFBSSxDQUFFdUI7b0JBQ3RCO2dCQUNEO2dCQUNBLE1BQVE0QyxJQUFNO29CQUNiRyxPQUFPekUsSUFBSSxDQUFFdUcsU0FBU2dLLFVBQVUsQ0FBRWpNLEVBQUcsRUFBRTtnQkFDeEM7WUFDRDtZQUVBLCtDQUErQztZQUMvQyxnREFBZ0Q7WUFDaEQyRSxZQUFZO1lBRVosT0FBTzFDO1FBQ1I7UUFFQS9ELE9BQU9HLEVBQUUsQ0FBQzJOLFVBQVUsR0FBRztZQUN0QixPQUFPLElBQUksQ0FBQ2xOLFNBQVMsQ0FBRVosT0FBTzhOLFVBQVUsQ0FBRXpRLE1BQU1LLEtBQUssQ0FBRSxJQUFJO1FBQzVEO1FBRUE2SSxPQUFPdkcsT0FBT3lOLElBQUksR0FBRztZQUVwQiw4QkFBOEI7WUFDOUJoQyxhQUFhO1lBRWJ3QyxjQUFjdEM7WUFFZHZCLE9BQU9yQztZQUVQOEYsWUFBWSxDQUFDO1lBRWI3RCxNQUFNLENBQUM7WUFFUGtFLFVBQVU7Z0JBQ1QsS0FBSztvQkFBRTFFLEtBQUs7b0JBQWNsSSxPQUFPO2dCQUFLO2dCQUN0QyxLQUFLO29CQUFFa0ksS0FBSztnQkFBYTtnQkFDekIsS0FBSztvQkFBRUEsS0FBSztvQkFBbUJsSSxPQUFPO2dCQUFLO2dCQUMzQyxLQUFLO29CQUFFa0ksS0FBSztnQkFBa0I7WUFDL0I7WUFFQTJFLFdBQVc7Z0JBQ1ZoRyxNQUFNLFNBQVVpQyxLQUFLO29CQUNwQkEsS0FBSyxDQUFFLEVBQUcsR0FBR0EsS0FBSyxDQUFFLEVBQUcsQ0FBQ25ILE9BQU8sQ0FBRTJGLFdBQVdDO29CQUU1Qyw4REFBOEQ7b0JBQzlEdUIsS0FBSyxDQUFFLEVBQUcsR0FBRyxDQUFFQSxLQUFLLENBQUUsRUFBRyxJQUFJQSxLQUFLLENBQUUsRUFBRyxJQUFJQSxLQUFLLENBQUUsRUFBRyxJQUFJLEVBQUMsRUFDeERuSCxPQUFPLENBQUUyRixXQUFXQztvQkFFdEIsSUFBS3VCLEtBQUssQ0FBRSxFQUFHLEtBQUssTUFBTzt3QkFDMUJBLEtBQUssQ0FBRSxFQUFHLEdBQUcsTUFBTUEsS0FBSyxDQUFFLEVBQUcsR0FBRztvQkFDakM7b0JBRUEsT0FBT0EsTUFBTS9NLEtBQUssQ0FBRSxHQUFHO2dCQUN4QjtnQkFFQWdMLE9BQU8sU0FBVStCLEtBQUs7b0JBRXJCOzs7Ozs7Ozs7R0FTQSxHQUNBQSxLQUFLLENBQUUsRUFBRyxHQUFHQSxLQUFLLENBQUUsRUFBRyxDQUFDaEYsV0FBVztvQkFFbkMsSUFBS2dGLEtBQUssQ0FBRSxFQUFHLENBQUMvTSxLQUFLLENBQUUsR0FBRyxPQUFRLE9BQVE7d0JBRXpDLDBCQUEwQjt3QkFDMUIsSUFBSyxDQUFDK00sS0FBSyxDQUFFLEVBQUcsRUFBRzs0QkFDbEJKLEtBQUs3RyxLQUFLLENBQUVpSCxLQUFLLENBQUUsRUFBRzt3QkFDdkI7d0JBRUEsbURBQW1EO3dCQUNuRCxvREFBb0Q7d0JBQ3BEQSxLQUFLLENBQUUsRUFBRyxHQUFHLENBQUdBLENBQUFBLEtBQUssQ0FBRSxFQUFHLEdBQ3pCQSxLQUFLLENBQUUsRUFBRyxHQUFLQSxDQUFBQSxLQUFLLENBQUUsRUFBRyxJQUFJLEtBQzdCLElBQU1BLENBQUFBLEtBQUssQ0FBRSxFQUFHLEtBQUssVUFBVUEsS0FBSyxDQUFFLEVBQUcsS0FBSyxLQUFJLENBQUU7d0JBRXJEQSxLQUFLLENBQUUsRUFBRyxHQUFHLENBQUcsTUFBTyxDQUFFLEVBQUcsR0FBR0EsS0FBSyxDQUFFLEVBQUcsSUFBTUEsS0FBSyxDQUFFLEVBQUcsS0FBSyxLQUFJO29CQUVuRSxpQ0FBaUM7b0JBQ2pDLE9BQU8sSUFBS0EsS0FBSyxDQUFFLEVBQUcsRUFBRzt3QkFDeEJKLEtBQUs3RyxLQUFLLENBQUVpSCxLQUFLLENBQUUsRUFBRztvQkFDdkI7b0JBRUEsT0FBT0E7Z0JBQ1I7Z0JBRUFoQyxRQUFRLFNBQVVnQyxLQUFLO29CQUN0QixJQUFJZ0UsUUFDSEMsV0FBVyxDQUFDakUsS0FBSyxDQUFFLEVBQUcsSUFBSUEsS0FBSyxDQUFFLEVBQUc7b0JBRXJDLElBQUtyQyxVQUFVTSxLQUFLLENBQUMvRCxJQUFJLENBQUU4RixLQUFLLENBQUUsRUFBRyxHQUFLO3dCQUN6QyxPQUFPO29CQUNSO29CQUVBLGdDQUFnQztvQkFDaEMsSUFBS0EsS0FBSyxDQUFFLEVBQUcsRUFBRzt3QkFDakJBLEtBQUssQ0FBRSxFQUFHLEdBQUdBLEtBQUssQ0FBRSxFQUFHLElBQUlBLEtBQUssQ0FBRSxFQUFHLElBQUk7b0JBRTFDLGtEQUFrRDtvQkFDbEQsT0FBTyxJQUFLaUUsWUFBWXhHLFFBQVF2RCxJQUFJLENBQUUrSixhQUVyQyx5Q0FBeUM7b0JBQ3ZDRCxDQUFBQSxTQUFTckQsU0FBVXNELFVBQVUsS0FBSyxLQUVwQywwQ0FBMEM7b0JBQ3hDRCxDQUFBQSxTQUFTQyxTQUFTelEsT0FBTyxDQUFFLEtBQUt5USxTQUFTN04sTUFBTSxHQUFHNE4sVUFBV0MsU0FBUzdOLE1BQU0sR0FBSzt3QkFFbkYsNkJBQTZCO3dCQUM3QjRKLEtBQUssQ0FBRSxFQUFHLEdBQUdBLEtBQUssQ0FBRSxFQUFHLENBQUMvTSxLQUFLLENBQUUsR0FBRytRO3dCQUNsQ2hFLEtBQUssQ0FBRSxFQUFHLEdBQUdpRSxTQUFTaFIsS0FBSyxDQUFFLEdBQUcrUTtvQkFDakM7b0JBRUEsOEVBQThFO29CQUM5RSxPQUFPaEUsTUFBTS9NLEtBQUssQ0FBRSxHQUFHO2dCQUN4QjtZQUNEO1lBRUEyUCxRQUFRO2dCQUVQOUUsS0FBSyxTQUFVb0csZ0JBQWdCO29CQUM5QixJQUFJQyxtQkFBbUJELGlCQUFpQnJMLE9BQU8sQ0FBRTJGLFdBQVdDLFdBQVl6RCxXQUFXO29CQUNuRixPQUFPa0oscUJBQXFCLE1BQzNCO3dCQUNDLE9BQU87b0JBQ1IsSUFDQSxTQUFVbE4sSUFBSTt3QkFDYixPQUFPbUQsU0FBVW5ELE1BQU1tTjtvQkFDeEI7Z0JBQ0Y7Z0JBRUF0RyxPQUFPLFNBQVVtRixTQUFTO29CQUN6QixJQUFJb0IsVUFBVXpILFVBQVUsQ0FBRXFHLFlBQVksSUFBSztvQkFFM0MsT0FBT29CLFdBQ04sQ0FBRUEsVUFBVSxJQUFJaEosT0FBUSxRQUFRRixhQUFhLE1BQU04SCxZQUNsRCxNQUFNOUgsYUFBYSxNQUFNLEtBQzFCeUIsV0FBWXFHLFdBQVcsU0FBVWhNLElBQUk7d0JBQ3BDLE9BQU9vTixRQUFRbEssSUFBSSxDQUNsQixPQUFPbEQsS0FBS2dNLFNBQVMsS0FBSyxZQUFZaE0sS0FBS2dNLFNBQVMsSUFDbkQsT0FBT2hNLEtBQUs3QixZQUFZLEtBQUssZUFDNUI2QixLQUFLN0IsWUFBWSxDQUFFLFlBQ3BCO29CQUVIO2dCQUNGO2dCQUVBNEksTUFBTSxTQUFVL0YsSUFBSSxFQUFFcU0sUUFBUSxFQUFFQyxLQUFLO29CQUNwQyxPQUFPLFNBQVV0TixJQUFJO3dCQUNwQixJQUFJdU4sU0FBUzNFLEtBQUs0RCxJQUFJLENBQUV4TSxNQUFNZ0I7d0JBRTlCLElBQUt1TSxVQUFVLE1BQU87NEJBQ3JCLE9BQU9GLGFBQWE7d0JBQ3JCO3dCQUNBLElBQUssQ0FBQ0EsVUFBVzs0QkFDaEIsT0FBTzt3QkFDUjt3QkFFQUUsVUFBVTt3QkFFVixJQUFLRixhQUFhLEtBQU07NEJBQ3ZCLE9BQU9FLFdBQVdEO3dCQUNuQjt3QkFDQSxJQUFLRCxhQUFhLE1BQU87NEJBQ3hCLE9BQU9FLFdBQVdEO3dCQUNuQjt3QkFDQSxJQUFLRCxhQUFhLE1BQU87NEJBQ3hCLE9BQU9DLFNBQVNDLE9BQU8vUSxPQUFPLENBQUU4USxXQUFZO3dCQUM3Qzt3QkFDQSxJQUFLRCxhQUFhLE1BQU87NEJBQ3hCLE9BQU9DLFNBQVNDLE9BQU8vUSxPQUFPLENBQUU4USxTQUFVLENBQUM7d0JBQzVDO3dCQUNBLElBQUtELGFBQWEsTUFBTzs0QkFDeEIsT0FBT0MsU0FBU0MsT0FBT3RSLEtBQUssQ0FBRSxDQUFDcVIsTUFBTWxPLE1BQU0sTUFBT2tPO3dCQUNuRDt3QkFDQSxJQUFLRCxhQUFhLE1BQU87NEJBQ3hCLE9BQU8sQ0FBRSxNQUFNRSxPQUFPMUwsT0FBTyxDQUFFd0UsYUFBYSxPQUFRLEdBQUUsRUFDcEQ3SixPQUFPLENBQUU4USxTQUFVLENBQUM7d0JBQ3ZCO3dCQUNBLElBQUtELGFBQWEsTUFBTzs0QkFDeEIsT0FBT0UsV0FBV0QsU0FBU0MsT0FBT3RSLEtBQUssQ0FBRSxHQUFHcVIsTUFBTWxPLE1BQU0sR0FBRyxPQUFRa08sUUFBUTt3QkFDNUU7d0JBRUEsT0FBTztvQkFDUjtnQkFDRDtnQkFFQXJHLE9BQU8sU0FBVTNKLElBQUksRUFBRWtRLElBQUksRUFBRUMsU0FBUyxFQUFFdk4sS0FBSyxFQUFFRSxJQUFJO29CQUNsRCxJQUFJc04sU0FBU3BRLEtBQUtyQixLQUFLLENBQUUsR0FBRyxPQUFRLE9BQ25DMFIsVUFBVXJRLEtBQUtyQixLQUFLLENBQUUsQ0FBQyxPQUFRLFFBQy9CMlIsU0FBU0osU0FBUztvQkFFbkIsT0FBT3ROLFVBQVUsS0FBS0UsU0FBUyxJQUU5Qix5QkFBeUI7b0JBQ3pCLFNBQVVKLElBQUk7d0JBQ2IsT0FBTyxDQUFDLENBQUNBLEtBQUt6QixVQUFVO29CQUN6QixJQUVBLFNBQVV5QixJQUFJLEVBQUU2TixRQUFRLEVBQUVDLEdBQUc7d0JBQzVCLElBQUkzRCxPQUFPNEQsWUFBWW5RLE1BQU1vUSxXQUFXQyxPQUN2QzdGLE1BQU1zRixXQUFXQyxVQUFVLGdCQUFnQixtQkFDM0NPLFNBQVNsTyxLQUFLekIsVUFBVSxFQUN4QnlDLE9BQU80TSxVQUFVNU4sS0FBS21ELFFBQVEsQ0FBQ2EsV0FBVyxJQUMxQ21LLFdBQVcsQ0FBQ0wsT0FBTyxDQUFDRixRQUNwQlEsT0FBTzt3QkFFUixJQUFLRixRQUFTOzRCQUViLHFDQUFxQzs0QkFDckMsSUFBS1IsUUFBUztnQ0FDYixNQUFRdEYsSUFBTTtvQ0FDYnhLLE9BQU9vQztvQ0FDUCxNQUFVcEMsT0FBT0EsSUFBSSxDQUFFd0ssSUFBSyxDQUFLO3dDQUNoQyxJQUFLd0YsU0FDSnpLLFNBQVV2RixNQUFNb0QsUUFDaEJwRCxLQUFLVixRQUFRLEtBQUssR0FBSTs0Q0FFdEIsT0FBTzt3Q0FDUjtvQ0FDRDtvQ0FFQSw0REFBNEQ7b0NBQzVEK1EsUUFBUTdGLE1BQU05SyxTQUFTLFVBQVUsQ0FBQzJRLFNBQVM7Z0NBQzVDO2dDQUNBLE9BQU87NEJBQ1I7NEJBRUFBLFFBQVE7Z0NBQUVOLFVBQVVPLE9BQU9HLFVBQVUsR0FBR0gsT0FBT0ksU0FBUzs2QkFBRTs0QkFFMUQsd0RBQXdEOzRCQUN4RCxJQUFLWCxXQUFXUSxVQUFXO2dDQUUxQiw2Q0FBNkM7Z0NBQzdDSixhQUFhRyxNQUFNLENBQUV4TSxRQUFTLElBQU13TSxDQUFBQSxNQUFNLENBQUV4TSxRQUFTLEdBQUcsQ0FBQztnQ0FDekR5SSxRQUFRNEQsVUFBVSxDQUFFelEsS0FBTSxJQUFJLEVBQUU7Z0NBQ2hDMFEsWUFBWTdELEtBQUssQ0FBRSxFQUFHLEtBQUsxRSxXQUFXMEUsS0FBSyxDQUFFLEVBQUc7Z0NBQ2hEaUUsT0FBT0osYUFBYTdELEtBQUssQ0FBRSxFQUFHO2dDQUM5QnZNLE9BQU9vUSxhQUFhRSxPQUFPekYsVUFBVSxDQUFFdUYsVUFBVztnQ0FFbEQsTUFBVXBRLE9BQU8sRUFBRW9RLGFBQWFwUSxRQUFRQSxJQUFJLENBQUV3SyxJQUFLLElBRWxELDRDQUE0QztnQ0FDMUNnRyxDQUFBQSxPQUFPSixZQUFZLE1BQU9DLE1BQU1oSyxHQUFHLEdBQU87b0NBRTVDLGtEQUFrRDtvQ0FDbEQsSUFBS3JHLEtBQUtWLFFBQVEsS0FBSyxLQUFLLEVBQUVrUixRQUFReFEsU0FBU29DLE1BQU87d0NBQ3JEK04sVUFBVSxDQUFFelEsS0FBTSxHQUFHOzRDQUFFbUk7NENBQVN1STs0Q0FBV0k7eUNBQU07d0NBQ2pEO29DQUNEO2dDQUNEOzRCQUVELE9BQU87Z0NBRU4sbURBQW1EO2dDQUNuRCxJQUFLRCxVQUFXO29DQUNmSixhQUFhL04sSUFBSSxDQUFFMEIsUUFBUyxJQUFNMUIsQ0FBQUEsSUFBSSxDQUFFMEIsUUFBUyxHQUFHLENBQUM7b0NBQ3JEeUksUUFBUTRELFVBQVUsQ0FBRXpRLEtBQU0sSUFBSSxFQUFFO29DQUNoQzBRLFlBQVk3RCxLQUFLLENBQUUsRUFBRyxLQUFLMUUsV0FBVzBFLEtBQUssQ0FBRSxFQUFHO29DQUNoRGlFLE9BQU9KO2dDQUNSO2dDQUVBLHNCQUFzQjtnQ0FDdEIsdURBQXVEO2dDQUN2RCxJQUFLSSxTQUFTLE9BQVE7b0NBRXJCLDJEQUEyRDtvQ0FDM0QsTUFBVXhRLE9BQU8sRUFBRW9RLGFBQWFwUSxRQUFRQSxJQUFJLENBQUV3SyxJQUFLLElBQ2hEZ0csQ0FBQUEsT0FBT0osWUFBWSxNQUFPQyxNQUFNaEssR0FBRyxHQUFPO3dDQUU1QyxJQUFLLENBQUUySixTQUNOekssU0FBVXZGLE1BQU1vRCxRQUNoQnBELEtBQUtWLFFBQVEsS0FBSyxNQUNsQixFQUFFa1IsTUFBTzs0Q0FFVCw4Q0FBOEM7NENBQzlDLElBQUtELFVBQVc7Z0RBQ2ZKLGFBQWFuUSxJQUFJLENBQUU4RCxRQUFTLElBQ3pCOUQsQ0FBQUEsSUFBSSxDQUFFOEQsUUFBUyxHQUFHLENBQUM7Z0RBQ3RCcU0sVUFBVSxDQUFFelEsS0FBTSxHQUFHO29EQUFFbUk7b0RBQVMySTtpREFBTTs0Q0FDdkM7NENBRUEsSUFBS3hRLFNBQVNvQyxNQUFPO2dEQUNwQjs0Q0FDRDt3Q0FDRDtvQ0FDRDtnQ0FDRDs0QkFDRDs0QkFFQSx3REFBd0Q7NEJBQ3hEb08sUUFBUWhPOzRCQUNSLE9BQU9nTyxTQUFTbE8sU0FBV2tPLE9BQU9sTyxVQUFVLEtBQUtrTyxPQUFPbE8sU0FBUzt3QkFDbEU7b0JBQ0Q7Z0JBQ0Y7Z0JBRUE4RyxRQUFRLFNBQVV1SCxNQUFNLEVBQUV4RCxRQUFRO29CQUVqQywwQ0FBMEM7b0JBQzFDLGtEQUFrRDtvQkFDbEQseUZBQXlGO29CQUN6RixpREFBaUQ7b0JBQ2pELElBQUl5RCxNQUNIelAsS0FBS29HLEtBQUtpQixPQUFPLENBQUVtSSxPQUFRLElBQUlwSixLQUFLc0osVUFBVSxDQUFFRixPQUFPdkssV0FBVyxHQUFJLElBQ3JFNEUsS0FBSzdHLEtBQUssQ0FBRSx5QkFBeUJ3TTtvQkFFdkMsaURBQWlEO29CQUNqRCxxREFBcUQ7b0JBQ3JELHNCQUFzQjtvQkFDdEIsSUFBS3hQLEVBQUUsQ0FBRTJDLFFBQVMsRUFBRzt3QkFDcEIsT0FBTzNDLEdBQUlnTTtvQkFDWjtvQkFFQSwwQ0FBMEM7b0JBQzFDLElBQUtoTSxHQUFHSyxNQUFNLEdBQUcsR0FBSTt3QkFDcEJvUCxPQUFPOzRCQUFFRDs0QkFBUUE7NEJBQVE7NEJBQUl4RDt5QkFBVTt3QkFDdkMsT0FBTzVGLEtBQUtzSixVQUFVLENBQUM3UixjQUFjLENBQUUyUixPQUFPdkssV0FBVyxNQUN4RHVHLGFBQWMsU0FBVTFCLElBQUksRUFBRXRGLE9BQU87NEJBQ3BDLElBQUltTCxLQUNIQyxVQUFVNVAsR0FBSThKLE1BQU1rQyxXQUNwQmpOLElBQUk2USxRQUFRdlAsTUFBTTs0QkFDbkIsTUFBUXRCLElBQU07Z0NBQ2I0USxNQUFNbFMsUUFBUUosSUFBSSxDQUFFeU0sTUFBTThGLE9BQU8sQ0FBRTdRLEVBQUc7Z0NBQ3RDK0ssSUFBSSxDQUFFNkYsSUFBSyxHQUFHLENBQUduTCxDQUFBQSxPQUFPLENBQUVtTCxJQUFLLEdBQUdDLE9BQU8sQ0FBRTdRLEVBQUc7NEJBQy9DO3dCQUNELEtBQ0EsU0FBVWtDLElBQUk7NEJBQ2IsT0FBT2pCLEdBQUlpQixNQUFNLEdBQUd3Tzt3QkFDckI7b0JBQ0Y7b0JBRUEsT0FBT3pQO2dCQUNSO1lBQ0Q7WUFFQXFILFNBQVM7Z0JBRVIsOEJBQThCO2dCQUM5QndJLEtBQUtyRSxhQUFjLFNBQVUxTCxRQUFRO29CQUVwQyxzQ0FBc0M7b0JBQ3RDLHlDQUF5QztvQkFDekMsd0JBQXdCO29CQUN4QixJQUFJb04sUUFBUSxFQUFFLEVBQ2J0SixVQUFVLEVBQUUsRUFDWmtNLFVBQVVDLFFBQVNqUSxTQUFTZ0QsT0FBTyxDQUFFc0MsVUFBVTtvQkFFaEQsT0FBTzBLLE9BQU8sQ0FBRW5OLFFBQVMsR0FDeEI2SSxhQUFjLFNBQVUxQixJQUFJLEVBQUV0RixPQUFPLEVBQUVzSyxRQUFRLEVBQUVDLEdBQUc7d0JBQ25ELElBQUk5TixNQUNIK08sWUFBWUYsUUFBU2hHLE1BQU0sTUFBTWlGLEtBQUssRUFBRSxHQUN4Q2hRLElBQUkrSyxLQUFLekosTUFBTTt3QkFFaEIsd0NBQXdDO3dCQUN4QyxNQUFRdEIsSUFBTTs0QkFDYixJQUFPa0MsT0FBTytPLFNBQVMsQ0FBRWpSLEVBQUcsRUFBSztnQ0FDaEMrSyxJQUFJLENBQUUvSyxFQUFHLEdBQUcsQ0FBR3lGLENBQUFBLE9BQU8sQ0FBRXpGLEVBQUcsR0FBR2tDLElBQUc7NEJBQ2xDO3dCQUNEO29CQUNELEtBQ0EsU0FBVUEsSUFBSSxFQUFFNk4sUUFBUSxFQUFFQyxHQUFHO3dCQUM1QjdCLEtBQUssQ0FBRSxFQUFHLEdBQUdqTTt3QkFDYjZPLFFBQVM1QyxPQUFPLE1BQU02QixLQUFLbkw7d0JBRTNCLHlCQUF5Qjt3QkFDekIsb0RBQW9EO3dCQUNwRHNKLEtBQUssQ0FBRSxFQUFHLEdBQUc7d0JBQ2IsT0FBTyxDQUFDdEosUUFBUXNCLEdBQUc7b0JBQ3BCO2dCQUNGO2dCQUVBK0ssS0FBS3pFLGFBQWMsU0FBVTFMLFFBQVE7b0JBQ3BDLE9BQU8sU0FBVW1CLElBQUk7d0JBQ3BCLE9BQU80SSxLQUFNL0osVUFBVW1CLE1BQU9aLE1BQU0sR0FBRztvQkFDeEM7Z0JBQ0Q7Z0JBRUFpRixVQUFVa0csYUFBYyxTQUFVck0sSUFBSTtvQkFDckNBLE9BQU9BLEtBQUsyRCxPQUFPLENBQUUyRixXQUFXQztvQkFDaEMsT0FBTyxTQUFVekgsSUFBSTt3QkFDcEIsT0FBTyxDQUFFQSxLQUFLdUMsV0FBVyxJQUFJM0QsT0FBT1YsSUFBSSxDQUFFOEIsS0FBSyxFQUFJeEQsT0FBTyxDQUFFMEIsUUFBUyxDQUFDO29CQUN2RTtnQkFDRDtnQkFFQSwyREFBMkQ7Z0JBQzNELGtEQUFrRDtnQkFDbEQsbUNBQW1DO2dCQUNuQyxrRUFBa0U7Z0JBQ2xFLDBGQUEwRjtnQkFDMUYsK0RBQStEO2dCQUMvRCwrQ0FBK0M7Z0JBQy9DK1EsTUFBTTFFLGFBQWMsU0FBVTBFLElBQUk7b0JBRWpDLHdDQUF3QztvQkFDeEMsSUFBSyxDQUFDdkksWUFBWXhELElBQUksQ0FBRStMLFFBQVEsS0FBTzt3QkFDdENyRyxLQUFLN0csS0FBSyxDQUFFLHVCQUF1QmtOO29CQUNwQztvQkFDQUEsT0FBT0EsS0FBS3BOLE9BQU8sQ0FBRTJGLFdBQVdDLFdBQVl6RCxXQUFXO29CQUN2RCxPQUFPLFNBQVVoRSxJQUFJO3dCQUNwQixJQUFJa1A7d0JBQ0osR0FBRzs0QkFDRixJQUFPQSxXQUFXM0osaUJBQ2pCdkYsS0FBS2lQLElBQUksR0FDVGpQLEtBQUs3QixZQUFZLENBQUUsZUFBZ0I2QixLQUFLN0IsWUFBWSxDQUFFLFNBQWE7Z0NBRW5FK1EsV0FBV0EsU0FBU2xMLFdBQVc7Z0NBQy9CLE9BQU9rTCxhQUFhRCxRQUFRQyxTQUFTMVMsT0FBTyxDQUFFeVMsT0FBTyxTQUFVOzRCQUNoRTt3QkFDRCxRQUFVLENBQUVqUCxPQUFPQSxLQUFLekIsVUFBVSxLQUFNeUIsS0FBSzlDLFFBQVEsS0FBSyxHQUFJO3dCQUM5RCxPQUFPO29CQUNSO2dCQUNEO2dCQUVBLGdCQUFnQjtnQkFDaEJrRSxRQUFRLFNBQVVwQixJQUFJO29CQUNyQixJQUFJbVAsT0FBT3hULFFBQU95VCxRQUFRLElBQUl6VCxRQUFPeVQsUUFBUSxDQUFDRCxJQUFJO29CQUNsRCxPQUFPQSxRQUFRQSxLQUFLbFQsS0FBSyxDQUFFLE9BQVErRCxLQUFLc0osRUFBRTtnQkFDM0M7Z0JBRUErRixNQUFNLFNBQVVyUCxJQUFJO29CQUNuQixPQUFPQSxTQUFTd0M7Z0JBQ2pCO2dCQUVBOE0sT0FBTyxTQUFVdFAsSUFBSTtvQkFDcEIsT0FBT0EsU0FBU3NJLHVCQUNmOU0sU0FBUytULFFBQVEsTUFDakIsQ0FBQyxDQUFHdlAsQ0FBQUEsS0FBSzFDLElBQUksSUFBSTBDLEtBQUt3UCxJQUFJLElBQUksQ0FBQ3hQLEtBQUt5UCxRQUFRO2dCQUM5QztnQkFFQSxxQkFBcUI7Z0JBQ3JCQyxTQUFTOUUscUJBQXNCO2dCQUMvQnpDLFVBQVV5QyxxQkFBc0I7Z0JBRWhDK0UsU0FBUyxTQUFVM1AsSUFBSTtvQkFFdEIscUVBQXFFO29CQUNyRSxrRUFBa0U7b0JBQ2xFLE9BQU8sU0FBWUEsTUFBTSxZQUFhLENBQUMsQ0FBQ0EsS0FBSzJQLE9BQU8sSUFDakR4TSxTQUFVbkQsTUFBTSxhQUFjLENBQUMsQ0FBQ0EsS0FBSzRQLFFBQVE7Z0JBQ2pEO2dCQUVBQSxVQUFVLFNBQVU1UCxJQUFJO29CQUV2QixvQkFBb0I7b0JBQ3BCLHVDQUF1QztvQkFDdkMsb0RBQW9EO29CQUNwRCxnQ0FBZ0M7b0JBQ2hDLElBQUtBLEtBQUt6QixVQUFVLEVBQUc7d0JBQ3RCLGlEQUFpRDt3QkFDakR5QixLQUFLekIsVUFBVSxDQUFDc1IsYUFBYTtvQkFDOUI7b0JBRUEsT0FBTzdQLEtBQUs0UCxRQUFRLEtBQUs7Z0JBQzFCO2dCQUVBLFdBQVc7Z0JBQ1hFLE9BQU8sU0FBVTlQLElBQUk7b0JBRXBCLGdEQUFnRDtvQkFDaEQsd0ZBQXdGO29CQUN4RixvRUFBb0U7b0JBQ3BFLHNFQUFzRTtvQkFDdEUsSUFBTUEsT0FBT0EsS0FBS3FPLFVBQVUsRUFBRXJPLE1BQU1BLE9BQU9BLEtBQUsrUCxXQUFXLENBQUc7d0JBQzdELElBQUsvUCxLQUFLOUMsUUFBUSxHQUFHLEdBQUk7NEJBQ3hCLE9BQU87d0JBQ1I7b0JBQ0Q7b0JBQ0EsT0FBTztnQkFDUjtnQkFFQWdSLFFBQVEsU0FBVWxPLElBQUk7b0JBQ3JCLE9BQU8sQ0FBQ21GLEtBQUtpQixPQUFPLENBQUMwSixLQUFLLENBQUU5UDtnQkFDN0I7Z0JBRUEsc0JBQXNCO2dCQUN0QmdRLFFBQVEsU0FBVWhRLElBQUk7b0JBQ3JCLE9BQU9xSCxRQUFRbkUsSUFBSSxDQUFFbEQsS0FBS21ELFFBQVE7Z0JBQ25DO2dCQUVBOEksT0FBTyxTQUFVak0sSUFBSTtvQkFDcEIsT0FBT29ILFFBQVFsRSxJQUFJLENBQUVsRCxLQUFLbUQsUUFBUTtnQkFDbkM7Z0JBRUE4TSxRQUFRLFNBQVVqUSxJQUFJO29CQUNyQixPQUFPbUQsU0FBVW5ELE1BQU0sWUFBYUEsS0FBSzFDLElBQUksS0FBSyxZQUNqRDZGLFNBQVVuRCxNQUFNO2dCQUNsQjtnQkFFQTlCLE1BQU0sU0FBVThCLElBQUk7b0JBQ25CLElBQUl3TTtvQkFDSixPQUFPckosU0FBVW5ELE1BQU0sWUFBYUEsS0FBSzFDLElBQUksS0FBSyxVQUVqRCx1QkFBdUI7b0JBQ3ZCLHFEQUFxRDtvQkFDckQsNEJBQTRCO29CQUMxQixFQUFFa1AsT0FBT3hNLEtBQUs3QixZQUFZLENBQUUsT0FBTyxLQUFPLFFBQzNDcU8sS0FBS3hJLFdBQVcsT0FBTyxNQUFLO2dCQUMvQjtnQkFFQSx5QkFBeUI7Z0JBQ3pCOUQsT0FBTzRLLHVCQUF3QjtvQkFDOUIsT0FBTzt3QkFBRTtxQkFBRztnQkFDYjtnQkFFQTFLLE1BQU0wSyx1QkFBd0IsU0FBVW9GLGFBQWEsRUFBRTlRLE1BQU07b0JBQzVELE9BQU87d0JBQUVBLFNBQVM7cUJBQUc7Z0JBQ3RCO2dCQUVBZSxJQUFJMkssdUJBQXdCLFNBQVVvRixhQUFhLEVBQUU5USxNQUFNLEVBQUUyTCxRQUFRO29CQUNwRSxPQUFPO3dCQUFFQSxXQUFXLElBQUlBLFdBQVczTCxTQUFTMkw7cUJBQVU7Z0JBQ3ZEO2dCQUVBMUssTUFBTXlLLHVCQUF3QixTQUFVRSxZQUFZLEVBQUU1TCxNQUFNO29CQUMzRCxJQUFJdEIsSUFBSTtvQkFDUixNQUFRQSxJQUFJc0IsUUFBUXRCLEtBQUssRUFBSTt3QkFDNUJrTixhQUFhek8sSUFBSSxDQUFFdUI7b0JBQ3BCO29CQUNBLE9BQU9rTjtnQkFDUjtnQkFFQXhLLEtBQUtzSyx1QkFBd0IsU0FBVUUsWUFBWSxFQUFFNUwsTUFBTTtvQkFDMUQsSUFBSXRCLElBQUk7b0JBQ1IsTUFBUUEsSUFBSXNCLFFBQVF0QixLQUFLLEVBQUk7d0JBQzVCa04sYUFBYXpPLElBQUksQ0FBRXVCO29CQUNwQjtvQkFDQSxPQUFPa047Z0JBQ1I7Z0JBRUFtRixJQUFJckYsdUJBQXdCLFNBQVVFLFlBQVksRUFBRTVMLE1BQU0sRUFBRTJMLFFBQVE7b0JBQ25FLElBQUlqTjtvQkFFSixJQUFLaU4sV0FBVyxHQUFJO3dCQUNuQmpOLElBQUlpTixXQUFXM0w7b0JBQ2hCLE9BQU8sSUFBSzJMLFdBQVczTCxRQUFTO3dCQUMvQnRCLElBQUlzQjtvQkFDTCxPQUFPO3dCQUNOdEIsSUFBSWlOO29CQUNMO29CQUVBLE1BQVEsRUFBRWpOLEtBQUssR0FBSzt3QkFDbkJrTixhQUFhek8sSUFBSSxDQUFFdUI7b0JBQ3BCO29CQUNBLE9BQU9rTjtnQkFDUjtnQkFFQW9GLElBQUl0Rix1QkFBd0IsU0FBVUUsWUFBWSxFQUFFNUwsTUFBTSxFQUFFMkwsUUFBUTtvQkFDbkUsSUFBSWpOLElBQUlpTixXQUFXLElBQUlBLFdBQVczTCxTQUFTMkw7b0JBQzNDLE1BQVEsRUFBRWpOLElBQUlzQixRQUFVO3dCQUN2QjRMLGFBQWF6TyxJQUFJLENBQUV1QjtvQkFDcEI7b0JBQ0EsT0FBT2tOO2dCQUNSO1lBQ0Q7UUFDRDtRQUVBN0YsS0FBS2lCLE9BQU8sQ0FBQ2lLLEdBQUcsR0FBR2xMLEtBQUtpQixPQUFPLENBQUNqRyxFQUFFO1FBRWxDLGdDQUFnQztRQUNoQyxJQUFNckMsS0FBSztZQUFFd1MsT0FBTztZQUFNQyxVQUFVO1lBQU1DLE1BQU07WUFBTUMsVUFBVTtZQUFNQyxPQUFPO1FBQUssRUFBSTtZQUNyRnZMLEtBQUtpQixPQUFPLENBQUV0SSxFQUFHLEdBQUc0TSxrQkFBbUI1TTtRQUN4QztRQUNBLElBQU1BLEtBQUs7WUFBRTZTLFFBQVE7WUFBTUMsT0FBTztRQUFLLEVBQUk7WUFDMUN6TCxLQUFLaUIsT0FBTyxDQUFFdEksRUFBRyxHQUFHNk0sbUJBQW9CN007UUFDekM7UUFFQSx1Q0FBdUM7UUFDdkMsU0FBUzJRLGNBQWM7UUFDdkJBLFdBQVd4UCxTQUFTLEdBQUdrRyxLQUFLMEwsT0FBTyxHQUFHMUwsS0FBS2lCLE9BQU87UUFDbERqQixLQUFLc0osVUFBVSxHQUFHLElBQUlBO1FBRXRCLFNBQVM5RSxTQUFVOUssUUFBUSxFQUFFaVMsU0FBUztZQUNyQyxJQUFJbkMsU0FBUzNGLE9BQU8rSCxRQUFRelQsTUFDM0IwVCxPQUFPL0gsUUFBUWdJLFlBQ2ZDLFNBQVNyTCxVQUFVLENBQUVoSCxXQUFXLElBQUs7WUFFdEMsSUFBS3FTLFFBQVM7Z0JBQ2IsT0FBT0osWUFBWSxJQUFJSSxPQUFPalYsS0FBSyxDQUFFO1lBQ3RDO1lBRUErVSxRQUFRblM7WUFDUm9LLFNBQVMsRUFBRTtZQUNYZ0ksYUFBYTlMLEtBQUs0SCxTQUFTO1lBRTNCLE1BQVFpRSxNQUFRO2dCQUVmLHNCQUFzQjtnQkFDdEIsSUFBSyxDQUFDckMsV0FBYTNGLENBQUFBLFFBQVExQyxPQUFPOEMsSUFBSSxDQUFFNEgsTUFBTSxHQUFNO29CQUNuRCxJQUFLaEksT0FBUTt3QkFFWix5Q0FBeUM7d0JBQ3pDZ0ksUUFBUUEsTUFBTS9VLEtBQUssQ0FBRStNLEtBQUssQ0FBRSxFQUFHLENBQUM1SixNQUFNLEtBQU00UjtvQkFDN0M7b0JBQ0EvSCxPQUFPMU0sSUFBSSxDQUFJd1UsU0FBUyxFQUFFO2dCQUMzQjtnQkFFQXBDLFVBQVU7Z0JBRVYsY0FBYztnQkFDZCxJQUFPM0YsUUFBUXpDLG1CQUFtQjZDLElBQUksQ0FBRTRILFFBQVk7b0JBQ25EckMsVUFBVTNGLE1BQU1zQixLQUFLO29CQUNyQnlHLE9BQU94VSxJQUFJLENBQUU7d0JBQ1ptSCxPQUFPaUw7d0JBRVAsdUNBQXVDO3dCQUN2Q3JSLE1BQU0wTCxLQUFLLENBQUUsRUFBRyxDQUFDbkgsT0FBTyxDQUFFc0MsVUFBVTtvQkFDckM7b0JBQ0E2TSxRQUFRQSxNQUFNL1UsS0FBSyxDQUFFMFMsUUFBUXZQLE1BQU07Z0JBQ3BDO2dCQUVBLFVBQVU7Z0JBQ1YsSUFBTTlCLFFBQVE2SCxLQUFLeUcsTUFBTSxDQUFHO29CQUMzQixJQUFLLENBQUU1QyxRQUFRckMsU0FBUyxDQUFFckosS0FBTSxDQUFDOEwsSUFBSSxDQUFFNEgsTUFBTSxLQUFTLEVBQUNDLFVBQVUsQ0FBRTNULEtBQU0sSUFDdEUwTCxDQUFBQSxRQUFRaUksVUFBVSxDQUFFM1QsS0FBTSxDQUFFMEwsTUFBTSxDQUFFLEdBQU07d0JBQzVDMkYsVUFBVTNGLE1BQU1zQixLQUFLO3dCQUNyQnlHLE9BQU94VSxJQUFJLENBQUU7NEJBQ1ptSCxPQUFPaUw7NEJBQ1ByUixNQUFNQTs0QkFDTmlHLFNBQVN5Rjt3QkFDVjt3QkFDQWdJLFFBQVFBLE1BQU0vVSxLQUFLLENBQUUwUyxRQUFRdlAsTUFBTTtvQkFDcEM7Z0JBQ0Q7Z0JBRUEsSUFBSyxDQUFDdVAsU0FBVTtvQkFDZjtnQkFDRDtZQUNEO1lBRUEsMENBQTBDO1lBQzFDLHdCQUF3QjtZQUN4Qiw2Q0FBNkM7WUFDN0MsSUFBS21DLFdBQVk7Z0JBQ2hCLE9BQU9FLE1BQU01UixNQUFNO1lBQ3BCO1lBRUEsT0FBTzRSLFFBQ05wSSxLQUFLN0csS0FBSyxDQUFFbEQsWUFFWixtQkFBbUI7WUFDbkJnSCxXQUFZaEgsVUFBVW9LLFFBQVNoTixLQUFLLENBQUU7UUFDeEM7UUFFQSxTQUFTMk4sV0FBWW1ILE1BQU07WUFDMUIsSUFBSWpULElBQUksR0FDUDJDLE1BQU1zUSxPQUFPM1IsTUFBTSxFQUNuQlAsV0FBVztZQUNaLE1BQVFmLElBQUkyQyxLQUFLM0MsSUFBTTtnQkFDdEJlLFlBQVlrUyxNQUFNLENBQUVqVCxFQUFHLENBQUM0RixLQUFLO1lBQzlCO1lBQ0EsT0FBTzdFO1FBQ1I7UUFFQSxTQUFTcUosY0FBZTJHLE9BQU8sRUFBRXNDLFVBQVUsRUFBRUMsSUFBSTtZQUNoRCxJQUFJaEosTUFBTStJLFdBQVcvSSxHQUFHLEVBQ3ZCaUosT0FBT0YsV0FBVzlJLElBQUksRUFDdEIrQixNQUFNaUgsUUFBUWpKLEtBQ2RrSixtQkFBbUJGLFFBQVFoSCxRQUFRLGNBQ25DbUgsV0FBVzdMO1lBRVosT0FBT3lMLFdBQVdqUixLQUFLLEdBRXRCLG1EQUFtRDtZQUNuRCxTQUFVRixJQUFJLEVBQUVsQixPQUFPLEVBQUVnUCxHQUFHO2dCQUMzQixNQUFVOU4sT0FBT0EsSUFBSSxDQUFFb0ksSUFBSyxDQUFLO29CQUNoQyxJQUFLcEksS0FBSzlDLFFBQVEsS0FBSyxLQUFLb1Usa0JBQW1CO3dCQUM5QyxPQUFPekMsUUFBUzdPLE1BQU1sQixTQUFTZ1A7b0JBQ2hDO2dCQUNEO2dCQUNBLE9BQU87WUFDUixJQUVBLGdEQUFnRDtZQUNoRCxTQUFVOU4sSUFBSSxFQUFFbEIsT0FBTyxFQUFFZ1AsR0FBRztnQkFDM0IsSUFBSTBELFVBQVV6RCxZQUNiMEQsV0FBVztvQkFBRWhNO29CQUFTOEw7aUJBQVU7Z0JBRWpDLDBGQUEwRjtnQkFDMUYsSUFBS3pELEtBQU07b0JBQ1YsTUFBVTlOLE9BQU9BLElBQUksQ0FBRW9JLElBQUssQ0FBSzt3QkFDaEMsSUFBS3BJLEtBQUs5QyxRQUFRLEtBQUssS0FBS29VLGtCQUFtQjs0QkFDOUMsSUFBS3pDLFFBQVM3TyxNQUFNbEIsU0FBU2dQLE1BQVE7Z0NBQ3BDLE9BQU87NEJBQ1I7d0JBQ0Q7b0JBQ0Q7Z0JBQ0QsT0FBTztvQkFDTixNQUFVOU4sT0FBT0EsSUFBSSxDQUFFb0ksSUFBSyxDQUFLO3dCQUNoQyxJQUFLcEksS0FBSzlDLFFBQVEsS0FBSyxLQUFLb1Usa0JBQW1COzRCQUM5Q3ZELGFBQWEvTixJQUFJLENBQUUwQixRQUFTLElBQU0xQixDQUFBQSxJQUFJLENBQUUwQixRQUFTLEdBQUcsQ0FBQzs0QkFFckQsSUFBSzJQLFFBQVFsTyxTQUFVbkQsTUFBTXFSLE9BQVM7Z0NBQ3JDclIsT0FBT0EsSUFBSSxDQUFFb0ksSUFBSyxJQUFJcEk7NEJBQ3ZCLE9BQU8sSUFBSyxDQUFFd1IsV0FBV3pELFVBQVUsQ0FBRTNELElBQUssS0FDekNvSCxRQUFRLENBQUUsRUFBRyxLQUFLL0wsV0FBVytMLFFBQVEsQ0FBRSxFQUFHLEtBQUtELFVBQVc7Z0NBRTFELG9FQUFvRTtnQ0FDcEUsT0FBU0UsUUFBUSxDQUFFLEVBQUcsR0FBR0QsUUFBUSxDQUFFLEVBQUc7NEJBQ3ZDLE9BQU87Z0NBRU4sZ0VBQWdFO2dDQUNoRXpELFVBQVUsQ0FBRTNELElBQUssR0FBR3FIO2dDQUVwQixrRUFBa0U7Z0NBQ2xFLElBQU9BLFFBQVEsQ0FBRSxFQUFHLEdBQUc1QyxRQUFTN08sTUFBTWxCLFNBQVNnUCxNQUFVO29DQUN4RCxPQUFPO2dDQUNSOzRCQUNEO3dCQUNEO29CQUNEO2dCQUNEO2dCQUNBLE9BQU87WUFDUjtRQUNGO1FBRUEsU0FBUzRELGVBQWdCQyxRQUFRO1lBQ2hDLE9BQU9BLFNBQVN2UyxNQUFNLEdBQUcsSUFDeEIsU0FBVVksSUFBSSxFQUFFbEIsT0FBTyxFQUFFZ1AsR0FBRztnQkFDM0IsSUFBSWhRLElBQUk2VCxTQUFTdlMsTUFBTTtnQkFDdkIsTUFBUXRCLElBQU07b0JBQ2IsSUFBSyxDQUFDNlQsUUFBUSxDQUFFN1QsRUFBRyxDQUFFa0MsTUFBTWxCLFNBQVNnUCxNQUFRO3dCQUMzQyxPQUFPO29CQUNSO2dCQUNEO2dCQUNBLE9BQU87WUFDUixJQUNBNkQsUUFBUSxDQUFFLEVBQUc7UUFDZjtRQUVBLFNBQVNDLGlCQUFrQi9TLFFBQVEsRUFBRWdULFFBQVEsRUFBRWxQLE9BQU87WUFDckQsSUFBSTdFLElBQUksR0FDUDJDLE1BQU1vUixTQUFTelMsTUFBTTtZQUN0QixNQUFRdEIsSUFBSTJDLEtBQUszQyxJQUFNO2dCQUN0QjhLLEtBQU0vSixVQUFVZ1QsUUFBUSxDQUFFL1QsRUFBRyxFQUFFNkU7WUFDaEM7WUFDQSxPQUFPQTtRQUNSO1FBRUEsU0FBU21QLFNBQVUvQyxTQUFTLEVBQUVoUCxHQUFHLEVBQUU2TCxNQUFNLEVBQUU5TSxPQUFPLEVBQUVnUCxHQUFHO1lBQ3RELElBQUk5TixNQUNIK1IsZUFBZSxFQUFFLEVBQ2pCalUsSUFBSSxHQUNKMkMsTUFBTXNPLFVBQVUzUCxNQUFNLEVBQ3RCNFMsU0FBU2pTLE9BQU87WUFFakIsTUFBUWpDLElBQUkyQyxLQUFLM0MsSUFBTTtnQkFDdEIsSUFBT2tDLE9BQU8rTyxTQUFTLENBQUVqUixFQUFHLEVBQUs7b0JBQ2hDLElBQUssQ0FBQzhOLFVBQVVBLE9BQVE1TCxNQUFNbEIsU0FBU2dQLE1BQVE7d0JBQzlDaUUsYUFBYXhWLElBQUksQ0FBRXlEO3dCQUNuQixJQUFLZ1MsUUFBUzs0QkFDYmpTLElBQUl4RCxJQUFJLENBQUV1Qjt3QkFDWDtvQkFDRDtnQkFDRDtZQUNEO1lBRUEsT0FBT2lVO1FBQ1I7UUFFQSxTQUFTRSxXQUFZbEYsU0FBUyxFQUFFbE8sUUFBUSxFQUFFZ1EsT0FBTyxFQUFFcUQsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLFlBQVk7WUFDdEYsSUFBS0YsY0FBYyxDQUFDQSxVQUFVLENBQUV4USxRQUFTLEVBQUc7Z0JBQzNDd1EsYUFBYUQsV0FBWUM7WUFDMUI7WUFDQSxJQUFLQyxjQUFjLENBQUNBLFVBQVUsQ0FBRXpRLFFBQVMsRUFBRztnQkFDM0N5USxhQUFhRixXQUFZRSxZQUFZQztZQUN0QztZQUNBLE9BQU83SCxhQUFjLFNBQVUxQixJQUFJLEVBQUVsRyxPQUFPLEVBQUU3RCxPQUFPLEVBQUVnUCxHQUFHO2dCQUN6RCxJQUFJdUUsTUFBTXZVLEdBQUdrQyxNQUFNc1MsWUFDbEJDLFNBQVMsRUFBRSxFQUNYQyxVQUFVLEVBQUUsRUFDWkMsY0FBYzlQLFFBQVF2RCxNQUFNLEVBRTVCLDRDQUE0QztnQkFDNUNLLFFBQVFvSixRQUNQK0ksaUJBQWtCL1MsWUFBWSxLQUM3QkMsUUFBUTVCLFFBQVEsR0FBRztvQkFBRTRCO2lCQUFTLEdBQUdBLFNBQVMsRUFBRSxHQUU5QyxvRkFBb0Y7Z0JBQ3BGNFQsWUFBWTNGLGFBQWVsRSxDQUFBQSxRQUFRLENBQUNoSyxRQUFPLElBQzFDaVQsU0FBVXJTLE9BQU84UyxRQUFReEYsV0FBV2pPLFNBQVNnUCxPQUM3Q3JPO2dCQUVGLElBQUtvUCxTQUFVO29CQUVkLG9FQUFvRTtvQkFDcEUsMEJBQTBCO29CQUMxQnlELGFBQWFILGNBQWdCdEosQ0FBQUEsT0FBT2tFLFlBQVkwRixlQUFlUCxVQUFTLElBRXZFLDBDQUEwQztvQkFDMUMsRUFBRSxHQUVGLG9DQUFvQztvQkFDcEN2UDtvQkFFRCx1QkFBdUI7b0JBQ3ZCa00sUUFBUzZELFdBQVdKLFlBQVl4VCxTQUFTZ1A7Z0JBQzFDLE9BQU87b0JBQ053RSxhQUFhSTtnQkFDZDtnQkFFQSxtQkFBbUI7Z0JBQ25CLElBQUtSLFlBQWE7b0JBQ2pCRyxPQUFPUCxTQUFVUSxZQUFZRTtvQkFDN0JOLFdBQVlHLE1BQU0sRUFBRSxFQUFFdlQsU0FBU2dQO29CQUUvQiw2REFBNkQ7b0JBQzdEaFEsSUFBSXVVLEtBQUtqVCxNQUFNO29CQUNmLE1BQVF0QixJQUFNO3dCQUNiLElBQU9rQyxPQUFPcVMsSUFBSSxDQUFFdlUsRUFBRyxFQUFLOzRCQUMzQndVLFVBQVUsQ0FBRUUsT0FBTyxDQUFFMVUsRUFBRyxDQUFFLEdBQUcsQ0FBRzRVLENBQUFBLFNBQVMsQ0FBRUYsT0FBTyxDQUFFMVUsRUFBRyxDQUFFLEdBQUdrQyxJQUFHO3dCQUNoRTtvQkFDRDtnQkFDRDtnQkFFQSxJQUFLNkksTUFBTztvQkFDWCxJQUFLc0osY0FBY3BGLFdBQVk7d0JBQzlCLElBQUtvRixZQUFhOzRCQUVqQixvRkFBb0Y7NEJBQ3BGRSxPQUFPLEVBQUU7NEJBQ1R2VSxJQUFJd1UsV0FBV2xULE1BQU07NEJBQ3JCLE1BQVF0QixJQUFNO2dDQUNiLElBQU9rQyxPQUFPc1MsVUFBVSxDQUFFeFUsRUFBRyxFQUFLO29DQUVqQyx3REFBd0Q7b0NBQ3hEdVUsS0FBSzlWLElBQUksQ0FBSW1XLFNBQVMsQ0FBRTVVLEVBQUcsR0FBR2tDO2dDQUMvQjs0QkFDRDs0QkFDQW1TLFdBQVksTUFBUUcsYUFBYSxFQUFFLEVBQUlELE1BQU12RTt3QkFDOUM7d0JBRUEsdUVBQXVFO3dCQUN2RWhRLElBQUl3VSxXQUFXbFQsTUFBTTt3QkFDckIsTUFBUXRCLElBQU07NEJBQ2IsSUFBSyxDQUFFa0MsT0FBT3NTLFVBQVUsQ0FBRXhVLEVBQUcsS0FDNUIsQ0FBRXVVLE9BQU9GLGFBQWEzVixRQUFRSixJQUFJLENBQUV5TSxNQUFNN0ksUUFBU3VTLE1BQU0sQ0FBRXpVLEVBQUcsSUFBSyxDQUFDLEdBQUk7Z0NBRXhFK0ssSUFBSSxDQUFFd0osS0FBTSxHQUFHLENBQUcxUCxDQUFBQSxPQUFPLENBQUUwUCxLQUFNLEdBQUdyUyxJQUFHOzRCQUN4Qzt3QkFDRDtvQkFDRDtnQkFFRCx5REFBeUQ7Z0JBQ3pELE9BQU87b0JBQ05zUyxhQUFhUixTQUNaUSxlQUFlM1AsVUFDZDJQLFdBQVd6UixNQUFNLENBQUU0UixhQUFhSCxXQUFXbFQsTUFBTSxJQUNqRGtUO29CQUVGLElBQUtILFlBQWE7d0JBQ2pCQSxXQUFZLE1BQU14UCxTQUFTMlAsWUFBWXhFO29CQUN4QyxPQUFPO3dCQUNOdlIsS0FBS0QsS0FBSyxDQUFFcUcsU0FBUzJQO29CQUN0QjtnQkFDRDtZQUNEO1FBQ0Q7UUFFQSxTQUFTSyxrQkFBbUI1QixNQUFNO1lBQ2pDLElBQUk2QixjQUFjL0QsU0FBU25PLEdBQzFCRCxNQUFNc1EsT0FBTzNSLE1BQU0sRUFDbkJ5VCxrQkFBa0IxTixLQUFLMkgsUUFBUSxDQUFFaUUsTUFBTSxDQUFFLEVBQUcsQ0FBQ3pULElBQUksQ0FBRSxFQUNuRHdWLG1CQUFtQkQsbUJBQW1CMU4sS0FBSzJILFFBQVEsQ0FBRSxJQUFLLEVBQzFEaFAsSUFBSStVLGtCQUFrQixJQUFJLEdBRTFCLHlGQUF5RjtZQUN6RkUsZUFBZTdLLGNBQWUsU0FBVWxJLElBQUk7Z0JBQzNDLE9BQU9BLFNBQVM0UztZQUNqQixHQUFHRSxrQkFBa0IsT0FDckJFLGtCQUFrQjlLLGNBQWUsU0FBVWxJLElBQUk7Z0JBQzlDLE9BQU94RCxRQUFRSixJQUFJLENBQUV3VyxjQUFjNVMsUUFBUyxDQUFDO1lBQzlDLEdBQUc4UyxrQkFBa0IsT0FDckJuQixXQUFXO2dCQUFFLFNBQVUzUixJQUFJLEVBQUVsQixPQUFPLEVBQUVnUCxHQUFHO29CQUV4QyxpQ0FBaUM7b0JBQ2pDLDRFQUE0RTtvQkFDNUUsMkNBQTJDO29CQUMzQyxrQ0FBa0M7b0JBQ2xDLElBQUlwTyxNQUFNLENBQUdtVCxtQkFBcUIvRSxDQUFBQSxPQUFPaFAsV0FBV3NHLGdCQUFlLEtBQ2xFLEVBQUV3TixlQUFlOVQsT0FBTSxFQUFJNUIsUUFBUSxHQUNsQzZWLGFBQWMvUyxNQUFNbEIsU0FBU2dQLE9BQzdCa0YsZ0JBQWlCaFQsTUFBTWxCLFNBQVNnUCxJQUFJO29CQUV0Qyw2QkFBNkI7b0JBQzdCLG9EQUFvRDtvQkFDcEQ4RSxlQUFlO29CQUNmLE9BQU9sVDtnQkFDUjthQUFHO1lBRUosTUFBUTVCLElBQUkyQyxLQUFLM0MsSUFBTTtnQkFDdEIsSUFBTytRLFVBQVUxSixLQUFLMkgsUUFBUSxDQUFFaUUsTUFBTSxDQUFFalQsRUFBRyxDQUFDUixJQUFJLENBQUUsRUFBSztvQkFDdERxVSxXQUFXO3dCQUFFekosY0FBZXdKLGVBQWdCQyxXQUFZOUM7cUJBQVc7Z0JBQ3BFLE9BQU87b0JBQ05BLFVBQVUxSixLQUFLeUcsTUFBTSxDQUFFbUYsTUFBTSxDQUFFalQsRUFBRyxDQUFDUixJQUFJLENBQUUsQ0FBQ2hCLEtBQUssQ0FBRSxNQUFNeVUsTUFBTSxDQUFFalQsRUFBRyxDQUFDeUYsT0FBTztvQkFFMUUsa0RBQWtEO29CQUNsRCxJQUFLc0wsT0FBTyxDQUFFbk4sUUFBUyxFQUFHO3dCQUV6QiwrREFBK0Q7d0JBQy9EaEIsSUFBSSxFQUFFNUM7d0JBQ04sTUFBUTRDLElBQUlELEtBQUtDLElBQU07NEJBQ3RCLElBQUt5RSxLQUFLMkgsUUFBUSxDQUFFaUUsTUFBTSxDQUFFclEsRUFBRyxDQUFDcEQsSUFBSSxDQUFFLEVBQUc7Z0NBQ3hDOzRCQUNEO3dCQUNEO3dCQUNBLE9BQU8yVSxXQUNOblUsSUFBSSxLQUFLNFQsZUFBZ0JDLFdBQ3pCN1QsSUFBSSxLQUFLOEwsV0FFUix5RkFBeUY7d0JBQ3pGbUgsT0FBTzlVLEtBQUssQ0FBRSxHQUFHNkIsSUFBSSxHQUNuQnpCLE1BQU0sQ0FBRTs0QkFBRXFILE9BQU9xTixNQUFNLENBQUVqVCxJQUFJLEVBQUcsQ0FBQ1IsSUFBSSxLQUFLLE1BQU0sTUFBTTt3QkFBRyxJQUMxRHVFLE9BQU8sQ0FBRXNDLFVBQVUsT0FDckIwSyxTQUNBL1EsSUFBSTRDLEtBQUtpUyxrQkFBbUI1QixPQUFPOVUsS0FBSyxDQUFFNkIsR0FBRzRDLEtBQzdDQSxJQUFJRCxPQUFPa1Msa0JBQXFCNUIsU0FBU0EsT0FBTzlVLEtBQUssQ0FBRXlFLEtBQ3ZEQSxJQUFJRCxPQUFPbUosV0FBWW1IO29CQUV6QjtvQkFDQVksU0FBU3BWLElBQUksQ0FBRXNTO2dCQUNoQjtZQUNEO1lBRUEsT0FBTzZDLGVBQWdCQztRQUN4QjtRQUVBLFNBQVNzQix5QkFBMEJDLGVBQWUsRUFBRUMsV0FBVztZQUM5RCxJQUFJQyxRQUFRRCxZQUFZL1QsTUFBTSxHQUFHLEdBQ2hDaVUsWUFBWUgsZ0JBQWdCOVQsTUFBTSxHQUFHLEdBQ3JDa1UsZUFBZSxTQUFVekssSUFBSSxFQUFFL0osT0FBTyxFQUFFZ1AsR0FBRyxFQUFFbkwsT0FBTyxFQUFFNFEsU0FBUztnQkFDOUQsSUFBSXZULE1BQU1VLEdBQUdtTyxTQUNaMkUsZUFBZSxHQUNmMVYsSUFBSSxLQUNKaVIsWUFBWWxHLFFBQVEsRUFBRSxFQUN0QjRLLGFBQWEsRUFBRSxFQUNmQyxnQkFBZ0J0TyxrQkFFaEIsZ0VBQWdFO2dCQUNoRTNGLFFBQVFvSixRQUFRd0ssYUFBYWxPLEtBQUt5RCxJQUFJLENBQUM5QixHQUFHLENBQUUsS0FBS3lNLFlBRWpELHdEQUF3RDtnQkFDeERJLGdCQUFrQmxPLFdBQVdpTyxpQkFBaUIsT0FBTyxJQUFJL1IsS0FBS0MsTUFBTSxNQUFNLEtBQzFFbkIsTUFBTWhCLE1BQU1MLE1BQU07Z0JBRW5CLElBQUttVSxXQUFZO29CQUVoQixpQ0FBaUM7b0JBQ2pDLDRFQUE0RTtvQkFDNUUsMkNBQTJDO29CQUMzQyxrQ0FBa0M7b0JBQ2xDbk8sbUJBQW1CdEcsV0FBV3RELFlBQVlzRCxXQUFXeVU7Z0JBQ3REO2dCQUVBLDJEQUEyRDtnQkFDM0QsNEJBQTRCO2dCQUM1Qix5RUFBeUU7Z0JBQ3pFLG1DQUFtQztnQkFDbkMsTUFBUXpWLE1BQU0yQyxPQUFPLENBQUVULE9BQU9QLEtBQUssQ0FBRTNCLEVBQUcsS0FBTSxNQUFNQSxJQUFNO29CQUN6RCxJQUFLdVYsYUFBYXJULE1BQU87d0JBQ3hCVSxJQUFJO3dCQUVKLGlDQUFpQzt3QkFDakMsNEVBQTRFO3dCQUM1RSwyQ0FBMkM7d0JBQzNDLGtDQUFrQzt3QkFDbEMsSUFBSyxDQUFDNUIsV0FBV2tCLEtBQUtpRCxhQUFhLElBQUl6SCxVQUFXOzRCQUNqRHdNLFlBQWFoSTs0QkFDYjhOLE1BQU0sQ0FBQ3ZJO3dCQUNSO3dCQUNBLE1BQVVzSixVQUFVcUUsZUFBZSxDQUFFeFMsSUFBSyxDQUFLOzRCQUM5QyxJQUFLbU8sUUFBUzdPLE1BQU1sQixXQUFXdEQsVUFBVXNTLE1BQVE7Z0NBQ2hEdlIsS0FBS0gsSUFBSSxDQUFFdUcsU0FBUzNDO2dDQUNwQjs0QkFDRDt3QkFDRDt3QkFDQSxJQUFLdVQsV0FBWTs0QkFDaEI5TixVQUFVa087d0JBQ1g7b0JBQ0Q7b0JBRUEsMkNBQTJDO29CQUMzQyxJQUFLUCxPQUFRO3dCQUVaLG9EQUFvRDt3QkFDcEQsSUFBT3BULE9BQU8sQ0FBQzZPLFdBQVc3TyxNQUFTOzRCQUNsQ3dUO3dCQUNEO3dCQUVBLHVEQUF1RDt3QkFDdkQsSUFBSzNLLE1BQU87NEJBQ1hrRyxVQUFVeFMsSUFBSSxDQUFFeUQ7d0JBQ2pCO29CQUNEO2dCQUNEO2dCQUVBLGtGQUFrRjtnQkFDbEYsZ0NBQWdDO2dCQUNoQ3dULGdCQUFnQjFWO2dCQUVoQiwwQ0FBMEM7Z0JBQzFDLHFGQUFxRjtnQkFDckYsdUZBQXVGO2dCQUN2RixtQ0FBbUM7Z0JBQ25DLHNGQUFzRjtnQkFDdEYscUZBQXFGO2dCQUNyRixvQkFBb0I7Z0JBQ3BCLElBQUtzVixTQUFTdFYsTUFBTTBWLGNBQWU7b0JBQ2xDOVMsSUFBSTtvQkFDSixNQUFVbU8sVUFBVXNFLFdBQVcsQ0FBRXpTLElBQUssQ0FBSzt3QkFDMUNtTyxRQUFTRSxXQUFXMEUsWUFBWTNVLFNBQVNnUDtvQkFDMUM7b0JBRUEsSUFBS2pGLE1BQU87d0JBRVgsZ0VBQWdFO3dCQUNoRSxJQUFLMkssZUFBZSxHQUFJOzRCQUN2QixNQUFRMVYsSUFBTTtnQ0FDYixJQUFLLENBQUdpUixDQUFBQSxTQUFTLENBQUVqUixFQUFHLElBQUkyVixVQUFVLENBQUUzVixFQUFHLEdBQUs7b0NBQzdDMlYsVUFBVSxDQUFFM1YsRUFBRyxHQUFHbUcsSUFBSTdILElBQUksQ0FBRXVHO2dDQUM3Qjs0QkFDRDt3QkFDRDt3QkFFQSw4REFBOEQ7d0JBQzlEOFEsYUFBYTNCLFNBQVUyQjtvQkFDeEI7b0JBRUEseUJBQXlCO29CQUN6QmxYLEtBQUtELEtBQUssQ0FBRXFHLFNBQVM4UTtvQkFFckIsaUZBQWlGO29CQUNqRixJQUFLRixhQUFhLENBQUMxSyxRQUFRNEssV0FBV3JVLE1BQU0sR0FBRyxLQUM5QyxlQUFpQitULFlBQVkvVCxNQUFNLEdBQUssR0FBSTt3QkFFNUNSLE9BQU84TixVQUFVLENBQUUvSjtvQkFDcEI7Z0JBQ0Q7Z0JBRUEsc0RBQXNEO2dCQUN0RCxJQUFLNFEsV0FBWTtvQkFDaEI5TixVQUFVa087b0JBQ1Z2TyxtQkFBbUJzTztnQkFDcEI7Z0JBRUEsT0FBTzNFO1lBQ1I7WUFFRCxPQUFPcUUsUUFDTjdJLGFBQWMrSSxnQkFDZEE7UUFDRjtRQUVBLFNBQVN4RSxRQUFTalEsUUFBUSxFQUFFbUssTUFBTSxxQkFBcUIsR0FBdEI7WUFDaEMsSUFBSWxMLEdBQ0hxVixjQUFjLEVBQUUsRUFDaEJELGtCQUFrQixFQUFFLEVBQ3BCaEMsU0FBU3BMLGFBQWEsQ0FBRWpILFdBQVcsSUFBSztZQUV6QyxJQUFLLENBQUNxUyxRQUFTO2dCQUVkLG9GQUFvRjtnQkFDcEYsSUFBSyxDQUFDbEksT0FBUTtvQkFDYkEsUUFBUVcsU0FBVTlLO2dCQUNuQjtnQkFDQWYsSUFBSWtMLE1BQU01SixNQUFNO2dCQUNoQixNQUFRdEIsSUFBTTtvQkFDYm9ULFNBQVN5QixrQkFBbUIzSixLQUFLLENBQUVsTCxFQUFHO29CQUN0QyxJQUFLb1QsTUFBTSxDQUFFeFAsUUFBUyxFQUFHO3dCQUN4QnlSLFlBQVk1VyxJQUFJLENBQUUyVTtvQkFDbkIsT0FBTzt3QkFDTmdDLGdCQUFnQjNXLElBQUksQ0FBRTJVO29CQUN2QjtnQkFDRDtnQkFFQSw4QkFBOEI7Z0JBQzlCQSxTQUFTcEwsY0FBZWpILFVBQ3ZCb1UseUJBQTBCQyxpQkFBaUJDO2dCQUU1QyxpQ0FBaUM7Z0JBQ2pDakMsT0FBT3JTLFFBQVEsR0FBR0E7WUFDbkI7WUFDQSxPQUFPcVM7UUFDUjtRQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU2pILE9BQVFwTCxRQUFRLEVBQUVDLE9BQU8sRUFBRTZELE9BQU8sRUFBRWtHLElBQUk7WUFDaEQsSUFBSS9LLEdBQUdpVCxRQUFRNkMsT0FBT3RXLE1BQU1zTCxNQUMzQmlMLFdBQVcsT0FBT2hWLGFBQWEsY0FBY0EsVUFDN0NtSyxRQUFRLENBQUNILFFBQVFjLFNBQVk5SyxXQUFXZ1YsU0FBU2hWLFFBQVEsSUFBSUE7WUFFOUQ4RCxVQUFVQSxXQUFXLEVBQUU7WUFFdkIsbUZBQW1GO1lBQ25GLDhDQUE4QztZQUM5QyxJQUFLcUcsTUFBTTVKLE1BQU0sS0FBSyxHQUFJO2dCQUV6QiwyREFBMkQ7Z0JBQzNEMlIsU0FBUy9ILEtBQUssQ0FBRSxFQUFHLEdBQUdBLEtBQUssQ0FBRSxFQUFHLENBQUMvTSxLQUFLLENBQUU7Z0JBQ3hDLElBQUs4VSxPQUFPM1IsTUFBTSxHQUFHLEtBQUssQ0FBRXdVLFFBQVE3QyxNQUFNLENBQUUsRUFBRyxFQUFHelQsSUFBSSxLQUFLLFFBQ3pEd0IsUUFBUTVCLFFBQVEsS0FBSyxLQUFLcUksa0JBQWtCSixLQUFLMkgsUUFBUSxDQUFFaUUsTUFBTSxDQUFFLEVBQUcsQ0FBQ3pULElBQUksQ0FBRSxFQUFHO29CQUVqRndCLFVBQVUsQ0FBRXFHLEtBQUt5RCxJQUFJLENBQUNoQyxFQUFFLENBQ3ZCZ04sTUFBTXJRLE9BQU8sQ0FBRSxFQUFHLENBQUMxQixPQUFPLENBQUUyRixXQUFXQyxZQUN2QzNJLFlBQ0ksRUFBRSxDQUFFLENBQUUsRUFBRztvQkFDZCxJQUFLLENBQUNBLFNBQVU7d0JBQ2YsT0FBTzZEO29CQUVSLHNFQUFzRTtvQkFDdEUsT0FBTyxJQUFLa1IsVUFBVzt3QkFDdEIvVSxVQUFVQSxRQUFRUCxVQUFVO29CQUM3QjtvQkFFQU0sV0FBV0EsU0FBUzVDLEtBQUssQ0FBRThVLE9BQU96RyxLQUFLLEdBQUc1RyxLQUFLLENBQUN0RSxNQUFNO2dCQUN2RDtnQkFFQSw4Q0FBOEM7Z0JBQzlDdEIsSUFBSTZJLFVBQVVRLFlBQVksQ0FBQ2pFLElBQUksQ0FBRXJFLFlBQWEsSUFBSWtTLE9BQU8zUixNQUFNO2dCQUMvRCxNQUFRdEIsSUFBTTtvQkFDYjhWLFFBQVE3QyxNQUFNLENBQUVqVCxFQUFHO29CQUVuQiwrQkFBK0I7b0JBQy9CLElBQUtxSCxLQUFLMkgsUUFBUSxDQUFJeFAsT0FBT3NXLE1BQU10VyxJQUFJLENBQUksRUFBRzt3QkFDN0M7b0JBQ0Q7b0JBQ0EsSUFBT3NMLE9BQU96RCxLQUFLeUQsSUFBSSxDQUFFdEwsS0FBTSxFQUFLO3dCQUVuQyw0REFBNEQ7d0JBQzVELElBQU91TCxPQUFPRCxLQUNiZ0wsTUFBTXJRLE9BQU8sQ0FBRSxFQUFHLENBQUMxQixPQUFPLENBQUUyRixXQUFXQyxZQUN2Q0YsU0FBU3JFLElBQUksQ0FBRTZOLE1BQU0sQ0FBRSxFQUFHLENBQUN6VCxJQUFJLEtBQzlCbU0sWUFBYTNLLFFBQVFQLFVBQVUsS0FBTU8sVUFDakM7NEJBRUwsNERBQTREOzRCQUM1RGlTLE9BQU9sUSxNQUFNLENBQUUvQyxHQUFHOzRCQUNsQmUsV0FBV2dLLEtBQUt6SixNQUFNLElBQUl3SyxXQUFZbUg7NEJBQ3RDLElBQUssQ0FBQ2xTLFVBQVc7Z0NBQ2hCdEMsS0FBS0QsS0FBSyxDQUFFcUcsU0FBU2tHO2dDQUNyQixPQUFPbEc7NEJBQ1I7NEJBRUE7d0JBQ0Q7b0JBQ0Q7Z0JBQ0Q7WUFDRDtZQUVBLGtFQUFrRTtZQUNsRSw0RUFBNEU7WUFDMUVrUixDQUFBQSxZQUFZL0UsUUFBU2pRLFVBQVVtSyxNQUFNLEVBQ3RDSCxNQUNBL0osU0FDQSxDQUFDeUcsZ0JBQ0Q1QyxTQUNBLENBQUM3RCxXQUFXeUksU0FBU3JFLElBQUksQ0FBRXJFLGFBQWM0SyxZQUFhM0ssUUFBUVAsVUFBVSxLQUFNTztZQUUvRSxPQUFPNkQ7UUFDUjtRQUVBLHVCQUF1QjtRQUV2QixnQ0FBZ0M7UUFDaEMsaUJBQWlCO1FBQ2pCNUYsUUFBUTZQLFVBQVUsR0FBR2xMLFFBQVFvQyxLQUFLLENBQUUsSUFBS2xELElBQUksQ0FBRW9GLFdBQVk2RCxJQUFJLENBQUUsUUFBU25JO1FBRTFFLDBDQUEwQztRQUMxQ3NHO1FBRUEsZ0NBQWdDO1FBQ2hDLG1EQUFtRDtRQUNuRGpMLFFBQVFxUCxZQUFZLEdBQUc1QixPQUFRLFNBQVVDLEVBQUU7WUFFMUMsNkNBQTZDO1lBQzdDLE9BQU9BLEdBQUdoRyx1QkFBdUIsQ0FBRWpKLFNBQVN5QyxhQUFhLENBQUUsZUFBaUI7UUFDN0U7UUFFQVcsT0FBT2dLLElBQUksR0FBR0E7UUFFZCxhQUFhO1FBQ2JoSyxPQUFPeU4sSUFBSSxDQUFFLElBQUssR0FBR3pOLE9BQU95TixJQUFJLENBQUNqRyxPQUFPO1FBQ3hDeEgsT0FBT2tWLE1BQU0sR0FBR2xWLE9BQU84TixVQUFVO1FBRWpDLDRFQUE0RTtRQUM1RSw4RUFBOEU7UUFDOUU5RCxLQUFLa0csT0FBTyxHQUFHQTtRQUNmbEcsS0FBS3FCLE1BQU0sR0FBR0E7UUFDZHJCLEtBQUtaLFdBQVcsR0FBR0E7UUFDbkJZLEtBQUtlLFFBQVEsR0FBR0E7UUFFaEJmLEtBQUtsQixNQUFNLEdBQUc5SSxPQUFPbUcsY0FBYztRQUNuQzZELEtBQUttTCxPQUFPLEdBQUduVixPQUFPVixJQUFJO1FBQzFCMEssS0FBS29MLEtBQUssR0FBR3BWLE9BQU9pRSxRQUFRO1FBQzVCK0YsS0FBS3FMLFNBQVMsR0FBR3JWLE9BQU95TixJQUFJO1FBQzVCekQsS0FBSzdMLE9BQU8sR0FBRzZCLE9BQU83QixPQUFPO1FBQzdCNkwsS0FBSzhELFVBQVUsR0FBRzlOLE9BQU84TixVQUFVO0lBRWxDLGlCQUFpQixHQUVsQjtJQUdBLElBQUl0RSxNQUFNLFNBQVVwSSxJQUFJLEVBQUVvSSxHQUFHLEVBQUU4TCxLQUFLO1FBQ25DLElBQUl2RixVQUFVLEVBQUUsRUFDZndGLFdBQVdELFVBQVV6UztRQUV0QixNQUFRLENBQUV6QixPQUFPQSxJQUFJLENBQUVvSSxJQUFLLEtBQU1wSSxLQUFLOUMsUUFBUSxLQUFLLEVBQUk7WUFDdkQsSUFBSzhDLEtBQUs5QyxRQUFRLEtBQUssR0FBSTtnQkFDMUIsSUFBS2lYLFlBQVl2VixPQUFRb0IsTUFBT29VLEVBQUUsQ0FBRUYsUUFBVTtvQkFDN0M7Z0JBQ0Q7Z0JBQ0F2RixRQUFRcFMsSUFBSSxDQUFFeUQ7WUFDZjtRQUNEO1FBQ0EsT0FBTzJPO0lBQ1I7SUFHQSxJQUFJMEYsV0FBVyxTQUFVQyxDQUFDLEVBQUV0VSxJQUFJO1FBQy9CLElBQUkyTyxVQUFVLEVBQUU7UUFFaEIsTUFBUTJGLEdBQUdBLElBQUlBLEVBQUV2RSxXQUFXLENBQUc7WUFDOUIsSUFBS3VFLEVBQUVwWCxRQUFRLEtBQUssS0FBS29YLE1BQU10VSxNQUFPO2dCQUNyQzJPLFFBQVFwUyxJQUFJLENBQUUrWDtZQUNmO1FBQ0Q7UUFFQSxPQUFPM0Y7SUFDUjtJQUdBLElBQUk0RixnQkFBZ0IzVixPQUFPeU4sSUFBSSxDQUFDckQsS0FBSyxDQUFDN0IsWUFBWTtJQUVsRCxJQUFJcU4sYUFBZTtJQUluQiwyREFBMkQ7SUFDM0QsU0FBU0MsT0FBUW5JLFFBQVEsRUFBRW9JLFNBQVMsRUFBRTlGLEdBQUc7UUFDeEMsSUFBSzVSLFdBQVkwWCxZQUFjO1lBQzlCLE9BQU85VixPQUFPMEIsSUFBSSxDQUFFZ00sVUFBVSxTQUFVdE0sSUFBSSxFQUFFbEMsQ0FBQztnQkFDOUMsT0FBTyxDQUFDLENBQUM0VyxVQUFVdFksSUFBSSxDQUFFNEQsTUFBTWxDLEdBQUdrQyxVQUFXNE87WUFDOUM7UUFDRDtRQUVBLGlCQUFpQjtRQUNqQixJQUFLOEYsVUFBVXhYLFFBQVEsRUFBRztZQUN6QixPQUFPMEIsT0FBTzBCLElBQUksQ0FBRWdNLFVBQVUsU0FBVXRNLElBQUk7Z0JBQzNDLE9BQU8sU0FBVzBVLGNBQWdCOUY7WUFDbkM7UUFDRDtRQUVBLG1EQUFtRDtRQUNuRCxJQUFLLE9BQU84RixjQUFjLFVBQVc7WUFDcEMsT0FBTzlWLE9BQU8wQixJQUFJLENBQUVnTSxVQUFVLFNBQVV0TSxJQUFJO2dCQUMzQyxPQUFPLFFBQVU1RCxJQUFJLENBQUVzWSxXQUFXMVUsUUFBUyxDQUFDLE1BQVE0TztZQUNyRDtRQUNEO1FBRUEsMERBQTBEO1FBQzFELE9BQU9oUSxPQUFPZ04sTUFBTSxDQUFFOEksV0FBV3BJLFVBQVVzQztJQUM1QztJQUVBaFEsT0FBT2dOLE1BQU0sR0FBRyxTQUFVUyxJQUFJLEVBQUU1TSxLQUFLLEVBQUVtUCxHQUFHO1FBQ3pDLElBQUk1TyxPQUFPUCxLQUFLLENBQUUsRUFBRztRQUVyQixJQUFLbVAsS0FBTTtZQUNWdkMsT0FBTyxVQUFVQSxPQUFPO1FBQ3pCO1FBRUEsSUFBSzVNLE1BQU1MLE1BQU0sS0FBSyxLQUFLWSxLQUFLOUMsUUFBUSxLQUFLLEdBQUk7WUFDaEQsT0FBTzBCLE9BQU9nSyxJQUFJLENBQUMyRCxlQUFlLENBQUV2TSxNQUFNcU0sUUFBUztnQkFBRXJNO2FBQU0sR0FBRyxFQUFFO1FBQ2pFO1FBRUEsT0FBT3BCLE9BQU9nSyxJQUFJLENBQUNyRixPQUFPLENBQUU4SSxNQUFNek4sT0FBTzBCLElBQUksQ0FBRWIsT0FBTyxTQUFVTyxJQUFJO1lBQ25FLE9BQU9BLEtBQUs5QyxRQUFRLEtBQUs7UUFDMUI7SUFDRDtJQUVBMEIsT0FBT0csRUFBRSxDQUFDK0IsTUFBTSxDQUFFO1FBQ2pCOEgsTUFBTSxTQUFVL0osUUFBUTtZQUN2QixJQUFJZixHQUFHNEIsS0FDTmUsTUFBTSxJQUFJLENBQUNyQixNQUFNLEVBQ2pCdVYsT0FBTyxJQUFJO1lBRVosSUFBSyxPQUFPOVYsYUFBYSxVQUFXO2dCQUNuQyxPQUFPLElBQUksQ0FBQ1csU0FBUyxDQUFFWixPQUFRQyxVQUFXK00sTUFBTSxDQUFFO29CQUNqRCxJQUFNOU4sSUFBSSxHQUFHQSxJQUFJMkMsS0FBSzNDLElBQU07d0JBQzNCLElBQUtjLE9BQU95RixRQUFRLENBQUVzUSxJQUFJLENBQUU3VyxFQUFHLEVBQUUsSUFBSSxHQUFLOzRCQUN6QyxPQUFPO3dCQUNSO29CQUNEO2dCQUNEO1lBQ0Q7WUFFQTRCLE1BQU0sSUFBSSxDQUFDRixTQUFTLENBQUUsRUFBRTtZQUV4QixJQUFNMUIsSUFBSSxHQUFHQSxJQUFJMkMsS0FBSzNDLElBQU07Z0JBQzNCYyxPQUFPZ0ssSUFBSSxDQUFFL0osVUFBVThWLElBQUksQ0FBRTdXLEVBQUcsRUFBRTRCO1lBQ25DO1lBRUEsT0FBT2UsTUFBTSxJQUFJN0IsT0FBTzhOLFVBQVUsQ0FBRWhOLE9BQVFBO1FBQzdDO1FBQ0FrTSxRQUFRLFNBQVUvTSxRQUFRO1lBQ3pCLE9BQU8sSUFBSSxDQUFDVyxTQUFTLENBQUVpVixPQUFRLElBQUksRUFBRTVWLFlBQVksRUFBRSxFQUFFO1FBQ3REO1FBQ0ErUCxLQUFLLFNBQVUvUCxRQUFRO1lBQ3RCLE9BQU8sSUFBSSxDQUFDVyxTQUFTLENBQUVpVixPQUFRLElBQUksRUFBRTVWLFlBQVksRUFBRSxFQUFFO1FBQ3REO1FBQ0F1VixJQUFJLFNBQVV2VixRQUFRO1lBQ3JCLE9BQU8sQ0FBQyxDQUFDNFYsT0FDUixJQUFJLEVBRUosa0ZBQWtGO1lBQ2xGLHlFQUF5RTtZQUN6RSxPQUFPNVYsYUFBYSxZQUFZMFYsY0FBY3JSLElBQUksQ0FBRXJFLFlBQ25ERCxPQUFRQyxZQUNSQSxZQUFZLEVBQUUsRUFDZixPQUNDTyxNQUFNO1FBQ1Q7SUFDRDtJQUdBLDZCQUE2QjtJQUc3QixtREFBbUQ7SUFDbkQsSUFBSXdWLFlBRUgseUNBQXlDO0lBQ3pDLHVFQUF1RTtJQUN2RSwwREFBMEQ7SUFDMUQscUNBQXFDO0lBQ3JDdE4sYUFBYSx1Q0FFYnRJLE9BQU9KLE9BQU9HLEVBQUUsQ0FBQ0MsSUFBSSxHQUFHLFNBQVVILFFBQVEsRUFBRUMsT0FBTyxFQUFFdVEsSUFBSTtRQUN4RCxJQUFJckcsT0FBT2hKO1FBRVgsaURBQWlEO1FBQ2pELElBQUssQ0FBQ25CLFVBQVc7WUFDaEIsT0FBTyxJQUFJO1FBQ1o7UUFFQSxnREFBZ0Q7UUFDaEQsOENBQThDO1FBQzlDd1EsT0FBT0EsUUFBUXVGO1FBRWYsc0JBQXNCO1FBQ3RCLElBQUssT0FBTy9WLGFBQWEsVUFBVztZQUNuQyxJQUFLQSxRQUFRLENBQUUsRUFBRyxLQUFLLE9BQ3RCQSxRQUFRLENBQUVBLFNBQVNPLE1BQU0sR0FBRyxFQUFHLEtBQUssT0FDcENQLFNBQVNPLE1BQU0sSUFBSSxHQUFJO2dCQUV2QixtRkFBbUY7Z0JBQ25GNEosUUFBUTtvQkFBRTtvQkFBTW5LO29CQUFVO2lCQUFNO1lBRWpDLE9BQU87Z0JBQ05tSyxRQUFRMUIsV0FBVzhCLElBQUksQ0FBRXZLO1lBQzFCO1lBRUEsMERBQTBEO1lBQzFELElBQUttSyxTQUFXQSxDQUFBQSxLQUFLLENBQUUsRUFBRyxJQUFJLENBQUNsSyxPQUFNLEdBQU07Z0JBRTFDLDhCQUE4QjtnQkFDOUIsSUFBS2tLLEtBQUssQ0FBRSxFQUFHLEVBQUc7b0JBQ2pCbEssVUFBVUEsbUJBQW1CRixTQUFTRSxPQUFPLENBQUUsRUFBRyxHQUFHQTtvQkFFckQsZ0RBQWdEO29CQUNoRCxvRUFBb0U7b0JBQ3BFRixPQUFPZSxLQUFLLENBQUUsSUFBSSxFQUFFZixPQUFPaVcsU0FBUyxDQUNuQzdMLEtBQUssQ0FBRSxFQUFHLEVBQ1ZsSyxXQUFXQSxRQUFRNUIsUUFBUSxHQUFHNEIsUUFBUW1FLGFBQWEsSUFBSW5FLFVBQVV0RCxVQUNqRTtvQkFHRCx5QkFBeUI7b0JBQ3pCLElBQUtnWixXQUFXdFIsSUFBSSxDQUFFOEYsS0FBSyxDQUFFLEVBQUcsS0FBTXBLLE9BQU8wQyxhQUFhLENBQUV4QyxVQUFZO3dCQUN2RSxJQUFNa0ssU0FBU2xLLFFBQVU7NEJBRXhCLDBEQUEwRDs0QkFDMUQsSUFBSzlCLFdBQVksSUFBSSxDQUFFZ00sTUFBTyxHQUFLO2dDQUNsQyxJQUFJLENBQUVBLE1BQU8sQ0FBRWxLLE9BQU8sQ0FBRWtLLE1BQU87NEJBRWhDLHFDQUFxQzs0QkFDckMsT0FBTztnQ0FDTixJQUFJLENBQUN3RCxJQUFJLENBQUV4RCxPQUFPbEssT0FBTyxDQUFFa0ssTUFBTzs0QkFDbkM7d0JBQ0Q7b0JBQ0Q7b0JBRUEsT0FBTyxJQUFJO2dCQUVaLGlCQUFpQjtnQkFDakIsT0FBTztvQkFDTmhKLE9BQU94RSxTQUFTNk4sY0FBYyxDQUFFTCxLQUFLLENBQUUsRUFBRztvQkFFMUMsSUFBS2hKLE1BQU87d0JBRVgscURBQXFEO3dCQUNyRCxJQUFJLENBQUUsRUFBRyxHQUFHQTt3QkFDWixJQUFJLENBQUNaLE1BQU0sR0FBRztvQkFDZjtvQkFDQSxPQUFPLElBQUk7Z0JBQ1o7WUFFRCwwQkFBMEI7WUFDMUIsT0FBTyxJQUFLLENBQUNOLFdBQVdBLFFBQVFJLE1BQU0sRUFBRztnQkFDeEMsT0FBTyxDQUFFSixXQUFXdVEsSUFBRyxFQUFJekcsSUFBSSxDQUFFL0o7WUFFbEMsMkJBQTJCO1lBQzNCLHNEQUFzRDtZQUN0RCxPQUFPO2dCQUNOLE9BQU8sSUFBSSxDQUFDTSxXQUFXLENBQUVMLFNBQVU4SixJQUFJLENBQUUvSjtZQUMxQztRQUVELHdCQUF3QjtRQUN4QixPQUFPLElBQUtBLFNBQVMzQixRQUFRLEVBQUc7WUFDL0IsSUFBSSxDQUFFLEVBQUcsR0FBRzJCO1lBQ1osSUFBSSxDQUFDTyxNQUFNLEdBQUc7WUFDZCxPQUFPLElBQUk7UUFFWixzQkFBc0I7UUFDdEIsOEJBQThCO1FBQzlCLE9BQU8sSUFBS3BDLFdBQVk2QixXQUFhO1lBQ3BDLE9BQU93USxLQUFLeUYsS0FBSyxLQUFLclQsWUFDckI0TixLQUFLeUYsS0FBSyxDQUFFalcsWUFFWiw4Q0FBOEM7WUFDOUNBLFNBQVVEO1FBQ1o7UUFFQSxPQUFPQSxPQUFPOEQsU0FBUyxDQUFFN0QsVUFBVSxJQUFJO0lBQ3hDO0lBRUQsc0VBQXNFO0lBQ3RFRyxLQUFLQyxTQUFTLEdBQUdMLE9BQU9HLEVBQUU7SUFFMUIsK0JBQStCO0lBQy9CNlYsYUFBYWhXLE9BQVFwRDtJQUdyQixJQUFJdVosZUFBZSxrQ0FFbEIsNkVBQTZFO0lBQzdFQyxtQkFBbUI7UUFDbEJDLFVBQVU7UUFDVkMsVUFBVTtRQUNWN00sTUFBTTtRQUNOOE0sTUFBTTtJQUNQO0lBRUR2VyxPQUFPRyxFQUFFLENBQUMrQixNQUFNLENBQUU7UUFDakJrTyxLQUFLLFNBQVU1TixNQUFNO1lBQ3BCLElBQUlnVSxVQUFVeFcsT0FBUXdDLFFBQVEsSUFBSSxHQUNqQ2lVLElBQUlELFFBQVFoVyxNQUFNO1lBRW5CLE9BQU8sSUFBSSxDQUFDd00sTUFBTSxDQUFFO2dCQUNuQixJQUFJOU4sSUFBSTtnQkFDUixNQUFRQSxJQUFJdVgsR0FBR3ZYLElBQU07b0JBQ3BCLElBQUtjLE9BQU95RixRQUFRLENBQUUsSUFBSSxFQUFFK1EsT0FBTyxDQUFFdFgsRUFBRyxHQUFLO3dCQUM1QyxPQUFPO29CQUNSO2dCQUNEO1lBQ0Q7UUFDRDtRQUVBd1gsU0FBUyxTQUFVckIsU0FBUyxFQUFFblYsT0FBTztZQUNwQyxJQUFJeVcsS0FDSHpYLElBQUksR0FDSnVYLElBQUksSUFBSSxDQUFDalcsTUFBTSxFQUNmdVAsVUFBVSxFQUFFLEVBQ1p5RyxVQUFVLE9BQU9uQixjQUFjLFlBQVlyVixPQUFRcVY7WUFFcEQseUVBQXlFO1lBQ3pFLElBQUssQ0FBQ00sY0FBY3JSLElBQUksQ0FBRStRLFlBQWM7Z0JBQ3ZDLE1BQVFuVyxJQUFJdVgsR0FBR3ZYLElBQU07b0JBQ3BCLElBQU15WCxNQUFNLElBQUksQ0FBRXpYLEVBQUcsRUFBRXlYLE9BQU9BLFFBQVF6VyxTQUFTeVcsTUFBTUEsSUFBSWhYLFVBQVUsQ0FBRzt3QkFFckUsaUNBQWlDO3dCQUNqQyxJQUFLZ1gsSUFBSXJZLFFBQVEsR0FBRyxNQUFRa1ksQ0FBQUEsVUFDM0JBLFFBQVFJLEtBQUssQ0FBRUQsT0FBUSxDQUFDLElBRXhCLHlDQUF5Qzt3QkFDekNBLElBQUlyWSxRQUFRLEtBQUssS0FDaEIwQixPQUFPZ0ssSUFBSSxDQUFDMkQsZUFBZSxDQUFFZ0osS0FBS3RCLFVBQVUsR0FBTTs0QkFFbkR0RixRQUFRcFMsSUFBSSxDQUFFZ1o7NEJBQ2Q7d0JBQ0Q7b0JBQ0Q7Z0JBQ0Q7WUFDRDtZQUVBLE9BQU8sSUFBSSxDQUFDL1YsU0FBUyxDQUFFbVAsUUFBUXZQLE1BQU0sR0FBRyxJQUFJUixPQUFPOE4sVUFBVSxDQUFFaUMsV0FBWUE7UUFDNUU7UUFFQSxzREFBc0Q7UUFDdEQ2RyxPQUFPLFNBQVV4VixJQUFJO1lBRXBCLHNDQUFzQztZQUN0QyxJQUFLLENBQUNBLE1BQU87Z0JBQ1osT0FBTyxJQUFNLENBQUUsRUFBRyxJQUFJLElBQUksQ0FBRSxFQUFHLENBQUN6QixVQUFVLEdBQUssSUFBSSxDQUFDMkIsS0FBSyxHQUFHdVYsT0FBTyxHQUFHclcsTUFBTSxHQUFHLENBQUM7WUFDakY7WUFFQSxvQkFBb0I7WUFDcEIsSUFBSyxPQUFPWSxTQUFTLFVBQVc7Z0JBQy9CLE9BQU94RCxRQUFRSixJQUFJLENBQUV3QyxPQUFRb0IsT0FBUSxJQUFJLENBQUUsRUFBRztZQUMvQztZQUVBLDZDQUE2QztZQUM3QyxPQUFPeEQsUUFBUUosSUFBSSxDQUFFLElBQUksRUFFeEIsNERBQTREO1lBQzVENEQsS0FBS2QsTUFBTSxHQUFHYyxJQUFJLENBQUUsRUFBRyxHQUFHQTtRQUU1QjtRQUVBMFYsS0FBSyxTQUFVN1csUUFBUSxFQUFFQyxPQUFPO1lBQy9CLE9BQU8sSUFBSSxDQUFDVSxTQUFTLENBQ3BCWixPQUFPOE4sVUFBVSxDQUNoQjlOLE9BQU9lLEtBQUssQ0FBRSxJQUFJLENBQUNMLEdBQUcsSUFBSVYsT0FBUUMsVUFBVUM7UUFHL0M7UUFFQTZXLFNBQVMsU0FBVTlXLFFBQVE7WUFDMUIsT0FBTyxJQUFJLENBQUM2VyxHQUFHLENBQUU3VyxZQUFZLE9BQzVCLElBQUksQ0FBQ2UsVUFBVSxHQUFHLElBQUksQ0FBQ0EsVUFBVSxDQUFDZ00sTUFBTSxDQUFFL007UUFFNUM7SUFDRDtJQUVBLFNBQVMrVyxRQUFTTCxHQUFHLEVBQUVuTixHQUFHO1FBQ3pCLE1BQVEsQ0FBRW1OLE1BQU1BLEdBQUcsQ0FBRW5OLElBQUssS0FBTW1OLElBQUlyWSxRQUFRLEtBQUssRUFBSSxDQUFDO1FBQ3RELE9BQU9xWTtJQUNSO0lBRUEzVyxPQUFPaUIsSUFBSSxDQUFFO1FBQ1pxTyxRQUFRLFNBQVVsTyxJQUFJO1lBQ3JCLElBQUlrTyxTQUFTbE8sS0FBS3pCLFVBQVU7WUFDNUIsT0FBTzJQLFVBQVVBLE9BQU9oUixRQUFRLEtBQUssS0FBS2dSLFNBQVM7UUFDcEQ7UUFDQTJILFNBQVMsU0FBVTdWLElBQUk7WUFDdEIsT0FBT29JLElBQUtwSSxNQUFNO1FBQ25CO1FBQ0E4VixjQUFjLFNBQVU5VixJQUFJLEVBQUUrRCxFQUFFLEVBQUVtUSxLQUFLO1lBQ3RDLE9BQU85TCxJQUFLcEksTUFBTSxjQUFja1U7UUFDakM7UUFDQTdMLE1BQU0sU0FBVXJJLElBQUk7WUFDbkIsT0FBTzRWLFFBQVM1VixNQUFNO1FBQ3ZCO1FBQ0FtVixNQUFNLFNBQVVuVixJQUFJO1lBQ25CLE9BQU80VixRQUFTNVYsTUFBTTtRQUN2QjtRQUNBK1YsU0FBUyxTQUFVL1YsSUFBSTtZQUN0QixPQUFPb0ksSUFBS3BJLE1BQU07UUFDbkI7UUFDQXlWLFNBQVMsU0FBVXpWLElBQUk7WUFDdEIsT0FBT29JLElBQUtwSSxNQUFNO1FBQ25CO1FBQ0FnVyxXQUFXLFNBQVVoVyxJQUFJLEVBQUUrRCxFQUFFLEVBQUVtUSxLQUFLO1lBQ25DLE9BQU85TCxJQUFLcEksTUFBTSxlQUFla1U7UUFDbEM7UUFDQStCLFdBQVcsU0FBVWpXLElBQUksRUFBRStELEVBQUUsRUFBRW1RLEtBQUs7WUFDbkMsT0FBTzlMLElBQUtwSSxNQUFNLG1CQUFtQmtVO1FBQ3RDO1FBQ0FHLFVBQVUsU0FBVXJVLElBQUk7WUFDdkIsT0FBT3FVLFNBQVUsQ0FBRXJVLEtBQUt6QixVQUFVLElBQUksQ0FBQyxHQUFJOFAsVUFBVSxFQUFFck87UUFDeEQ7UUFDQWlWLFVBQVUsU0FBVWpWLElBQUk7WUFDdkIsT0FBT3FVLFNBQVVyVSxLQUFLcU8sVUFBVTtRQUNqQztRQUNBNkcsVUFBVSxTQUFVbFYsSUFBSTtZQUN2QixJQUFLQSxLQUFLa1csZUFBZSxJQUFJLFFBRTVCLGtCQUFrQjtZQUNsQiwyREFBMkQ7WUFDM0QsNkNBQTZDO1lBQzdDcGEsU0FBVWtFLEtBQUtrVyxlQUFlLEdBQUs7Z0JBRW5DLE9BQU9sVyxLQUFLa1csZUFBZTtZQUM1QjtZQUVBLGtFQUFrRTtZQUNsRSwrREFBK0Q7WUFDL0Qsb0JBQW9CO1lBQ3BCLElBQUsvUyxTQUFVbkQsTUFBTSxhQUFlO2dCQUNuQ0EsT0FBT0EsS0FBS21XLE9BQU8sSUFBSW5XO1lBQ3hCO1lBRUEsT0FBT3BCLE9BQU9lLEtBQUssQ0FBRSxFQUFFLEVBQUVLLEtBQUt5SSxVQUFVO1FBQ3pDO0lBQ0QsR0FBRyxTQUFVekgsSUFBSSxFQUFFakMsRUFBRTtRQUNwQkgsT0FBT0csRUFBRSxDQUFFaUMsS0FBTSxHQUFHLFNBQVVrVCxLQUFLLEVBQUVyVixRQUFRO1lBQzVDLElBQUk4UCxVQUFVL1AsT0FBT21CLEdBQUcsQ0FBRSxJQUFJLEVBQUVoQixJQUFJbVY7WUFFcEMsSUFBS2xULEtBQUsvRSxLQUFLLENBQUUsQ0FBQyxPQUFRLFNBQVU7Z0JBQ25DNEMsV0FBV3FWO1lBQ1o7WUFFQSxJQUFLclYsWUFBWSxPQUFPQSxhQUFhLFVBQVc7Z0JBQy9DOFAsVUFBVS9QLE9BQU9nTixNQUFNLENBQUUvTSxVQUFVOFA7WUFDcEM7WUFFQSxJQUFLLElBQUksQ0FBQ3ZQLE1BQU0sR0FBRyxHQUFJO2dCQUV0QixvQkFBb0I7Z0JBQ3BCLElBQUssQ0FBQzRWLGdCQUFnQixDQUFFaFUsS0FBTSxFQUFHO29CQUNoQ3BDLE9BQU84TixVQUFVLENBQUVpQztnQkFDcEI7Z0JBRUEsa0RBQWtEO2dCQUNsRCxJQUFLb0csYUFBYTdSLElBQUksQ0FBRWxDLE9BQVM7b0JBQ2hDMk4sUUFBUXlILE9BQU87Z0JBQ2hCO1lBQ0Q7WUFFQSxPQUFPLElBQUksQ0FBQzVXLFNBQVMsQ0FBRW1QO1FBQ3hCO0lBQ0Q7SUFDQSxJQUFJMEgsZ0JBQWtCO0lBSXRCLDhEQUE4RDtJQUM5RCxTQUFTQyxjQUFldlYsT0FBTztRQUM5QixJQUFJd1YsU0FBUyxDQUFDO1FBQ2QzWCxPQUFPaUIsSUFBSSxDQUFFa0IsUUFBUWlJLEtBQUssQ0FBRXFOLGtCQUFtQixFQUFFLEVBQUUsU0FBVUcsQ0FBQyxFQUFFQyxJQUFJO1lBQ25FRixNQUFNLENBQUVFLEtBQU0sR0FBRztRQUNsQjtRQUNBLE9BQU9GO0lBQ1I7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ0QzWCxPQUFPOFgsU0FBUyxHQUFHLFNBQVUzVixPQUFPO1FBRW5DLHNFQUFzRTtRQUN0RSw0QkFBNEI7UUFDNUJBLFVBQVUsT0FBT0EsWUFBWSxXQUM1QnVWLGNBQWV2VixXQUNmbkMsT0FBT2tDLE1BQU0sQ0FBRSxDQUFDLEdBQUdDO1FBRXBCLElBQ0M0VixRQUVBLDRDQUE0QztRQUM1Q0MsUUFFQSx5Q0FBeUM7UUFDekNDLE9BRUEseUJBQXlCO1FBQ3pCQyxRQUVBLHVCQUF1QjtRQUN2QkMsT0FBTyxFQUFFLEVBRVQsK0NBQStDO1FBQy9DQyxRQUFRLEVBQUUsRUFFVix3RUFBd0U7UUFDeEVDLGNBQWMsQ0FBQyxHQUVmLGlCQUFpQjtRQUNqQkMsT0FBTztZQUVOLHdCQUF3QjtZQUN4QkosU0FBU0EsVUFBVS9WLFFBQVFvVyxJQUFJO1lBRS9CLGdEQUFnRDtZQUNoRCx1REFBdUQ7WUFDdkROLFFBQVFGLFNBQVM7WUFDakIsTUFBUUssTUFBTTVYLE1BQU0sRUFBRTZYLGNBQWMsQ0FBQyxFQUFJO2dCQUN4Q0wsU0FBU0ksTUFBTTFNLEtBQUs7Z0JBQ3BCLE1BQVEsRUFBRTJNLGNBQWNGLEtBQUszWCxNQUFNLENBQUc7b0JBRXJDLCtDQUErQztvQkFDL0MsSUFBSzJYLElBQUksQ0FBRUUsWUFBYSxDQUFDM2EsS0FBSyxDQUFFc2EsTUFBTSxDQUFFLEVBQUcsRUFBRUEsTUFBTSxDQUFFLEVBQUcsTUFBTyxTQUM5RDdWLFFBQVFxVyxXQUFXLEVBQUc7d0JBRXRCLDBEQUEwRDt3QkFDMURILGNBQWNGLEtBQUszWCxNQUFNO3dCQUN6QndYLFNBQVM7b0JBQ1Y7Z0JBQ0Q7WUFDRDtZQUVBLHdDQUF3QztZQUN4QyxJQUFLLENBQUM3VixRQUFRNlYsTUFBTSxFQUFHO2dCQUN0QkEsU0FBUztZQUNWO1lBRUFELFNBQVM7WUFFVCx5Q0FBeUM7WUFDekMsSUFBS0csUUFBUztnQkFFYiwwREFBMEQ7Z0JBQzFELElBQUtGLFFBQVM7b0JBQ2JHLE9BQU8sRUFBRTtnQkFFVixrQ0FBa0M7Z0JBQ2xDLE9BQU87b0JBQ05BLE9BQU87Z0JBQ1I7WUFDRDtRQUNELEdBRUEsMEJBQTBCO1FBQzFCcEMsT0FBTztZQUVOLDBEQUEwRDtZQUMxRGUsS0FBSztnQkFDSixJQUFLcUIsTUFBTztvQkFFWCxpRUFBaUU7b0JBQ2pFLElBQUtILFVBQVUsQ0FBQ0QsUUFBUzt3QkFDeEJNLGNBQWNGLEtBQUszWCxNQUFNLEdBQUc7d0JBQzVCNFgsTUFBTXphLElBQUksQ0FBRXFhO29CQUNiO29CQUVFLFVBQVNsQixJQUFLbEgsSUFBSTt3QkFDbkI1UCxPQUFPaUIsSUFBSSxDQUFFMk8sTUFBTSxTQUFVZ0ksQ0FBQyxFQUFFL1MsR0FBRzs0QkFDbEMsSUFBS3pHLFdBQVl5RyxNQUFRO2dDQUN4QixJQUFLLENBQUMxQyxRQUFRK1MsTUFBTSxJQUFJLENBQUNhLEtBQUszRixHQUFHLENBQUV2TCxNQUFRO29DQUMxQ3NULEtBQUt4YSxJQUFJLENBQUVrSDtnQ0FDWjs0QkFDRCxPQUFPLElBQUtBLE9BQU9BLElBQUlyRSxNQUFNLElBQUlYLE9BQVFnRixTQUFVLFVBQVc7Z0NBRTdELHNCQUFzQjtnQ0FDdEJpUyxJQUFLalM7NEJBQ047d0JBQ0Q7b0JBQ0QsR0FBS3hEO29CQUVMLElBQUsyVyxVQUFVLENBQUNELFFBQVM7d0JBQ3hCTztvQkFDRDtnQkFDRDtnQkFDQSxPQUFPLElBQUk7WUFDWjtZQUVBLGtDQUFrQztZQUNsQ0csUUFBUTtnQkFDUHpZLE9BQU9pQixJQUFJLENBQUVJLFdBQVcsU0FBVXVXLENBQUMsRUFBRS9TLEdBQUc7b0JBQ3ZDLElBQUkrUjtvQkFDSixNQUFRLENBQUVBLFFBQVE1VyxPQUFPZ0UsT0FBTyxDQUFFYSxLQUFLc1QsTUFBTXZCLE1BQU0sSUFBTSxDQUFDLEVBQUk7d0JBQzdEdUIsS0FBS2xXLE1BQU0sQ0FBRTJVLE9BQU87d0JBRXBCLHdCQUF3Qjt3QkFDeEIsSUFBS0EsU0FBU3lCLGFBQWM7NEJBQzNCQTt3QkFDRDtvQkFDRDtnQkFDRDtnQkFDQSxPQUFPLElBQUk7WUFDWjtZQUVBLDRDQUE0QztZQUM1Qyw4RUFBOEU7WUFDOUVqSSxLQUFLLFNBQVVqUSxFQUFFO2dCQUNoQixPQUFPQSxLQUNOSCxPQUFPZ0UsT0FBTyxDQUFFN0QsSUFBSWdZLFFBQVMsQ0FBQyxJQUM5QkEsS0FBSzNYLE1BQU0sR0FBRztZQUNoQjtZQUVBLHFDQUFxQztZQUNyQzBRLE9BQU87Z0JBQ04sSUFBS2lILE1BQU87b0JBQ1hBLE9BQU8sRUFBRTtnQkFDVjtnQkFDQSxPQUFPLElBQUk7WUFDWjtZQUVBLHlCQUF5QjtZQUN6Qix1Q0FBdUM7WUFDdkMsaUNBQWlDO1lBQ2pDTyxTQUFTO2dCQUNSUixTQUFTRSxRQUFRLEVBQUU7Z0JBQ25CRCxPQUFPSCxTQUFTO2dCQUNoQixPQUFPLElBQUk7WUFDWjtZQUNBek8sVUFBVTtnQkFDVCxPQUFPLENBQUM0TztZQUNUO1lBRUEsZ0JBQWdCO1lBQ2hCLDBFQUEwRTtZQUMxRSwrQkFBK0I7WUFDL0JRLE1BQU07Z0JBQ0xULFNBQVNFLFFBQVEsRUFBRTtnQkFDbkIsSUFBSyxDQUFDSixVQUFVLENBQUNELFFBQVM7b0JBQ3pCSSxPQUFPSCxTQUFTO2dCQUNqQjtnQkFDQSxPQUFPLElBQUk7WUFDWjtZQUNBRSxRQUFRO2dCQUNQLE9BQU8sQ0FBQyxDQUFDQTtZQUNWO1lBRUEsMERBQTBEO1lBQzFEVSxVQUFVLFNBQVUxWSxPQUFPLEVBQUUwUCxJQUFJO2dCQUNoQyxJQUFLLENBQUNzSSxRQUFTO29CQUNkdEksT0FBT0EsUUFBUSxFQUFFO29CQUNqQkEsT0FBTzt3QkFBRTFQO3dCQUFTMFAsS0FBS3ZTLEtBQUssR0FBR3VTLEtBQUt2UyxLQUFLLEtBQUt1UztxQkFBTTtvQkFDcER3SSxNQUFNemEsSUFBSSxDQUFFaVM7b0JBQ1osSUFBSyxDQUFDbUksUUFBUzt3QkFDZE87b0JBQ0Q7Z0JBQ0Q7Z0JBQ0EsT0FBTyxJQUFJO1lBQ1o7WUFFQSxrREFBa0Q7WUFDbERBLE1BQU07Z0JBQ0x2QyxLQUFLNkMsUUFBUSxDQUFFLElBQUksRUFBRXZYO2dCQUNyQixPQUFPLElBQUk7WUFDWjtZQUVBLGtFQUFrRTtZQUNsRTRXLE9BQU87Z0JBQ04sT0FBTyxDQUFDLENBQUNBO1lBQ1Y7UUFDRDtRQUVELE9BQU9sQztJQUNSO0lBR0EsU0FBUzhDLFNBQVVDLENBQUM7UUFDbkIsT0FBT0E7SUFDUjtJQUNBLFNBQVNDLFFBQVNDLEVBQUU7UUFDbkIsTUFBTUE7SUFDUDtJQUVBLFNBQVNDLFdBQVluVSxLQUFLLEVBQUVvVSxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsT0FBTztRQUNuRCxJQUFJQztRQUVKLElBQUk7WUFFSCxtRUFBbUU7WUFDbkUsSUFBS3ZVLFNBQVMxRyxXQUFjaWIsU0FBU3ZVLE1BQU13VSxPQUFPLEdBQU87Z0JBQ3hERCxPQUFPN2IsSUFBSSxDQUFFc0gsT0FBUWdDLElBQUksQ0FBRW9TLFNBQVVLLElBQUksQ0FBRUo7WUFFNUMsa0JBQWtCO1lBQ2xCLE9BQU8sSUFBS3JVLFNBQVMxRyxXQUFjaWIsU0FBU3ZVLE1BQU0wVSxJQUFJLEdBQU87Z0JBQzVESCxPQUFPN2IsSUFBSSxDQUFFc0gsT0FBT29VLFNBQVNDO1lBRTlCLHNCQUFzQjtZQUN0QixPQUFPO2dCQUVOLHdGQUF3RjtnQkFDeEYsb0RBQW9EO2dCQUNwRCw0Q0FBNEM7Z0JBQzVDRCxRQUFReGIsS0FBSyxDQUFFbUYsV0FBVztvQkFBRWlDO2lCQUFPLENBQUN6SCxLQUFLLENBQUUrYjtZQUM1QztRQUVELHNEQUFzRDtRQUN0RCx3RkFBd0Y7UUFDeEYscURBQXFEO1FBQ3JELEVBQUUsT0FBUXRVLE9BQVE7WUFFakIsNEJBQTRCO1lBQzVCLCtFQUErRTtZQUMvRXFVLE9BQU96YixLQUFLLENBQUVtRixXQUFXO2dCQUFFaUM7YUFBTztRQUNuQztJQUNEO0lBRUE5RSxPQUFPa0MsTUFBTSxDQUFFO1FBRWR1WCxVQUFVLFNBQVVDLElBQUk7WUFDdkIsSUFBSUMsU0FBUztnQkFFWCxtQ0FBbUM7Z0JBQ25DLG9EQUFvRDtnQkFDcEQ7b0JBQUU7b0JBQVU7b0JBQVkzWixPQUFPOFgsU0FBUyxDQUFFO29CQUN6QzlYLE9BQU84WCxTQUFTLENBQUU7b0JBQVk7aUJBQUc7Z0JBQ2xDO29CQUFFO29CQUFXO29CQUFROVgsT0FBTzhYLFNBQVMsQ0FBRTtvQkFDdEM5WCxPQUFPOFgsU0FBUyxDQUFFO29CQUFpQjtvQkFBRztpQkFBWTtnQkFDbkQ7b0JBQUU7b0JBQVU7b0JBQVE5WCxPQUFPOFgsU0FBUyxDQUFFO29CQUNyQzlYLE9BQU84WCxTQUFTLENBQUU7b0JBQWlCO29CQUFHO2lCQUFZO2FBQ25ELEVBQ0Q4QixRQUFRLFdBQ1JOLFVBQVU7Z0JBQ1RNLE9BQU87b0JBQ04sT0FBT0E7Z0JBQ1I7Z0JBQ0FDLFFBQVE7b0JBQ1BDLFNBQVNoVCxJQUFJLENBQUV6RixXQUFZa1ksSUFBSSxDQUFFbFk7b0JBQ2pDLE9BQU8sSUFBSTtnQkFDWjtnQkFDQSxTQUFTLFNBQVVsQixFQUFFO29CQUNwQixPQUFPbVosUUFBUUUsSUFBSSxDQUFFLE1BQU1yWjtnQkFDNUI7Z0JBRUEsNEJBQTRCO2dCQUM1QjRaLE1BQU07b0JBQ0wsSUFBSUMsTUFBTTNZO29CQUVWLE9BQU9yQixPQUFPeVosUUFBUSxDQUFFLFNBQVVRLFFBQVE7d0JBQ3pDamEsT0FBT2lCLElBQUksQ0FBRTBZLFFBQVEsU0FBVXhVLEVBQUUsRUFBRStVLEtBQUs7NEJBRXZDLHdFQUF3RTs0QkFDeEUsSUFBSS9aLEtBQUsvQixXQUFZNGIsR0FBRyxDQUFFRSxLQUFLLENBQUUsRUFBRyxDQUFFLEtBQU1GLEdBQUcsQ0FBRUUsS0FBSyxDQUFFLEVBQUcsQ0FBRTs0QkFFN0Qsd0VBQXdFOzRCQUN4RSxxRUFBcUU7NEJBQ3JFLG9FQUFvRTs0QkFDcEVKLFFBQVEsQ0FBRUksS0FBSyxDQUFFLEVBQUcsQ0FBRSxDQUFFO2dDQUN2QixJQUFJQyxXQUFXaGEsTUFBTUEsR0FBR3pDLEtBQUssQ0FBRSxJQUFJLEVBQUUyRDtnQ0FDckMsSUFBSzhZLFlBQVkvYixXQUFZK2IsU0FBU2IsT0FBTyxHQUFLO29DQUNqRGEsU0FBU2IsT0FBTyxHQUNkYyxRQUFRLENBQUVILFNBQVNJLE1BQU0sRUFDekJ2VCxJQUFJLENBQUVtVCxTQUFTZixPQUFPLEVBQ3RCSyxJQUFJLENBQUVVLFNBQVNkLE1BQU07Z0NBQ3hCLE9BQU87b0NBQ05jLFFBQVEsQ0FBRUMsS0FBSyxDQUFFLEVBQUcsR0FBRyxPQUFRLENBQzlCLElBQUksRUFDSi9aLEtBQUs7d0NBQUVnYTtxQ0FBVSxHQUFHOVk7Z0NBRXRCOzRCQUNEO3dCQUNEO3dCQUNBMlksTUFBTTtvQkFDUCxHQUFJVixPQUFPO2dCQUNaO2dCQUNBRSxNQUFNLFNBQVVjLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxVQUFVO29CQUNsRCxJQUFJQyxXQUFXO29CQUNmLFNBQVN2QixRQUFTd0IsS0FBSyxFQUFFWixRQUFRLEVBQUVhLE9BQU8sRUFBRUMsT0FBTzt3QkFDbEQsT0FBTzs0QkFDTixJQUFJQyxPQUFPLElBQUksRUFDZGpMLE9BQU92TyxXQUNQeVosYUFBYTtnQ0FDWixJQUFJWCxVQUFVWDtnQ0FFZCx5Q0FBeUM7Z0NBQ3pDLHNDQUFzQztnQ0FDdEMsb0NBQW9DO2dDQUNwQyxJQUFLa0IsUUFBUUQsVUFBVztvQ0FDdkI7Z0NBQ0Q7Z0NBRUFOLFdBQVdRLFFBQVFqZCxLQUFLLENBQUVtZCxNQUFNakw7Z0NBRWhDLHFDQUFxQztnQ0FDckMsc0NBQXNDO2dDQUN0QyxJQUFLdUssYUFBYUwsU0FBU1IsT0FBTyxJQUFLO29DQUN0QyxNQUFNLElBQUl5QixVQUFXO2dDQUN0QjtnQ0FFQSw2Q0FBNkM7Z0NBQzdDLHNDQUFzQztnQ0FDdEMsc0NBQXNDO2dDQUN0Qyw0QkFBNEI7Z0NBQzVCdkIsT0FBT1csWUFFTixxQ0FBcUM7Z0NBQ3JDLHNDQUFzQztnQ0FDdEMsbURBQW1EO2dDQUNqRCxRQUFPQSxhQUFhLFlBQ3JCLE9BQU9BLGFBQWEsVUFBUyxLQUM5QkEsU0FBU1gsSUFBSTtnQ0FFZCw2QkFBNkI7Z0NBQzdCLElBQUtwYixXQUFZb2IsT0FBUztvQ0FFekIsdURBQXVEO29DQUN2RCxJQUFLb0IsU0FBVTt3Q0FDZHBCLEtBQUtoYyxJQUFJLENBQ1IyYyxVQUNBakIsUUFBU3VCLFVBQVVYLFVBQVVqQixVQUFVK0IsVUFDdkMxQixRQUFTdUIsVUFBVVgsVUFBVWYsU0FBUzZCO29DQUd4QyxzREFBc0Q7b0NBQ3RELE9BQU87d0NBRU4sMkNBQTJDO3dDQUMzQ0g7d0NBRUFqQixLQUFLaGMsSUFBSSxDQUNSMmMsVUFDQWpCLFFBQVN1QixVQUFVWCxVQUFVakIsVUFBVStCLFVBQ3ZDMUIsUUFBU3VCLFVBQVVYLFVBQVVmLFNBQVM2QixVQUN0QzFCLFFBQVN1QixVQUFVWCxVQUFVakIsVUFDNUJpQixTQUFTa0IsVUFBVTtvQ0FFdEI7Z0NBRUQsbUNBQW1DO2dDQUNuQyxPQUFPO29DQUVOLDJDQUEyQztvQ0FDM0MsMENBQTBDO29DQUMxQyxJQUFLTCxZQUFZOUIsVUFBVzt3Q0FDM0JnQyxPQUFPaFk7d0NBQ1ArTSxPQUFPOzRDQUFFdUs7eUNBQVU7b0NBQ3BCO29DQUVBLHVCQUF1QjtvQ0FDdkIsNkJBQTZCO29DQUMzQlMsQ0FBQUEsV0FBV2QsU0FBU21CLFdBQVcsRUFBSUosTUFBTWpMO2dDQUM1Qzs0QkFDRCxHQUVBLCtEQUErRDs0QkFDL0RzTCxVQUFVTixVQUNURSxhQUNBO2dDQUNDLElBQUk7b0NBQ0hBO2dDQUNELEVBQUUsT0FBUWhSLEdBQUk7b0NBRWIsSUFBSzlKLE9BQU95WixRQUFRLENBQUMwQixhQUFhLEVBQUc7d0NBQ3BDbmIsT0FBT3laLFFBQVEsQ0FBQzBCLGFBQWEsQ0FBRXJSLEdBQzlCb1IsUUFBUS9YLEtBQUs7b0NBQ2Y7b0NBRUEsMkNBQTJDO29DQUMzQyxzQ0FBc0M7b0NBQ3RDLG9DQUFvQztvQ0FDcEMsSUFBS3VYLFFBQVEsS0FBS0QsVUFBVzt3Q0FFNUIsMkNBQTJDO3dDQUMzQywwQ0FBMEM7d0NBQzFDLElBQUtFLFlBQVk1QixTQUFVOzRDQUMxQjhCLE9BQU9oWTs0Q0FDUCtNLE9BQU87Z0RBQUU5Rjs2Q0FBRzt3Q0FDYjt3Q0FFQWdRLFNBQVNzQixVQUFVLENBQUVQLE1BQU1qTDtvQ0FDNUI7Z0NBQ0Q7NEJBQ0Q7NEJBRUYseUNBQXlDOzRCQUN6QyxzQ0FBc0M7NEJBQ3RDLGdFQUFnRTs0QkFDaEUsb0JBQW9COzRCQUNwQixJQUFLOEssT0FBUTtnQ0FDWlE7NEJBQ0QsT0FBTztnQ0FFTixrRUFBa0U7Z0NBQ2xFLHNEQUFzRDtnQ0FDdEQsSUFBS2xiLE9BQU95WixRQUFRLENBQUM0QixZQUFZLEVBQUc7b0NBQ25DSCxRQUFRL1gsS0FBSyxHQUFHbkQsT0FBT3laLFFBQVEsQ0FBQzRCLFlBQVk7Z0NBRTdDLDZEQUE2RDtnQ0FDN0QsaUVBQWlFO2dDQUNqRSwrREFBK0Q7Z0NBQy9ELDJDQUEyQztnQ0FDM0MsT0FBTyxJQUFLcmIsT0FBT3laLFFBQVEsQ0FBQzZCLFlBQVksRUFBRztvQ0FDMUNKLFFBQVEvWCxLQUFLLEdBQUduRCxPQUFPeVosUUFBUSxDQUFDNkIsWUFBWTtnQ0FDN0M7Z0NBQ0F2ZSxRQUFPd2UsVUFBVSxDQUFFTDs0QkFDcEI7d0JBQ0Q7b0JBQ0Q7b0JBRUEsT0FBT2xiLE9BQU95WixRQUFRLENBQUUsU0FBVVEsUUFBUTt3QkFFekMsK0JBQStCO3dCQUMvQk4sTUFBTSxDQUFFLEVBQUcsQ0FBRSxFQUFHLENBQUM3QyxHQUFHLENBQ25Cb0MsUUFDQyxHQUNBZSxVQUNBN2IsV0FBWW9jLGNBQ1hBLGFBQ0EzQixVQUNEb0IsU0FBU2UsVUFBVTt3QkFJckIsZ0NBQWdDO3dCQUNoQ3JCLE1BQU0sQ0FBRSxFQUFHLENBQUUsRUFBRyxDQUFDN0MsR0FBRyxDQUNuQm9DLFFBQ0MsR0FDQWUsVUFDQTdiLFdBQVlrYyxlQUNYQSxjQUNBekI7d0JBSUgsK0JBQStCO3dCQUMvQmMsTUFBTSxDQUFFLEVBQUcsQ0FBRSxFQUFHLENBQUM3QyxHQUFHLENBQ25Cb0MsUUFDQyxHQUNBZSxVQUNBN2IsV0FBWW1jLGNBQ1hBLGFBQ0F4QjtvQkFHSixHQUFJTyxPQUFPO2dCQUNaO2dCQUVBLGtDQUFrQztnQkFDbEMsZ0VBQWdFO2dCQUNoRUEsU0FBUyxTQUFVamIsR0FBRztvQkFDckIsT0FBT0EsT0FBTyxPQUFPMkIsT0FBT2tDLE1BQU0sQ0FBRTdELEtBQUtpYixXQUFZQTtnQkFDdEQ7WUFDRCxHQUNBUSxXQUFXLENBQUM7WUFFYiw0QkFBNEI7WUFDNUI5WixPQUFPaUIsSUFBSSxDQUFFMFksUUFBUSxTQUFVemEsQ0FBQyxFQUFFZ2IsS0FBSztnQkFDdEMsSUFBSS9CLE9BQU8rQixLQUFLLENBQUUsRUFBRyxFQUNwQnNCLGNBQWN0QixLQUFLLENBQUUsRUFBRztnQkFFekIsOEJBQThCO2dCQUM5QiwwQkFBMEI7Z0JBQzFCLDBCQUEwQjtnQkFDMUJaLE9BQU8sQ0FBRVksS0FBSyxDQUFFLEVBQUcsQ0FBRSxHQUFHL0IsS0FBS3JCLEdBQUc7Z0JBRWhDLGVBQWU7Z0JBQ2YsSUFBSzBFLGFBQWM7b0JBQ2xCckQsS0FBS3JCLEdBQUcsQ0FDUDt3QkFFQyx1Q0FBdUM7d0JBQ3ZDLHFCQUFxQjt3QkFDckI4QyxRQUFRNEI7b0JBQ1QsR0FFQSw2QkFBNkI7b0JBQzdCLDhCQUE4QjtvQkFDOUI3QixNQUFNLENBQUUsSUFBSXphLEVBQUcsQ0FBRSxFQUFHLENBQUN3WixPQUFPLEVBRTVCLDRCQUE0QjtvQkFDNUIsNkJBQTZCO29CQUM3QmlCLE1BQU0sQ0FBRSxJQUFJemEsRUFBRyxDQUFFLEVBQUcsQ0FBQ3daLE9BQU8sRUFFNUIsMEJBQTBCO29CQUMxQmlCLE1BQU0sQ0FBRSxFQUFHLENBQUUsRUFBRyxDQUFDaEIsSUFBSSxFQUVyQix5QkFBeUI7b0JBQ3pCZ0IsTUFBTSxDQUFFLEVBQUcsQ0FBRSxFQUFHLENBQUNoQixJQUFJO2dCQUV2QjtnQkFFQSx5QkFBeUI7Z0JBQ3pCLDBCQUEwQjtnQkFDMUIseUJBQXlCO2dCQUN6QlIsS0FBS3JCLEdBQUcsQ0FBRW9ELEtBQUssQ0FBRSxFQUFHLENBQUM1QixJQUFJO2dCQUV6Qiw0REFBNEQ7Z0JBQzVELDhEQUE4RDtnQkFDOUQsNERBQTREO2dCQUM1RHdCLFFBQVEsQ0FBRUksS0FBSyxDQUFFLEVBQUcsQ0FBRSxHQUFHO29CQUN4QkosUUFBUSxDQUFFSSxLQUFLLENBQUUsRUFBRyxHQUFHLE9BQVEsQ0FBRSxJQUFJLEtBQUtKLFdBQVdqWCxZQUFZLElBQUksRUFBRXhCO29CQUN2RSxPQUFPLElBQUk7Z0JBQ1o7Z0JBRUEsc0NBQXNDO2dCQUN0Qyx1Q0FBdUM7Z0JBQ3ZDLHNDQUFzQztnQkFDdEN5WSxRQUFRLENBQUVJLEtBQUssQ0FBRSxFQUFHLEdBQUcsT0FBUSxHQUFHL0IsS0FBS1MsUUFBUTtZQUNoRDtZQUVBLDhCQUE4QjtZQUM5QlUsUUFBUUEsT0FBTyxDQUFFUTtZQUVqQix5QkFBeUI7WUFDekIsSUFBS0osTUFBTztnQkFDWEEsS0FBS2xjLElBQUksQ0FBRXNjLFVBQVVBO1lBQ3RCO1lBRUEsWUFBWTtZQUNaLE9BQU9BO1FBQ1I7UUFFQSxrQkFBa0I7UUFDbEIyQixNQUFNLFNBQVVDLFdBQVc7WUFDMUIsSUFFQyxvQ0FBb0M7WUFDcENDLFlBQVl0YSxVQUFVYixNQUFNLEVBRTVCLGlDQUFpQztZQUNqQ3RCLElBQUl5YyxXQUVKLCtCQUErQjtZQUMvQkMsa0JBQWtCalosTUFBT3pELElBQ3pCMmMsZ0JBQWdCeGUsTUFBTUcsSUFBSSxDQUFFNkQsWUFFNUIsdUJBQXVCO1lBQ3ZCeWEsVUFBVTliLE9BQU95WixRQUFRLElBRXpCLCtCQUErQjtZQUMvQnNDLGFBQWEsU0FBVTdjLENBQUM7Z0JBQ3ZCLE9BQU8sU0FBVTRGLEtBQUs7b0JBQ3JCOFcsZUFBZSxDQUFFMWMsRUFBRyxHQUFHLElBQUk7b0JBQzNCMmMsYUFBYSxDQUFFM2MsRUFBRyxHQUFHbUMsVUFBVWIsTUFBTSxHQUFHLElBQUluRCxNQUFNRyxJQUFJLENBQUU2RCxhQUFjeUQ7b0JBQ3RFLElBQUssQ0FBRyxFQUFFNlcsV0FBYzt3QkFDdkJHLFFBQVFiLFdBQVcsQ0FBRVcsaUJBQWlCQztvQkFDdkM7Z0JBQ0Q7WUFDRDtZQUVELCtEQUErRDtZQUMvRCxJQUFLRixhQUFhLEdBQUk7Z0JBQ3JCMUMsV0FBWXlDLGFBQWFJLFFBQVFoVixJQUFJLENBQUVpVixXQUFZN2MsSUFBTWdhLE9BQU8sRUFBRTRDLFFBQVEzQyxNQUFNLEVBQy9FLENBQUN3QztnQkFFRiwwREFBMEQ7Z0JBQzFELElBQUtHLFFBQVFsQyxLQUFLLE9BQU8sYUFDeEJ4YixXQUFZeWQsYUFBYSxDQUFFM2MsRUFBRyxJQUFJMmMsYUFBYSxDQUFFM2MsRUFBRyxDQUFDc2EsSUFBSSxHQUFLO29CQUU5RCxPQUFPc0MsUUFBUXRDLElBQUk7Z0JBQ3BCO1lBQ0Q7WUFFQSxvRUFBb0U7WUFDcEUsTUFBUXRhLElBQU07Z0JBQ2IrWixXQUFZNEMsYUFBYSxDQUFFM2MsRUFBRyxFQUFFNmMsV0FBWTdjLElBQUs0YyxRQUFRM0MsTUFBTTtZQUNoRTtZQUVBLE9BQU8yQyxRQUFReEMsT0FBTztRQUN2QjtJQUNEO0lBR0Esa0VBQWtFO0lBQ2xFLCtEQUErRDtJQUMvRCxJQUFJMEMsY0FBYztJQUVsQix5RUFBeUU7SUFDekUsb0VBQW9FO0lBQ3BFLGlDQUFpQztJQUNqQ2hjLE9BQU95WixRQUFRLENBQUMwQixhQUFhLEdBQUcsU0FBVWhZLEtBQUssRUFBRThZLFVBQVU7UUFFMUQseUJBQXlCO1FBQ3pCLHVFQUF1RTtRQUN2RSxJQUFLbGYsUUFBT21mLE9BQU8sSUFBSW5mLFFBQU9tZixPQUFPLENBQUNDLElBQUksSUFBSWhaLFNBQVM2WSxZQUFZMVgsSUFBSSxDQUFFbkIsTUFBTWYsSUFBSSxHQUFLO1lBQ3ZGckYsUUFBT21mLE9BQU8sQ0FBQ0MsSUFBSSxDQUFFLGdDQUFnQ2haLE1BQU1pWixPQUFPLEVBQ2pFalosTUFBTWtaLEtBQUssRUFBRUo7UUFDZjtJQUNEO0lBS0FqYyxPQUFPc2MsY0FBYyxHQUFHLFNBQVVuWixLQUFLO1FBQ3RDcEcsUUFBT3dlLFVBQVUsQ0FBRTtZQUNsQixNQUFNcFk7UUFDUDtJQUNEO0lBS0EsaUNBQWlDO0lBQ2pDLElBQUlvWixZQUFZdmMsT0FBT3laLFFBQVE7SUFFL0J6WixPQUFPRyxFQUFFLENBQUMrVixLQUFLLEdBQUcsU0FBVS9WLEVBQUU7UUFFN0JvYyxVQUNFL0MsSUFBSSxDQUFFclosR0FFUCw4REFBOEQ7UUFDOUQsNERBQTREO1FBQzVELGdCQUFnQjtTQUNmcWMsS0FBSyxDQUFFLFNBQVVyWixLQUFLO1lBQ3RCbkQsT0FBT3NjLGNBQWMsQ0FBRW5aO1FBQ3hCO1FBRUQsT0FBTyxJQUFJO0lBQ1o7SUFFQW5ELE9BQU9rQyxNQUFNLENBQUU7UUFFZCwyREFBMkQ7UUFDM0RnQixTQUFTO1FBRVQsdURBQXVEO1FBQ3ZELHVDQUF1QztRQUN2Q3VaLFdBQVc7UUFFWCwrQkFBK0I7UUFDL0J2RyxPQUFPLFNBQVV3RyxJQUFJO1lBRXBCLDBEQUEwRDtZQUMxRCxJQUFLQSxTQUFTLE9BQU8sRUFBRTFjLE9BQU95YyxTQUFTLEdBQUd6YyxPQUFPa0QsT0FBTyxFQUFHO2dCQUMxRDtZQUNEO1lBRUEsaUNBQWlDO1lBQ2pDbEQsT0FBT2tELE9BQU8sR0FBRztZQUVqQixvRUFBb0U7WUFDcEUsSUFBS3daLFNBQVMsUUFBUSxFQUFFMWMsT0FBT3ljLFNBQVMsR0FBRyxHQUFJO2dCQUM5QztZQUNEO1lBRUEsMkNBQTJDO1lBQzNDRixVQUFVdEIsV0FBVyxDQUFFcmUsVUFBVTtnQkFBRW9EO2FBQVE7UUFDNUM7SUFDRDtJQUVBQSxPQUFPa1csS0FBSyxDQUFDc0QsSUFBSSxHQUFHK0MsVUFBVS9DLElBQUk7SUFFbEMsa0RBQWtEO0lBQ2xELFNBQVNtRDtRQUNSL2YsU0FBU2dnQixtQkFBbUIsQ0FBRSxvQkFBb0JEO1FBQ2xENWYsUUFBTzZmLG1CQUFtQixDQUFFLFFBQVFEO1FBQ3BDM2MsT0FBT2tXLEtBQUs7SUFDYjtJQUVBLGtEQUFrRDtJQUNsRCxnREFBZ0Q7SUFDaEQsNEJBQTRCO0lBQzVCLG9EQUFvRDtJQUNwRCxJQUFLdFosU0FBU2lnQixVQUFVLEtBQUssY0FDMUJqZ0IsU0FBU2lnQixVQUFVLEtBQUssYUFBYSxDQUFDamdCLFNBQVNnSCxlQUFlLENBQUNrWixRQUFRLEVBQUs7UUFFOUUsMkVBQTJFO1FBQzNFL2YsUUFBT3dlLFVBQVUsQ0FBRXZiLE9BQU9rVyxLQUFLO0lBRWhDLE9BQU87UUFFTiwrQkFBK0I7UUFDL0J0WixTQUFTOFAsZ0JBQWdCLENBQUUsb0JBQW9CaVE7UUFFL0MscURBQXFEO1FBQ3JENWYsUUFBTzJQLGdCQUFnQixDQUFFLFFBQVFpUTtJQUNsQztJQUtBLCtEQUErRDtJQUMvRCw0REFBNEQ7SUFDNUQsSUFBSUksU0FBUyxTQUFVbGMsS0FBSyxFQUFFVixFQUFFLEVBQUVxTCxHQUFHLEVBQUUxRyxLQUFLLEVBQUVrWSxTQUFTLEVBQUVDLFFBQVEsRUFBRUMsR0FBRztRQUNyRSxJQUFJaGUsSUFBSSxHQUNQMkMsTUFBTWhCLE1BQU1MLE1BQU0sRUFDbEIyYyxPQUFPM1IsT0FBTztRQUVmLG1CQUFtQjtRQUNuQixJQUFLM0wsT0FBUTJMLFNBQVUsVUFBVztZQUNqQ3dSLFlBQVk7WUFDWixJQUFNOWQsS0FBS3NNLElBQU07Z0JBQ2hCdVIsT0FBUWxjLE9BQU9WLElBQUlqQixHQUFHc00sR0FBRyxDQUFFdE0sRUFBRyxFQUFFLE1BQU0rZCxVQUFVQztZQUNqRDtRQUVELGlCQUFpQjtRQUNqQixPQUFPLElBQUtwWSxVQUFVakMsV0FBWTtZQUNqQ21hLFlBQVk7WUFFWixJQUFLLENBQUM1ZSxXQUFZMEcsUUFBVTtnQkFDM0JvWSxNQUFNO1lBQ1A7WUFFQSxJQUFLQyxNQUFPO2dCQUVYLDZDQUE2QztnQkFDN0MsSUFBS0QsS0FBTTtvQkFDVi9jLEdBQUczQyxJQUFJLENBQUVxRCxPQUFPaUU7b0JBQ2hCM0UsS0FBSztnQkFFTiwyQ0FBMkM7Z0JBQzNDLE9BQU87b0JBQ05nZCxPQUFPaGQ7b0JBQ1BBLEtBQUssU0FBVWlCLElBQUksRUFBRWdjLElBQUksRUFBRXRZLEtBQUs7d0JBQy9CLE9BQU9xWSxLQUFLM2YsSUFBSSxDQUFFd0MsT0FBUW9CLE9BQVEwRDtvQkFDbkM7Z0JBQ0Q7WUFDRDtZQUVBLElBQUszRSxJQUFLO2dCQUNULE1BQVFqQixJQUFJMkMsS0FBSzNDLElBQU07b0JBQ3RCaUIsR0FDQ1UsS0FBSyxDQUFFM0IsRUFBRyxFQUFFc00sS0FBSzBSLE1BQ2hCcFksUUFDQUEsTUFBTXRILElBQUksQ0FBRXFELEtBQUssQ0FBRTNCLEVBQUcsRUFBRUEsR0FBR2lCLEdBQUlVLEtBQUssQ0FBRTNCLEVBQUcsRUFBRXNNO2dCQUU5QztZQUNEO1FBQ0Q7UUFFQSxJQUFLd1IsV0FBWTtZQUNoQixPQUFPbmM7UUFDUjtRQUVBLE9BQU87UUFDUCxJQUFLc2MsTUFBTztZQUNYLE9BQU9oZCxHQUFHM0MsSUFBSSxDQUFFcUQ7UUFDakI7UUFFQSxPQUFPZ0IsTUFBTTFCLEdBQUlVLEtBQUssQ0FBRSxFQUFHLEVBQUUySyxPQUFReVI7SUFDdEM7SUFHQSx1Q0FBdUM7SUFDdkMsSUFBSUksWUFBWSxTQUNmQyxhQUFhO0lBRWQsNkNBQTZDO0lBQzdDLFNBQVNDLFdBQVlDLElBQUksRUFBRUMsTUFBTTtRQUNoQyxPQUFPQSxPQUFPQyxXQUFXO0lBQzFCO0lBRUEsZ0VBQWdFO0lBQ2hFLHFDQUFxQztJQUNyQywyREFBMkQ7SUFDM0QsU0FBU0MsVUFBV0MsTUFBTTtRQUN6QixPQUFPQSxPQUFPM2EsT0FBTyxDQUFFb2EsV0FBVyxPQUFRcGEsT0FBTyxDQUFFcWEsWUFBWUM7SUFDaEU7SUFDQSxJQUFJTSxhQUFhLFNBQVVDLEtBQUs7UUFFL0IsZ0JBQWdCO1FBQ2hCLFVBQVU7UUFDVix5QkFBeUI7UUFDekIsMEJBQTBCO1FBQzFCLFlBQVk7UUFDWixXQUFXO1FBQ1gsT0FBT0EsTUFBTXhmLFFBQVEsS0FBSyxLQUFLd2YsTUFBTXhmLFFBQVEsS0FBSyxLQUFLLENBQUcsQ0FBQ3dmLE1BQU14ZixRQUFRO0lBQzFFO0lBS0EsU0FBU3lmO1FBQ1IsSUFBSSxDQUFDamIsT0FBTyxHQUFHOUMsT0FBTzhDLE9BQU8sR0FBR2liLEtBQUtDLEdBQUc7SUFDekM7SUFFQUQsS0FBS0MsR0FBRyxHQUFHO0lBRVhELEtBQUsxZCxTQUFTLEdBQUc7UUFFaEJrTCxPQUFPLFNBQVV1UyxLQUFLO1lBRXJCLGdEQUFnRDtZQUNoRCxJQUFJaFosUUFBUWdaLEtBQUssQ0FBRSxJQUFJLENBQUNoYixPQUFPLENBQUU7WUFFakMscUJBQXFCO1lBQ3JCLElBQUssQ0FBQ2dDLE9BQVE7Z0JBQ2JBLFFBQVEsQ0FBQztnQkFFVCwrREFBK0Q7Z0JBQy9ELG9DQUFvQztnQkFDcEMsaUNBQWlDO2dCQUNqQyxJQUFLK1ksV0FBWUMsUUFBVTtvQkFFMUIsNkRBQTZEO29CQUM3RCx1QkFBdUI7b0JBQ3ZCLElBQUtBLE1BQU14ZixRQUFRLEVBQUc7d0JBQ3JCd2YsS0FBSyxDQUFFLElBQUksQ0FBQ2hiLE9BQU8sQ0FBRSxHQUFHZ0M7b0JBRXpCLG1EQUFtRDtvQkFDbkQsd0RBQXdEO29CQUN4RCwrQkFBK0I7b0JBQy9CLE9BQU87d0JBQ04zSCxPQUFPOGdCLGNBQWMsQ0FBRUgsT0FBTyxJQUFJLENBQUNoYixPQUFPLEVBQUU7NEJBQzNDZ0MsT0FBT0E7NEJBQ1BvWixjQUFjO3dCQUNmO29CQUNEO2dCQUNEO1lBQ0Q7WUFFQSxPQUFPcFo7UUFDUjtRQUNBcVosS0FBSyxTQUFVTCxLQUFLLEVBQUVNLElBQUksRUFBRXRaLEtBQUs7WUFDaEMsSUFBSXVaLE1BQ0g5UyxRQUFRLElBQUksQ0FBQ0EsS0FBSyxDQUFFdVM7WUFFckIscUNBQXFDO1lBQ3JDLHFDQUFxQztZQUNyQyxJQUFLLE9BQU9NLFNBQVMsVUFBVztnQkFDL0I3UyxLQUFLLENBQUVvUyxVQUFXUyxNQUFRLEdBQUd0WjtZQUU5Qix5Q0FBeUM7WUFDekMsT0FBTztnQkFFTixxREFBcUQ7Z0JBQ3JELElBQU11WixRQUFRRCxLQUFPO29CQUNwQjdTLEtBQUssQ0FBRW9TLFVBQVdVLE1BQVEsR0FBR0QsSUFBSSxDQUFFQyxLQUFNO2dCQUMxQztZQUNEO1lBQ0EsT0FBTzlTO1FBQ1I7UUFDQTdLLEtBQUssU0FBVW9kLEtBQUssRUFBRXRTLEdBQUc7WUFDeEIsT0FBT0EsUUFBUTNJLFlBQ2QsSUFBSSxDQUFDMEksS0FBSyxDQUFFdVMsU0FFWixxQ0FBcUM7WUFDckNBLEtBQUssQ0FBRSxJQUFJLENBQUNoYixPQUFPLENBQUUsSUFBSWdiLEtBQUssQ0FBRSxJQUFJLENBQUNoYixPQUFPLENBQUUsQ0FBRTZhLFVBQVduUyxLQUFPO1FBQ3BFO1FBQ0F1UixRQUFRLFNBQVVlLEtBQUssRUFBRXRTLEdBQUcsRUFBRTFHLEtBQUs7WUFFbEMseUJBQXlCO1lBQ3pCLEVBQUU7WUFDRiw0QkFBNEI7WUFDNUIseURBQXlEO1lBQ3pELEVBQUU7WUFDRiw2REFBNkQ7WUFDN0QsOENBQThDO1lBQzlDLEVBQUU7WUFDRiwrQkFBK0I7WUFDL0Isa0NBQWtDO1lBQ2xDLEVBQUU7WUFDRixJQUFLMEcsUUFBUTNJLGFBQ1QsT0FBUyxPQUFPMkksUUFBUSxZQUFjMUcsVUFBVWpDLFdBQWM7Z0JBRWpFLE9BQU8sSUFBSSxDQUFDbkMsR0FBRyxDQUFFb2QsT0FBT3RTO1lBQ3pCO1lBRUEsd0RBQXdEO1lBQ3hELCtEQUErRDtZQUMvRCxFQUFFO1lBQ0YsK0JBQStCO1lBQy9CLHVCQUF1QjtZQUN2QixFQUFFO1lBQ0YsSUFBSSxDQUFDMlMsR0FBRyxDQUFFTCxPQUFPdFMsS0FBSzFHO1lBRXRCLDBEQUEwRDtZQUMxRCw0REFBNEQ7WUFDNUQsT0FBT0EsVUFBVWpDLFlBQVlpQyxRQUFRMEc7UUFDdEM7UUFDQWlOLFFBQVEsU0FBVXFGLEtBQUssRUFBRXRTLEdBQUc7WUFDM0IsSUFBSXRNLEdBQ0hxTSxRQUFRdVMsS0FBSyxDQUFFLElBQUksQ0FBQ2hiLE9BQU8sQ0FBRTtZQUU5QixJQUFLeUksVUFBVTFJLFdBQVk7Z0JBQzFCO1lBQ0Q7WUFFQSxJQUFLMkksUUFBUTNJLFdBQVk7Z0JBRXhCLGtEQUFrRDtnQkFDbEQsSUFBS0YsTUFBTUMsT0FBTyxDQUFFNEksTUFBUTtvQkFFM0IsZ0NBQWdDO29CQUNoQyxnREFBZ0Q7b0JBQ2hEQSxNQUFNQSxJQUFJckssR0FBRyxDQUFFd2M7Z0JBQ2hCLE9BQU87b0JBQ05uUyxNQUFNbVMsVUFBV25TO29CQUVqQiwyQ0FBMkM7b0JBQzNDLHdEQUF3RDtvQkFDeERBLE1BQU1BLE9BQU9ELFFBQ1o7d0JBQUVDO3FCQUFLLEdBQ0xBLElBQUlwQixLQUFLLENBQUVxTixrQkFBbUIsRUFBRTtnQkFDcEM7Z0JBRUF2WSxJQUFJc00sSUFBSWhMLE1BQU07Z0JBRWQsTUFBUXRCLElBQU07b0JBQ2IsT0FBT3FNLEtBQUssQ0FBRUMsR0FBRyxDQUFFdE0sRUFBRyxDQUFFO2dCQUN6QjtZQUNEO1lBRUEsNkNBQTZDO1lBQzdDLElBQUtzTSxRQUFRM0ksYUFBYTdDLE9BQU93RCxhQUFhLENBQUUrSCxRQUFVO2dCQUV6RCw0QkFBNEI7Z0JBQzVCLDhEQUE4RDtnQkFDOUQsOENBQThDO2dCQUM5QyxnRkFBZ0Y7Z0JBQ2hGLElBQUt1UyxNQUFNeGYsUUFBUSxFQUFHO29CQUNyQndmLEtBQUssQ0FBRSxJQUFJLENBQUNoYixPQUFPLENBQUUsR0FBR0Q7Z0JBQ3pCLE9BQU87b0JBQ04sT0FBT2liLEtBQUssQ0FBRSxJQUFJLENBQUNoYixPQUFPLENBQUU7Z0JBQzdCO1lBQ0Q7UUFDRDtRQUNBd2IsU0FBUyxTQUFVUixLQUFLO1lBQ3ZCLElBQUl2UyxRQUFRdVMsS0FBSyxDQUFFLElBQUksQ0FBQ2hiLE9BQU8sQ0FBRTtZQUNqQyxPQUFPeUksVUFBVTFJLGFBQWEsQ0FBQzdDLE9BQU93RCxhQUFhLENBQUUrSDtRQUN0RDtJQUNEO0lBQ0EsSUFBSWdULFdBQVcsSUFBSVI7SUFFbkIsSUFBSVMsV0FBVyxJQUFJVDtJQUluQix5QkFBeUI7SUFDekIsRUFBRTtJQUNGLHNFQUFzRTtJQUN0RSxrRUFBa0U7SUFDbEUsZ0NBQWdDO0lBQ2hDLHlFQUF5RTtJQUN6RSxnRkFBZ0Y7SUFDaEYsb0ZBQW9GO0lBQ3BGLHdFQUF3RTtJQUV4RSxJQUFJVSxTQUFTLGlDQUNaQyxhQUFhO0lBRWQsU0FBU0MsUUFBU1AsSUFBSTtRQUNyQixJQUFLQSxTQUFTLFFBQVM7WUFDdEIsT0FBTztRQUNSO1FBRUEsSUFBS0EsU0FBUyxTQUFVO1lBQ3ZCLE9BQU87UUFDUjtRQUVBLElBQUtBLFNBQVMsUUFBUztZQUN0QixPQUFPO1FBQ1I7UUFFQSwyREFBMkQ7UUFDM0QsSUFBS0EsU0FBUyxDQUFDQSxPQUFPLElBQUs7WUFDMUIsT0FBTyxDQUFDQTtRQUNUO1FBRUEsSUFBS0ssT0FBT25hLElBQUksQ0FBRThaLE9BQVM7WUFDMUIsT0FBT1EsS0FBS0MsS0FBSyxDQUFFVDtRQUNwQjtRQUVBLE9BQU9BO0lBQ1I7SUFFQSxTQUFTVSxTQUFVMWQsSUFBSSxFQUFFb0ssR0FBRyxFQUFFNFMsSUFBSTtRQUNqQyxJQUFJaGM7UUFFSixvREFBb0Q7UUFDcEQsdUNBQXVDO1FBQ3ZDLElBQUtnYyxTQUFTdmIsYUFBYXpCLEtBQUs5QyxRQUFRLEtBQUssR0FBSTtZQUNoRDhELE9BQU8sVUFBVW9KLElBQUl2SSxPQUFPLENBQUV5YixZQUFZLE9BQVF0WixXQUFXO1lBQzdEZ1osT0FBT2hkLEtBQUs3QixZQUFZLENBQUU2QztZQUUxQixJQUFLLE9BQU9nYyxTQUFTLFVBQVc7Z0JBQy9CLElBQUk7b0JBQ0hBLE9BQU9PLFFBQVNQO2dCQUNqQixFQUFFLE9BQVF0VSxHQUFJLENBQUM7Z0JBRWYsc0RBQXNEO2dCQUN0RDBVLFNBQVNMLEdBQUcsQ0FBRS9jLE1BQU1vSyxLQUFLNFM7WUFDMUIsT0FBTztnQkFDTkEsT0FBT3ZiO1lBQ1I7UUFDRDtRQUNBLE9BQU91YjtJQUNSO0lBRUFwZSxPQUFPa0MsTUFBTSxDQUFFO1FBQ2RvYyxTQUFTLFNBQVVsZCxJQUFJO1lBQ3RCLE9BQU9vZCxTQUFTRixPQUFPLENBQUVsZCxTQUFVbWQsU0FBU0QsT0FBTyxDQUFFbGQ7UUFDdEQ7UUFFQWdkLE1BQU0sU0FBVWhkLElBQUksRUFBRWdCLElBQUksRUFBRWdjLElBQUk7WUFDL0IsT0FBT0ksU0FBU3pCLE1BQU0sQ0FBRTNiLE1BQU1nQixNQUFNZ2M7UUFDckM7UUFFQVcsWUFBWSxTQUFVM2QsSUFBSSxFQUFFZ0IsSUFBSTtZQUMvQm9jLFNBQVMvRixNQUFNLENBQUVyWCxNQUFNZ0I7UUFDeEI7UUFFQSx1RUFBdUU7UUFDdkUsa0VBQWtFO1FBQ2xFNGMsT0FBTyxTQUFVNWQsSUFBSSxFQUFFZ0IsSUFBSSxFQUFFZ2MsSUFBSTtZQUNoQyxPQUFPRyxTQUFTeEIsTUFBTSxDQUFFM2IsTUFBTWdCLE1BQU1nYztRQUNyQztRQUVBYSxhQUFhLFNBQVU3ZCxJQUFJLEVBQUVnQixJQUFJO1lBQ2hDbWMsU0FBUzlGLE1BQU0sQ0FBRXJYLE1BQU1nQjtRQUN4QjtJQUNEO0lBRUFwQyxPQUFPRyxFQUFFLENBQUMrQixNQUFNLENBQUU7UUFDakJrYyxNQUFNLFNBQVU1UyxHQUFHLEVBQUUxRyxLQUFLO1lBQ3pCLElBQUk1RixHQUFHa0QsTUFBTWdjLE1BQ1poZCxPQUFPLElBQUksQ0FBRSxFQUFHLEVBQ2hCOGQsUUFBUTlkLFFBQVFBLEtBQUttRyxVQUFVO1lBRWhDLGtCQUFrQjtZQUNsQixJQUFLaUUsUUFBUTNJLFdBQVk7Z0JBQ3hCLElBQUssSUFBSSxDQUFDckMsTUFBTSxFQUFHO29CQUNsQjRkLE9BQU9JLFNBQVM5ZCxHQUFHLENBQUVVO29CQUVyQixJQUFLQSxLQUFLOUMsUUFBUSxLQUFLLEtBQUssQ0FBQ2lnQixTQUFTN2QsR0FBRyxDQUFFVSxNQUFNLGlCQUFtQjt3QkFDbkVsQyxJQUFJZ2dCLE1BQU0xZSxNQUFNO3dCQUNoQixNQUFRdEIsSUFBTTs0QkFFYixzQkFBc0I7NEJBQ3RCLDhDQUE4Qzs0QkFDOUMsSUFBS2dnQixLQUFLLENBQUVoZ0IsRUFBRyxFQUFHO2dDQUNqQmtELE9BQU84YyxLQUFLLENBQUVoZ0IsRUFBRyxDQUFDa0QsSUFBSTtnQ0FDdEIsSUFBS0EsS0FBS3hFLE9BQU8sQ0FBRSxhQUFjLEdBQUk7b0NBQ3BDd0UsT0FBT3ViLFVBQVd2YixLQUFLL0UsS0FBSyxDQUFFO29DQUM5QnloQixTQUFVMWQsTUFBTWdCLE1BQU1nYyxJQUFJLENBQUVoYyxLQUFNO2dDQUNuQzs0QkFDRDt3QkFDRDt3QkFDQW1jLFNBQVNKLEdBQUcsQ0FBRS9jLE1BQU0sZ0JBQWdCO29CQUNyQztnQkFDRDtnQkFFQSxPQUFPZ2Q7WUFDUjtZQUVBLHVCQUF1QjtZQUN2QixJQUFLLE9BQU81UyxRQUFRLFVBQVc7Z0JBQzlCLE9BQU8sSUFBSSxDQUFDdkssSUFBSSxDQUFFO29CQUNqQnVkLFNBQVNMLEdBQUcsQ0FBRSxJQUFJLEVBQUUzUztnQkFDckI7WUFDRDtZQUVBLE9BQU91UixPQUFRLElBQUksRUFBRSxTQUFValksS0FBSztnQkFDbkMsSUFBSXNaO2dCQUVKLDJEQUEyRDtnQkFDM0QsOERBQThEO2dCQUM5RCw4REFBOEQ7Z0JBQzlELDZEQUE2RDtnQkFDN0QsaUVBQWlFO2dCQUNqRSxJQUFLaGQsUUFBUTBELFVBQVVqQyxXQUFZO29CQUVsQyxxQ0FBcUM7b0JBQ3JDLDRDQUE0QztvQkFDNUN1YixPQUFPSSxTQUFTOWQsR0FBRyxDQUFFVSxNQUFNb0s7b0JBQzNCLElBQUs0UyxTQUFTdmIsV0FBWTt3QkFDekIsT0FBT3ViO29CQUNSO29CQUVBLG9DQUFvQztvQkFDcEMsNEJBQTRCO29CQUM1QkEsT0FBT1UsU0FBVTFkLE1BQU1vSztvQkFDdkIsSUFBSzRTLFNBQVN2YixXQUFZO3dCQUN6QixPQUFPdWI7b0JBQ1I7b0JBRUEsb0RBQW9EO29CQUNwRDtnQkFDRDtnQkFFQSxrQkFBa0I7Z0JBQ2xCLElBQUksQ0FBQ25kLElBQUksQ0FBRTtvQkFFVixxQ0FBcUM7b0JBQ3JDdWQsU0FBU0wsR0FBRyxDQUFFLElBQUksRUFBRTNTLEtBQUsxRztnQkFDMUI7WUFDRCxHQUFHLE1BQU1BLE9BQU96RCxVQUFVYixNQUFNLEdBQUcsR0FBRyxNQUFNO1FBQzdDO1FBRUF1ZSxZQUFZLFNBQVV2VCxHQUFHO1lBQ3hCLE9BQU8sSUFBSSxDQUFDdkssSUFBSSxDQUFFO2dCQUNqQnVkLFNBQVMvRixNQUFNLENBQUUsSUFBSSxFQUFFak47WUFDeEI7UUFDRDtJQUNEO0lBR0F4TCxPQUFPa0MsTUFBTSxDQUFFO1FBQ2RrVyxPQUFPLFNBQVVoWCxJQUFJLEVBQUUxQyxJQUFJLEVBQUUwZixJQUFJO1lBQ2hDLElBQUloRztZQUVKLElBQUtoWCxNQUFPO2dCQUNYMUMsT0FBTyxDQUFFQSxRQUFRLElBQUcsSUFBTTtnQkFDMUIwWixRQUFRbUcsU0FBUzdkLEdBQUcsQ0FBRVUsTUFBTTFDO2dCQUU1QixtRUFBbUU7Z0JBQ25FLElBQUswZixNQUFPO29CQUNYLElBQUssQ0FBQ2hHLFNBQVN6VixNQUFNQyxPQUFPLENBQUV3YixPQUFTO3dCQUN0Q2hHLFFBQVFtRyxTQUFTeEIsTUFBTSxDQUFFM2IsTUFBTTFDLE1BQU1zQixPQUFPOEQsU0FBUyxDQUFFc2E7b0JBQ3hELE9BQU87d0JBQ05oRyxNQUFNemEsSUFBSSxDQUFFeWdCO29CQUNiO2dCQUNEO2dCQUNBLE9BQU9oRyxTQUFTLEVBQUU7WUFDbkI7UUFDRDtRQUVBK0csU0FBUyxTQUFVL2QsSUFBSSxFQUFFMUMsSUFBSTtZQUM1QkEsT0FBT0EsUUFBUTtZQUVmLElBQUkwWixRQUFRcFksT0FBT29ZLEtBQUssQ0FBRWhYLE1BQU0xQyxPQUMvQjBnQixjQUFjaEgsTUFBTTVYLE1BQU0sRUFDMUJMLEtBQUtpWSxNQUFNMU0sS0FBSyxJQUNoQjJULFFBQVFyZixPQUFPc2YsV0FBVyxDQUFFbGUsTUFBTTFDLE9BQ2xDK0ssT0FBTztnQkFDTnpKLE9BQU9tZixPQUFPLENBQUUvZCxNQUFNMUM7WUFDdkI7WUFFRCxtRUFBbUU7WUFDbkUsSUFBS3lCLE9BQU8sY0FBZTtnQkFDMUJBLEtBQUtpWSxNQUFNMU0sS0FBSztnQkFDaEIwVDtZQUNEO1lBRUEsSUFBS2pmLElBQUs7Z0JBRVQsNkRBQTZEO2dCQUM3RCx5QkFBeUI7Z0JBQ3pCLElBQUt6QixTQUFTLE1BQU87b0JBQ3BCMFosTUFBTW1ILE9BQU8sQ0FBRTtnQkFDaEI7Z0JBRUEsd0NBQXdDO2dCQUN4QyxPQUFPRixNQUFNRyxJQUFJO2dCQUNqQnJmLEdBQUczQyxJQUFJLENBQUU0RCxNQUFNcUksTUFBTTRWO1lBQ3RCO1lBRUEsSUFBSyxDQUFDRCxlQUFlQyxPQUFRO2dCQUM1QkEsTUFBTW5PLEtBQUssQ0FBQ29ILElBQUk7WUFDakI7UUFDRDtRQUVBLHVFQUF1RTtRQUN2RWdILGFBQWEsU0FBVWxlLElBQUksRUFBRTFDLElBQUk7WUFDaEMsSUFBSThNLE1BQU05TSxPQUFPO1lBQ2pCLE9BQU82ZixTQUFTN2QsR0FBRyxDQUFFVSxNQUFNb0ssUUFBUytTLFNBQVN4QixNQUFNLENBQUUzYixNQUFNb0ssS0FBSztnQkFDL0QwRixPQUFPbFIsT0FBTzhYLFNBQVMsQ0FBRSxlQUFnQmhCLEdBQUcsQ0FBRTtvQkFDN0N5SCxTQUFTOUYsTUFBTSxDQUFFclgsTUFBTTt3QkFBRTFDLE9BQU87d0JBQVM4TTtxQkFBSztnQkFDL0M7WUFDRDtRQUNEO0lBQ0Q7SUFFQXhMLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQmtXLE9BQU8sU0FBVTFaLElBQUksRUFBRTBmLElBQUk7WUFDMUIsSUFBSXFCLFNBQVM7WUFFYixJQUFLLE9BQU8vZ0IsU0FBUyxVQUFXO2dCQUMvQjBmLE9BQU8xZjtnQkFDUEEsT0FBTztnQkFDUCtnQjtZQUNEO1lBRUEsSUFBS3BlLFVBQVViLE1BQU0sR0FBR2lmLFFBQVM7Z0JBQ2hDLE9BQU96ZixPQUFPb1ksS0FBSyxDQUFFLElBQUksQ0FBRSxFQUFHLEVBQUUxWjtZQUNqQztZQUVBLE9BQU8wZixTQUFTdmIsWUFDZixJQUFJLEdBQ0osSUFBSSxDQUFDNUIsSUFBSSxDQUFFO2dCQUNWLElBQUltWCxRQUFRcFksT0FBT29ZLEtBQUssQ0FBRSxJQUFJLEVBQUUxWixNQUFNMGY7Z0JBRXRDLGdDQUFnQztnQkFDaENwZSxPQUFPc2YsV0FBVyxDQUFFLElBQUksRUFBRTVnQjtnQkFFMUIsSUFBS0EsU0FBUyxRQUFRMFosS0FBSyxDQUFFLEVBQUcsS0FBSyxjQUFlO29CQUNuRHBZLE9BQU9tZixPQUFPLENBQUUsSUFBSSxFQUFFemdCO2dCQUN2QjtZQUNEO1FBQ0Y7UUFDQXlnQixTQUFTLFNBQVV6Z0IsSUFBSTtZQUN0QixPQUFPLElBQUksQ0FBQ3VDLElBQUksQ0FBRTtnQkFDakJqQixPQUFPbWYsT0FBTyxDQUFFLElBQUksRUFBRXpnQjtZQUN2QjtRQUNEO1FBQ0FnaEIsWUFBWSxTQUFVaGhCLElBQUk7WUFDekIsT0FBTyxJQUFJLENBQUMwWixLQUFLLENBQUUxWixRQUFRLE1BQU0sRUFBRTtRQUNwQztRQUVBLHVEQUF1RDtRQUN2RCwwQ0FBMEM7UUFDMUM0YSxTQUFTLFNBQVU1YSxJQUFJLEVBQUVMLEdBQUc7WUFDM0IsSUFBSXNoQixLQUNIQyxRQUFRLEdBQ1JDLFFBQVE3ZixPQUFPeVosUUFBUSxJQUN2Qi9MLFdBQVcsSUFBSSxFQUNmeE8sSUFBSSxJQUFJLENBQUNzQixNQUFNLEVBQ2YwWSxVQUFVO2dCQUNULElBQUssQ0FBRyxFQUFFMEcsT0FBVTtvQkFDbkJDLE1BQU01RSxXQUFXLENBQUV2TixVQUFVO3dCQUFFQTtxQkFBVTtnQkFDMUM7WUFDRDtZQUVELElBQUssT0FBT2hQLFNBQVMsVUFBVztnQkFDL0JMLE1BQU1LO2dCQUNOQSxPQUFPbUU7WUFDUjtZQUNBbkUsT0FBT0EsUUFBUTtZQUVmLE1BQVFRLElBQU07Z0JBQ2J5Z0IsTUFBTXBCLFNBQVM3ZCxHQUFHLENBQUVnTixRQUFRLENBQUV4TyxFQUFHLEVBQUVSLE9BQU87Z0JBQzFDLElBQUtpaEIsT0FBT0EsSUFBSXpPLEtBQUssRUFBRztvQkFDdkIwTztvQkFDQUQsSUFBSXpPLEtBQUssQ0FBQzRGLEdBQUcsQ0FBRW9DO2dCQUNoQjtZQUNEO1lBQ0FBO1lBQ0EsT0FBTzJHLE1BQU12RyxPQUFPLENBQUVqYjtRQUN2QjtJQUNEO0lBQ0EsSUFBSXloQixPQUFPLHNDQUEwQ0MsTUFBTTtJQUUzRCxJQUFJQyxVQUFVLElBQUl4YSxPQUFRLG1CQUFtQnNhLE9BQU8sZUFBZTtJQUduRSxJQUFJRyxZQUFZO1FBQUU7UUFBTztRQUFTO1FBQVU7S0FBUTtJQUVwRCxJQUFJcmMsa0JBQWtCaEgsU0FBU2dILGVBQWU7SUFJN0MsSUFBSXNjLGFBQWEsU0FBVTllLElBQUk7UUFDN0IsT0FBT3BCLE9BQU95RixRQUFRLENBQUVyRSxLQUFLaUQsYUFBYSxFQUFFakQ7SUFDN0MsR0FDQStlLFdBQVc7UUFBRUEsVUFBVTtJQUFLO0lBRTdCLDJEQUEyRDtJQUMzRCx3RUFBd0U7SUFDeEUsOEJBQThCO0lBQzlCLHNFQUFzRTtJQUN0RSx5REFBeUQ7SUFDekQsSUFBS3ZjLGdCQUFnQndjLFdBQVcsRUFBRztRQUNsQ0YsYUFBYSxTQUFVOWUsSUFBSTtZQUMxQixPQUFPcEIsT0FBT3lGLFFBQVEsQ0FBRXJFLEtBQUtpRCxhQUFhLEVBQUVqRCxTQUMzQ0EsS0FBS2dmLFdBQVcsQ0FBRUQsY0FBZS9lLEtBQUtpRCxhQUFhO1FBQ3JEO0lBQ0Q7SUFDRCxJQUFJZ2MscUJBQXFCLFNBQVVqZixJQUFJLEVBQUV5SyxFQUFFO1FBRXpDLGtFQUFrRTtRQUNsRSxnREFBZ0Q7UUFDaER6SyxPQUFPeUssTUFBTXpLO1FBRWIsMEJBQTBCO1FBQzFCLE9BQU9BLEtBQUtrZixLQUFLLENBQUNDLE9BQU8sS0FBSyxVQUM3Qm5mLEtBQUtrZixLQUFLLENBQUNDLE9BQU8sS0FBSyxNQUV2QixrQ0FBa0M7UUFDbEMsNkJBQTZCO1FBQzdCLHVGQUF1RjtRQUN2RixtQkFBbUI7UUFDbkJMLFdBQVk5ZSxTQUVacEIsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNLGVBQWdCO0lBQ3BDO0lBSUQsU0FBU3FmLFVBQVdyZixJQUFJLEVBQUVpZCxJQUFJLEVBQUVxQyxVQUFVLEVBQUVDLEtBQUs7UUFDaEQsSUFBSUMsVUFBVUMsT0FDYkMsZ0JBQWdCLElBQ2hCQyxlQUFlSixRQUNkO1lBQ0MsT0FBT0EsTUFBTWhLLEdBQUc7UUFDakIsSUFDQTtZQUNDLE9BQU8zVyxPQUFPd2dCLEdBQUcsQ0FBRXBmLE1BQU1pZCxNQUFNO1FBQ2hDLEdBQ0QyQyxVQUFVRCxnQkFDVkUsT0FBT1AsY0FBY0EsVUFBVSxDQUFFLEVBQUcsSUFBTTFnQixDQUFBQSxPQUFPa2hCLFNBQVMsQ0FBRTdDLEtBQU0sR0FBRyxLQUFLLElBQUcsR0FFN0UsdUVBQXVFO1FBQ3ZFOEMsZ0JBQWdCL2YsS0FBSzlDLFFBQVEsSUFDMUIwQixDQUFBQSxPQUFPa2hCLFNBQVMsQ0FBRTdDLEtBQU0sSUFBSTRDLFNBQVMsUUFBUSxDQUFDRCxPQUFNLEtBQ3REaEIsUUFBUXhWLElBQUksQ0FBRXhLLE9BQU93Z0IsR0FBRyxDQUFFcGYsTUFBTWlkO1FBRWxDLElBQUs4QyxpQkFBaUJBLGFBQWEsQ0FBRSxFQUFHLEtBQUtGLE1BQU87WUFFbkQsd0JBQXdCO1lBQ3hCLDJGQUEyRjtZQUMzRkQsVUFBVUEsVUFBVTtZQUVwQixxQ0FBcUM7WUFDckNDLE9BQU9BLFFBQVFFLGFBQWEsQ0FBRSxFQUFHO1lBRWpDLHdEQUF3RDtZQUN4REEsZ0JBQWdCLENBQUNILFdBQVc7WUFFNUIsTUFBUUYsZ0JBQWtCO2dCQUV6Qix1RUFBdUU7Z0JBQ3ZFLHFGQUFxRjtnQkFDckY5Z0IsT0FBT3NnQixLQUFLLENBQUVsZixNQUFNaWQsTUFBTThDLGdCQUFnQkY7Z0JBQzFDLElBQUssQ0FBRSxJQUFJSixLQUFJLElBQVEsS0FBTUEsQ0FBQUEsUUFBUUUsaUJBQWlCQyxXQUFXLEdBQUUsQ0FBRSxLQUFPLEdBQUk7b0JBQy9FRixnQkFBZ0I7Z0JBQ2pCO2dCQUNBSyxnQkFBZ0JBLGdCQUFnQk47WUFFakM7WUFFQU0sZ0JBQWdCQSxnQkFBZ0I7WUFDaENuaEIsT0FBT3NnQixLQUFLLENBQUVsZixNQUFNaWQsTUFBTThDLGdCQUFnQkY7WUFFMUMsb0RBQW9EO1lBQ3BEUCxhQUFhQSxjQUFjLEVBQUU7UUFDOUI7UUFFQSxJQUFLQSxZQUFhO1lBQ2pCUyxnQkFBZ0IsQ0FBQ0EsaUJBQWlCLENBQUNILFdBQVc7WUFFOUMsNkNBQTZDO1lBQzdDSixXQUFXRixVQUFVLENBQUUsRUFBRyxHQUN6QlMsZ0JBQWdCLENBQUVULFVBQVUsQ0FBRSxFQUFHLEdBQUcsS0FBTUEsVUFBVSxDQUFFLEVBQUcsR0FDekQsQ0FBQ0EsVUFBVSxDQUFFLEVBQUc7WUFDakIsSUFBS0MsT0FBUTtnQkFDWkEsTUFBTU0sSUFBSSxHQUFHQTtnQkFDYk4sTUFBTXRSLEtBQUssR0FBRzhSO2dCQUNkUixNQUFNNWUsR0FBRyxHQUFHNmU7WUFDYjtRQUNEO1FBQ0EsT0FBT0E7SUFDUjtJQUdBLElBQUlRLG9CQUFvQixDQUFDO0lBRXpCLFNBQVNDLGtCQUFtQmpnQixJQUFJO1FBQy9CLElBQUlxUyxNQUNIeFUsTUFBTW1DLEtBQUtpRCxhQUFhLEVBQ3hCRSxXQUFXbkQsS0FBS21ELFFBQVEsRUFDeEJnYyxVQUFVYSxpQkFBaUIsQ0FBRTdjLFNBQVU7UUFFeEMsSUFBS2djLFNBQVU7WUFDZCxPQUFPQTtRQUNSO1FBRUE5TSxPQUFPeFUsSUFBSXFpQixJQUFJLENBQUM1aEIsV0FBVyxDQUFFVCxJQUFJSSxhQUFhLENBQUVrRjtRQUNoRGdjLFVBQVV2Z0IsT0FBT3dnQixHQUFHLENBQUUvTSxNQUFNO1FBRTVCQSxLQUFLOVQsVUFBVSxDQUFDQyxXQUFXLENBQUU2VDtRQUU3QixJQUFLOE0sWUFBWSxRQUFTO1lBQ3pCQSxVQUFVO1FBQ1g7UUFDQWEsaUJBQWlCLENBQUU3YyxTQUFVLEdBQUdnYztRQUVoQyxPQUFPQTtJQUNSO0lBRUEsU0FBU2dCLFNBQVU3VCxRQUFRLEVBQUU4VCxJQUFJO1FBQ2hDLElBQUlqQixTQUFTbmYsTUFDWnFnQixTQUFTLEVBQUUsRUFDWDdLLFFBQVEsR0FDUnBXLFNBQVNrTixTQUFTbE4sTUFBTTtRQUV6QiwrREFBK0Q7UUFDL0QsTUFBUW9XLFFBQVFwVyxRQUFRb1csUUFBVTtZQUNqQ3hWLE9BQU9zTSxRQUFRLENBQUVrSixNQUFPO1lBQ3hCLElBQUssQ0FBQ3hWLEtBQUtrZixLQUFLLEVBQUc7Z0JBQ2xCO1lBQ0Q7WUFFQUMsVUFBVW5mLEtBQUtrZixLQUFLLENBQUNDLE9BQU87WUFDNUIsSUFBS2lCLE1BQU87Z0JBRVgsa0ZBQWtGO2dCQUNsRix1RkFBdUY7Z0JBQ3ZGLGtDQUFrQztnQkFDbEMsSUFBS2pCLFlBQVksUUFBUztvQkFDekJrQixNQUFNLENBQUU3SyxNQUFPLEdBQUcySCxTQUFTN2QsR0FBRyxDQUFFVSxNQUFNLGNBQWU7b0JBQ3JELElBQUssQ0FBQ3FnQixNQUFNLENBQUU3SyxNQUFPLEVBQUc7d0JBQ3ZCeFYsS0FBS2tmLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO29CQUN0QjtnQkFDRDtnQkFDQSxJQUFLbmYsS0FBS2tmLEtBQUssQ0FBQ0MsT0FBTyxLQUFLLE1BQU1GLG1CQUFvQmpmLE9BQVM7b0JBQzlEcWdCLE1BQU0sQ0FBRTdLLE1BQU8sR0FBR3lLLGtCQUFtQmpnQjtnQkFDdEM7WUFDRCxPQUFPO2dCQUNOLElBQUttZixZQUFZLFFBQVM7b0JBQ3pCa0IsTUFBTSxDQUFFN0ssTUFBTyxHQUFHO29CQUVsQixrQ0FBa0M7b0JBQ2xDMkgsU0FBU0osR0FBRyxDQUFFL2MsTUFBTSxXQUFXbWY7Z0JBQ2hDO1lBQ0Q7UUFDRDtRQUVBLDRFQUE0RTtRQUM1RSxJQUFNM0osUUFBUSxHQUFHQSxRQUFRcFcsUUFBUW9XLFFBQVU7WUFDMUMsSUFBSzZLLE1BQU0sQ0FBRTdLLE1BQU8sSUFBSSxNQUFPO2dCQUM5QmxKLFFBQVEsQ0FBRWtKLE1BQU8sQ0FBQzBKLEtBQUssQ0FBQ0MsT0FBTyxHQUFHa0IsTUFBTSxDQUFFN0ssTUFBTztZQUNsRDtRQUNEO1FBRUEsT0FBT2xKO0lBQ1I7SUFFQTFOLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQnNmLE1BQU07WUFDTCxPQUFPRCxTQUFVLElBQUksRUFBRTtRQUN4QjtRQUNBRyxNQUFNO1lBQ0wsT0FBT0gsU0FBVSxJQUFJO1FBQ3RCO1FBQ0FJLFFBQVEsU0FBVS9ILEtBQUs7WUFDdEIsSUFBSyxPQUFPQSxVQUFVLFdBQVk7Z0JBQ2pDLE9BQU9BLFFBQVEsSUFBSSxDQUFDNEgsSUFBSSxLQUFLLElBQUksQ0FBQ0UsSUFBSTtZQUN2QztZQUVBLE9BQU8sSUFBSSxDQUFDemdCLElBQUksQ0FBRTtnQkFDakIsSUFBS29mLG1CQUFvQixJQUFJLEdBQUs7b0JBQ2pDcmdCLE9BQVEsSUFBSSxFQUFHd2hCLElBQUk7Z0JBQ3BCLE9BQU87b0JBQ054aEIsT0FBUSxJQUFJLEVBQUcwaEIsSUFBSTtnQkFDcEI7WUFDRDtRQUNEO0lBQ0Q7SUFDQSxJQUFJRSxpQkFBbUI7SUFFdkIsSUFBSUMsV0FBYTtJQUVqQixJQUFJQyxjQUFnQjtJQUlsQjtRQUNELElBQUlDLFdBQVdubEIsU0FBU29sQixzQkFBc0IsSUFDN0NDLE1BQU1GLFNBQVNyaUIsV0FBVyxDQUFFOUMsU0FBU3lDLGFBQWEsQ0FBRSxTQUNwRGdPLFFBQVF6USxTQUFTeUMsYUFBYSxDQUFFO1FBRWpDLGtDQUFrQztRQUNsQyxtREFBbUQ7UUFDbkQsa0NBQWtDO1FBQ2xDLGdFQUFnRTtRQUNoRWdPLE1BQU03TixZQUFZLENBQUUsUUFBUTtRQUM1QjZOLE1BQU03TixZQUFZLENBQUUsV0FBVztRQUMvQjZOLE1BQU03TixZQUFZLENBQUUsUUFBUTtRQUU1QnlpQixJQUFJdmlCLFdBQVcsQ0FBRTJOO1FBRWpCLDhCQUE4QjtRQUM5QixrRUFBa0U7UUFDbEVsUCxRQUFRK2pCLFVBQVUsR0FBR0QsSUFBSUUsU0FBUyxDQUFFLE1BQU9BLFNBQVMsQ0FBRSxNQUFPelMsU0FBUyxDQUFDcUIsT0FBTztRQUU5RSx3QkFBd0I7UUFDeEIsb0VBQW9FO1FBQ3BFa1IsSUFBSTNVLFNBQVMsR0FBRztRQUNoQm5QLFFBQVFpa0IsY0FBYyxHQUFHLENBQUMsQ0FBQ0gsSUFBSUUsU0FBUyxDQUFFLE1BQU96UyxTQUFTLENBQUMyUyxZQUFZO1FBRXZFLHVCQUF1QjtRQUN2Qiw2RUFBNkU7UUFDN0Usc0JBQXNCO1FBQ3RCSixJQUFJM1UsU0FBUyxHQUFHO1FBQ2hCblAsUUFBUW1rQixNQUFNLEdBQUcsQ0FBQyxDQUFDTCxJQUFJdlMsU0FBUztJQUNqQztJQUdBLDREQUE0RDtJQUM1RCxJQUFJNlMsVUFBVTtRQUViLHdEQUF3RDtRQUN4RCwwREFBMEQ7UUFDMUQsdURBQXVEO1FBQ3ZEQyxPQUFPO1lBQUU7WUFBRztZQUFXO1NBQVk7UUFDbkNDLEtBQUs7WUFBRTtZQUFHO1lBQXFCO1NBQXVCO1FBQ3REQyxJQUFJO1lBQUU7WUFBRztZQUFrQjtTQUFvQjtRQUMvQ0MsSUFBSTtZQUFFO1lBQUc7WUFBc0I7U0FBeUI7UUFFeERDLFVBQVU7WUFBRTtZQUFHO1lBQUk7U0FBSTtJQUN4QjtJQUVBTCxRQUFRTSxLQUFLLEdBQUdOLFFBQVFPLEtBQUssR0FBR1AsUUFBUVEsUUFBUSxHQUFHUixRQUFRUyxPQUFPLEdBQUdULFFBQVFDLEtBQUs7SUFDbEZELFFBQVFVLEVBQUUsR0FBR1YsUUFBUUksRUFBRTtJQUV2Qix1QkFBdUI7SUFDdkIsSUFBSyxDQUFDeGtCLFFBQVFta0IsTUFBTSxFQUFHO1FBQ3RCQyxRQUFRVyxRQUFRLEdBQUdYLFFBQVFELE1BQU0sR0FBRztZQUFFO1lBQUc7WUFBZ0M7U0FBYTtJQUN2RjtJQUdBLFNBQVNhLE9BQVFqakIsT0FBTyxFQUFFaU4sR0FBRztRQUU1Qiw0QkFBNEI7UUFDNUIsbUZBQW1GO1FBQ25GLElBQUlyTTtRQUVKLElBQUssT0FBT1osUUFBUXlLLG9CQUFvQixLQUFLLGFBQWM7WUFDMUQ3SixNQUFNWixRQUFReUssb0JBQW9CLENBQUV3QyxPQUFPO1FBRTVDLE9BQU8sSUFBSyxPQUFPak4sUUFBUWdMLGdCQUFnQixLQUFLLGFBQWM7WUFDN0RwSyxNQUFNWixRQUFRZ0wsZ0JBQWdCLENBQUVpQyxPQUFPO1FBRXhDLE9BQU87WUFDTnJNLE1BQU0sRUFBRTtRQUNUO1FBRUEsSUFBS3FNLFFBQVF0SyxhQUFhc0ssT0FBTzVJLFNBQVVyRSxTQUFTaU4sTUFBUTtZQUMzRCxPQUFPbk4sT0FBT2UsS0FBSyxDQUFFO2dCQUFFYjthQUFTLEVBQUVZO1FBQ25DO1FBRUEsT0FBT0E7SUFDUjtJQUdBLGdEQUFnRDtJQUNoRCxTQUFTc2lCLGNBQWV2aUIsS0FBSyxFQUFFd2lCLFdBQVc7UUFDekMsSUFBSW5rQixJQUFJLEdBQ1B1WCxJQUFJNVYsTUFBTUwsTUFBTTtRQUVqQixNQUFRdEIsSUFBSXVYLEdBQUd2WCxJQUFNO1lBQ3BCcWYsU0FBU0osR0FBRyxDQUNYdGQsS0FBSyxDQUFFM0IsRUFBRyxFQUNWLGNBQ0EsQ0FBQ21rQixlQUFlOUUsU0FBUzdkLEdBQUcsQ0FBRTJpQixXQUFXLENBQUVua0IsRUFBRyxFQUFFO1FBRWxEO0lBQ0Q7SUFHQSxJQUFJb2tCLFFBQVE7SUFFWixTQUFTQyxjQUFlMWlCLEtBQUssRUFBRVgsT0FBTyxFQUFFc2pCLE9BQU8sRUFBRUMsU0FBUyxFQUFFQyxPQUFPO1FBQ2xFLElBQUl0aUIsTUFBTXVlLEtBQUt4UyxLQUFLd1csTUFBTUMsVUFBVTloQixHQUNuQ2lnQixXQUFXN2hCLFFBQVE4aEIsc0JBQXNCLElBQ3pDNkIsUUFBUSxFQUFFLEVBQ1Yza0IsSUFBSSxHQUNKdVgsSUFBSTVWLE1BQU1MLE1BQU07UUFFakIsTUFBUXRCLElBQUl1WCxHQUFHdlgsSUFBTTtZQUNwQmtDLE9BQU9QLEtBQUssQ0FBRTNCLEVBQUc7WUFFakIsSUFBS2tDLFFBQVFBLFNBQVMsR0FBSTtnQkFFekIscUJBQXFCO2dCQUNyQixJQUFLdkIsT0FBUXVCLFVBQVcsVUFBVztvQkFFbEMsZ0RBQWdEO29CQUNoRCxvREFBb0Q7b0JBQ3BEcEIsT0FBT2UsS0FBSyxDQUFFOGlCLE9BQU96aUIsS0FBSzlDLFFBQVEsR0FBRzt3QkFBRThDO3FCQUFNLEdBQUdBO2dCQUVqRCxvQ0FBb0M7Z0JBQ3BDLE9BQU8sSUFBSyxDQUFDa2lCLE1BQU1oZixJQUFJLENBQUVsRCxPQUFTO29CQUNqQ3lpQixNQUFNbG1CLElBQUksQ0FBRXVDLFFBQVE0akIsY0FBYyxDQUFFMWlCO2dCQUVyQyw4QkFBOEI7Z0JBQzlCLE9BQU87b0JBQ051ZSxNQUFNQSxPQUFPb0MsU0FBU3JpQixXQUFXLENBQUVRLFFBQVFiLGFBQWEsQ0FBRTtvQkFFMUQsd0NBQXdDO29CQUN4QzhOLE1BQU0sQ0FBRTBVLFNBQVNyWCxJQUFJLENBQUVwSixTQUFVO3dCQUFFO3dCQUFJO3FCQUFJLENBQUUsQ0FBRSxFQUFHLENBQUNnRSxXQUFXO29CQUM5RHVlLE9BQU9wQixPQUFPLENBQUVwVixJQUFLLElBQUlvVixRQUFRSyxRQUFRO29CQUN6Q2pELElBQUlyUyxTQUFTLEdBQUdxVyxJQUFJLENBQUUsRUFBRyxHQUFHM2pCLE9BQU8rakIsYUFBYSxDQUFFM2lCLFFBQVN1aUIsSUFBSSxDQUFFLEVBQUc7b0JBRXBFLGdEQUFnRDtvQkFDaEQ3aEIsSUFBSTZoQixJQUFJLENBQUUsRUFBRztvQkFDYixNQUFRN2hCLElBQU07d0JBQ2I2ZCxNQUFNQSxJQUFJalEsU0FBUztvQkFDcEI7b0JBRUEsZ0RBQWdEO29CQUNoRCxvREFBb0Q7b0JBQ3BEMVAsT0FBT2UsS0FBSyxDQUFFOGlCLE9BQU9sRSxJQUFJOVYsVUFBVTtvQkFFbkMsbUNBQW1DO29CQUNuQzhWLE1BQU1vQyxTQUFTdFMsVUFBVTtvQkFFekIscURBQXFEO29CQUNyRGtRLElBQUloYyxXQUFXLEdBQUc7Z0JBQ25CO1lBQ0Q7UUFDRDtRQUVBLCtCQUErQjtRQUMvQm9lLFNBQVNwZSxXQUFXLEdBQUc7UUFFdkJ6RSxJQUFJO1FBQ0osTUFBVWtDLE9BQU95aUIsS0FBSyxDQUFFM2tCLElBQUssQ0FBSztZQUVqQyw4REFBOEQ7WUFDOUQsSUFBS3VrQixhQUFhempCLE9BQU9nRSxPQUFPLENBQUU1QyxNQUFNcWlCLGFBQWMsQ0FBQyxHQUFJO2dCQUMxRCxJQUFLQyxTQUFVO29CQUNkQSxRQUFRL2xCLElBQUksQ0FBRXlEO2dCQUNmO2dCQUNBO1lBQ0Q7WUFFQXdpQixXQUFXMUQsV0FBWTllO1lBRXZCLHFCQUFxQjtZQUNyQnVlLE1BQU13RCxPQUFRcEIsU0FBU3JpQixXQUFXLENBQUUwQixPQUFRO1lBRTVDLHFDQUFxQztZQUNyQyxJQUFLd2lCLFVBQVc7Z0JBQ2ZSLGNBQWV6RDtZQUNoQjtZQUVBLHNCQUFzQjtZQUN0QixJQUFLNkQsU0FBVTtnQkFDZDFoQixJQUFJO2dCQUNKLE1BQVVWLE9BQU91ZSxHQUFHLENBQUU3ZCxJQUFLLENBQUs7b0JBQy9CLElBQUtnZ0IsWUFBWXhkLElBQUksQ0FBRWxELEtBQUsxQyxJQUFJLElBQUksS0FBTzt3QkFDMUM4a0IsUUFBUTdsQixJQUFJLENBQUV5RDtvQkFDZjtnQkFDRDtZQUNEO1FBQ0Q7UUFFQSxPQUFPMmdCO0lBQ1I7SUFHQSxJQUFJaUMsaUJBQWlCO0lBRXJCLFNBQVNDO1FBQ1IsT0FBTztJQUNSO0lBRUEsU0FBU0M7UUFDUixPQUFPO0lBQ1I7SUFFQSxTQUFTQyxHQUFJL2lCLElBQUksRUFBRWdqQixLQUFLLEVBQUVua0IsUUFBUSxFQUFFbWUsSUFBSSxFQUFFamUsRUFBRSxFQUFFa2tCLEdBQUc7UUFDaEQsSUFBSUMsUUFBUTVsQjtRQUVaLHVDQUF1QztRQUN2QyxJQUFLLE9BQU8wbEIsVUFBVSxVQUFXO1lBRWhDLG1DQUFtQztZQUNuQyxJQUFLLE9BQU9ua0IsYUFBYSxVQUFXO2dCQUVuQyx5QkFBeUI7Z0JBQ3pCbWUsT0FBT0EsUUFBUW5lO2dCQUNmQSxXQUFXNEM7WUFDWjtZQUNBLElBQU1uRSxRQUFRMGxCLE1BQVE7Z0JBQ3JCRCxHQUFJL2lCLE1BQU0xQyxNQUFNdUIsVUFBVW1lLE1BQU1nRyxLQUFLLENBQUUxbEIsS0FBTSxFQUFFMmxCO1lBQ2hEO1lBQ0EsT0FBT2pqQjtRQUNSO1FBRUEsSUFBS2dkLFFBQVEsUUFBUWplLE1BQU0sTUFBTztZQUVqQyxnQkFBZ0I7WUFDaEJBLEtBQUtGO1lBQ0xtZSxPQUFPbmUsV0FBVzRDO1FBQ25CLE9BQU8sSUFBSzFDLE1BQU0sTUFBTztZQUN4QixJQUFLLE9BQU9GLGFBQWEsVUFBVztnQkFFbkMsMEJBQTBCO2dCQUMxQkUsS0FBS2llO2dCQUNMQSxPQUFPdmI7WUFDUixPQUFPO2dCQUVOLHNCQUFzQjtnQkFDdEIxQyxLQUFLaWU7Z0JBQ0xBLE9BQU9uZTtnQkFDUEEsV0FBVzRDO1lBQ1o7UUFDRDtRQUNBLElBQUsxQyxPQUFPLE9BQVE7WUFDbkJBLEtBQUsrakI7UUFDTixPQUFPLElBQUssQ0FBQy9qQixJQUFLO1lBQ2pCLE9BQU9pQjtRQUNSO1FBRUEsSUFBS2lqQixRQUFRLEdBQUk7WUFDaEJDLFNBQVNua0I7WUFDVEEsS0FBSyxTQUFVb2tCLEtBQUs7Z0JBRW5CLHNEQUFzRDtnQkFDdER2a0IsU0FBU3drQixHQUFHLENBQUVEO2dCQUNkLE9BQU9ELE9BQU81bUIsS0FBSyxDQUFFLElBQUksRUFBRTJEO1lBQzVCO1lBRUEsa0RBQWtEO1lBQ2xEbEIsR0FBRzRFLElBQUksR0FBR3VmLE9BQU92ZixJQUFJLElBQU11ZixDQUFBQSxPQUFPdmYsSUFBSSxHQUFHL0UsT0FBTytFLElBQUksRUFBQztRQUN0RDtRQUNBLE9BQU8zRCxLQUFLSCxJQUFJLENBQUU7WUFDakJqQixPQUFPdWtCLEtBQUssQ0FBQ3pOLEdBQUcsQ0FBRSxJQUFJLEVBQUVzTixPQUFPamtCLElBQUlpZSxNQUFNbmU7UUFDMUM7SUFDRDtJQUVBOzs7Q0FHQyxHQUNERCxPQUFPdWtCLEtBQUssR0FBRztRQUVkL25CLFFBQVEsQ0FBQztRQUVUc2EsS0FBSyxTQUFVMVYsSUFBSSxFQUFFZ2pCLEtBQUssRUFBRXpKLE9BQU8sRUFBRXlELElBQUksRUFBRW5lLFFBQVE7WUFFbEQsSUFBSXdrQixhQUFhQyxhQUFhL0UsS0FDN0JnRixRQUFRQyxHQUFHQyxXQUNYakssU0FBU2tLLFVBQVVwbUIsTUFBTXFtQixZQUFZQyxVQUNyQ0MsV0FBVzFHLFNBQVM3ZCxHQUFHLENBQUVVO1lBRTFCLGlEQUFpRDtZQUNqRCxJQUFLLENBQUN5YyxXQUFZemMsT0FBUztnQkFDMUI7WUFDRDtZQUVBLHFFQUFxRTtZQUNyRSxJQUFLdVosUUFBUUEsT0FBTyxFQUFHO2dCQUN0QjhKLGNBQWM5SjtnQkFDZEEsVUFBVThKLFlBQVk5SixPQUFPO2dCQUM3QjFhLFdBQVd3a0IsWUFBWXhrQixRQUFRO1lBQ2hDO1lBRUEsZ0VBQWdFO1lBQ2hFLHVGQUF1RjtZQUN2RixJQUFLQSxVQUFXO2dCQUNmRCxPQUFPZ0ssSUFBSSxDQUFDMkQsZUFBZSxDQUFFL0osaUJBQWlCM0Q7WUFDL0M7WUFFQSwyRUFBMkU7WUFDM0UsSUFBSyxDQUFDMGEsUUFBUTVWLElBQUksRUFBRztnQkFDcEI0VixRQUFRNVYsSUFBSSxHQUFHL0UsT0FBTytFLElBQUk7WUFDM0I7WUFFQSw0RUFBNEU7WUFDNUUsSUFBSyxDQUFHNGYsQ0FBQUEsU0FBU00sU0FBU04sTUFBTSxHQUFLO2dCQUNwQ0EsU0FBU00sU0FBU04sTUFBTSxHQUFHeG5CLE9BQU8rbkIsTUFBTSxDQUFFO1lBQzNDO1lBQ0EsSUFBSyxDQUFHUixDQUFBQSxjQUFjTyxTQUFTRSxNQUFNLEdBQUs7Z0JBQ3pDVCxjQUFjTyxTQUFTRSxNQUFNLEdBQUcsU0FBVXJiLENBQUM7b0JBRTFDLDJEQUEyRDtvQkFDM0Qsb0RBQW9EO29CQUNwRCxPQUFPLE9BQU85SixXQUFXLGVBQWVBLE9BQU91a0IsS0FBSyxDQUFDYSxTQUFTLEtBQUt0YixFQUFFcEwsSUFBSSxHQUN4RXNCLE9BQU91a0IsS0FBSyxDQUFDYyxRQUFRLENBQUMzbkIsS0FBSyxDQUFFMEQsTUFBTUMsYUFBY3dCO2dCQUNuRDtZQUNEO1lBRUEsOENBQThDO1lBQzlDdWhCLFFBQVEsQ0FBRUEsU0FBUyxFQUFDLEVBQUloYSxLQUFLLENBQUVxTixrQkFBbUI7Z0JBQUU7YUFBSTtZQUN4RG1OLElBQUlSLE1BQU01akIsTUFBTTtZQUNoQixNQUFRb2tCLElBQU07Z0JBQ2JqRixNQUFNcUUsZUFBZXhaLElBQUksQ0FBRTRaLEtBQUssQ0FBRVEsRUFBRyxLQUFNLEVBQUU7Z0JBQzdDbG1CLE9BQU9zbUIsV0FBV3JGLEdBQUcsQ0FBRSxFQUFHO2dCQUMxQm9GLGFBQWEsQ0FBRXBGLEdBQUcsQ0FBRSxFQUFHLElBQUksRUFBQyxFQUFJemEsS0FBSyxDQUFFLEtBQU1sRCxJQUFJO2dCQUVqRCwrREFBK0Q7Z0JBQy9ELElBQUssQ0FBQ3RELE1BQU87b0JBQ1o7Z0JBQ0Q7Z0JBRUEsaUZBQWlGO2dCQUNqRmtjLFVBQVU1YSxPQUFPdWtCLEtBQUssQ0FBQzNKLE9BQU8sQ0FBRWxjLEtBQU0sSUFBSSxDQUFDO2dCQUUzQyw4RUFBOEU7Z0JBQzlFQSxPQUFPLENBQUV1QixXQUFXMmEsUUFBUTBLLFlBQVksR0FBRzFLLFFBQVEySyxRQUFRLEtBQU03bUI7Z0JBRWpFLDJDQUEyQztnQkFDM0NrYyxVQUFVNWEsT0FBT3VrQixLQUFLLENBQUMzSixPQUFPLENBQUVsYyxLQUFNLElBQUksQ0FBQztnQkFFM0MsNENBQTRDO2dCQUM1Q21tQixZQUFZN2tCLE9BQU9rQyxNQUFNLENBQUU7b0JBQzFCeEQsTUFBTUE7b0JBQ05zbUIsVUFBVUE7b0JBQ1Y1RyxNQUFNQTtvQkFDTnpELFNBQVNBO29CQUNUNVYsTUFBTTRWLFFBQVE1VixJQUFJO29CQUNsQjlFLFVBQVVBO29CQUNWc0ksY0FBY3RJLFlBQVlELE9BQU95TixJQUFJLENBQUNyRCxLQUFLLENBQUM3QixZQUFZLENBQUNqRSxJQUFJLENBQUVyRTtvQkFDL0RpRSxXQUFXNmdCLFdBQVc5WixJQUFJLENBQUU7Z0JBQzdCLEdBQUd3WjtnQkFFSCxrREFBa0Q7Z0JBQ2xELElBQUssQ0FBR0ssQ0FBQUEsV0FBV0gsTUFBTSxDQUFFam1CLEtBQU0sR0FBSztvQkFDckNvbUIsV0FBV0gsTUFBTSxDQUFFam1CLEtBQU0sR0FBRyxFQUFFO29CQUM5Qm9tQixTQUFTVSxhQUFhLEdBQUc7b0JBRXpCLHdFQUF3RTtvQkFDeEUsSUFBSyxDQUFDNUssUUFBUTZLLEtBQUssSUFDbEI3SyxRQUFRNkssS0FBSyxDQUFDam9CLElBQUksQ0FBRTRELE1BQU1nZCxNQUFNMkcsWUFBWUwsaUJBQWtCLE9BQVE7d0JBRXRFLElBQUt0akIsS0FBS3NMLGdCQUFnQixFQUFHOzRCQUM1QnRMLEtBQUtzTCxnQkFBZ0IsQ0FBRWhPLE1BQU1nbUI7d0JBQzlCO29CQUNEO2dCQUNEO2dCQUVBLElBQUs5SixRQUFROUQsR0FBRyxFQUFHO29CQUNsQjhELFFBQVE5RCxHQUFHLENBQUN0WixJQUFJLENBQUU0RCxNQUFNeWpCO29CQUV4QixJQUFLLENBQUNBLFVBQVVsSyxPQUFPLENBQUM1VixJQUFJLEVBQUc7d0JBQzlCOGYsVUFBVWxLLE9BQU8sQ0FBQzVWLElBQUksR0FBRzRWLFFBQVE1VixJQUFJO29CQUN0QztnQkFDRDtnQkFFQSx3REFBd0Q7Z0JBQ3hELElBQUs5RSxVQUFXO29CQUNmNmtCLFNBQVM3aUIsTUFBTSxDQUFFNmlCLFNBQVNVLGFBQWEsSUFBSSxHQUFHWDtnQkFDL0MsT0FBTztvQkFDTkMsU0FBU25uQixJQUFJLENBQUVrbkI7Z0JBQ2hCO2dCQUVBLHlFQUF5RTtnQkFDekU3a0IsT0FBT3VrQixLQUFLLENBQUMvbkIsTUFBTSxDQUFFa0MsS0FBTSxHQUFHO1lBQy9CO1FBRUQ7UUFFQSxtREFBbUQ7UUFDbkQrWixRQUFRLFNBQVVyWCxJQUFJLEVBQUVnakIsS0FBSyxFQUFFekosT0FBTyxFQUFFMWEsUUFBUSxFQUFFeWxCLFdBQVc7WUFFNUQsSUFBSTVqQixHQUFHNmpCLFdBQVdoRyxLQUNqQmdGLFFBQVFDLEdBQUdDLFdBQ1hqSyxTQUFTa0ssVUFBVXBtQixNQUFNcW1CLFlBQVlDLFVBQ3JDQyxXQUFXMUcsU0FBU0QsT0FBTyxDQUFFbGQsU0FBVW1kLFNBQVM3ZCxHQUFHLENBQUVVO1lBRXRELElBQUssQ0FBQzZqQixZQUFZLENBQUdOLENBQUFBLFNBQVNNLFNBQVNOLE1BQU0sR0FBSztnQkFDakQ7WUFDRDtZQUVBLDZEQUE2RDtZQUM3RFAsUUFBUSxDQUFFQSxTQUFTLEVBQUMsRUFBSWhhLEtBQUssQ0FBRXFOLGtCQUFtQjtnQkFBRTthQUFJO1lBQ3hEbU4sSUFBSVIsTUFBTTVqQixNQUFNO1lBQ2hCLE1BQVFva0IsSUFBTTtnQkFDYmpGLE1BQU1xRSxlQUFleFosSUFBSSxDQUFFNFosS0FBSyxDQUFFUSxFQUFHLEtBQU0sRUFBRTtnQkFDN0NsbUIsT0FBT3NtQixXQUFXckYsR0FBRyxDQUFFLEVBQUc7Z0JBQzFCb0YsYUFBYSxDQUFFcEYsR0FBRyxDQUFFLEVBQUcsSUFBSSxFQUFDLEVBQUl6YSxLQUFLLENBQUUsS0FBTWxELElBQUk7Z0JBRWpELHFFQUFxRTtnQkFDckUsSUFBSyxDQUFDdEQsTUFBTztvQkFDWixJQUFNQSxRQUFRaW1CLE9BQVM7d0JBQ3RCM2tCLE9BQU91a0IsS0FBSyxDQUFDOUwsTUFBTSxDQUFFclgsTUFBTTFDLE9BQU8wbEIsS0FBSyxDQUFFUSxFQUFHLEVBQUVqSyxTQUFTMWEsVUFBVTtvQkFDbEU7b0JBQ0E7Z0JBQ0Q7Z0JBRUEyYSxVQUFVNWEsT0FBT3VrQixLQUFLLENBQUMzSixPQUFPLENBQUVsYyxLQUFNLElBQUksQ0FBQztnQkFDM0NBLE9BQU8sQ0FBRXVCLFdBQVcyYSxRQUFRMEssWUFBWSxHQUFHMUssUUFBUTJLLFFBQVEsS0FBTTdtQjtnQkFDakVvbUIsV0FBV0gsTUFBTSxDQUFFam1CLEtBQU0sSUFBSSxFQUFFO2dCQUMvQmloQixNQUFNQSxHQUFHLENBQUUsRUFBRyxJQUNiLElBQUluYSxPQUFRLFlBQVl1ZixXQUFXOVosSUFBSSxDQUFFLG1CQUFvQjtnQkFFOUQseUJBQXlCO2dCQUN6QjBhLFlBQVk3akIsSUFBSWdqQixTQUFTdGtCLE1BQU07Z0JBQy9CLE1BQVFzQixJQUFNO29CQUNiK2lCLFlBQVlDLFFBQVEsQ0FBRWhqQixFQUFHO29CQUV6QixJQUFLLENBQUU0akIsZUFBZVYsYUFBYUgsVUFBVUcsUUFBUSxLQUNsRCxFQUFDckssV0FBV0EsUUFBUTVWLElBQUksS0FBSzhmLFVBQVU5ZixJQUFJLEtBQzNDLEVBQUM0YSxPQUFPQSxJQUFJcmIsSUFBSSxDQUFFdWdCLFVBQVUzZ0IsU0FBUyxDQUFDLEtBQ3RDLEVBQUNqRSxZQUFZQSxhQUFhNGtCLFVBQVU1a0IsUUFBUSxJQUM3Q0EsYUFBYSxRQUFRNGtCLFVBQVU1a0IsUUFBUSxHQUFLO3dCQUM3QzZrQixTQUFTN2lCLE1BQU0sQ0FBRUgsR0FBRzt3QkFFcEIsSUFBSytpQixVQUFVNWtCLFFBQVEsRUFBRzs0QkFDekI2a0IsU0FBU1UsYUFBYTt3QkFDdkI7d0JBQ0EsSUFBSzVLLFFBQVFuQyxNQUFNLEVBQUc7NEJBQ3JCbUMsUUFBUW5DLE1BQU0sQ0FBQ2piLElBQUksQ0FBRTRELE1BQU15akI7d0JBQzVCO29CQUNEO2dCQUNEO2dCQUVBLGtGQUFrRjtnQkFDbEYsb0ZBQW9GO2dCQUNwRixJQUFLYyxhQUFhLENBQUNiLFNBQVN0a0IsTUFBTSxFQUFHO29CQUNwQyxJQUFLLENBQUNvYSxRQUFRZ0wsUUFBUSxJQUNyQmhMLFFBQVFnTCxRQUFRLENBQUNwb0IsSUFBSSxDQUFFNEQsTUFBTTJqQixZQUFZRSxTQUFTRSxNQUFNLE1BQU8sT0FBUTt3QkFFdkVubEIsT0FBTzZsQixXQUFXLENBQUV6a0IsTUFBTTFDLE1BQU11bUIsU0FBU0UsTUFBTTtvQkFDaEQ7b0JBRUEsT0FBT1IsTUFBTSxDQUFFam1CLEtBQU07Z0JBQ3RCO1lBQ0Q7WUFFQSxxREFBcUQ7WUFDckQsSUFBS3NCLE9BQU93RCxhQUFhLENBQUVtaEIsU0FBVztnQkFDckNwRyxTQUFTOUYsTUFBTSxDQUFFclgsTUFBTTtZQUN4QjtRQUNEO1FBRUFpa0IsVUFBVSxTQUFVUyxXQUFXO1lBRTlCLElBQUk1bUIsR0FBRzRDLEdBQUdoQixLQUFLaVAsU0FBUzhVLFdBQVdrQixjQUNsQ25XLE9BQU8sSUFBSWpOLE1BQU90QixVQUFVYixNQUFNLEdBRWxDLDREQUE0RDtZQUM1RCtqQixRQUFRdmtCLE9BQU91a0IsS0FBSyxDQUFDeUIsR0FBRyxDQUFFRixjQUUxQmhCLFdBQVcsQ0FDVnZHLFNBQVM3ZCxHQUFHLENBQUUsSUFBSSxFQUFFLGFBQWN2RCxPQUFPK25CLE1BQU0sQ0FBRSxLQUFLLENBQ3RELENBQUVYLE1BQU03bEIsSUFBSSxDQUFFLElBQUksRUFBRSxFQUNyQmtjLFVBQVU1YSxPQUFPdWtCLEtBQUssQ0FBQzNKLE9BQU8sQ0FBRTJKLE1BQU03bEIsSUFBSSxDQUFFLElBQUksQ0FBQztZQUVsRCx1RUFBdUU7WUFDdkVrUixJQUFJLENBQUUsRUFBRyxHQUFHMlU7WUFFWixJQUFNcmxCLElBQUksR0FBR0EsSUFBSW1DLFVBQVViLE1BQU0sRUFBRXRCLElBQU07Z0JBQ3hDMFEsSUFBSSxDQUFFMVEsRUFBRyxHQUFHbUMsU0FBUyxDQUFFbkMsRUFBRztZQUMzQjtZQUVBcWxCLE1BQU0wQixjQUFjLEdBQUcsSUFBSTtZQUUzQiw0RUFBNEU7WUFDNUUsSUFBS3JMLFFBQVFzTCxXQUFXLElBQUl0TCxRQUFRc0wsV0FBVyxDQUFDMW9CLElBQUksQ0FBRSxJQUFJLEVBQUUrbUIsV0FBWSxPQUFRO2dCQUMvRTtZQUNEO1lBRUEscUJBQXFCO1lBQ3JCd0IsZUFBZS9sQixPQUFPdWtCLEtBQUssQ0FBQ08sUUFBUSxDQUFDdG5CLElBQUksQ0FBRSxJQUFJLEVBQUUrbUIsT0FBT087WUFFeEQsb0VBQW9FO1lBQ3BFNWxCLElBQUk7WUFDSixNQUFRLENBQUU2USxVQUFVZ1csWUFBWSxDQUFFN21CLElBQUssS0FBTSxDQUFDcWxCLE1BQU00QixvQkFBb0IsR0FBSztnQkFDNUU1QixNQUFNNkIsYUFBYSxHQUFHclcsUUFBUTNPLElBQUk7Z0JBRWxDVSxJQUFJO2dCQUNKLE1BQVEsQ0FBRStpQixZQUFZOVUsUUFBUStVLFFBQVEsQ0FBRWhqQixJQUFLLEtBQzVDLENBQUN5aUIsTUFBTThCLDZCQUE2QixHQUFLO29CQUV6Qyx5RUFBeUU7b0JBQ3pFLHVFQUF1RTtvQkFDdkUsSUFBSyxDQUFDOUIsTUFBTStCLFVBQVUsSUFBSXpCLFVBQVUzZ0IsU0FBUyxLQUFLLFNBQ2pEcWdCLE1BQU0rQixVQUFVLENBQUNoaUIsSUFBSSxDQUFFdWdCLFVBQVUzZ0IsU0FBUyxHQUFLO3dCQUUvQ3FnQixNQUFNTSxTQUFTLEdBQUdBO3dCQUNsQk4sTUFBTW5HLElBQUksR0FBR3lHLFVBQVV6RyxJQUFJO3dCQUUzQnRkLE1BQU0sQ0FBRSxDQUFFZCxPQUFPdWtCLEtBQUssQ0FBQzNKLE9BQU8sQ0FBRWlLLFVBQVVHLFFBQVEsQ0FBRSxJQUFJLENBQUMsR0FBSUcsTUFBTSxJQUNsRU4sVUFBVWxLLE9BQU8sRUFBR2pkLEtBQUssQ0FBRXFTLFFBQVEzTyxJQUFJLEVBQUV3Tzt3QkFFMUMsSUFBSzlPLFFBQVErQixXQUFZOzRCQUN4QixJQUFLLENBQUUwaEIsTUFBTTVWLE1BQU0sR0FBRzdOLEdBQUUsTUFBUSxPQUFRO2dDQUN2Q3lqQixNQUFNZ0MsY0FBYztnQ0FDcEJoQyxNQUFNaUMsZUFBZTs0QkFDdEI7d0JBQ0Q7b0JBQ0Q7Z0JBQ0Q7WUFDRDtZQUVBLGlEQUFpRDtZQUNqRCxJQUFLNUwsUUFBUTZMLFlBQVksRUFBRztnQkFDM0I3TCxRQUFRNkwsWUFBWSxDQUFDanBCLElBQUksQ0FBRSxJQUFJLEVBQUUrbUI7WUFDbEM7WUFFQSxPQUFPQSxNQUFNNVYsTUFBTTtRQUNwQjtRQUVBbVcsVUFBVSxTQUFVUCxLQUFLLEVBQUVPLFFBQVE7WUFDbEMsSUFBSTVsQixHQUFHMmxCLFdBQVd6ZSxLQUFLc2dCLGlCQUFpQkMsa0JBQ3ZDWixlQUFlLEVBQUUsRUFDakJQLGdCQUFnQlYsU0FBU1UsYUFBYSxFQUN0QzdPLE1BQU00TixNQUFNL2hCLE1BQU07WUFFbkIseUJBQXlCO1lBQ3pCLElBQUtnakIsaUJBRUosa0JBQWtCO1lBQ2xCLG1EQUFtRDtZQUNuRDdPLElBQUlyWSxRQUFRLElBRVosd0JBQXdCO1lBQ3hCLHFGQUFxRjtZQUNyRiw2REFBNkQ7WUFDN0Qsc0JBQXNCO1lBQ3RCLHNGQUFzRjtZQUN0RixDQUFHaW1CLENBQUFBLE1BQU03bEIsSUFBSSxLQUFLLFdBQVc2bEIsTUFBTWxULE1BQU0sSUFBSSxJQUFNO2dCQUVuRCxNQUFRc0YsUUFBUSxJQUFJLEVBQUVBLE1BQU1BLElBQUloWCxVQUFVLElBQUksSUFBSSxDQUFHO29CQUVwRCx3Q0FBd0M7b0JBQ3hDLDJGQUEyRjtvQkFDM0YsSUFBS2dYLElBQUlyWSxRQUFRLEtBQUssS0FBSyxDQUFHaW1CLENBQUFBLE1BQU03bEIsSUFBSSxLQUFLLFdBQVdpWSxJQUFJcE4sUUFBUSxLQUFLLElBQUcsR0FBTTt3QkFDakZtZCxrQkFBa0IsRUFBRTt3QkFDcEJDLG1CQUFtQixDQUFDO3dCQUNwQixJQUFNem5CLElBQUksR0FBR0EsSUFBSXNtQixlQUFldG1CLElBQU07NEJBQ3JDMmxCLFlBQVlDLFFBQVEsQ0FBRTVsQixFQUFHOzRCQUV6QiwrREFBK0Q7NEJBQy9Ea0gsTUFBTXllLFVBQVU1a0IsUUFBUSxHQUFHOzRCQUUzQixJQUFLMG1CLGdCQUFnQixDQUFFdmdCLElBQUssS0FBS3ZELFdBQVk7Z0NBQzVDOGpCLGdCQUFnQixDQUFFdmdCLElBQUssR0FBR3llLFVBQVV0YyxZQUFZLEdBQy9DdkksT0FBUW9HLEtBQUssSUFBSSxFQUFHd1EsS0FBSyxDQUFFRCxPQUFRLENBQUMsSUFDcEMzVyxPQUFPZ0ssSUFBSSxDQUFFNUQsS0FBSyxJQUFJLEVBQUUsTUFBTTtvQ0FBRXVRO2lDQUFLLEVBQUduVyxNQUFNOzRCQUNoRDs0QkFDQSxJQUFLbW1CLGdCQUFnQixDQUFFdmdCLElBQUssRUFBRztnQ0FDOUJzZ0IsZ0JBQWdCL29CLElBQUksQ0FBRWtuQjs0QkFDdkI7d0JBQ0Q7d0JBQ0EsSUFBSzZCLGdCQUFnQmxtQixNQUFNLEVBQUc7NEJBQzdCdWxCLGFBQWFwb0IsSUFBSSxDQUFFO2dDQUFFeUQsTUFBTXVWO2dDQUFLbU8sVUFBVTRCOzRCQUFnQjt3QkFDM0Q7b0JBQ0Q7Z0JBQ0Q7WUFDRDtZQUVBLDhDQUE4QztZQUM5Qy9QLE1BQU0sSUFBSTtZQUNWLElBQUs2TyxnQkFBZ0JWLFNBQVN0a0IsTUFBTSxFQUFHO2dCQUN0Q3VsQixhQUFhcG9CLElBQUksQ0FBRTtvQkFBRXlELE1BQU11VjtvQkFBS21PLFVBQVVBLFNBQVN6bkIsS0FBSyxDQUFFbW9CO2dCQUFnQjtZQUMzRTtZQUVBLE9BQU9PO1FBQ1I7UUFFQWEsU0FBUyxTQUFVeGtCLElBQUksRUFBRXlrQixJQUFJO1lBQzVCMXBCLE9BQU84Z0IsY0FBYyxDQUFFamUsT0FBTzhtQixLQUFLLENBQUN6bUIsU0FBUyxFQUFFK0IsTUFBTTtnQkFDcEQya0IsWUFBWTtnQkFDWjdJLGNBQWM7Z0JBRWR4ZCxLQUFLdEMsV0FBWXlvQixRQUNoQjtvQkFDQyxJQUFLLElBQUksQ0FBQ0csYUFBYSxFQUFHO3dCQUN6QixPQUFPSCxLQUFNLElBQUksQ0FBQ0csYUFBYTtvQkFDaEM7Z0JBQ0QsSUFDQTtvQkFDQyxJQUFLLElBQUksQ0FBQ0EsYUFBYSxFQUFHO3dCQUN6QixPQUFPLElBQUksQ0FBQ0EsYUFBYSxDQUFFNWtCLEtBQU07b0JBQ2xDO2dCQUNEO2dCQUVEK2IsS0FBSyxTQUFVclosS0FBSztvQkFDbkIzSCxPQUFPOGdCLGNBQWMsQ0FBRSxJQUFJLEVBQUU3YixNQUFNO3dCQUNsQzJrQixZQUFZO3dCQUNaN0ksY0FBYzt3QkFDZCtJLFVBQVU7d0JBQ1ZuaUIsT0FBT0E7b0JBQ1I7Z0JBQ0Q7WUFDRDtRQUNEO1FBRUFraEIsS0FBSyxTQUFVZ0IsYUFBYTtZQUMzQixPQUFPQSxhQUFhLENBQUVobkIsT0FBTzhDLE9BQU8sQ0FBRSxHQUNyQ2trQixnQkFDQSxJQUFJaG5CLE9BQU84bUIsS0FBSyxDQUFFRTtRQUNwQjtRQUVBcE0sU0FBUztZQUNSc00sTUFBTTtnQkFFTCxtRUFBbUU7Z0JBQ25FQyxVQUFVO1lBQ1g7WUFDQUMsT0FBTztnQkFFTixvRUFBb0U7Z0JBQ3BFM0IsT0FBTyxTQUFVckgsSUFBSTtvQkFFcEIsb0ZBQW9GO29CQUNwRixtRkFBbUY7b0JBQ25GLElBQUl2UyxLQUFLLElBQUksSUFBSXVTO29CQUVqQiwwQkFBMEI7b0JBQzFCLElBQUt3RCxlQUFldGQsSUFBSSxDQUFFdUgsR0FBR25OLElBQUksS0FDaENtTixHQUFHdWIsS0FBSyxJQUFJN2lCLFNBQVVzSCxJQUFJLFVBQVk7d0JBRXRDLG1DQUFtQzt3QkFDbkN3YixlQUFnQnhiLElBQUksU0FBUztvQkFDOUI7b0JBRUEsd0RBQXdEO29CQUN4RCxPQUFPO2dCQUNSO2dCQUNBeWIsU0FBUyxTQUFVbEosSUFBSTtvQkFFdEIsb0ZBQW9GO29CQUNwRixtRkFBbUY7b0JBQ25GLElBQUl2UyxLQUFLLElBQUksSUFBSXVTO29CQUVqQix3Q0FBd0M7b0JBQ3hDLElBQUt3RCxlQUFldGQsSUFBSSxDQUFFdUgsR0FBR25OLElBQUksS0FDaENtTixHQUFHdWIsS0FBSyxJQUFJN2lCLFNBQVVzSCxJQUFJLFVBQVk7d0JBRXRDd2IsZUFBZ0J4YixJQUFJO29CQUNyQjtvQkFFQSwwREFBMEQ7b0JBQzFELE9BQU87Z0JBQ1I7Z0JBRUEsbUVBQW1FO2dCQUNuRSwyRUFBMkU7Z0JBQzNFK1csVUFBVSxTQUFVMkIsS0FBSztvQkFDeEIsSUFBSS9oQixTQUFTK2hCLE1BQU0vaEIsTUFBTTtvQkFDekIsT0FBT29mLGVBQWV0ZCxJQUFJLENBQUU5QixPQUFPOUQsSUFBSSxLQUN0QzhELE9BQU80a0IsS0FBSyxJQUFJN2lCLFNBQVUvQixRQUFRLFlBQ2xDK2IsU0FBUzdkLEdBQUcsQ0FBRThCLFFBQVEsWUFDdEIrQixTQUFVL0IsUUFBUTtnQkFDcEI7WUFDRDtZQUVBK2tCLGNBQWM7Z0JBQ2JkLGNBQWMsU0FBVWxDLEtBQUs7b0JBRTVCLHVCQUF1QjtvQkFDdkIsNkRBQTZEO29CQUM3RCxJQUFLQSxNQUFNNVYsTUFBTSxLQUFLOUwsYUFBYTBoQixNQUFNeUMsYUFBYSxFQUFHO3dCQUN4RHpDLE1BQU15QyxhQUFhLENBQUNRLFdBQVcsR0FBR2pELE1BQU01VixNQUFNO29CQUMvQztnQkFDRDtZQUNEO1FBQ0Q7SUFDRDtJQUVBLDJFQUEyRTtJQUMzRSwyRUFBMkU7SUFDM0UsMkVBQTJFO0lBQzNFLHVEQUF1RDtJQUN2RCxTQUFTMFksZUFBZ0J4YixFQUFFLEVBQUVuTixJQUFJLEVBQUUrb0IsT0FBTztRQUV6Qyw4RkFBOEY7UUFDOUYsSUFBSyxDQUFDQSxTQUFVO1lBQ2YsSUFBS2xKLFNBQVM3ZCxHQUFHLENBQUVtTCxJQUFJbk4sVUFBV21FLFdBQVk7Z0JBQzdDN0MsT0FBT3VrQixLQUFLLENBQUN6TixHQUFHLENBQUVqTCxJQUFJbk4sTUFBTXVsQjtZQUM3QjtZQUNBO1FBQ0Q7UUFFQSxrRkFBa0Y7UUFDbEYxRixTQUFTSixHQUFHLENBQUV0UyxJQUFJbk4sTUFBTTtRQUN4QnNCLE9BQU91a0IsS0FBSyxDQUFDek4sR0FBRyxDQUFFakwsSUFBSW5OLE1BQU07WUFDM0J3RixXQUFXO1lBQ1h5VyxTQUFTLFNBQVU0SixLQUFLO2dCQUN2QixJQUFJNVYsUUFDSCtZLFFBQVFuSixTQUFTN2QsR0FBRyxDQUFFLElBQUksRUFBRWhDO2dCQUU3QixJQUFLLE1BQVFpcEIsU0FBUyxHQUFHLEtBQU8sSUFBSSxDQUFFanBCLEtBQU0sRUFBRztvQkFFOUMsaUVBQWlFO29CQUNqRSxJQUFLLENBQUNncEIsT0FBUTt3QkFFYiwrREFBK0Q7d0JBQy9ELDhFQUE4RTt3QkFDOUUsdURBQXVEO3dCQUN2REEsUUFBUXJxQixNQUFNRyxJQUFJLENBQUU2RDt3QkFDcEJrZCxTQUFTSixHQUFHLENBQUUsSUFBSSxFQUFFemYsTUFBTWdwQjt3QkFFMUIsa0RBQWtEO3dCQUNsRCxJQUFJLENBQUVocEIsS0FBTTt3QkFDWmlRLFNBQVM0UCxTQUFTN2QsR0FBRyxDQUFFLElBQUksRUFBRWhDO3dCQUM3QjZmLFNBQVNKLEdBQUcsQ0FBRSxJQUFJLEVBQUV6ZixNQUFNO3dCQUUxQixJQUFLZ3BCLFVBQVUvWSxRQUFTOzRCQUV2QixtQ0FBbUM7NEJBQ25DNFYsTUFBTXFELHdCQUF3Qjs0QkFDOUJyRCxNQUFNZ0MsY0FBYzs0QkFFcEIsT0FBTzVYO3dCQUNSO29CQUVELDZFQUE2RTtvQkFDN0UsZ0ZBQWdGO29CQUNoRiwrREFBK0Q7b0JBQy9ELGdGQUFnRjtvQkFDaEYsK0VBQStFO29CQUMvRSw2QkFBNkI7b0JBQzdCLE9BQU8sSUFBSyxDQUFFM08sT0FBT3VrQixLQUFLLENBQUMzSixPQUFPLENBQUVsYyxLQUFNLElBQUksQ0FBQyxHQUFJNG1CLFlBQVksRUFBRzt3QkFDakVmLE1BQU1pQyxlQUFlO29CQUN0QjtnQkFFRCx3RUFBd0U7Z0JBQ3hFLDREQUE0RDtnQkFDNUQsT0FBTyxJQUFLa0IsT0FBUTtvQkFFbkIsNEJBQTRCO29CQUM1Qm5KLFNBQVNKLEdBQUcsQ0FBRSxJQUFJLEVBQUV6ZixNQUFNc0IsT0FBT3VrQixLQUFLLENBQUMrQyxPQUFPLENBQzdDSSxLQUFLLENBQUUsRUFBRyxFQUNWQSxNQUFNcnFCLEtBQUssQ0FBRSxJQUNiLElBQUk7b0JBR0wsMkVBQTJFO29CQUMzRSwwRUFBMEU7b0JBQzFFLHVFQUF1RTtvQkFDdkUsc0VBQXNFO29CQUN0RSxzRUFBc0U7b0JBQ3RFLHFFQUFxRTtvQkFDckUsMkVBQTJFO29CQUMzRSx5Q0FBeUM7b0JBQ3pDa25CLE1BQU1pQyxlQUFlO29CQUNyQmpDLE1BQU04Qiw2QkFBNkIsR0FBR3BDO2dCQUN2QztZQUNEO1FBQ0Q7SUFDRDtJQUVBamtCLE9BQU82bEIsV0FBVyxHQUFHLFNBQVV6a0IsSUFBSSxFQUFFMUMsSUFBSSxFQUFFeW1CLE1BQU07UUFFaEQsd0NBQXdDO1FBQ3hDLElBQUsvakIsS0FBS3diLG1CQUFtQixFQUFHO1lBQy9CeGIsS0FBS3diLG1CQUFtQixDQUFFbGUsTUFBTXltQjtRQUNqQztJQUNEO0lBRUFubEIsT0FBTzhtQixLQUFLLEdBQUcsU0FBVW5vQixHQUFHLEVBQUVrcEIsS0FBSztRQUVsQyxnREFBZ0Q7UUFDaEQsSUFBSyxDQUFHLEtBQUksWUFBWTduQixPQUFPOG1CLEtBQUssR0FBSztZQUN4QyxPQUFPLElBQUk5bUIsT0FBTzhtQixLQUFLLENBQUVub0IsS0FBS2twQjtRQUMvQjtRQUVBLGVBQWU7UUFDZixJQUFLbHBCLE9BQU9BLElBQUlELElBQUksRUFBRztZQUN0QixJQUFJLENBQUNzb0IsYUFBYSxHQUFHcm9CO1lBQ3JCLElBQUksQ0FBQ0QsSUFBSSxHQUFHQyxJQUFJRCxJQUFJO1lBRXBCLG9FQUFvRTtZQUNwRSwrREFBK0Q7WUFDL0QsSUFBSSxDQUFDb3BCLGtCQUFrQixHQUFHbnBCLElBQUlvcEIsZ0JBQWdCLElBQzVDcHBCLElBQUlvcEIsZ0JBQWdCLEtBQUtsbEIsYUFFekIsOEJBQThCO1lBQzlCbEUsSUFBSTZvQixXQUFXLEtBQUssUUFDckJ2RCxhQUNBQztZQUVELDJCQUEyQjtZQUMzQiwrQkFBK0I7WUFDL0IsMERBQTBEO1lBQzFELElBQUksQ0FBQzFoQixNQUFNLEdBQUcsSUFBTUEsTUFBTSxJQUFJN0QsSUFBSTZELE1BQU0sQ0FBQ2xFLFFBQVEsS0FBSyxJQUNyREssSUFBSTZELE1BQU0sQ0FBQzdDLFVBQVUsR0FDckJoQixJQUFJNkQsTUFBTTtZQUVYLElBQUksQ0FBQzRqQixhQUFhLEdBQUd6bkIsSUFBSXluQixhQUFhO1lBQ3RDLElBQUksQ0FBQzRCLGFBQWEsR0FBR3JwQixJQUFJcXBCLGFBQWE7UUFFdkMsYUFBYTtRQUNiLE9BQU87WUFDTixJQUFJLENBQUN0cEIsSUFBSSxHQUFHQztRQUNiO1FBRUEsMkRBQTJEO1FBQzNELElBQUtrcEIsT0FBUTtZQUNaN25CLE9BQU9rQyxNQUFNLENBQUUsSUFBSSxFQUFFMmxCO1FBQ3RCO1FBRUEsd0RBQXdEO1FBQ3hELElBQUksQ0FBQ0ksU0FBUyxHQUFHdHBCLE9BQU9BLElBQUlzcEIsU0FBUyxJQUFJQyxLQUFLQyxHQUFHO1FBRWpELG1CQUFtQjtRQUNuQixJQUFJLENBQUVub0IsT0FBTzhDLE9BQU8sQ0FBRSxHQUFHO0lBQzFCO0lBRUEsdUZBQXVGO0lBQ3ZGLHFGQUFxRjtJQUNyRjlDLE9BQU84bUIsS0FBSyxDQUFDem1CLFNBQVMsR0FBRztRQUN4QkUsYUFBYVAsT0FBTzhtQixLQUFLO1FBQ3pCZ0Isb0JBQW9CNUQ7UUFDcEJpQyxzQkFBc0JqQztRQUN0Qm1DLCtCQUErQm5DO1FBQy9Ca0UsYUFBYTtRQUViN0IsZ0JBQWdCO1lBQ2YsSUFBSXpjLElBQUksSUFBSSxDQUFDa2QsYUFBYTtZQUUxQixJQUFJLENBQUNjLGtCQUFrQixHQUFHN0Q7WUFFMUIsSUFBS25hLEtBQUssQ0FBQyxJQUFJLENBQUNzZSxXQUFXLEVBQUc7Z0JBQzdCdGUsRUFBRXljLGNBQWM7WUFDakI7UUFDRDtRQUNBQyxpQkFBaUI7WUFDaEIsSUFBSTFjLElBQUksSUFBSSxDQUFDa2QsYUFBYTtZQUUxQixJQUFJLENBQUNiLG9CQUFvQixHQUFHbEM7WUFFNUIsSUFBS25hLEtBQUssQ0FBQyxJQUFJLENBQUNzZSxXQUFXLEVBQUc7Z0JBQzdCdGUsRUFBRTBjLGVBQWU7WUFDbEI7UUFDRDtRQUNBb0IsMEJBQTBCO1lBQ3pCLElBQUk5ZCxJQUFJLElBQUksQ0FBQ2tkLGFBQWE7WUFFMUIsSUFBSSxDQUFDWCw2QkFBNkIsR0FBR3BDO1lBRXJDLElBQUtuYSxLQUFLLENBQUMsSUFBSSxDQUFDc2UsV0FBVyxFQUFHO2dCQUM3QnRlLEVBQUU4ZCx3QkFBd0I7WUFDM0I7WUFFQSxJQUFJLENBQUNwQixlQUFlO1FBQ3JCO0lBQ0Q7SUFFQSxtRkFBbUY7SUFDbkZ4bUIsT0FBT2lCLElBQUksQ0FBRTtRQUNab25CLFFBQVE7UUFDUkMsU0FBUztRQUNUQyxZQUFZO1FBQ1pDLGdCQUFnQjtRQUNoQkMsU0FBUztRQUNUQyxRQUFRO1FBQ1JDLFlBQVk7UUFDWkMsU0FBUztRQUNUQyxPQUFPO1FBQ1BDLE9BQU87UUFDUEMsVUFBVTtRQUNWQyxNQUFNO1FBQ04sUUFBUTtRQUNSanFCLE1BQU07UUFDTmtxQixVQUFVO1FBQ1Z6ZCxLQUFLO1FBQ0wwZCxTQUFTO1FBQ1Q3WCxRQUFRO1FBQ1I4WCxTQUFTO1FBQ1RDLFNBQVM7UUFDVEMsU0FBUztRQUNUQyxTQUFTO1FBQ1RDLFNBQVM7UUFDVEMsV0FBVztRQUNYQyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsU0FBUztRQUNUQyxlQUFlO1FBQ2ZDLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxPQUFPO0lBQ1IsR0FBRy9wQixPQUFPdWtCLEtBQUssQ0FBQ3FDLE9BQU87SUFFdkI1bUIsT0FBT2lCLElBQUksQ0FBRTtRQUFFeVAsT0FBTztRQUFXc1osTUFBTTtJQUFXLEdBQUcsU0FBVXRyQixJQUFJLEVBQUU0bUIsWUFBWTtRQUVoRixTQUFTMkUsbUJBQW9CbkUsV0FBVztZQUN2QyxJQUFLbHBCLFNBQVNzdEIsWUFBWSxFQUFHO2dCQUU1QixrQkFBa0I7Z0JBQ2xCLCtFQUErRTtnQkFDL0UsZ0ZBQWdGO2dCQUNoRiw4RUFBOEU7Z0JBRTlFLHVFQUF1RTtnQkFDdkUsNkJBQTZCO2dCQUM3QixJQUFJL0UsU0FBUzVHLFNBQVM3ZCxHQUFHLENBQUUsSUFBSSxFQUFFLFdBQ2hDNmpCLFFBQVF2a0IsT0FBT3VrQixLQUFLLENBQUN5QixHQUFHLENBQUVGO2dCQUMzQnZCLE1BQU03bEIsSUFBSSxHQUFHb25CLFlBQVlwbkIsSUFBSSxLQUFLLFlBQVksVUFBVTtnQkFDeEQ2bEIsTUFBTTZELFdBQVcsR0FBRztnQkFFcEIsaUNBQWlDO2dCQUNqQ2pELE9BQVFXO2dCQUVSLDZCQUE2QjtnQkFDN0IsRUFBRTtnQkFDRixpRkFBaUY7Z0JBQ2pGLDJDQUEyQztnQkFDM0MsSUFBS3ZCLE1BQU0vaEIsTUFBTSxLQUFLK2hCLE1BQU02QixhQUFhLEVBQUc7b0JBRTNDLCtEQUErRDtvQkFDL0QsaUVBQWlFO29CQUNqRSxpQkFBaUI7b0JBQ2pCakIsT0FBUVo7Z0JBQ1Q7WUFDRCxPQUFPO2dCQUVOLHlFQUF5RTtnQkFDekUsd0NBQXdDO2dCQUN4Q3ZrQixPQUFPdWtCLEtBQUssQ0FBQzRGLFFBQVEsQ0FBRTdFLGNBQWNRLFlBQVl0akIsTUFBTSxFQUN0RHhDLE9BQU91a0IsS0FBSyxDQUFDeUIsR0FBRyxDQUFFRjtZQUNwQjtRQUNEO1FBRUE5bEIsT0FBT3VrQixLQUFLLENBQUMzSixPQUFPLENBQUVsYyxLQUFNLEdBQUc7WUFFOUIscUVBQXFFO1lBQ3JFK21CLE9BQU87Z0JBRU4sSUFBSTJFO2dCQUVKLDBCQUEwQjtnQkFDMUIscUNBQXFDO2dCQUNyQyxvQ0FBb0M7Z0JBQ3BDL0MsZUFBZ0IsSUFBSSxFQUFFM29CLE1BQU07Z0JBRTVCLElBQUs5QixTQUFTc3RCLFlBQVksRUFBRztvQkFFNUIsc0JBQXNCO29CQUN0QiwyRUFBMkU7b0JBQzNFLHdFQUF3RTtvQkFDeEUsK0VBQStFO29CQUMvRUUsV0FBVzdMLFNBQVM3ZCxHQUFHLENBQUUsSUFBSSxFQUFFNGtCO29CQUMvQixJQUFLLENBQUM4RSxVQUFXO3dCQUNoQixJQUFJLENBQUMxZCxnQkFBZ0IsQ0FBRTRZLGNBQWMyRTtvQkFDdEM7b0JBQ0ExTCxTQUFTSixHQUFHLENBQUUsSUFBSSxFQUFFbUgsY0FBYyxDQUFFOEUsWUFBWSxLQUFNO2dCQUN2RCxPQUFPO29CQUVOLHdEQUF3RDtvQkFDeEQsT0FBTztnQkFDUjtZQUNEO1lBQ0E5QyxTQUFTO2dCQUVSLDZCQUE2QjtnQkFDN0JELGVBQWdCLElBQUksRUFBRTNvQjtnQkFFdEIsMERBQTBEO2dCQUMxRCxPQUFPO1lBQ1I7WUFFQWtuQixVQUFVO2dCQUNULElBQUl3RTtnQkFFSixJQUFLeHRCLFNBQVNzdEIsWUFBWSxFQUFHO29CQUM1QkUsV0FBVzdMLFNBQVM3ZCxHQUFHLENBQUUsSUFBSSxFQUFFNGtCLGdCQUFpQjtvQkFDaEQsSUFBSyxDQUFDOEUsVUFBVzt3QkFDaEIsSUFBSSxDQUFDeE4sbUJBQW1CLENBQUUwSSxjQUFjMkU7d0JBQ3hDMUwsU0FBUzlGLE1BQU0sQ0FBRSxJQUFJLEVBQUU2TTtvQkFDeEIsT0FBTzt3QkFDTi9HLFNBQVNKLEdBQUcsQ0FBRSxJQUFJLEVBQUVtSCxjQUFjOEU7b0JBQ25DO2dCQUNELE9BQU87b0JBRU4sK0RBQStEO29CQUMvRCxPQUFPO2dCQUNSO1lBQ0Q7WUFFQSwwREFBMEQ7WUFDMUQsaUNBQWlDO1lBQ2pDeEgsVUFBVSxTQUFVMkIsS0FBSztnQkFDeEIsT0FBT2hHLFNBQVM3ZCxHQUFHLENBQUU2akIsTUFBTS9oQixNQUFNLEVBQUU5RDtZQUNwQztZQUVBNG1CLGNBQWNBO1FBQ2Y7UUFFQSx3QkFBd0I7UUFDeEIsOENBQThDO1FBQzlDLHVFQUF1RTtRQUN2RSxFQUFFO1FBQ0YsZ0RBQWdEO1FBQ2hELHlEQUF5RDtRQUN6RCxtR0FBbUc7UUFDbkcsZ0ZBQWdGO1FBQ2hGLEVBQUU7UUFDRixzQkFBc0I7UUFDdEIsK0ZBQStGO1FBQy9GLGlEQUFpRDtRQUNqRHRsQixPQUFPdWtCLEtBQUssQ0FBQzNKLE9BQU8sQ0FBRTBLLGFBQWMsR0FBRztZQUN0Q0csT0FBTztnQkFFTiwyREFBMkQ7Z0JBQzNELGlEQUFpRDtnQkFDakQsSUFBSXhtQixNQUFNLElBQUksQ0FBQ29GLGFBQWEsSUFBSSxJQUFJLENBQUN6SCxRQUFRLElBQUksSUFBSSxFQUNwRHl0QixhQUFhenRCLFNBQVNzdEIsWUFBWSxHQUFHLElBQUksR0FBR2pyQixLQUM1Q21yQixXQUFXN0wsU0FBUzdkLEdBQUcsQ0FBRTJwQixZQUFZL0U7Z0JBRXRDLHNCQUFzQjtnQkFDdEIsMkVBQTJFO2dCQUMzRSx3RUFBd0U7Z0JBQ3hFLCtFQUErRTtnQkFDL0UsSUFBSyxDQUFDOEUsVUFBVztvQkFDaEIsSUFBS3h0QixTQUFTc3RCLFlBQVksRUFBRzt3QkFDNUIsSUFBSSxDQUFDeGQsZ0JBQWdCLENBQUU0WSxjQUFjMkU7b0JBQ3RDLE9BQU87d0JBQ05ockIsSUFBSXlOLGdCQUFnQixDQUFFaE8sTUFBTXVyQixvQkFBb0I7b0JBQ2pEO2dCQUNEO2dCQUNBMUwsU0FBU0osR0FBRyxDQUFFa00sWUFBWS9FLGNBQWMsQ0FBRThFLFlBQVksS0FBTTtZQUM3RDtZQUNBeEUsVUFBVTtnQkFDVCxJQUFJM21CLE1BQU0sSUFBSSxDQUFDb0YsYUFBYSxJQUFJLElBQUksQ0FBQ3pILFFBQVEsSUFBSSxJQUFJLEVBQ3BEeXRCLGFBQWF6dEIsU0FBU3N0QixZQUFZLEdBQUcsSUFBSSxHQUFHanJCLEtBQzVDbXJCLFdBQVc3TCxTQUFTN2QsR0FBRyxDQUFFMnBCLFlBQVkvRSxnQkFBaUI7Z0JBRXZELElBQUssQ0FBQzhFLFVBQVc7b0JBQ2hCLElBQUt4dEIsU0FBU3N0QixZQUFZLEVBQUc7d0JBQzVCLElBQUksQ0FBQ3ROLG1CQUFtQixDQUFFMEksY0FBYzJFO29CQUN6QyxPQUFPO3dCQUNOaHJCLElBQUkyZCxtQkFBbUIsQ0FBRWxlLE1BQU11ckIsb0JBQW9CO29CQUNwRDtvQkFDQTFMLFNBQVM5RixNQUFNLENBQUU0UixZQUFZL0U7Z0JBQzlCLE9BQU87b0JBQ04vRyxTQUFTSixHQUFHLENBQUVrTSxZQUFZL0UsY0FBYzhFO2dCQUN6QztZQUNEO1FBQ0Q7SUFDRDtJQUVBLDJFQUEyRTtJQUMzRSw0Q0FBNEM7SUFDNUMsdUVBQXVFO0lBQ3ZFLEVBQUU7SUFDRix5QkFBeUI7SUFDekIsMENBQTBDO0lBQzFDLCtEQUErRDtJQUMvRCxnRkFBZ0Y7SUFDaEZwcUIsT0FBT2lCLElBQUksQ0FBRTtRQUNacXBCLFlBQVk7UUFDWkMsWUFBWTtRQUNaQyxjQUFjO1FBQ2RDLGNBQWM7SUFDZixHQUFHLFNBQVVDLElBQUksRUFBRTFFLEdBQUc7UUFDckJobUIsT0FBT3VrQixLQUFLLENBQUMzSixPQUFPLENBQUU4UCxLQUFNLEdBQUc7WUFDOUJwRixjQUFjVTtZQUNkVCxVQUFVUztZQUVWYixRQUFRLFNBQVVaLEtBQUs7Z0JBQ3RCLElBQUl6akIsS0FDSDBCLFNBQVMsSUFBSSxFQUNibW9CLFVBQVVwRyxNQUFNeUQsYUFBYSxFQUM3Qm5ELFlBQVlOLE1BQU1NLFNBQVM7Z0JBRTVCLDBFQUEwRTtnQkFDMUUsb0VBQW9FO2dCQUNwRSxJQUFLLENBQUM4RixXQUFhQSxZQUFZbm9CLFVBQVUsQ0FBQ3hDLE9BQU95RixRQUFRLENBQUVqRCxRQUFRbW9CLFVBQWM7b0JBQ2hGcEcsTUFBTTdsQixJQUFJLEdBQUdtbUIsVUFBVUcsUUFBUTtvQkFDL0Jsa0IsTUFBTStqQixVQUFVbEssT0FBTyxDQUFDamQsS0FBSyxDQUFFLElBQUksRUFBRTJEO29CQUNyQ2tqQixNQUFNN2xCLElBQUksR0FBR3NuQjtnQkFDZDtnQkFDQSxPQUFPbGxCO1lBQ1I7UUFDRDtJQUNEO0lBRUFkLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUVqQmlpQixJQUFJLFNBQVVDLEtBQUssRUFBRW5rQixRQUFRLEVBQUVtZSxJQUFJLEVBQUVqZSxFQUFFO1lBQ3RDLE9BQU9na0IsR0FBSSxJQUFJLEVBQUVDLE9BQU9ua0IsVUFBVW1lLE1BQU1qZTtRQUN6QztRQUNBa2tCLEtBQUssU0FBVUQsS0FBSyxFQUFFbmtCLFFBQVEsRUFBRW1lLElBQUksRUFBRWplLEVBQUU7WUFDdkMsT0FBT2drQixHQUFJLElBQUksRUFBRUMsT0FBT25rQixVQUFVbWUsTUFBTWplLElBQUk7UUFDN0M7UUFDQXFrQixLQUFLLFNBQVVKLEtBQUssRUFBRW5rQixRQUFRLEVBQUVFLEVBQUU7WUFDakMsSUFBSTBrQixXQUFXbm1CO1lBQ2YsSUFBSzBsQixTQUFTQSxNQUFNbUMsY0FBYyxJQUFJbkMsTUFBTVMsU0FBUyxFQUFHO2dCQUV2RCxxQ0FBcUM7Z0JBQ3JDQSxZQUFZVCxNQUFNUyxTQUFTO2dCQUMzQjdrQixPQUFRb2tCLE1BQU02QixjQUFjLEVBQUd6QixHQUFHLENBQ2pDSyxVQUFVM2dCLFNBQVMsR0FDbEIyZ0IsVUFBVUcsUUFBUSxHQUFHLE1BQU1ILFVBQVUzZ0IsU0FBUyxHQUM5QzJnQixVQUFVRyxRQUFRLEVBQ25CSCxVQUFVNWtCLFFBQVEsRUFDbEI0a0IsVUFBVWxLLE9BQU87Z0JBRWxCLE9BQU8sSUFBSTtZQUNaO1lBQ0EsSUFBSyxPQUFPeUosVUFBVSxVQUFXO2dCQUVoQyxnQ0FBZ0M7Z0JBQ2hDLElBQU0xbEIsUUFBUTBsQixNQUFRO29CQUNyQixJQUFJLENBQUNJLEdBQUcsQ0FBRTlsQixNQUFNdUIsVUFBVW1rQixLQUFLLENBQUUxbEIsS0FBTTtnQkFDeEM7Z0JBQ0EsT0FBTyxJQUFJO1lBQ1o7WUFDQSxJQUFLdUIsYUFBYSxTQUFTLE9BQU9BLGFBQWEsWUFBYTtnQkFFM0QsbUJBQW1CO2dCQUNuQkUsS0FBS0Y7Z0JBQ0xBLFdBQVc0QztZQUNaO1lBQ0EsSUFBSzFDLE9BQU8sT0FBUTtnQkFDbkJBLEtBQUsrakI7WUFDTjtZQUNBLE9BQU8sSUFBSSxDQUFDampCLElBQUksQ0FBRTtnQkFDakJqQixPQUFPdWtCLEtBQUssQ0FBQzlMLE1BQU0sQ0FBRSxJQUFJLEVBQUUyTCxPQUFPamtCLElBQUlGO1lBQ3ZDO1FBQ0Q7SUFDRDtJQUdBLElBRUMsMkNBQTJDO0lBQzNDLDhEQUE4RDtJQUM5RCxpRUFBaUU7SUFDakUycUIsZUFBZSx5QkFFZiwrQkFBK0I7SUFDL0JDLFdBQVcscUNBRVhDLGVBQWU7SUFFaEIsK0RBQStEO0lBQy9ELFNBQVNDLG1CQUFvQjNwQixJQUFJLEVBQUVtVyxPQUFPO1FBQ3pDLElBQUtoVCxTQUFVbkQsTUFBTSxZQUNwQm1ELFNBQVVnVCxRQUFRalosUUFBUSxLQUFLLEtBQUtpWixVQUFVQSxRQUFROUgsVUFBVSxFQUFFLE9BQVM7WUFFM0UsT0FBT3pQLE9BQVFvQixNQUFPaVYsUUFBUSxDQUFFLFFBQVMsQ0FBRSxFQUFHLElBQUlqVjtRQUNuRDtRQUVBLE9BQU9BO0lBQ1I7SUFFQSxrRkFBa0Y7SUFDbEYsU0FBUzRwQixjQUFlNXBCLElBQUk7UUFDM0JBLEtBQUsxQyxJQUFJLEdBQUcsQ0FBRTBDLEtBQUs3QixZQUFZLENBQUUsWUFBYSxJQUFHLElBQU0sTUFBTTZCLEtBQUsxQyxJQUFJO1FBQ3RFLE9BQU8wQztJQUNSO0lBQ0EsU0FBUzZwQixjQUFlN3BCLElBQUk7UUFDM0IsSUFBSyxDQUFFQSxLQUFLMUMsSUFBSSxJQUFJLEVBQUMsRUFBSXJCLEtBQUssQ0FBRSxHQUFHLE9BQVEsU0FBVTtZQUNwRCtELEtBQUsxQyxJQUFJLEdBQUcwQyxLQUFLMUMsSUFBSSxDQUFDckIsS0FBSyxDQUFFO1FBQzlCLE9BQU87WUFDTitELEtBQUtnSyxlQUFlLENBQUU7UUFDdkI7UUFFQSxPQUFPaEs7SUFDUjtJQUVBLFNBQVM4cEIsZUFBZ0J2c0IsR0FBRyxFQUFFd3NCLElBQUk7UUFDakMsSUFBSWpzQixHQUFHdVgsR0FBRy9YLE1BQU0wc0IsVUFBVUMsVUFBVUMsVUFBVTNHO1FBRTlDLElBQUt3RyxLQUFLN3NCLFFBQVEsS0FBSyxHQUFJO1lBQzFCO1FBQ0Q7UUFFQSwrQ0FBK0M7UUFDL0MsSUFBS2lnQixTQUFTRCxPQUFPLENBQUUzZixNQUFRO1lBQzlCeXNCLFdBQVc3TSxTQUFTN2QsR0FBRyxDQUFFL0I7WUFDekJnbUIsU0FBU3lHLFNBQVN6RyxNQUFNO1lBRXhCLElBQUtBLFFBQVM7Z0JBQ2JwRyxTQUFTOUYsTUFBTSxDQUFFMFMsTUFBTTtnQkFFdkIsSUFBTXpzQixRQUFRaW1CLE9BQVM7b0JBQ3RCLElBQU16bEIsSUFBSSxHQUFHdVgsSUFBSWtPLE1BQU0sQ0FBRWptQixLQUFNLENBQUM4QixNQUFNLEVBQUV0QixJQUFJdVgsR0FBR3ZYLElBQU07d0JBQ3BEYyxPQUFPdWtCLEtBQUssQ0FBQ3pOLEdBQUcsQ0FBRXFVLE1BQU16c0IsTUFBTWltQixNQUFNLENBQUVqbUIsS0FBTSxDQUFFUSxFQUFHO29CQUNsRDtnQkFDRDtZQUNEO1FBQ0Q7UUFFQSxvQkFBb0I7UUFDcEIsSUFBS3NmLFNBQVNGLE9BQU8sQ0FBRTNmLE1BQVE7WUFDOUIwc0IsV0FBVzdNLFNBQVN6QixNQUFNLENBQUVwZTtZQUM1QjJzQixXQUFXdHJCLE9BQU9rQyxNQUFNLENBQUUsQ0FBQyxHQUFHbXBCO1lBRTlCN00sU0FBU0wsR0FBRyxDQUFFZ04sTUFBTUc7UUFDckI7SUFDRDtJQUVBLGlDQUFpQztJQUNqQyxTQUFTQyxTQUFVNXNCLEdBQUcsRUFBRXdzQixJQUFJO1FBQzNCLElBQUk1bUIsV0FBVzRtQixLQUFLNW1CLFFBQVEsQ0FBQ2EsV0FBVztRQUV4QywyRUFBMkU7UUFDM0UsSUFBS2IsYUFBYSxXQUFXcWQsZUFBZXRkLElBQUksQ0FBRTNGLElBQUlELElBQUksR0FBSztZQUM5RHlzQixLQUFLcGEsT0FBTyxHQUFHcFMsSUFBSW9TLE9BQU87UUFFM0IseUZBQXlGO1FBQ3pGLE9BQU8sSUFBS3hNLGFBQWEsV0FBV0EsYUFBYSxZQUFhO1lBQzdENG1CLEtBQUs5SSxZQUFZLEdBQUcxakIsSUFBSTBqQixZQUFZO1FBQ3JDO0lBQ0Q7SUFFQSxTQUFTbUosU0FBVUMsVUFBVSxFQUFFN2IsSUFBSSxFQUFFMU8sUUFBUSxFQUFFd2lCLE9BQU87UUFFckQsNEJBQTRCO1FBQzVCOVQsT0FBT3RTLEtBQU1zUztRQUViLElBQUltUyxVQUFVemdCLE9BQU9raUIsU0FBU2tJLFlBQVkxc0IsTUFBTUMsS0FDL0NDLElBQUksR0FDSnVYLElBQUlnVixXQUFXanJCLE1BQU0sRUFDckJtckIsV0FBV2xWLElBQUksR0FDZjNSLFFBQVE4SyxJQUFJLENBQUUsRUFBRyxFQUNqQmdjLGtCQUFrQnh0QixXQUFZMEc7UUFFL0IsK0RBQStEO1FBQy9ELElBQUs4bUIsbUJBQ0RuVixJQUFJLEtBQUssT0FBTzNSLFVBQVUsWUFDM0IsQ0FBQzNHLFFBQVErakIsVUFBVSxJQUFJMkksU0FBU3ZtQixJQUFJLENBQUVRLFFBQVk7WUFDcEQsT0FBTzJtQixXQUFXeHFCLElBQUksQ0FBRSxTQUFVMlYsS0FBSztnQkFDdEMsSUFBSWIsT0FBTzBWLFdBQVdscUIsRUFBRSxDQUFFcVY7Z0JBQzFCLElBQUtnVixpQkFBa0I7b0JBQ3RCaGMsSUFBSSxDQUFFLEVBQUcsR0FBRzlLLE1BQU10SCxJQUFJLENBQUUsSUFBSSxFQUFFb1osT0FBT2IsS0FBSzhWLElBQUk7Z0JBQy9DO2dCQUNBTCxTQUFVelYsTUFBTW5HLE1BQU0xTyxVQUFVd2lCO1lBQ2pDO1FBQ0Q7UUFFQSxJQUFLak4sR0FBSTtZQUNSc0wsV0FBV3dCLGNBQWUzVCxNQUFNNmIsVUFBVSxDQUFFLEVBQUcsQ0FBQ3BuQixhQUFhLEVBQUUsT0FBT29uQixZQUFZL0g7WUFDbEZwaUIsUUFBUXlnQixTQUFTdFMsVUFBVTtZQUUzQixJQUFLc1MsU0FBU2xZLFVBQVUsQ0FBQ3JKLE1BQU0sS0FBSyxHQUFJO2dCQUN2Q3VoQixXQUFXemdCO1lBQ1o7WUFFQSx1RkFBdUY7WUFDdkYsSUFBS0EsU0FBU29pQixTQUFVO2dCQUN2QkYsVUFBVXhqQixPQUFPbUIsR0FBRyxDQUFFZ2lCLE9BQVFwQixVQUFVLFdBQVlpSjtnQkFDcERVLGFBQWFsSSxRQUFRaGpCLE1BQU07Z0JBRTNCLDhDQUE4QztnQkFDOUMsNkNBQTZDO2dCQUM3QywrREFBK0Q7Z0JBQy9ELE1BQVF0QixJQUFJdVgsR0FBR3ZYLElBQU07b0JBQ3BCRixPQUFPK2lCO29CQUVQLElBQUs3aUIsTUFBTXlzQixVQUFXO3dCQUNyQjNzQixPQUFPZ0IsT0FBT3VDLEtBQUssQ0FBRXZELE1BQU0sTUFBTTt3QkFFakMsMERBQTBEO3dCQUMxRCxJQUFLMHNCLFlBQWE7NEJBRWpCLGdEQUFnRDs0QkFDaEQsb0RBQW9EOzRCQUNwRDFyQixPQUFPZSxLQUFLLENBQUV5aUIsU0FBU0wsT0FBUW5rQixNQUFNO3dCQUN0QztvQkFDRDtvQkFFQWtDLFNBQVMxRCxJQUFJLENBQUVpdUIsVUFBVSxDQUFFdnNCLEVBQUcsRUFBRUYsTUFBTUU7Z0JBQ3ZDO2dCQUVBLElBQUt3c0IsWUFBYTtvQkFDakJ6c0IsTUFBTXVrQixPQUFPLENBQUVBLFFBQVFoakIsTUFBTSxHQUFHLEVBQUcsQ0FBQzZELGFBQWE7b0JBRWpELG9CQUFvQjtvQkFDcEJyRSxPQUFPbUIsR0FBRyxDQUFFcWlCLFNBQVN5SDtvQkFFckIsMERBQTBEO29CQUMxRCxJQUFNL3JCLElBQUksR0FBR0EsSUFBSXdzQixZQUFZeHNCLElBQU07d0JBQ2xDRixPQUFPd2tCLE9BQU8sQ0FBRXRrQixFQUFHO3dCQUNuQixJQUFLNGlCLFlBQVl4ZCxJQUFJLENBQUV0RixLQUFLTixJQUFJLElBQUksT0FDbkMsQ0FBQzZmLFNBQVN4QixNQUFNLENBQUUvZCxNQUFNLGlCQUN4QmdCLE9BQU95RixRQUFRLENBQUV4RyxLQUFLRCxPQUFTOzRCQUUvQixJQUFLQSxLQUFLTCxHQUFHLElBQUksQ0FBRUssS0FBS04sSUFBSSxJQUFJLEVBQUMsRUFBSTBHLFdBQVcsT0FBUSxVQUFXO2dDQUVsRSxpRUFBaUU7Z0NBQ2pFLElBQUtwRixPQUFPOHJCLFFBQVEsSUFBSSxDQUFDOXNCLEtBQUtILFFBQVEsRUFBRztvQ0FDeENtQixPQUFPOHJCLFFBQVEsQ0FBRTlzQixLQUFLTCxHQUFHLEVBQUU7d0NBQzFCQyxPQUFPSSxLQUFLSixLQUFLLElBQUlJLEtBQUtPLFlBQVksQ0FBRTtvQ0FDekMsR0FBR047Z0NBQ0o7NEJBQ0QsT0FBTztnQ0FFTix1RUFBdUU7Z0NBQ3ZFLDhEQUE4RDtnQ0FDOUQsaUVBQWlFO2dDQUNqRSx1RUFBdUU7Z0NBQ3ZFLHVEQUF1RDtnQ0FDdkRILFFBQVNFLEtBQUsyRSxXQUFXLENBQUNWLE9BQU8sQ0FBRTZuQixjQUFjLEtBQU05ckIsTUFBTUM7NEJBQzlEO3dCQUNEO29CQUNEO2dCQUNEO1lBQ0Q7UUFDRDtRQUVBLE9BQU93c0I7SUFDUjtJQUVBLFNBQVNoVCxPQUFRclgsSUFBSSxFQUFFbkIsUUFBUSxFQUFFOHJCLFFBQVE7UUFDeEMsSUFBSS9zQixNQUNINmtCLFFBQVE1akIsV0FBV0QsT0FBT2dOLE1BQU0sQ0FBRS9NLFVBQVVtQixRQUFTQSxNQUNyRGxDLElBQUk7UUFFTCxNQUFRLENBQUVGLE9BQU82a0IsS0FBSyxDQUFFM2tCLEVBQUcsS0FBTSxNQUFNQSxJQUFNO1lBQzVDLElBQUssQ0FBQzZzQixZQUFZL3NCLEtBQUtWLFFBQVEsS0FBSyxHQUFJO2dCQUN2QzBCLE9BQU9nc0IsU0FBUyxDQUFFN0ksT0FBUW5rQjtZQUMzQjtZQUVBLElBQUtBLEtBQUtXLFVBQVUsRUFBRztnQkFDdEIsSUFBS29zQixZQUFZN0wsV0FBWWxoQixPQUFTO29CQUNyQ29rQixjQUFlRCxPQUFRbmtCLE1BQU07Z0JBQzlCO2dCQUNBQSxLQUFLVyxVQUFVLENBQUNDLFdBQVcsQ0FBRVo7WUFDOUI7UUFDRDtRQUVBLE9BQU9vQztJQUNSO0lBRUFwQixPQUFPa0MsTUFBTSxDQUFFO1FBQ2Q2aEIsZUFBZSxTQUFVOEgsSUFBSTtZQUM1QixPQUFPQTtRQUNSO1FBRUF0cEIsT0FBTyxTQUFVbkIsSUFBSSxFQUFFNnFCLGFBQWEsRUFBRUMsaUJBQWlCO1lBQ3RELElBQUlodEIsR0FBR3VYLEdBQUcwVixhQUFhQyxjQUN0QjdwQixRQUFRbkIsS0FBSytnQixTQUFTLENBQUUsT0FDeEJrSyxTQUFTbk0sV0FBWTllO1lBRXRCLHdCQUF3QjtZQUN4QixJQUFLLENBQUNqRCxRQUFRaWtCLGNBQWMsSUFBTWhoQixDQUFBQSxLQUFLOUMsUUFBUSxLQUFLLEtBQUs4QyxLQUFLOUMsUUFBUSxLQUFLLEVBQUMsS0FDMUUsQ0FBQzBCLE9BQU9pRSxRQUFRLENBQUU3QyxPQUFTO2dCQUU1QixzREFBc0Q7Z0JBQ3RELHdDQUF3QztnQkFDeENnckIsZUFBZWpKLE9BQVE1Z0I7Z0JBQ3ZCNHBCLGNBQWNoSixPQUFRL2hCO2dCQUV0QixJQUFNbEMsSUFBSSxHQUFHdVgsSUFBSTBWLFlBQVkzckIsTUFBTSxFQUFFdEIsSUFBSXVYLEdBQUd2WCxJQUFNO29CQUNqRHFzQixTQUFVWSxXQUFXLENBQUVqdEIsRUFBRyxFQUFFa3RCLFlBQVksQ0FBRWx0QixFQUFHO2dCQUM5QztZQUNEO1lBRUEsaURBQWlEO1lBQ2pELElBQUsrc0IsZUFBZ0I7Z0JBQ3BCLElBQUtDLG1CQUFvQjtvQkFDeEJDLGNBQWNBLGVBQWVoSixPQUFRL2hCO29CQUNyQ2dyQixlQUFlQSxnQkFBZ0JqSixPQUFRNWdCO29CQUV2QyxJQUFNckQsSUFBSSxHQUFHdVgsSUFBSTBWLFlBQVkzckIsTUFBTSxFQUFFdEIsSUFBSXVYLEdBQUd2WCxJQUFNO3dCQUNqRGdzQixlQUFnQmlCLFdBQVcsQ0FBRWp0QixFQUFHLEVBQUVrdEIsWUFBWSxDQUFFbHRCLEVBQUc7b0JBQ3BEO2dCQUNELE9BQU87b0JBQ05nc0IsZUFBZ0I5cEIsTUFBTW1CO2dCQUN2QjtZQUNEO1lBRUEscUNBQXFDO1lBQ3JDNnBCLGVBQWVqSixPQUFRNWdCLE9BQU87WUFDOUIsSUFBSzZwQixhQUFhNXJCLE1BQU0sR0FBRyxHQUFJO2dCQUM5QjRpQixjQUFlZ0osY0FBYyxDQUFDQyxVQUFVbEosT0FBUS9oQixNQUFNO1lBQ3ZEO1lBRUEsd0JBQXdCO1lBQ3hCLE9BQU9tQjtRQUNSO1FBRUF5cEIsV0FBVyxTQUFVbnJCLEtBQUs7WUFDekIsSUFBSXVkLE1BQU1oZCxNQUFNMUMsTUFDZmtjLFVBQVU1YSxPQUFPdWtCLEtBQUssQ0FBQzNKLE9BQU8sRUFDOUIxYixJQUFJO1lBRUwsTUFBUSxDQUFFa0MsT0FBT1AsS0FBSyxDQUFFM0IsRUFBRyxNQUFPMkQsV0FBVzNELElBQU07Z0JBQ2xELElBQUsyZSxXQUFZemMsT0FBUztvQkFDekIsSUFBT2dkLE9BQU9oZCxJQUFJLENBQUVtZCxTQUFTemIsT0FBTyxDQUFFLEVBQUs7d0JBQzFDLElBQUtzYixLQUFLdUcsTUFBTSxFQUFHOzRCQUNsQixJQUFNam1CLFFBQVEwZixLQUFLdUcsTUFBTSxDQUFHO2dDQUMzQixJQUFLL0osT0FBTyxDQUFFbGMsS0FBTSxFQUFHO29DQUN0QnNCLE9BQU91a0IsS0FBSyxDQUFDOUwsTUFBTSxDQUFFclgsTUFBTTFDO2dDQUU1Qiw2REFBNkQ7Z0NBQzdELE9BQU87b0NBQ05zQixPQUFPNmxCLFdBQVcsQ0FBRXprQixNQUFNMUMsTUFBTTBmLEtBQUsrRyxNQUFNO2dDQUM1Qzs0QkFDRDt3QkFDRDt3QkFFQSw2QkFBNkI7d0JBQzdCLDREQUE0RDt3QkFDNUQvakIsSUFBSSxDQUFFbWQsU0FBU3piLE9BQU8sQ0FBRSxHQUFHRDtvQkFDNUI7b0JBQ0EsSUFBS3pCLElBQUksQ0FBRW9kLFNBQVMxYixPQUFPLENBQUUsRUFBRzt3QkFFL0IsNkJBQTZCO3dCQUM3Qiw0REFBNEQ7d0JBQzVEMUIsSUFBSSxDQUFFb2QsU0FBUzFiLE9BQU8sQ0FBRSxHQUFHRDtvQkFDNUI7Z0JBQ0Q7WUFDRDtRQUNEO0lBQ0Q7SUFFQTdDLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQm9xQixRQUFRLFNBQVVyc0IsUUFBUTtZQUN6QixPQUFPd1ksT0FBUSxJQUFJLEVBQUV4WSxVQUFVO1FBQ2hDO1FBRUF3WSxRQUFRLFNBQVV4WSxRQUFRO1lBQ3pCLE9BQU93WSxPQUFRLElBQUksRUFBRXhZO1FBQ3RCO1FBRUFYLE1BQU0sU0FBVXdGLEtBQUs7WUFDcEIsT0FBT2lZLE9BQVEsSUFBSSxFQUFFLFNBQVVqWSxLQUFLO2dCQUNuQyxPQUFPQSxVQUFVakMsWUFDaEI3QyxPQUFPVixJQUFJLENBQUUsSUFBSSxJQUNqQixJQUFJLENBQUM0UixLQUFLLEdBQUdqUSxJQUFJLENBQUU7b0JBQ2xCLElBQUssSUFBSSxDQUFDM0MsUUFBUSxLQUFLLEtBQUssSUFBSSxDQUFDQSxRQUFRLEtBQUssTUFBTSxJQUFJLENBQUNBLFFBQVEsS0FBSyxHQUFJO3dCQUN6RSxJQUFJLENBQUNxRixXQUFXLEdBQUdtQjtvQkFDcEI7Z0JBQ0Q7WUFDRixHQUFHLE1BQU1BLE9BQU96RCxVQUFVYixNQUFNO1FBQ2pDO1FBRUErckIsUUFBUTtZQUNQLE9BQU9mLFNBQVUsSUFBSSxFQUFFbnFCLFdBQVcsU0FBVUQsSUFBSTtnQkFDL0MsSUFBSyxJQUFJLENBQUM5QyxRQUFRLEtBQUssS0FBSyxJQUFJLENBQUNBLFFBQVEsS0FBSyxNQUFNLElBQUksQ0FBQ0EsUUFBUSxLQUFLLEdBQUk7b0JBQ3pFLElBQUlrRSxTQUFTdW9CLG1CQUFvQixJQUFJLEVBQUUzcEI7b0JBQ3ZDb0IsT0FBTzlDLFdBQVcsQ0FBRTBCO2dCQUNyQjtZQUNEO1FBQ0Q7UUFFQW9yQixTQUFTO1lBQ1IsT0FBT2hCLFNBQVUsSUFBSSxFQUFFbnFCLFdBQVcsU0FBVUQsSUFBSTtnQkFDL0MsSUFBSyxJQUFJLENBQUM5QyxRQUFRLEtBQUssS0FBSyxJQUFJLENBQUNBLFFBQVEsS0FBSyxNQUFNLElBQUksQ0FBQ0EsUUFBUSxLQUFLLEdBQUk7b0JBQ3pFLElBQUlrRSxTQUFTdW9CLG1CQUFvQixJQUFJLEVBQUUzcEI7b0JBQ3ZDb0IsT0FBT2lxQixZQUFZLENBQUVyckIsTUFBTW9CLE9BQU9pTixVQUFVO2dCQUM3QztZQUNEO1FBQ0Q7UUFFQWlkLFFBQVE7WUFDUCxPQUFPbEIsU0FBVSxJQUFJLEVBQUVucUIsV0FBVyxTQUFVRCxJQUFJO2dCQUMvQyxJQUFLLElBQUksQ0FBQ3pCLFVBQVUsRUFBRztvQkFDdEIsSUFBSSxDQUFDQSxVQUFVLENBQUM4c0IsWUFBWSxDQUFFcnJCLE1BQU0sSUFBSTtnQkFDekM7WUFDRDtRQUNEO1FBRUF1ckIsT0FBTztZQUNOLE9BQU9uQixTQUFVLElBQUksRUFBRW5xQixXQUFXLFNBQVVELElBQUk7Z0JBQy9DLElBQUssSUFBSSxDQUFDekIsVUFBVSxFQUFHO29CQUN0QixJQUFJLENBQUNBLFVBQVUsQ0FBQzhzQixZQUFZLENBQUVyckIsTUFBTSxJQUFJLENBQUMrUCxXQUFXO2dCQUNyRDtZQUNEO1FBQ0Q7UUFFQUQsT0FBTztZQUNOLElBQUk5UCxNQUNIbEMsSUFBSTtZQUVMLE1BQVEsQ0FBRWtDLE9BQU8sSUFBSSxDQUFFbEMsRUFBRyxLQUFNLE1BQU1BLElBQU07Z0JBQzNDLElBQUtrQyxLQUFLOUMsUUFBUSxLQUFLLEdBQUk7b0JBRTFCLHVCQUF1QjtvQkFDdkIwQixPQUFPZ3NCLFNBQVMsQ0FBRTdJLE9BQVEvaEIsTUFBTTtvQkFFaEMsNkJBQTZCO29CQUM3QkEsS0FBS3VDLFdBQVcsR0FBRztnQkFDcEI7WUFDRDtZQUVBLE9BQU8sSUFBSTtRQUNaO1FBRUFwQixPQUFPLFNBQVUwcEIsYUFBYSxFQUFFQyxpQkFBaUI7WUFDaERELGdCQUFnQkEsaUJBQWlCLE9BQU8sUUFBUUE7WUFDaERDLG9CQUFvQkEscUJBQXFCLE9BQU9ELGdCQUFnQkM7WUFFaEUsT0FBTyxJQUFJLENBQUMvcUIsR0FBRyxDQUFFO2dCQUNoQixPQUFPbkIsT0FBT3VDLEtBQUssQ0FBRSxJQUFJLEVBQUUwcEIsZUFBZUM7WUFDM0M7UUFDRDtRQUVBTCxNQUFNLFNBQVUvbUIsS0FBSztZQUNwQixPQUFPaVksT0FBUSxJQUFJLEVBQUUsU0FBVWpZLEtBQUs7Z0JBQ25DLElBQUkxRCxPQUFPLElBQUksQ0FBRSxFQUFHLElBQUksQ0FBQyxHQUN4QmxDLElBQUksR0FDSnVYLElBQUksSUFBSSxDQUFDalcsTUFBTTtnQkFFaEIsSUFBS3NFLFVBQVVqQyxhQUFhekIsS0FBSzlDLFFBQVEsS0FBSyxHQUFJO29CQUNqRCxPQUFPOEMsS0FBS2tNLFNBQVM7Z0JBQ3RCO2dCQUVBLHVEQUF1RDtnQkFDdkQsSUFBSyxPQUFPeEksVUFBVSxZQUFZLENBQUM4bEIsYUFBYXRtQixJQUFJLENBQUVRLFVBQ3JELENBQUN5ZCxPQUFPLENBQUUsQ0FBRVYsU0FBU3JYLElBQUksQ0FBRTFGLFVBQVc7b0JBQUU7b0JBQUk7aUJBQUksQ0FBRSxDQUFFLEVBQUcsQ0FBQ00sV0FBVyxHQUFJLEVBQUc7b0JBRTFFTixRQUFROUUsT0FBTytqQixhQUFhLENBQUVqZjtvQkFFOUIsSUFBSTt3QkFDSCxNQUFRNUYsSUFBSXVYLEdBQUd2WCxJQUFNOzRCQUNwQmtDLE9BQU8sSUFBSSxDQUFFbEMsRUFBRyxJQUFJLENBQUM7NEJBRXJCLGdEQUFnRDs0QkFDaEQsSUFBS2tDLEtBQUs5QyxRQUFRLEtBQUssR0FBSTtnQ0FDMUIwQixPQUFPZ3NCLFNBQVMsQ0FBRTdJLE9BQVEvaEIsTUFBTTtnQ0FDaENBLEtBQUtrTSxTQUFTLEdBQUd4STs0QkFDbEI7d0JBQ0Q7d0JBRUExRCxPQUFPO29CQUVSLGtFQUFrRTtvQkFDbEUsRUFBRSxPQUFRMEksR0FBSSxDQUFDO2dCQUNoQjtnQkFFQSxJQUFLMUksTUFBTztvQkFDWCxJQUFJLENBQUM4UCxLQUFLLEdBQUdxYixNQUFNLENBQUV6bkI7Z0JBQ3RCO1lBQ0QsR0FBRyxNQUFNQSxPQUFPekQsVUFBVWIsTUFBTTtRQUNqQztRQUVBb3NCLGFBQWE7WUFDWixJQUFJbEosVUFBVSxFQUFFO1lBRWhCLG9GQUFvRjtZQUNwRixPQUFPOEgsU0FBVSxJQUFJLEVBQUVucUIsV0FBVyxTQUFVRCxJQUFJO2dCQUMvQyxJQUFJa08sU0FBUyxJQUFJLENBQUMzUCxVQUFVO2dCQUU1QixJQUFLSyxPQUFPZ0UsT0FBTyxDQUFFLElBQUksRUFBRTBmLFdBQVksR0FBSTtvQkFDMUMxakIsT0FBT2dzQixTQUFTLENBQUU3SSxPQUFRLElBQUk7b0JBQzlCLElBQUs3VCxRQUFTO3dCQUNiQSxPQUFPdWQsWUFBWSxDQUFFenJCLE1BQU0sSUFBSTtvQkFDaEM7Z0JBQ0Q7WUFFRCw0QkFBNEI7WUFDNUIsR0FBR3NpQjtRQUNKO0lBQ0Q7SUFFQTFqQixPQUFPaUIsSUFBSSxDQUFFO1FBQ1o2ckIsVUFBVTtRQUNWQyxXQUFXO1FBQ1hOLGNBQWM7UUFDZE8sYUFBYTtRQUNiQyxZQUFZO0lBQ2IsR0FBRyxTQUFVN3FCLElBQUksRUFBRThxQixRQUFRO1FBQzFCbHRCLE9BQU9HLEVBQUUsQ0FBRWlDLEtBQU0sR0FBRyxTQUFVbkMsUUFBUTtZQUNyQyxJQUFJWSxPQUNIQyxNQUFNLEVBQUUsRUFDUnFzQixTQUFTbnRCLE9BQVFDLFdBQ2pCdUIsT0FBTzJyQixPQUFPM3NCLE1BQU0sR0FBRyxHQUN2QnRCLElBQUk7WUFFTCxNQUFRQSxLQUFLc0MsTUFBTXRDLElBQU07Z0JBQ3hCMkIsUUFBUTNCLE1BQU1zQyxPQUFPLElBQUksR0FBRyxJQUFJLENBQUNlLEtBQUssQ0FBRTtnQkFDeEN2QyxPQUFRbXRCLE1BQU0sQ0FBRWp1QixFQUFHLENBQUUsQ0FBRWd1QixTQUFVLENBQUVyc0I7Z0JBRW5DLGdEQUFnRDtnQkFDaEQsbUVBQW1FO2dCQUNuRWxELEtBQUtELEtBQUssQ0FBRW9ELEtBQUtELE1BQU1ILEdBQUc7WUFDM0I7WUFFQSxPQUFPLElBQUksQ0FBQ0UsU0FBUyxDQUFFRTtRQUN4QjtJQUNEO0lBQ0EsSUFBSXNzQixZQUFZLElBQUk1bkIsT0FBUSxPQUFPc2EsT0FBTyxtQkFBbUI7SUFFN0QsSUFBSXVOLGNBQWM7SUFHbEIsSUFBSUMsWUFBWSxTQUFVbHNCLElBQUk7UUFFNUIsK0RBQStEO1FBQy9ELDBDQUEwQztRQUMxQywrRUFBK0U7UUFDL0UsSUFBSTRuQixPQUFPNW5CLEtBQUtpRCxhQUFhLENBQUNtSSxXQUFXO1FBRXpDLElBQUssQ0FBQ3djLFFBQVEsQ0FBQ0EsS0FBS3VFLE1BQU0sRUFBRztZQUM1QnZFLE9BQU9qc0I7UUFDUjtRQUVBLE9BQU9pc0IsS0FBS3dFLGdCQUFnQixDQUFFcHNCO0lBQy9CO0lBRUQsSUFBSXFzQixPQUFPLFNBQVVyc0IsSUFBSSxFQUFFZSxPQUFPLEVBQUVqQixRQUFRO1FBQzNDLElBQUlKLEtBQUtzQixNQUNSc3JCLE1BQU0sQ0FBQztRQUVSLG1EQUFtRDtRQUNuRCxJQUFNdHJCLFFBQVFELFFBQVU7WUFDdkJ1ckIsR0FBRyxDQUFFdHJCLEtBQU0sR0FBR2hCLEtBQUtrZixLQUFLLENBQUVsZSxLQUFNO1lBQ2hDaEIsS0FBS2tmLEtBQUssQ0FBRWxlLEtBQU0sR0FBR0QsT0FBTyxDQUFFQyxLQUFNO1FBQ3JDO1FBRUF0QixNQUFNSSxTQUFTMUQsSUFBSSxDQUFFNEQ7UUFFckIsd0JBQXdCO1FBQ3hCLElBQU1nQixRQUFRRCxRQUFVO1lBQ3ZCZixLQUFLa2YsS0FBSyxDQUFFbGUsS0FBTSxHQUFHc3JCLEdBQUcsQ0FBRXRyQixLQUFNO1FBQ2pDO1FBRUEsT0FBT3RCO0lBQ1I7SUFHQSxJQUFJNnNCLFlBQVksSUFBSW5vQixPQUFReWEsVUFBVWhWLElBQUksQ0FBRSxNQUFPO0lBSWpEO1FBRUQsaUZBQWlGO1FBQ2pGLHVFQUF1RTtRQUN2RSxTQUFTMmlCO1lBRVIsdURBQXVEO1lBQ3ZELElBQUssQ0FBQzNMLEtBQU07Z0JBQ1g7WUFDRDtZQUVBNEwsVUFBVXZOLEtBQUssQ0FBQ3dOLE9BQU8sR0FBRyxnREFDekI7WUFDRDdMLElBQUkzQixLQUFLLENBQUN3TixPQUFPLEdBQ2hCLDJFQUNBLHdDQUNBO1lBQ0RscUIsZ0JBQWdCbEUsV0FBVyxDQUFFbXVCLFdBQVludUIsV0FBVyxDQUFFdWlCO1lBRXRELElBQUk4TCxXQUFXaHhCLFFBQU95d0IsZ0JBQWdCLENBQUV2TDtZQUN4QytMLG1CQUFtQkQsU0FBU3RoQixHQUFHLEtBQUs7WUFFcEMsb0RBQW9EO1lBQ3BEd2hCLHdCQUF3QkMsbUJBQW9CSCxTQUFTSSxVQUFVLE1BQU87WUFFdEUsd0VBQXdFO1lBQ3hFLDJFQUEyRTtZQUMzRWxNLElBQUkzQixLQUFLLENBQUM4TixLQUFLLEdBQUc7WUFDbEJDLG9CQUFvQkgsbUJBQW9CSCxTQUFTSyxLQUFLLE1BQU87WUFFN0QsMEJBQTBCO1lBQzFCLCtFQUErRTtZQUMvRUUsdUJBQXVCSixtQkFBb0JILFNBQVNRLEtBQUssTUFBTztZQUVoRSxxQkFBcUI7WUFDckIsOENBQThDO1lBQzlDLHVCQUF1QjtZQUN2Qiw0REFBNEQ7WUFDNUR0TSxJQUFJM0IsS0FBSyxDQUFDa08sUUFBUSxHQUFHO1lBQ3JCQyxtQkFBbUJQLG1CQUFvQmpNLElBQUl5TSxXQUFXLEdBQUcsT0FBUTtZQUVqRTlxQixnQkFBZ0JoRSxXQUFXLENBQUVpdUI7WUFFN0IsNkRBQTZEO1lBQzdELHVEQUF1RDtZQUN2RDVMLE1BQU07UUFDUDtRQUVBLFNBQVNpTSxtQkFBb0JTLE9BQU87WUFDbkMsT0FBTzVyQixLQUFLNnJCLEtBQUssQ0FBRUMsV0FBWUY7UUFDaEM7UUFFQSxJQUFJWCxrQkFBa0JNLHNCQUFzQkcsa0JBQWtCSixtQkFDN0RTLHlCQUF5QmIsdUJBQ3pCSixZQUFZanhCLFNBQVN5QyxhQUFhLENBQUUsUUFDcEM0aUIsTUFBTXJsQixTQUFTeUMsYUFBYSxDQUFFO1FBRS9CLHFEQUFxRDtRQUNyRCxJQUFLLENBQUM0aUIsSUFBSTNCLEtBQUssRUFBRztZQUNqQjtRQUNEO1FBRUEsNEJBQTRCO1FBQzVCLG9FQUFvRTtRQUNwRTJCLElBQUkzQixLQUFLLENBQUN5TyxjQUFjLEdBQUc7UUFDM0I5TSxJQUFJRSxTQUFTLENBQUUsTUFBTzdCLEtBQUssQ0FBQ3lPLGNBQWMsR0FBRztRQUM3QzV3QixRQUFRNndCLGVBQWUsR0FBRy9NLElBQUkzQixLQUFLLENBQUN5TyxjQUFjLEtBQUs7UUFFdkQvdUIsT0FBT2tDLE1BQU0sQ0FBRS9ELFNBQVM7WUFDdkI4d0IsbUJBQW1CO2dCQUNsQnJCO2dCQUNBLE9BQU9VO1lBQ1I7WUFDQVksZ0JBQWdCO2dCQUNmdEI7Z0JBQ0EsT0FBT1M7WUFDUjtZQUNBYyxlQUFlO2dCQUNkdkI7Z0JBQ0EsT0FBT0k7WUFDUjtZQUNBb0Isb0JBQW9CO2dCQUNuQnhCO2dCQUNBLE9BQU9LO1lBQ1I7WUFDQW9CLGVBQWU7Z0JBQ2R6QjtnQkFDQSxPQUFPYTtZQUNSO1lBRUEscUNBQXFDO1lBQ3JDLHVFQUF1RTtZQUN2RSwrREFBK0Q7WUFDL0QscUVBQXFFO1lBQ3JFLG1FQUFtRTtZQUNuRSxFQUFFO1lBQ0YsdUJBQXVCO1lBQ3ZCLHNDQUFzQztZQUN0QyxvQ0FBb0M7WUFDcENhLHNCQUFzQjtnQkFDckIsSUFBSUMsT0FBTzdNLElBQUk4TSxTQUFTQztnQkFDeEIsSUFBS1gsMkJBQTJCLE1BQU87b0JBQ3RDUyxRQUFRM3lCLFNBQVN5QyxhQUFhLENBQUU7b0JBQ2hDcWpCLEtBQUs5bEIsU0FBU3lDLGFBQWEsQ0FBRTtvQkFDN0Jtd0IsVUFBVTV5QixTQUFTeUMsYUFBYSxDQUFFO29CQUVsQ2t3QixNQUFNalAsS0FBSyxDQUFDd04sT0FBTyxHQUFHO29CQUN0QnBMLEdBQUdwQyxLQUFLLENBQUN3TixPQUFPLEdBQUc7b0JBRW5CLHNCQUFzQjtvQkFDdEIsbURBQW1EO29CQUNuRCx3Q0FBd0M7b0JBQ3hDcEwsR0FBR3BDLEtBQUssQ0FBQ29QLE1BQU0sR0FBRztvQkFDbEJGLFFBQVFsUCxLQUFLLENBQUNvUCxNQUFNLEdBQUc7b0JBRXZCLGdDQUFnQztvQkFDaEMscUNBQXFDO29CQUNyQyxtREFBbUQ7b0JBQ25ELHNEQUFzRDtvQkFDdEQsdUNBQXVDO29CQUN2QywwQkFBMEI7b0JBQzFCRixRQUFRbFAsS0FBSyxDQUFDQyxPQUFPLEdBQUc7b0JBRXhCM2MsZ0JBQ0VsRSxXQUFXLENBQUU2dkIsT0FDYjd2QixXQUFXLENBQUVnakIsSUFDYmhqQixXQUFXLENBQUU4dkI7b0JBRWZDLFVBQVUxeUIsUUFBT3l3QixnQkFBZ0IsQ0FBRTlLO29CQUNuQ29NLDBCQUEwQixTQUFZVyxRQUFRQyxNQUFNLEVBQUUsTUFDckRDLFNBQVVGLFFBQVFHLGNBQWMsRUFBRSxNQUNsQ0QsU0FBVUYsUUFBUUksaUJBQWlCLEVBQUUsUUFBV25OLEdBQUdvTixZQUFZO29CQUVoRWxzQixnQkFBZ0JoRSxXQUFXLENBQUUydkI7Z0JBQzlCO2dCQUNBLE9BQU9UO1lBQ1I7UUFDRDtJQUNEO0lBR0EsU0FBU2lCLE9BQVEzdUIsSUFBSSxFQUFFZ0IsSUFBSSxFQUFFNHRCLFFBQVE7UUFDcEMsSUFBSXpCLE9BQU8wQixVQUFVQyxVQUFVcHZCLEtBQzlCcXZCLGVBQWU5QyxZQUFZL29CLElBQUksQ0FBRWxDLE9BRWpDLHVCQUF1QjtRQUN2QiwyQ0FBMkM7UUFDM0MsMkNBQTJDO1FBQzNDLHVCQUF1QjtRQUN2QmtlLFFBQVFsZixLQUFLa2YsS0FBSztRQUVuQjBQLFdBQVdBLFlBQVkxQyxVQUFXbHNCO1FBRWxDLGtDQUFrQztRQUNsQywyQ0FBMkM7UUFDM0Msc0NBQXNDO1FBQ3RDLElBQUs0dUIsVUFBVztZQUVmLHdCQUF3QjtZQUN4Qix1RUFBdUU7WUFDdkUsc0VBQXNFO1lBQ3RFLHFFQUFxRTtZQUNyRSx5REFBeUQ7WUFDekQsaUVBQWlFO1lBQ2pFLGlFQUFpRTtZQUNqRSxtRUFBbUU7WUFDbkUsbUVBQW1FO1lBQ25FbHZCLE1BQU1rdkIsU0FBU0ksZ0JBQWdCLENBQUVodUIsU0FBVTR0QixRQUFRLENBQUU1dEIsS0FBTTtZQUUzRCxJQUFLK3RCLGdCQUFnQnJ2QixLQUFNO2dCQUUxQix1Q0FBdUM7Z0JBQ3ZDLHFFQUFxRTtnQkFDckUsK0RBQStEO2dCQUMvRCx3REFBd0Q7Z0JBQ3hELEVBQUU7Z0JBQ0YscURBQXFEO2dCQUNyRCw0REFBNEQ7Z0JBQzVELHlEQUF5RDtnQkFDekQsa0VBQWtFO2dCQUNsRSxzREFBc0Q7Z0JBQ3RELEVBQUU7Z0JBQ0YsOERBQThEO2dCQUM5RCw4REFBOEQ7Z0JBQzlELGdFQUFnRTtnQkFDaEUsOEJBQThCO2dCQUM5QiwwREFBMEQ7Z0JBQzFEQSxNQUFNQSxJQUFJbUMsT0FBTyxDQUFFc0MsVUFBVSxTQUFVMUM7WUFDeEM7WUFFQSxJQUFLL0IsUUFBUSxNQUFNLENBQUNvZixXQUFZOWUsT0FBUztnQkFDeENOLE1BQU1kLE9BQU9zZ0IsS0FBSyxDQUFFbGYsTUFBTWdCO1lBQzNCO1lBRUEsa0RBQWtEO1lBQ2xELHNEQUFzRDtZQUN0RCx5Q0FBeUM7WUFDekMsd0NBQXdDO1lBQ3hDLGtEQUFrRDtZQUNsRCxJQUFLLENBQUNqRSxRQUFRK3dCLGNBQWMsTUFBTTlCLFVBQVU5b0IsSUFBSSxDQUFFeEQsUUFBUzZzQixVQUFVcnBCLElBQUksQ0FBRWxDLE9BQVM7Z0JBRW5GLCtCQUErQjtnQkFDL0Jtc0IsUUFBUWpPLE1BQU1pTyxLQUFLO2dCQUNuQjBCLFdBQVczUCxNQUFNMlAsUUFBUTtnQkFDekJDLFdBQVc1UCxNQUFNNFAsUUFBUTtnQkFFekIsb0RBQW9EO2dCQUNwRDVQLE1BQU0yUCxRQUFRLEdBQUczUCxNQUFNNFAsUUFBUSxHQUFHNVAsTUFBTWlPLEtBQUssR0FBR3p0QjtnQkFDaERBLE1BQU1rdkIsU0FBU3pCLEtBQUs7Z0JBRXBCLDRCQUE0QjtnQkFDNUJqTyxNQUFNaU8sS0FBSyxHQUFHQTtnQkFDZGpPLE1BQU0yUCxRQUFRLEdBQUdBO2dCQUNqQjNQLE1BQU00UCxRQUFRLEdBQUdBO1lBQ2xCO1FBQ0Q7UUFFQSxPQUFPcHZCLFFBQVErQixZQUVkLDRCQUE0QjtRQUM1Qix5Q0FBeUM7UUFDekMvQixNQUFNLEtBQ05BO0lBQ0Y7SUFHQSxTQUFTdXZCLGFBQWNDLFdBQVcsRUFBRUMsTUFBTTtRQUV6Qyx1RUFBdUU7UUFDdkUsT0FBTztZQUNON3ZCLEtBQUs7Z0JBQ0osSUFBSzR2QixlQUFnQjtvQkFFcEIsc0RBQXNEO29CQUN0RCxxQ0FBcUM7b0JBQ3JDLE9BQU8sSUFBSSxDQUFDNXZCLEdBQUc7b0JBQ2Y7Z0JBQ0Q7Z0JBRUEsMkVBQTJFO2dCQUMzRSxPQUFPLENBQUUsSUFBSSxDQUFDQSxHQUFHLEdBQUc2dkIsTUFBSyxFQUFJN3lCLEtBQUssQ0FBRSxJQUFJLEVBQUUyRDtZQUMzQztRQUNEO0lBQ0Q7SUFHQSxJQUFJbXZCLGNBQWM7UUFBRTtRQUFVO1FBQU87S0FBTSxFQUMxQ0MsYUFBYTd6QixTQUFTeUMsYUFBYSxDQUFFLE9BQVFpaEIsS0FBSyxFQUNsRG9RLGNBQWMsQ0FBQztJQUVoQixpREFBaUQ7SUFDakQsU0FBU0MsZUFBZ0J2dUIsSUFBSTtRQUU1QixrQ0FBa0M7UUFDbEMsSUFBSXd1QixVQUFVeHVCLElBQUksQ0FBRSxFQUFHLENBQUNzYixXQUFXLEtBQUt0YixLQUFLL0UsS0FBSyxDQUFFLElBQ25ENkIsSUFBSXN4QixZQUFZaHdCLE1BQU07UUFFdkIsTUFBUXRCLElBQU07WUFDYmtELE9BQU9vdUIsV0FBVyxDQUFFdHhCLEVBQUcsR0FBRzB4QjtZQUMxQixJQUFLeHVCLFFBQVFxdUIsWUFBYTtnQkFDekIsT0FBT3J1QjtZQUNSO1FBQ0Q7SUFDRDtJQUVBLDBFQUEwRTtJQUMxRSxTQUFTeXVCLGNBQWV6dUIsSUFBSTtRQUMzQixJQUFJMHVCLFFBQVE5d0IsT0FBTyt3QixRQUFRLENBQUUzdUIsS0FBTSxJQUFJc3VCLFdBQVcsQ0FBRXR1QixLQUFNO1FBRTFELElBQUswdUIsT0FBUTtZQUNaLE9BQU9BO1FBQ1I7UUFDQSxJQUFLMXVCLFFBQVFxdUIsWUFBYTtZQUN6QixPQUFPcnVCO1FBQ1I7UUFDQSxPQUFPc3VCLFdBQVcsQ0FBRXR1QixLQUFNLEdBQUd1dUIsZUFBZ0J2dUIsU0FBVUE7SUFDeEQ7SUFHQSxJQUVDLG9EQUFvRDtJQUNwRCxtREFBbUQ7SUFDbkQsb0ZBQW9GO0lBQ3BGNHVCLGVBQWUsNkJBQ2ZDLFVBQVU7UUFBRXpDLFVBQVU7UUFBWTBDLFlBQVk7UUFBVTNRLFNBQVM7SUFBUSxHQUN6RTRRLHFCQUFxQjtRQUNwQkMsZUFBZTtRQUNmQyxZQUFZO0lBQ2I7SUFFRCxTQUFTQyxrQkFBbUIzdkIsS0FBSyxFQUFFbUQsS0FBSyxFQUFFeXNCLFFBQVE7UUFFakQsOENBQThDO1FBQzlDLDJCQUEyQjtRQUMzQixJQUFJNXNCLFVBQVVxYixRQUFReFYsSUFBSSxDQUFFMUY7UUFDNUIsT0FBT0gsVUFFTixxRUFBcUU7UUFDckU1QixLQUFLeXVCLEdBQUcsQ0FBRSxHQUFHN3NCLE9BQU8sQ0FBRSxFQUFHLEdBQUs0c0IsQ0FBQUEsWUFBWSxNQUFVNXNCLENBQUFBLE9BQU8sQ0FBRSxFQUFHLElBQUksSUFBRyxJQUN2RUc7SUFDRjtJQUVBLFNBQVMyc0IsbUJBQW9CcndCLElBQUksRUFBRXN3QixTQUFTLEVBQUVDLEdBQUcsRUFBRUMsV0FBVyxFQUFFQyxNQUFNLEVBQUVDLFdBQVc7UUFDbEYsSUFBSTV5QixJQUFJd3lCLGNBQWMsVUFBVSxJQUFJLEdBQ25DSyxRQUFRLEdBQ1JDLFFBQVEsR0FDUkMsY0FBYztRQUVmLGtDQUFrQztRQUNsQyxJQUFLTixRQUFVQyxDQUFBQSxjQUFjLFdBQVcsU0FBUSxHQUFNO1lBQ3JELE9BQU87UUFDUjtRQUVBLE1BQVExeUIsSUFBSSxHQUFHQSxLQUFLLEVBQUk7WUFFdkIsaUNBQWlDO1lBQ2pDLCtFQUErRTtZQUMvRSxxRkFBcUY7WUFDckYsSUFBS3l5QixRQUFRLFVBQVc7Z0JBQ3ZCTSxlQUFlanlCLE9BQU93Z0IsR0FBRyxDQUFFcGYsTUFBTXV3QixNQUFNMVIsU0FBUyxDQUFFL2dCLEVBQUcsRUFBRSxNQUFNMnlCO1lBQzlEO1lBRUEscUZBQXFGO1lBQ3JGLElBQUssQ0FBQ0QsYUFBYztnQkFFbkIsY0FBYztnQkFDZEksU0FBU2h5QixPQUFPd2dCLEdBQUcsQ0FBRXBmLE1BQU0sWUFBWTZlLFNBQVMsQ0FBRS9nQixFQUFHLEVBQUUsTUFBTTJ5QjtnQkFFN0QsdUNBQXVDO2dCQUN2QyxJQUFLRixRQUFRLFdBQVk7b0JBQ3hCSyxTQUFTaHlCLE9BQU93Z0IsR0FBRyxDQUFFcGYsTUFBTSxXQUFXNmUsU0FBUyxDQUFFL2dCLEVBQUcsR0FBRyxTQUFTLE1BQU0yeUI7Z0JBRXZFLHVDQUF1QztnQkFDdkMsT0FBTztvQkFDTkUsU0FBUy94QixPQUFPd2dCLEdBQUcsQ0FBRXBmLE1BQU0sV0FBVzZlLFNBQVMsQ0FBRS9nQixFQUFHLEdBQUcsU0FBUyxNQUFNMnlCO2dCQUN2RTtZQUVELDRGQUE0RjtZQUM1Rix3QkFBd0I7WUFDeEIsT0FBTztnQkFFTixrQ0FBa0M7Z0JBQ2xDLElBQUtGLFFBQVEsV0FBWTtvQkFDeEJLLFNBQVNoeUIsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNLFlBQVk2ZSxTQUFTLENBQUUvZ0IsRUFBRyxFQUFFLE1BQU0yeUI7Z0JBQzlEO2dCQUVBLDhDQUE4QztnQkFDOUMsSUFBS0YsUUFBUSxVQUFXO29CQUN2QkssU0FBU2h5QixPQUFPd2dCLEdBQUcsQ0FBRXBmLE1BQU0sV0FBVzZlLFNBQVMsQ0FBRS9nQixFQUFHLEdBQUcsU0FBUyxNQUFNMnlCO2dCQUN2RTtZQUNEO1FBQ0Q7UUFFQSx5RkFBeUY7UUFDekYsSUFBSyxDQUFDRCxlQUFlRSxlQUFlLEdBQUk7WUFFdkMsMkZBQTJGO1lBQzNGLG1FQUFtRTtZQUNuRUUsU0FBU2p2QixLQUFLeXVCLEdBQUcsQ0FBRSxHQUFHenVCLEtBQUttdkIsSUFBSSxDQUM5Qjl3QixJQUFJLENBQUUsV0FBV3N3QixTQUFTLENBQUUsRUFBRyxDQUFDaFUsV0FBVyxLQUFLZ1UsVUFBVXIwQixLQUFLLENBQUUsR0FBSyxHQUN0RXkwQixjQUNBRSxRQUNBRCxRQUNBLFNBSU07UUFDUjtRQUVBLE9BQU9DLFFBQVFDO0lBQ2hCO0lBRUEsU0FBU0UsaUJBQWtCL3dCLElBQUksRUFBRXN3QixTQUFTLEVBQUVLLEtBQUs7UUFFaEQsNEJBQTRCO1FBQzVCLElBQUlGLFNBQVN2RSxVQUFXbHNCLE9BRXZCLDJFQUEyRTtRQUMzRSxxRUFBcUU7UUFDckVneEIsa0JBQWtCLENBQUNqMEIsUUFBUTh3QixpQkFBaUIsTUFBTThDLE9BQ2xESCxjQUFjUSxtQkFDYnB5QixPQUFPd2dCLEdBQUcsQ0FBRXBmLE1BQU0sYUFBYSxPQUFPeXdCLFlBQWEsY0FDcERRLG1CQUFtQlQsYUFFbkJ6eUIsTUFBTTR3QixPQUFRM3VCLE1BQU1zd0IsV0FBV0csU0FDL0JTLGFBQWEsV0FBV1osU0FBUyxDQUFFLEVBQUcsQ0FBQ2hVLFdBQVcsS0FBS2dVLFVBQVVyMEIsS0FBSyxDQUFFO1FBRXpFLHdCQUF3QjtRQUN4QiwyRUFBMkU7UUFDM0UsSUFBSyt2QixVQUFVOW9CLElBQUksQ0FBRW5GLE1BQVE7WUFDNUIsSUFBSyxDQUFDNHlCLE9BQVE7Z0JBQ2IsT0FBTzV5QjtZQUNSO1lBQ0FBLE1BQU07UUFDUDtRQUdBLDBCQUEwQjtRQUMxQixrRUFBa0U7UUFDbEUsc0VBQXNFO1FBQ3RFLElBQUssQ0FBRSxDQUFDaEIsUUFBUTh3QixpQkFBaUIsTUFBTTJDLGVBRXRDLHNDQUFzQztRQUN0Qyx1RUFBdUU7UUFDdkUsK0RBQStEO1FBQy9ELG9FQUFvRTtRQUNwRSxDQUFDenpCLFFBQVFteEIsb0JBQW9CLE1BQU0vcUIsU0FBVW5ELE1BQU0sU0FFbkQsNkRBQTZEO1FBQzdELHNFQUFzRTtRQUN0RWpDLFFBQVEsVUFFUixvQ0FBb0M7UUFDcEMsZ0ZBQWdGO1FBQ2hGLENBQUMwdkIsV0FBWTF2QixRQUFTYSxPQUFPd2dCLEdBQUcsQ0FBRXBmLE1BQU0sV0FBVyxPQUFPeXdCLFlBQWEsUUFBTyxLQUU5RSwrQ0FBK0M7UUFDL0N6d0IsS0FBS214QixjQUFjLEdBQUcveEIsTUFBTSxFQUFHO1lBRS9Cb3hCLGNBQWM1eEIsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNLGFBQWEsT0FBT3l3QixZQUFhO1lBRWpFLCtFQUErRTtZQUMvRSxrRkFBa0Y7WUFDbEYsOENBQThDO1lBQzlDUSxtQkFBbUJDLGNBQWNseEI7WUFDakMsSUFBS2l4QixrQkFBbUI7Z0JBQ3ZCbHpCLE1BQU1pQyxJQUFJLENBQUVreEIsV0FBWTtZQUN6QjtRQUNEO1FBRUEsd0JBQXdCO1FBQ3hCbnpCLE1BQU0wdkIsV0FBWTF2QixRQUFTO1FBRTNCLHFDQUFxQztRQUNyQyxPQUFPLE1BQ05zeUIsbUJBQ0Nyd0IsTUFDQXN3QixXQUNBSyxTQUFXSCxDQUFBQSxjQUFjLFdBQVcsU0FBUSxHQUM1Q1Msa0JBQ0FSLFFBRUEsbUZBQW1GO1FBQ25GMXlCLE9BRUU7SUFDTDtJQUVBYSxPQUFPa0MsTUFBTSxDQUFFO1FBRWQseURBQXlEO1FBQ3pELG1EQUFtRDtRQUNuRHN3QixVQUFVO1lBQ1RDLFNBQVM7Z0JBQ1IveEIsS0FBSyxTQUFVVSxJQUFJLEVBQUU0dUIsUUFBUTtvQkFDNUIsSUFBS0EsVUFBVzt3QkFFZixrREFBa0Q7d0JBQ2xELElBQUlsdkIsTUFBTWl2QixPQUFRM3VCLE1BQU07d0JBQ3hCLE9BQU9OLFFBQVEsS0FBSyxNQUFNQTtvQkFDM0I7Z0JBQ0Q7WUFDRDtRQUNEO1FBRUEscUVBQXFFO1FBQ3JFb2dCLFdBQVc7WUFDVndSLHlCQUF5QjtZQUN6QkMsYUFBYTtZQUNiQyxrQkFBa0I7WUFDbEJDLGFBQWE7WUFDYkMsVUFBVTtZQUNWQyxZQUFZO1lBQ1oxQixZQUFZO1lBQ1oyQixVQUFVO1lBQ1ZDLFlBQVk7WUFDWkMsZUFBZTtZQUNmQyxpQkFBaUI7WUFDakJDLFNBQVM7WUFDVEMsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFlBQVk7WUFDWmQsU0FBUztZQUNUZSxPQUFPO1lBQ1BDLFNBQVM7WUFDVDVTLE9BQU87WUFDUDZTLFFBQVE7WUFDUkMsUUFBUTtZQUNSQyxNQUFNO1lBRU4sY0FBYztZQUNkQyxhQUFhO1lBQ2JDLGNBQWM7WUFDZEMsYUFBYTtZQUNiQyxrQkFBa0I7WUFDbEJDLGVBQWU7UUFDaEI7UUFFQSx1REFBdUQ7UUFDdkQsK0JBQStCO1FBQy9CbEQsVUFBVSxDQUFDO1FBRVgsK0NBQStDO1FBQy9DelEsT0FBTyxTQUFVbGYsSUFBSSxFQUFFZ0IsSUFBSSxFQUFFMEMsS0FBSyxFQUFFaXRCLEtBQUs7WUFFeEMsNkNBQTZDO1lBQzdDLElBQUssQ0FBQzN3QixRQUFRQSxLQUFLOUMsUUFBUSxLQUFLLEtBQUs4QyxLQUFLOUMsUUFBUSxLQUFLLEtBQUssQ0FBQzhDLEtBQUtrZixLQUFLLEVBQUc7Z0JBQ3pFO1lBQ0Q7WUFFQSxtREFBbUQ7WUFDbkQsSUFBSXhmLEtBQUtwQyxNQUFNMmdCLE9BQ2Q2VSxXQUFXdlcsVUFBV3ZiLE9BQ3RCK3RCLGVBQWU5QyxZQUFZL29CLElBQUksQ0FBRWxDLE9BQ2pDa2UsUUFBUWxmLEtBQUtrZixLQUFLO1lBRW5CLDZEQUE2RDtZQUM3RCx5REFBeUQ7WUFDekQsK0JBQStCO1lBQy9CLElBQUssQ0FBQzZQLGNBQWU7Z0JBQ3BCL3RCLE9BQU95dUIsY0FBZXFEO1lBQ3ZCO1lBRUEsOERBQThEO1lBQzlEN1UsUUFBUXJmLE9BQU93eUIsUUFBUSxDQUFFcHdCLEtBQU0sSUFBSXBDLE9BQU93eUIsUUFBUSxDQUFFMEIsU0FBVTtZQUU5RCxpQ0FBaUM7WUFDakMsSUFBS3B2QixVQUFVakMsV0FBWTtnQkFDMUJuRSxPQUFPLE9BQU9vRztnQkFFZCx1REFBdUQ7Z0JBQ3ZELElBQUtwRyxTQUFTLFlBQWNvQyxDQUFBQSxNQUFNa2YsUUFBUXhWLElBQUksQ0FBRTFGLE1BQU0sS0FBT2hFLEdBQUcsQ0FBRSxFQUFHLEVBQUc7b0JBQ3ZFZ0UsUUFBUTJiLFVBQVdyZixNQUFNZ0IsTUFBTXRCO29CQUUvQixzQkFBc0I7b0JBQ3RCcEMsT0FBTztnQkFDUjtnQkFFQSw0REFBNEQ7Z0JBQzVELElBQUtvRyxTQUFTLFFBQVFBLFVBQVVBLE9BQVE7b0JBQ3ZDO2dCQUNEO2dCQUVBLDhFQUE4RTtnQkFDOUUsK0VBQStFO2dCQUMvRSxrQ0FBa0M7Z0JBQ2xDLElBQUtwRyxTQUFTLFlBQVksQ0FBQ3l4QixjQUFlO29CQUN6Q3JyQixTQUFTaEUsT0FBT0EsR0FBRyxDQUFFLEVBQUcsSUFBTWQsQ0FBQUEsT0FBT2toQixTQUFTLENBQUVnVCxTQUFVLEdBQUcsS0FBSyxJQUFHO2dCQUN0RTtnQkFFQSxvREFBb0Q7Z0JBQ3BELElBQUssQ0FBQy8xQixRQUFRNndCLGVBQWUsSUFBSWxxQixVQUFVLE1BQU0xQyxLQUFLeEUsT0FBTyxDQUFFLGtCQUFtQixHQUFJO29CQUNyRjBpQixLQUFLLENBQUVsZSxLQUFNLEdBQUc7Z0JBQ2pCO2dCQUVBLGlGQUFpRjtnQkFDakYsSUFBSyxDQUFDaWQsU0FBUyxDQUFHLFVBQVNBLEtBQUksS0FDOUIsQ0FBRXZhLFFBQVF1YSxNQUFNbEIsR0FBRyxDQUFFL2MsTUFBTTBELE9BQU9pdEIsTUFBTSxNQUFRbHZCLFdBQVk7b0JBRTVELElBQUtzdEIsY0FBZTt3QkFDbkI3UCxNQUFNNlQsV0FBVyxDQUFFL3hCLE1BQU0wQztvQkFDMUIsT0FBTzt3QkFDTndiLEtBQUssQ0FBRWxlLEtBQU0sR0FBRzBDO29CQUNqQjtnQkFDRDtZQUVELE9BQU87Z0JBRU4sK0RBQStEO2dCQUMvRCxJQUFLdWEsU0FBUyxTQUFTQSxTQUN0QixDQUFFdmUsTUFBTXVlLE1BQU0zZSxHQUFHLENBQUVVLE1BQU0sT0FBTzJ3QixNQUFNLE1BQVFsdkIsV0FBWTtvQkFFMUQsT0FBTy9CO2dCQUNSO2dCQUVBLHFEQUFxRDtnQkFDckQsT0FBT3dmLEtBQUssQ0FBRWxlLEtBQU07WUFDckI7UUFDRDtRQUVBb2UsS0FBSyxTQUFVcGYsSUFBSSxFQUFFZ0IsSUFBSSxFQUFFMnZCLEtBQUssRUFBRUYsTUFBTTtZQUN2QyxJQUFJMXlCLEtBQUt3QixLQUFLMGUsT0FDYjZVLFdBQVd2VyxVQUFXdmIsT0FDdEIrdEIsZUFBZTlDLFlBQVkvb0IsSUFBSSxDQUFFbEM7WUFFbEMsNkRBQTZEO1lBQzdELDBEQUEwRDtZQUMxRCwrQkFBK0I7WUFDL0IsSUFBSyxDQUFDK3RCLGNBQWU7Z0JBQ3BCL3RCLE9BQU95dUIsY0FBZXFEO1lBQ3ZCO1lBRUEsb0RBQW9EO1lBQ3BEN1UsUUFBUXJmLE9BQU93eUIsUUFBUSxDQUFFcHdCLEtBQU0sSUFBSXBDLE9BQU93eUIsUUFBUSxDQUFFMEIsU0FBVTtZQUU5RCwyREFBMkQ7WUFDM0QsSUFBSzdVLFNBQVMsU0FBU0EsT0FBUTtnQkFDOUJsZ0IsTUFBTWtnQixNQUFNM2UsR0FBRyxDQUFFVSxNQUFNLE1BQU0yd0I7WUFDOUI7WUFFQSxpRUFBaUU7WUFDakUsSUFBSzV5QixRQUFRMEQsV0FBWTtnQkFDeEIxRCxNQUFNNHdCLE9BQVEzdUIsTUFBTWdCLE1BQU15dkI7WUFDM0I7WUFFQSxxQ0FBcUM7WUFDckMsSUFBSzF5QixRQUFRLFlBQVlpRCxRQUFRK3VCLG9CQUFxQjtnQkFDckRoeUIsTUFBTWd5QixrQkFBa0IsQ0FBRS91QixLQUFNO1lBQ2pDO1lBRUEsMkVBQTJFO1lBQzNFLElBQUsydkIsVUFBVSxNQUFNQSxPQUFRO2dCQUM1QnB4QixNQUFNa3VCLFdBQVkxdkI7Z0JBQ2xCLE9BQU80eUIsVUFBVSxRQUFRcUMsU0FBVXp6QixPQUFRQSxPQUFPLElBQUl4QjtZQUN2RDtZQUVBLE9BQU9BO1FBQ1I7SUFDRDtJQUVBYSxPQUFPaUIsSUFBSSxDQUFFO1FBQUU7UUFBVTtLQUFTLEVBQUUsU0FBVWtFLEVBQUUsRUFBRXVzQixTQUFTO1FBQzFEMXhCLE9BQU93eUIsUUFBUSxDQUFFZCxVQUFXLEdBQUc7WUFDOUJoeEIsS0FBSyxTQUFVVSxJQUFJLEVBQUU0dUIsUUFBUSxFQUFFK0IsS0FBSztnQkFDbkMsSUFBSy9CLFVBQVc7b0JBRWYscUVBQXFFO29CQUNyRSw4REFBOEQ7b0JBQzlELE9BQU9nQixhQUFhMXNCLElBQUksQ0FBRXRFLE9BQU93Z0IsR0FBRyxDQUFFcGYsTUFBTSxlQUUzQyxxQkFBcUI7b0JBQ3JCLDJEQUEyRDtvQkFDM0QsMkRBQTJEO29CQUMzRCx3QkFBd0I7b0JBQ3hCLHVEQUF1RDtvQkFDdkQseUJBQXlCO29CQUN2QixFQUFDQSxLQUFLbXhCLGNBQWMsR0FBRy94QixNQUFNLElBQUksQ0FBQ1ksS0FBS2l6QixxQkFBcUIsR0FBRzlGLEtBQUssSUFDdEVkLEtBQU1yc0IsTUFBTTZ2QixTQUFTO3dCQUNwQixPQUFPa0IsaUJBQWtCL3dCLE1BQU1zd0IsV0FBV0s7b0JBQzNDLEtBQ0FJLGlCQUFrQi93QixNQUFNc3dCLFdBQVdLO2dCQUNyQztZQUNEO1lBRUE1VCxLQUFLLFNBQVUvYyxJQUFJLEVBQUUwRCxLQUFLLEVBQUVpdEIsS0FBSztnQkFDaEMsSUFBSXB0QixTQUNIa3RCLFNBQVN2RSxVQUFXbHNCLE9BRXBCLDZEQUE2RDtnQkFDN0QsNkJBQTZCO2dCQUM3Qmt6QixxQkFBcUIsQ0FBQ24yQixRQUFRa3hCLGFBQWEsTUFDMUN3QyxPQUFPckQsUUFBUSxLQUFLLFlBRXJCLDBFQUEwRTtnQkFDMUU0RCxrQkFBa0JrQyxzQkFBc0J2QyxPQUN4Q0gsY0FBY1EsbUJBQ2JweUIsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNLGFBQWEsT0FBT3l3QixZQUFhLGNBQ3BETixXQUFXUSxRQUNWTixtQkFDQ3J3QixNQUNBc3dCLFdBQ0FLLE9BQ0FILGFBQ0FDLFVBRUQ7Z0JBRUYsb0ZBQW9GO2dCQUNwRiwyREFBMkQ7Z0JBQzNELElBQUtELGVBQWUwQyxvQkFBcUI7b0JBQ3hDL0MsWUFBWXh1QixLQUFLbXZCLElBQUksQ0FDcEI5d0IsSUFBSSxDQUFFLFdBQVdzd0IsU0FBUyxDQUFFLEVBQUcsQ0FBQ2hVLFdBQVcsS0FBS2dVLFVBQVVyMEIsS0FBSyxDQUFFLEdBQUssR0FDdEV3eEIsV0FBWWdELE1BQU0sQ0FBRUgsVUFBVyxJQUMvQkQsbUJBQW9CcndCLE1BQU1zd0IsV0FBVyxVQUFVLE9BQU9HLFVBQ3REO2dCQUVGO2dCQUVBLGtEQUFrRDtnQkFDbEQsSUFBS04sWUFBYzVzQixDQUFBQSxVQUFVcWIsUUFBUXhWLElBQUksQ0FBRTFGLE1BQU0sS0FDaEQsQ0FBRUgsT0FBTyxDQUFFLEVBQUcsSUFBSSxJQUFHLE1BQVEsTUFBTztvQkFFcEN2RCxLQUFLa2YsS0FBSyxDQUFFb1IsVUFBVyxHQUFHNXNCO29CQUMxQkEsUUFBUTlFLE9BQU93Z0IsR0FBRyxDQUFFcGYsTUFBTXN3QjtnQkFDM0I7Z0JBRUEsT0FBT0osa0JBQW1CbHdCLE1BQU0wRCxPQUFPeXNCO1lBQ3hDO1FBQ0Q7SUFDRDtJQUVBdnhCLE9BQU93eUIsUUFBUSxDQUFDckUsVUFBVSxHQUFHa0MsYUFBY2x5QixRQUFRaXhCLGtCQUFrQixFQUNwRSxTQUFVaHVCLElBQUksRUFBRTR1QixRQUFRO1FBQ3ZCLElBQUtBLFVBQVc7WUFDZixPQUFPLENBQUVuQixXQUFZa0IsT0FBUTN1QixNQUFNLGtCQUNsQ0EsS0FBS2l6QixxQkFBcUIsR0FBR0UsSUFBSSxHQUNoQzlHLEtBQU1yc0IsTUFBTTtnQkFBRStzQixZQUFZO1lBQUUsR0FBRztnQkFDOUIsT0FBTy9zQixLQUFLaXpCLHFCQUFxQixHQUFHRSxJQUFJO1lBQ3pDLEVBQUUsSUFDQTtRQUNMO0lBQ0Q7SUFHRCx1REFBdUQ7SUFDdkR2MEIsT0FBT2lCLElBQUksQ0FBRTtRQUNadXpCLFFBQVE7UUFDUkMsU0FBUztRQUNUQyxRQUFRO0lBQ1QsR0FBRyxTQUFVQyxNQUFNLEVBQUVDLE1BQU07UUFDMUI1MEIsT0FBT3d5QixRQUFRLENBQUVtQyxTQUFTQyxPQUFRLEdBQUc7WUFDcENDLFFBQVEsU0FBVS92QixLQUFLO2dCQUN0QixJQUFJNUYsSUFBSSxHQUNQNDFCLFdBQVcsQ0FBQyxHQUVaLDBDQUEwQztnQkFDMUNDLFFBQVEsT0FBT2p3QixVQUFVLFdBQVdBLE1BQU1JLEtBQUssQ0FBRSxPQUFRO29CQUFFSjtpQkFBTztnQkFFbkUsTUFBUTVGLElBQUksR0FBR0EsSUFBTTtvQkFDcEI0MUIsUUFBUSxDQUFFSCxTQUFTMVUsU0FBUyxDQUFFL2dCLEVBQUcsR0FBRzAxQixPQUFRLEdBQzNDRyxLQUFLLENBQUU3MUIsRUFBRyxJQUFJNjFCLEtBQUssQ0FBRTcxQixJQUFJLEVBQUcsSUFBSTYxQixLQUFLLENBQUUsRUFBRztnQkFDNUM7Z0JBRUEsT0FBT0Q7WUFDUjtRQUNEO1FBRUEsSUFBS0gsV0FBVyxVQUFXO1lBQzFCMzBCLE9BQU93eUIsUUFBUSxDQUFFbUMsU0FBU0MsT0FBUSxDQUFDelcsR0FBRyxHQUFHbVQ7UUFDMUM7SUFDRDtJQUVBdHhCLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQnNlLEtBQUssU0FBVXBlLElBQUksRUFBRTBDLEtBQUs7WUFDekIsT0FBT2lZLE9BQVEsSUFBSSxFQUFFLFNBQVUzYixJQUFJLEVBQUVnQixJQUFJLEVBQUUwQyxLQUFLO2dCQUMvQyxJQUFJK3NCLFFBQVFod0IsS0FDWFYsTUFBTSxDQUFDLEdBQ1BqQyxJQUFJO2dCQUVMLElBQUt5RCxNQUFNQyxPQUFPLENBQUVSLE9BQVM7b0JBQzVCeXZCLFNBQVN2RSxVQUFXbHNCO29CQUNwQlMsTUFBTU8sS0FBSzVCLE1BQU07b0JBRWpCLE1BQVF0QixJQUFJMkMsS0FBSzNDLElBQU07d0JBQ3RCaUMsR0FBRyxDQUFFaUIsSUFBSSxDQUFFbEQsRUFBRyxDQUFFLEdBQUdjLE9BQU93Z0IsR0FBRyxDQUFFcGYsTUFBTWdCLElBQUksQ0FBRWxELEVBQUcsRUFBRSxPQUFPMnlCO29CQUN4RDtvQkFFQSxPQUFPMXdCO2dCQUNSO2dCQUVBLE9BQU8yRCxVQUFVakMsWUFDaEI3QyxPQUFPc2dCLEtBQUssQ0FBRWxmLE1BQU1nQixNQUFNMEMsU0FDMUI5RSxPQUFPd2dCLEdBQUcsQ0FBRXBmLE1BQU1nQjtZQUNwQixHQUFHQSxNQUFNMEMsT0FBT3pELFVBQVViLE1BQU0sR0FBRztRQUNwQztJQUNEO0lBR0EsU0FBU3cwQixNQUFPNXpCLElBQUksRUFBRWUsT0FBTyxFQUFFa2MsSUFBSSxFQUFFdGMsR0FBRyxFQUFFa3pCLE1BQU07UUFDL0MsT0FBTyxJQUFJRCxNQUFNMzBCLFNBQVMsQ0FBQ0QsSUFBSSxDQUFFZ0IsTUFBTWUsU0FBU2tjLE1BQU10YyxLQUFLa3pCO0lBQzVEO0lBQ0FqMUIsT0FBT2cxQixLQUFLLEdBQUdBO0lBRWZBLE1BQU0zMEIsU0FBUyxHQUFHO1FBQ2pCRSxhQUFheTBCO1FBQ2I1MEIsTUFBTSxTQUFVZ0IsSUFBSSxFQUFFZSxPQUFPLEVBQUVrYyxJQUFJLEVBQUV0YyxHQUFHLEVBQUVrekIsTUFBTSxFQUFFaFUsSUFBSTtZQUNyRCxJQUFJLENBQUM3ZixJQUFJLEdBQUdBO1lBQ1osSUFBSSxDQUFDaWQsSUFBSSxHQUFHQTtZQUNaLElBQUksQ0FBQzRXLE1BQU0sR0FBR0EsVUFBVWoxQixPQUFPaTFCLE1BQU0sQ0FBQ3JTLFFBQVE7WUFDOUMsSUFBSSxDQUFDemdCLE9BQU8sR0FBR0E7WUFDZixJQUFJLENBQUNrTixLQUFLLEdBQUcsSUFBSSxDQUFDOFksR0FBRyxHQUFHLElBQUksQ0FBQ3hSLEdBQUc7WUFDaEMsSUFBSSxDQUFDNVUsR0FBRyxHQUFHQTtZQUNYLElBQUksQ0FBQ2tmLElBQUksR0FBR0EsUUFBVWpoQixDQUFBQSxPQUFPa2hCLFNBQVMsQ0FBRTdDLEtBQU0sR0FBRyxLQUFLLElBQUc7UUFDMUQ7UUFDQTFILEtBQUs7WUFDSixJQUFJMEksUUFBUTJWLE1BQU1FLFNBQVMsQ0FBRSxJQUFJLENBQUM3VyxJQUFJLENBQUU7WUFFeEMsT0FBT2dCLFNBQVNBLE1BQU0zZSxHQUFHLEdBQ3hCMmUsTUFBTTNlLEdBQUcsQ0FBRSxJQUFJLElBQ2ZzMEIsTUFBTUUsU0FBUyxDQUFDdFMsUUFBUSxDQUFDbGlCLEdBQUcsQ0FBRSxJQUFJO1FBQ3BDO1FBQ0F5MEIsS0FBSyxTQUFVQyxPQUFPO1lBQ3JCLElBQUlDLE9BQ0hoVyxRQUFRMlYsTUFBTUUsU0FBUyxDQUFFLElBQUksQ0FBQzdXLElBQUksQ0FBRTtZQUVyQyxJQUFLLElBQUksQ0FBQ2xjLE9BQU8sQ0FBQ216QixRQUFRLEVBQUc7Z0JBQzVCLElBQUksQ0FBQ0MsR0FBRyxHQUFHRixRQUFRcjFCLE9BQU9pMUIsTUFBTSxDQUFFLElBQUksQ0FBQ0EsTUFBTSxDQUFFLENBQzlDRyxTQUFTLElBQUksQ0FBQ2p6QixPQUFPLENBQUNtekIsUUFBUSxHQUFHRixTQUFTLEdBQUcsR0FBRyxJQUFJLENBQUNqekIsT0FBTyxDQUFDbXpCLFFBQVE7WUFFdkUsT0FBTztnQkFDTixJQUFJLENBQUNDLEdBQUcsR0FBR0YsUUFBUUQ7WUFDcEI7WUFDQSxJQUFJLENBQUNqTixHQUFHLEdBQUcsQ0FBRSxJQUFJLENBQUNwbUIsR0FBRyxHQUFHLElBQUksQ0FBQ3NOLEtBQUssSUFBS2dtQixRQUFRLElBQUksQ0FBQ2htQixLQUFLO1lBRXpELElBQUssSUFBSSxDQUFDbE4sT0FBTyxDQUFDcXpCLElBQUksRUFBRztnQkFDeEIsSUFBSSxDQUFDcnpCLE9BQU8sQ0FBQ3F6QixJQUFJLENBQUNoNEIsSUFBSSxDQUFFLElBQUksQ0FBQzRELElBQUksRUFBRSxJQUFJLENBQUMrbUIsR0FBRyxFQUFFLElBQUk7WUFDbEQ7WUFFQSxJQUFLOUksU0FBU0EsTUFBTWxCLEdBQUcsRUFBRztnQkFDekJrQixNQUFNbEIsR0FBRyxDQUFFLElBQUk7WUFDaEIsT0FBTztnQkFDTjZXLE1BQU1FLFNBQVMsQ0FBQ3RTLFFBQVEsQ0FBQ3pFLEdBQUcsQ0FBRSxJQUFJO1lBQ25DO1lBQ0EsT0FBTyxJQUFJO1FBQ1o7SUFDRDtJQUVBNlcsTUFBTTMwQixTQUFTLENBQUNELElBQUksQ0FBQ0MsU0FBUyxHQUFHMjBCLE1BQU0zMEIsU0FBUztJQUVoRDIwQixNQUFNRSxTQUFTLEdBQUc7UUFDakJ0UyxVQUFVO1lBQ1RsaUIsS0FBSyxTQUFVaWdCLEtBQUs7Z0JBQ25CLElBQUloUztnQkFFSix1RUFBdUU7Z0JBQ3ZFLDJEQUEyRDtnQkFDM0QsSUFBS2dTLE1BQU12ZixJQUFJLENBQUM5QyxRQUFRLEtBQUssS0FDNUJxaUIsTUFBTXZmLElBQUksQ0FBRXVmLE1BQU10QyxJQUFJLENBQUUsSUFBSSxRQUFRc0MsTUFBTXZmLElBQUksQ0FBQ2tmLEtBQUssQ0FBRUssTUFBTXRDLElBQUksQ0FBRSxJQUFJLE1BQU87b0JBQzdFLE9BQU9zQyxNQUFNdmYsSUFBSSxDQUFFdWYsTUFBTXRDLElBQUksQ0FBRTtnQkFDaEM7Z0JBRUEsd0VBQXdFO2dCQUN4RSxvRUFBb0U7Z0JBQ3BFLG9EQUFvRDtnQkFDcEQsNERBQTREO2dCQUM1RDFQLFNBQVMzTyxPQUFPd2dCLEdBQUcsQ0FBRUcsTUFBTXZmLElBQUksRUFBRXVmLE1BQU10QyxJQUFJLEVBQUU7Z0JBRTdDLGdFQUFnRTtnQkFDaEUsT0FBTyxDQUFDMVAsVUFBVUEsV0FBVyxTQUFTLElBQUlBO1lBQzNDO1lBQ0F3UCxLQUFLLFNBQVV3QyxLQUFLO2dCQUVuQixpQ0FBaUM7Z0JBQ2pDLDRCQUE0QjtnQkFDNUIsb0VBQW9FO2dCQUNwRSxJQUFLM2dCLE9BQU95MUIsRUFBRSxDQUFDRCxJQUFJLENBQUU3VSxNQUFNdEMsSUFBSSxDQUFFLEVBQUc7b0JBQ25DcmUsT0FBT3kxQixFQUFFLENBQUNELElBQUksQ0FBRTdVLE1BQU10QyxJQUFJLENBQUUsQ0FBRXNDO2dCQUMvQixPQUFPLElBQUtBLE1BQU12ZixJQUFJLENBQUM5QyxRQUFRLEtBQUssS0FDbkMwQixDQUFBQSxPQUFPd3lCLFFBQVEsQ0FBRTdSLE1BQU10QyxJQUFJLENBQUUsSUFDNUJzQyxNQUFNdmYsSUFBSSxDQUFDa2YsS0FBSyxDQUFFdVEsY0FBZWxRLE1BQU10QyxJQUFJLEVBQUksSUFBSSxJQUFHLEdBQU07b0JBQzdEcmUsT0FBT3NnQixLQUFLLENBQUVLLE1BQU12ZixJQUFJLEVBQUV1ZixNQUFNdEMsSUFBSSxFQUFFc0MsTUFBTXdILEdBQUcsR0FBR3hILE1BQU1NLElBQUk7Z0JBQzdELE9BQU87b0JBQ05OLE1BQU12ZixJQUFJLENBQUV1ZixNQUFNdEMsSUFBSSxDQUFFLEdBQUdzQyxNQUFNd0gsR0FBRztnQkFDckM7WUFDRDtRQUNEO0lBQ0Q7SUFFQSx1QkFBdUI7SUFDdkIsK0RBQStEO0lBQy9ENk0sTUFBTUUsU0FBUyxDQUFDUSxTQUFTLEdBQUdWLE1BQU1FLFNBQVMsQ0FBQ1MsVUFBVSxHQUFHO1FBQ3hEeFgsS0FBSyxTQUFVd0MsS0FBSztZQUNuQixJQUFLQSxNQUFNdmYsSUFBSSxDQUFDOUMsUUFBUSxJQUFJcWlCLE1BQU12ZixJQUFJLENBQUN6QixVQUFVLEVBQUc7Z0JBQ25EZ2hCLE1BQU12ZixJQUFJLENBQUV1ZixNQUFNdEMsSUFBSSxDQUFFLEdBQUdzQyxNQUFNd0gsR0FBRztZQUNyQztRQUNEO0lBQ0Q7SUFFQW5vQixPQUFPaTFCLE1BQU0sR0FBRztRQUNmVyxRQUFRLFNBQVVDLENBQUM7WUFDbEIsT0FBT0E7UUFDUjtRQUNBQyxPQUFPLFNBQVVELENBQUM7WUFDakIsT0FBTyxNQUFNOXlCLEtBQUtnekIsR0FBRyxDQUFFRixJQUFJOXlCLEtBQUtpekIsRUFBRSxJQUFLO1FBQ3hDO1FBQ0FwVCxVQUFVO0lBQ1g7SUFFQTVpQixPQUFPeTFCLEVBQUUsR0FBR1QsTUFBTTMwQixTQUFTLENBQUNELElBQUk7SUFFaEMsbUNBQW1DO0lBQ25DSixPQUFPeTFCLEVBQUUsQ0FBQ0QsSUFBSSxHQUFHLENBQUM7SUFLbEIsSUFDQ1MsT0FBT0MsWUFDUEMsV0FBVywwQkFDWEMsT0FBTztJQUVSLFNBQVNDO1FBQ1IsSUFBS0gsWUFBYTtZQUNqQixJQUFLdDVCLFNBQVMwNUIsTUFBTSxLQUFLLFNBQVN2NUIsUUFBT3c1QixxQkFBcUIsRUFBRztnQkFDaEV4NUIsUUFBT3c1QixxQkFBcUIsQ0FBRUY7WUFDL0IsT0FBTztnQkFDTnQ1QixRQUFPd2UsVUFBVSxDQUFFOGEsVUFBVXIyQixPQUFPeTFCLEVBQUUsQ0FBQ2UsUUFBUTtZQUNoRDtZQUVBeDJCLE9BQU95MUIsRUFBRSxDQUFDZ0IsSUFBSTtRQUNmO0lBQ0Q7SUFFQSwwREFBMEQ7SUFDMUQsU0FBU0M7UUFDUjM1QixRQUFPd2UsVUFBVSxDQUFFO1lBQ2xCMGEsUUFBUXB6QjtRQUNUO1FBQ0EsT0FBU296QixRQUFRL04sS0FBS0MsR0FBRztJQUMxQjtJQUVBLHFEQUFxRDtJQUNyRCxTQUFTd08sTUFBT2o0QixJQUFJLEVBQUVrNEIsWUFBWTtRQUNqQyxJQUFJN00sT0FDSDdxQixJQUFJLEdBQ0pnZ0IsUUFBUTtZQUFFd1EsUUFBUWh4QjtRQUFLO1FBRXhCLG1FQUFtRTtRQUNuRSx3REFBd0Q7UUFDeERrNEIsZUFBZUEsZUFBZSxJQUFJO1FBQ2xDLE1BQVExM0IsSUFBSSxHQUFHQSxLQUFLLElBQUkwM0IsYUFBZTtZQUN0QzdNLFFBQVE5SixTQUFTLENBQUUvZ0IsRUFBRztZQUN0QmdnQixLQUFLLENBQUUsV0FBVzZLLE1BQU8sR0FBRzdLLEtBQUssQ0FBRSxZQUFZNkssTUFBTyxHQUFHcnJCO1FBQzFEO1FBRUEsSUFBS2s0QixjQUFlO1lBQ25CMVgsTUFBTXVULE9BQU8sR0FBR3ZULE1BQU1xUCxLQUFLLEdBQUc3dkI7UUFDL0I7UUFFQSxPQUFPd2dCO0lBQ1I7SUFFQSxTQUFTMlgsWUFBYS94QixLQUFLLEVBQUV1WixJQUFJLEVBQUV5WSxTQUFTO1FBQzNDLElBQUluVyxPQUNIOEssYUFBYSxDQUFFc0wsVUFBVUMsUUFBUSxDQUFFM1ksS0FBTSxJQUFJLEVBQUUsRUFBRzVnQixNQUFNLENBQUVzNUIsVUFBVUMsUUFBUSxDQUFFLElBQUssR0FDbkZwZ0IsUUFBUSxHQUNScFcsU0FBU2lyQixXQUFXanJCLE1BQU07UUFDM0IsTUFBUW9XLFFBQVFwVyxRQUFRb1csUUFBVTtZQUNqQyxJQUFPK0osUUFBUThLLFVBQVUsQ0FBRTdVLE1BQU8sQ0FBQ3BaLElBQUksQ0FBRXM1QixXQUFXelksTUFBTXZaLFFBQVk7Z0JBRXJFLGdDQUFnQztnQkFDaEMsT0FBTzZiO1lBQ1I7UUFDRDtJQUNEO0lBRUEsU0FBU3NXLGlCQUFrQjcxQixJQUFJLEVBQUV5bUIsS0FBSyxFQUFFcVAsSUFBSTtRQUMzQyxJQUFJN1ksTUFBTXZaLE9BQU82YyxRQUFRdEMsT0FBTzhYLFNBQVNDLFdBQVdDLGdCQUFnQjlXLFNBQ25FK1csUUFBUSxXQUFXelAsU0FBUyxZQUFZQSxPQUN4QzBQLE9BQU8sSUFBSSxFQUNYN00sT0FBTyxDQUFDLEdBQ1JwSyxRQUFRbGYsS0FBS2tmLEtBQUssRUFDbEJnVyxTQUFTbDFCLEtBQUs5QyxRQUFRLElBQUkraEIsbUJBQW9CamYsT0FDOUNvMkIsV0FBV2paLFNBQVM3ZCxHQUFHLENBQUVVLE1BQU07UUFFaEMsZ0RBQWdEO1FBQ2hELElBQUssQ0FBQzgxQixLQUFLOWUsS0FBSyxFQUFHO1lBQ2xCaUgsUUFBUXJmLE9BQU9zZixXQUFXLENBQUVsZSxNQUFNO1lBQ2xDLElBQUtpZSxNQUFNb1ksUUFBUSxJQUFJLE1BQU87Z0JBQzdCcFksTUFBTW9ZLFFBQVEsR0FBRztnQkFDakJOLFVBQVU5WCxNQUFNbk8sS0FBSyxDQUFDb0gsSUFBSTtnQkFDMUIrRyxNQUFNbk8sS0FBSyxDQUFDb0gsSUFBSSxHQUFHO29CQUNsQixJQUFLLENBQUMrRyxNQUFNb1ksUUFBUSxFQUFHO3dCQUN0Qk47b0JBQ0Q7Z0JBQ0Q7WUFDRDtZQUNBOVgsTUFBTW9ZLFFBQVE7WUFFZEYsS0FBSzFkLE1BQU0sQ0FBRTtnQkFFWiw4REFBOEQ7Z0JBQzlEMGQsS0FBSzFkLE1BQU0sQ0FBRTtvQkFDWndGLE1BQU1vWSxRQUFRO29CQUNkLElBQUssQ0FBQ3ozQixPQUFPb1ksS0FBSyxDQUFFaFgsTUFBTSxNQUFPWixNQUFNLEVBQUc7d0JBQ3pDNmUsTUFBTW5PLEtBQUssQ0FBQ29ILElBQUk7b0JBQ2pCO2dCQUNEO1lBQ0Q7UUFDRDtRQUVBLDhCQUE4QjtRQUM5QixJQUFNK0YsUUFBUXdKLE1BQVE7WUFDckIvaUIsUUFBUStpQixLQUFLLENBQUV4SixLQUFNO1lBQ3JCLElBQUs4WCxTQUFTN3hCLElBQUksQ0FBRVEsUUFBVTtnQkFDN0IsT0FBTytpQixLQUFLLENBQUV4SixLQUFNO2dCQUNwQnNELFNBQVNBLFVBQVU3YyxVQUFVO2dCQUM3QixJQUFLQSxVQUFZd3hCLENBQUFBLFNBQVMsU0FBUyxNQUFLLEdBQU07b0JBRTdDLCtDQUErQztvQkFDL0MsK0NBQStDO29CQUMvQyxJQUFLeHhCLFVBQVUsVUFBVTB5QixZQUFZQSxRQUFRLENBQUVuWixLQUFNLEtBQUt4YixXQUFZO3dCQUNyRXl6QixTQUFTO29CQUVWLHdDQUF3QztvQkFDeEMsT0FBTzt3QkFDTjtvQkFDRDtnQkFDRDtnQkFDQTVMLElBQUksQ0FBRXJNLEtBQU0sR0FBR21aLFlBQVlBLFFBQVEsQ0FBRW5aLEtBQU0sSUFBSXJlLE9BQU9zZ0IsS0FBSyxDQUFFbGYsTUFBTWlkO1lBQ3BFO1FBQ0Q7UUFFQSxrREFBa0Q7UUFDbEQrWSxZQUFZLENBQUNwM0IsT0FBT3dELGFBQWEsQ0FBRXFrQjtRQUNuQyxJQUFLLENBQUN1UCxhQUFhcDNCLE9BQU93RCxhQUFhLENBQUVrbkIsT0FBUztZQUNqRDtRQUNEO1FBRUEsaUVBQWlFO1FBQ2pFLElBQUs0TSxTQUFTbDJCLEtBQUs5QyxRQUFRLEtBQUssR0FBSTtZQUVuQyxxQ0FBcUM7WUFDckMsMkVBQTJFO1lBQzNFLHdFQUF3RTtZQUN4RSw2QkFBNkI7WUFDN0I0NEIsS0FBS1EsUUFBUSxHQUFHO2dCQUFFcFgsTUFBTW9YLFFBQVE7Z0JBQUVwWCxNQUFNcVgsU0FBUztnQkFBRXJYLE1BQU1zWCxTQUFTO2FBQUU7WUFFcEUsOEVBQThFO1lBQzlFUCxpQkFBaUJHLFlBQVlBLFNBQVNqWCxPQUFPO1lBQzdDLElBQUs4VyxrQkFBa0IsTUFBTztnQkFDN0JBLGlCQUFpQjlZLFNBQVM3ZCxHQUFHLENBQUVVLE1BQU07WUFDdEM7WUFDQW1mLFVBQVV2Z0IsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNO1lBQzVCLElBQUttZixZQUFZLFFBQVM7Z0JBQ3pCLElBQUs4VyxnQkFBaUI7b0JBQ3JCOVcsVUFBVThXO2dCQUNYLE9BQU87b0JBRU4sMERBQTBEO29CQUMxRDlWLFNBQVU7d0JBQUVuZ0I7cUJBQU0sRUFBRTtvQkFDcEJpMkIsaUJBQWlCajJCLEtBQUtrZixLQUFLLENBQUNDLE9BQU8sSUFBSThXO29CQUN2QzlXLFVBQVV2Z0IsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNO29CQUM1Qm1nQixTQUFVO3dCQUFFbmdCO3FCQUFNO2dCQUNuQjtZQUNEO1lBRUEsMENBQTBDO1lBQzFDLElBQUttZixZQUFZLFlBQVlBLFlBQVksa0JBQWtCOFcsa0JBQWtCLE1BQU87Z0JBQ25GLElBQUtyM0IsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNLGFBQWMsUUFBUztvQkFFN0MsNkVBQTZFO29CQUM3RSxJQUFLLENBQUNnMkIsV0FBWTt3QkFDakJHLEtBQUt6d0IsSUFBSSxDQUFFOzRCQUNWd1osTUFBTUMsT0FBTyxHQUFHOFc7d0JBQ2pCO3dCQUNBLElBQUtBLGtCQUFrQixNQUFPOzRCQUM3QjlXLFVBQVVELE1BQU1DLE9BQU87NEJBQ3ZCOFcsaUJBQWlCOVcsWUFBWSxTQUFTLEtBQUtBO3dCQUM1QztvQkFDRDtvQkFDQUQsTUFBTUMsT0FBTyxHQUFHO2dCQUNqQjtZQUNEO1FBQ0Q7UUFFQSxJQUFLMlcsS0FBS1EsUUFBUSxFQUFHO1lBQ3BCcFgsTUFBTW9YLFFBQVEsR0FBRztZQUNqQkgsS0FBSzFkLE1BQU0sQ0FBRTtnQkFDWnlHLE1BQU1vWCxRQUFRLEdBQUdSLEtBQUtRLFFBQVEsQ0FBRSxFQUFHO2dCQUNuQ3BYLE1BQU1xWCxTQUFTLEdBQUdULEtBQUtRLFFBQVEsQ0FBRSxFQUFHO2dCQUNwQ3BYLE1BQU1zWCxTQUFTLEdBQUdWLEtBQUtRLFFBQVEsQ0FBRSxFQUFHO1lBQ3JDO1FBQ0Q7UUFFQSxpQ0FBaUM7UUFDakNOLFlBQVk7UUFDWixJQUFNL1ksUUFBUXFNLEtBQU87WUFFcEIscURBQXFEO1lBQ3JELElBQUssQ0FBQzBNLFdBQVk7Z0JBQ2pCLElBQUtJLFVBQVc7b0JBQ2YsSUFBSyxZQUFZQSxVQUFXO3dCQUMzQmxCLFNBQVNrQixTQUFTbEIsTUFBTTtvQkFDekI7Z0JBQ0QsT0FBTztvQkFDTmtCLFdBQVdqWixTQUFTeEIsTUFBTSxDQUFFM2IsTUFBTSxVQUFVO3dCQUFFbWYsU0FBUzhXO29CQUFlO2dCQUN2RTtnQkFFQSxtRUFBbUU7Z0JBQ25FLElBQUsxVixRQUFTO29CQUNiNlYsU0FBU2xCLE1BQU0sR0FBRyxDQUFDQTtnQkFDcEI7Z0JBRUEsc0NBQXNDO2dCQUN0QyxJQUFLQSxRQUFTO29CQUNiL1UsU0FBVTt3QkFBRW5nQjtxQkFBTSxFQUFFO2dCQUNyQjtnQkFFQSwrQkFBK0IsR0FFL0JtMkIsS0FBS3p3QixJQUFJLENBQUU7b0JBRVYsOEJBQThCLEdBRTlCLHNFQUFzRTtvQkFDdEUsSUFBSyxDQUFDd3ZCLFFBQVM7d0JBQ2QvVSxTQUFVOzRCQUFFbmdCO3lCQUFNO29CQUNuQjtvQkFDQW1kLFNBQVM5RixNQUFNLENBQUVyWCxNQUFNO29CQUN2QixJQUFNaWQsUUFBUXFNLEtBQU87d0JBQ3BCMXFCLE9BQU9zZ0IsS0FBSyxDQUFFbGYsTUFBTWlkLE1BQU1xTSxJQUFJLENBQUVyTSxLQUFNO29CQUN2QztnQkFDRDtZQUNEO1lBRUEscUJBQXFCO1lBQ3JCK1ksWUFBWVAsWUFBYVAsU0FBU2tCLFFBQVEsQ0FBRW5aLEtBQU0sR0FBRyxHQUFHQSxNQUFNa1o7WUFDOUQsSUFBSyxDQUFHbFosQ0FBQUEsUUFBUW1aLFFBQU8sR0FBTTtnQkFDNUJBLFFBQVEsQ0FBRW5aLEtBQU0sR0FBRytZLFVBQVUvbkIsS0FBSztnQkFDbEMsSUFBS2luQixRQUFTO29CQUNiYyxVQUFVcjFCLEdBQUcsR0FBR3ExQixVQUFVL25CLEtBQUs7b0JBQy9CK25CLFVBQVUvbkIsS0FBSyxHQUFHO2dCQUNuQjtZQUNEO1FBQ0Q7SUFDRDtJQUVBLFNBQVN3b0IsV0FBWWhRLEtBQUssRUFBRWlRLGFBQWE7UUFDeEMsSUFBSWxoQixPQUFPeFUsTUFBTTZ5QixRQUFRbndCLE9BQU91YTtRQUVoQyxtREFBbUQ7UUFDbkQsSUFBTXpJLFNBQVNpUixNQUFRO1lBQ3RCemxCLE9BQU91YixVQUFXL0c7WUFDbEJxZSxTQUFTNkMsYUFBYSxDQUFFMTFCLEtBQU07WUFDOUIwQyxRQUFRK2lCLEtBQUssQ0FBRWpSLE1BQU87WUFDdEIsSUFBS2pVLE1BQU1DLE9BQU8sQ0FBRWtDLFFBQVU7Z0JBQzdCbXdCLFNBQVNud0IsS0FBSyxDQUFFLEVBQUc7Z0JBQ25CQSxRQUFRK2lCLEtBQUssQ0FBRWpSLE1BQU8sR0FBRzlSLEtBQUssQ0FBRSxFQUFHO1lBQ3BDO1lBRUEsSUFBSzhSLFVBQVV4VSxNQUFPO2dCQUNyQnlsQixLQUFLLENBQUV6bEIsS0FBTSxHQUFHMEM7Z0JBQ2hCLE9BQU8raUIsS0FBSyxDQUFFalIsTUFBTztZQUN0QjtZQUVBeUksUUFBUXJmLE9BQU93eUIsUUFBUSxDQUFFcHdCLEtBQU07WUFDL0IsSUFBS2lkLFNBQVMsWUFBWUEsT0FBUTtnQkFDakN2YSxRQUFRdWEsTUFBTXdWLE1BQU0sQ0FBRS92QjtnQkFDdEIsT0FBTytpQixLQUFLLENBQUV6bEIsS0FBTTtnQkFFcEIsMERBQTBEO2dCQUMxRCxxREFBcUQ7Z0JBQ3JELElBQU13VSxTQUFTOVIsTUFBUTtvQkFDdEIsSUFBSyxDQUFHOFIsQ0FBQUEsU0FBU2lSLEtBQUksR0FBTTt3QkFDMUJBLEtBQUssQ0FBRWpSLE1BQU8sR0FBRzlSLEtBQUssQ0FBRThSLE1BQU87d0JBQy9Ca2hCLGFBQWEsQ0FBRWxoQixNQUFPLEdBQUdxZTtvQkFDMUI7Z0JBQ0Q7WUFDRCxPQUFPO2dCQUNONkMsYUFBYSxDQUFFMTFCLEtBQU0sR0FBRzZ5QjtZQUN6QjtRQUNEO0lBQ0Q7SUFFQSxTQUFTOEIsVUFBVzMxQixJQUFJLEVBQUUyMkIsVUFBVSxFQUFFNTFCLE9BQU87UUFDNUMsSUFBSXdNLFFBQ0hxcEIsU0FDQXBoQixRQUFRLEdBQ1JwVyxTQUFTdTJCLFVBQVVrQixVQUFVLENBQUN6M0IsTUFBTSxFQUNwQ3NaLFdBQVc5WixPQUFPeVosUUFBUSxHQUFHSSxNQUFNLENBQUU7WUFFcEMsNkNBQTZDO1lBQzdDLE9BQU80YyxLQUFLcjFCLElBQUk7UUFDakIsSUFDQXExQixPQUFPO1lBQ04sSUFBS3VCLFNBQVU7Z0JBQ2QsT0FBTztZQUNSO1lBQ0EsSUFBSUUsY0FBY2pDLFNBQVNTLGVBQzFCL2EsWUFBWTVZLEtBQUt5dUIsR0FBRyxDQUFFLEdBQUdzRixVQUFVcUIsU0FBUyxHQUFHckIsVUFBVXhCLFFBQVEsR0FBRzRDLGNBRXBFLDRCQUE0QjtZQUM1QiwwRUFBMEU7WUFDMUV6a0IsT0FBT2tJLFlBQVltYixVQUFVeEIsUUFBUSxJQUFJLEdBQ3pDRixVQUFVLElBQUkzaEIsTUFDZG1ELFFBQVEsR0FDUnBXLFNBQVNzMkIsVUFBVXNCLE1BQU0sQ0FBQzUzQixNQUFNO1lBRWpDLE1BQVFvVyxRQUFRcFcsUUFBUW9XLFFBQVU7Z0JBQ2pDa2dCLFVBQVVzQixNQUFNLENBQUV4aEIsTUFBTyxDQUFDdWUsR0FBRyxDQUFFQztZQUNoQztZQUVBdGIsU0FBU2tCLFVBQVUsQ0FBRTVaLE1BQU07Z0JBQUUwMUI7Z0JBQVcxQjtnQkFBU3paO2FBQVc7WUFFNUQsK0JBQStCO1lBQy9CLElBQUt5WixVQUFVLEtBQUs1MEIsUUFBUztnQkFDNUIsT0FBT21iO1lBQ1I7WUFFQSwyRUFBMkU7WUFDM0UsSUFBSyxDQUFDbmIsUUFBUztnQkFDZHNaLFNBQVNrQixVQUFVLENBQUU1WixNQUFNO29CQUFFMDFCO29CQUFXO29CQUFHO2lCQUFHO1lBQy9DO1lBRUEsa0RBQWtEO1lBQ2xEaGQsU0FBU21CLFdBQVcsQ0FBRTdaLE1BQU07Z0JBQUUwMUI7YUFBVztZQUN6QyxPQUFPO1FBQ1IsR0FDQUEsWUFBWWhkLFNBQVNSLE9BQU8sQ0FBRTtZQUM3QmxZLE1BQU1BO1lBQ055bUIsT0FBTzduQixPQUFPa0MsTUFBTSxDQUFFLENBQUMsR0FBRzYxQjtZQUMxQmIsTUFBTWwzQixPQUFPa0MsTUFBTSxDQUFFLE1BQU07Z0JBQzFCNDFCLGVBQWUsQ0FBQztnQkFDaEI3QyxRQUFRajFCLE9BQU9pMUIsTUFBTSxDQUFDclMsUUFBUTtZQUMvQixHQUFHemdCO1lBQ0hrMkIsb0JBQW9CTjtZQUNwQk8saUJBQWlCbjJCO1lBQ2pCZzJCLFdBQVdsQyxTQUFTUztZQUNwQnBCLFVBQVVuekIsUUFBUW16QixRQUFRO1lBQzFCOEMsUUFBUSxFQUFFO1lBQ1Z2QixhQUFhLFNBQVV4WSxJQUFJLEVBQUV0YyxHQUFHO2dCQUMvQixJQUFJNGUsUUFBUTNnQixPQUFPZzFCLEtBQUssQ0FBRTV6QixNQUFNMDFCLFVBQVVJLElBQUksRUFBRTdZLE1BQU10YyxLQUNyRCswQixVQUFVSSxJQUFJLENBQUNZLGFBQWEsQ0FBRXpaLEtBQU0sSUFBSXlZLFVBQVVJLElBQUksQ0FBQ2pDLE1BQU07Z0JBQzlENkIsVUFBVXNCLE1BQU0sQ0FBQ3o2QixJQUFJLENBQUVnakI7Z0JBQ3ZCLE9BQU9BO1lBQ1I7WUFDQW5CLE1BQU0sU0FBVStZLE9BQU87Z0JBQ3RCLElBQUkzaEIsUUFBUSxHQUVYLDREQUE0RDtnQkFDNUQsOEJBQThCO2dCQUM5QnBXLFNBQVMrM0IsVUFBVXpCLFVBQVVzQixNQUFNLENBQUM1M0IsTUFBTSxHQUFHO2dCQUM5QyxJQUFLdzNCLFNBQVU7b0JBQ2QsT0FBTyxJQUFJO2dCQUNaO2dCQUNBQSxVQUFVO2dCQUNWLE1BQVFwaEIsUUFBUXBXLFFBQVFvVyxRQUFVO29CQUNqQ2tnQixVQUFVc0IsTUFBTSxDQUFFeGhCLE1BQU8sQ0FBQ3VlLEdBQUcsQ0FBRTtnQkFDaEM7Z0JBRUEsMkRBQTJEO2dCQUMzRCxJQUFLb0QsU0FBVTtvQkFDZHplLFNBQVNrQixVQUFVLENBQUU1WixNQUFNO3dCQUFFMDFCO3dCQUFXO3dCQUFHO3FCQUFHO29CQUM5Q2hkLFNBQVNtQixXQUFXLENBQUU3WixNQUFNO3dCQUFFMDFCO3dCQUFXeUI7cUJBQVM7Z0JBQ25ELE9BQU87b0JBQ056ZSxTQUFTc0IsVUFBVSxDQUFFaGEsTUFBTTt3QkFBRTAxQjt3QkFBV3lCO3FCQUFTO2dCQUNsRDtnQkFDQSxPQUFPLElBQUk7WUFDWjtRQUNELElBQ0ExUSxRQUFRaVAsVUFBVWpQLEtBQUs7UUFFeEJnUSxXQUFZaFEsT0FBT2lQLFVBQVVJLElBQUksQ0FBQ1ksYUFBYTtRQUUvQyxNQUFRbGhCLFFBQVFwVyxRQUFRb1csUUFBVTtZQUNqQ2pJLFNBQVNvb0IsVUFBVWtCLFVBQVUsQ0FBRXJoQixNQUFPLENBQUNwWixJQUFJLENBQUVzNUIsV0FBVzExQixNQUFNeW1CLE9BQU9pUCxVQUFVSSxJQUFJO1lBQ25GLElBQUt2b0IsUUFBUztnQkFDYixJQUFLdlEsV0FBWXVRLE9BQU82USxJQUFJLEdBQUs7b0JBQ2hDeGYsT0FBT3NmLFdBQVcsQ0FBRXdYLFVBQVUxMUIsSUFBSSxFQUFFMDFCLFVBQVVJLElBQUksQ0FBQzllLEtBQUssRUFBR29ILElBQUksR0FDOUQ3USxPQUFPNlEsSUFBSSxDQUFDZ1osSUFBSSxDQUFFN3BCO2dCQUNwQjtnQkFDQSxPQUFPQTtZQUNSO1FBQ0Q7UUFFQTNPLE9BQU9tQixHQUFHLENBQUUwbUIsT0FBT2dQLGFBQWFDO1FBRWhDLElBQUsxNEIsV0FBWTA0QixVQUFVSSxJQUFJLENBQUM3bkIsS0FBSyxHQUFLO1lBQ3pDeW5CLFVBQVVJLElBQUksQ0FBQzduQixLQUFLLENBQUM3UixJQUFJLENBQUU0RCxNQUFNMDFCO1FBQ2xDO1FBRUEsZ0NBQWdDO1FBQ2hDQSxVQUNFMWMsUUFBUSxDQUFFMGMsVUFBVUksSUFBSSxDQUFDOWMsUUFBUSxFQUNqQ3RULElBQUksQ0FBRWd3QixVQUFVSSxJQUFJLENBQUNwd0IsSUFBSSxFQUFFZ3dCLFVBQVVJLElBQUksQ0FBQ3VCLFFBQVEsRUFDbERsZixJQUFJLENBQUV1ZCxVQUFVSSxJQUFJLENBQUMzZCxJQUFJLEVBQ3pCTSxNQUFNLENBQUVpZCxVQUFVSSxJQUFJLENBQUNyZCxNQUFNO1FBRS9CN1osT0FBT3kxQixFQUFFLENBQUNpRCxLQUFLLENBQ2QxNEIsT0FBT2tDLE1BQU0sQ0FBRXUwQixNQUFNO1lBQ3BCcjFCLE1BQU1BO1lBQ05tMkIsTUFBTVQ7WUFDTjFlLE9BQU8wZSxVQUFVSSxJQUFJLENBQUM5ZSxLQUFLO1FBQzVCO1FBR0QsT0FBTzBlO0lBQ1I7SUFFQTkyQixPQUFPKzJCLFNBQVMsR0FBRy8yQixPQUFPa0MsTUFBTSxDQUFFNjBCLFdBQVc7UUFFNUNDLFVBQVU7WUFDVCxLQUFLO2dCQUFFLFNBQVUzWSxJQUFJLEVBQUV2WixLQUFLO29CQUMzQixJQUFJNmIsUUFBUSxJQUFJLENBQUNrVyxXQUFXLENBQUV4WSxNQUFNdlo7b0JBQ3BDMmIsVUFBV0UsTUFBTXZmLElBQUksRUFBRWlkLE1BQU0yQixRQUFReFYsSUFBSSxDQUFFMUYsUUFBUzZiO29CQUNwRCxPQUFPQTtnQkFDUjthQUFHO1FBQ0o7UUFFQWdZLFNBQVMsU0FBVTlRLEtBQUssRUFBRTNtQixRQUFRO1lBQ2pDLElBQUs5QyxXQUFZeXBCLFFBQVU7Z0JBQzFCM21CLFdBQVcybUI7Z0JBQ1hBLFFBQVE7b0JBQUU7aUJBQUs7WUFDaEIsT0FBTztnQkFDTkEsUUFBUUEsTUFBTXpkLEtBQUssQ0FBRXFOO1lBQ3RCO1lBRUEsSUFBSTRHLE1BQ0h6SCxRQUFRLEdBQ1JwVyxTQUFTcW5CLE1BQU1ybkIsTUFBTTtZQUV0QixNQUFRb1csUUFBUXBXLFFBQVFvVyxRQUFVO2dCQUNqQ3lILE9BQU93SixLQUFLLENBQUVqUixNQUFPO2dCQUNyQm1nQixVQUFVQyxRQUFRLENBQUUzWSxLQUFNLEdBQUcwWSxVQUFVQyxRQUFRLENBQUUzWSxLQUFNLElBQUksRUFBRTtnQkFDN0QwWSxVQUFVQyxRQUFRLENBQUUzWSxLQUFNLENBQUNrQixPQUFPLENBQUVyZTtZQUNyQztRQUNEO1FBRUErMkIsWUFBWTtZQUFFaEI7U0FBa0I7UUFFaEMyQixXQUFXLFNBQVUxM0IsUUFBUSxFQUFFc3JCLE9BQU87WUFDckMsSUFBS0EsU0FBVTtnQkFDZHVLLFVBQVVrQixVQUFVLENBQUMxWSxPQUFPLENBQUVyZTtZQUMvQixPQUFPO2dCQUNONjFCLFVBQVVrQixVQUFVLENBQUN0NkIsSUFBSSxDQUFFdUQ7WUFDNUI7UUFDRDtJQUNEO0lBRUFsQixPQUFPNjRCLEtBQUssR0FBRyxTQUFVQSxLQUFLLEVBQUU1RCxNQUFNLEVBQUU5MEIsRUFBRTtRQUN6QyxJQUFJMjRCLE1BQU1ELFNBQVMsT0FBT0EsVUFBVSxXQUFXNzRCLE9BQU9rQyxNQUFNLENBQUUsQ0FBQyxHQUFHMjJCLFNBQVU7WUFDM0VKLFVBQVV0NEIsTUFBTSxDQUFDQSxNQUFNODBCLFVBQ3RCNzJCLFdBQVl5NkIsVUFBV0E7WUFDeEJ2RCxVQUFVdUQ7WUFDVjVELFFBQVE5MEIsTUFBTTgwQixVQUFVQSxVQUFVLENBQUM3MkIsV0FBWTYyQixXQUFZQTtRQUM1RDtRQUVBLG9DQUFvQztRQUNwQyxJQUFLajFCLE9BQU95MUIsRUFBRSxDQUFDalIsR0FBRyxFQUFHO1lBQ3BCc1UsSUFBSXhELFFBQVEsR0FBRztRQUVoQixPQUFPO1lBQ04sSUFBSyxPQUFPd0QsSUFBSXhELFFBQVEsS0FBSyxVQUFXO2dCQUN2QyxJQUFLd0QsSUFBSXhELFFBQVEsSUFBSXQxQixPQUFPeTFCLEVBQUUsQ0FBQ3NELE1BQU0sRUFBRztvQkFDdkNELElBQUl4RCxRQUFRLEdBQUd0MUIsT0FBT3kxQixFQUFFLENBQUNzRCxNQUFNLENBQUVELElBQUl4RCxRQUFRLENBQUU7Z0JBRWhELE9BQU87b0JBQ053RCxJQUFJeEQsUUFBUSxHQUFHdDFCLE9BQU95MUIsRUFBRSxDQUFDc0QsTUFBTSxDQUFDblcsUUFBUTtnQkFDekM7WUFDRDtRQUNEO1FBRUEsb0RBQW9EO1FBQ3BELElBQUtrVyxJQUFJMWdCLEtBQUssSUFBSSxRQUFRMGdCLElBQUkxZ0IsS0FBSyxLQUFLLE1BQU87WUFDOUMwZ0IsSUFBSTFnQixLQUFLLEdBQUc7UUFDYjtRQUVBLFdBQVc7UUFDWDBnQixJQUFJcEwsR0FBRyxHQUFHb0wsSUFBSUwsUUFBUTtRQUV0QkssSUFBSUwsUUFBUSxHQUFHO1lBQ2QsSUFBS3I2QixXQUFZMDZCLElBQUlwTCxHQUFHLEdBQUs7Z0JBQzVCb0wsSUFBSXBMLEdBQUcsQ0FBQ2x3QixJQUFJLENBQUUsSUFBSTtZQUNuQjtZQUVBLElBQUtzN0IsSUFBSTFnQixLQUFLLEVBQUc7Z0JBQ2hCcFksT0FBT21mLE9BQU8sQ0FBRSxJQUFJLEVBQUUyWixJQUFJMWdCLEtBQUs7WUFDaEM7UUFDRDtRQUVBLE9BQU8wZ0I7SUFDUjtJQUVBOTRCLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQjgyQixRQUFRLFNBQVVILEtBQUssRUFBRUksRUFBRSxFQUFFaEUsTUFBTSxFQUFFL3pCLFFBQVE7WUFFNUMsc0RBQXNEO1lBQ3RELE9BQU8sSUFBSSxDQUFDOEwsTUFBTSxDQUFFcVQsb0JBQXFCRyxHQUFHLENBQUUsV0FBVyxHQUFJZ0IsSUFBSSxFQUVoRSxpQ0FBaUM7YUFDaEN6ZixHQUFHLEdBQUdtM0IsT0FBTyxDQUFFO2dCQUFFekcsU0FBU3dHO1lBQUcsR0FBR0osT0FBTzVELFFBQVEvekI7UUFDbEQ7UUFDQWc0QixTQUFTLFNBQVU3YSxJQUFJLEVBQUV3YSxLQUFLLEVBQUU1RCxNQUFNLEVBQUUvekIsUUFBUTtZQUMvQyxJQUFJZ1EsUUFBUWxSLE9BQU93RCxhQUFhLENBQUU2YSxPQUNqQzhhLFNBQVNuNUIsT0FBTzY0QixLQUFLLENBQUVBLE9BQU81RCxRQUFRL3pCLFdBQ3RDazRCLGNBQWM7Z0JBRWIsaUVBQWlFO2dCQUNqRSxJQUFJN0IsT0FBT1IsVUFBVyxJQUFJLEVBQUUvMkIsT0FBT2tDLE1BQU0sQ0FBRSxDQUFDLEdBQUdtYyxPQUFROGE7Z0JBRXZELHNEQUFzRDtnQkFDdEQsSUFBS2pvQixTQUFTcU4sU0FBUzdkLEdBQUcsQ0FBRSxJQUFJLEVBQUUsV0FBYTtvQkFDOUM2MkIsS0FBSy9YLElBQUksQ0FBRTtnQkFDWjtZQUNEO1lBRUQ0WixZQUFZQyxNQUFNLEdBQUdEO1lBRXJCLE9BQU9sb0IsU0FBU2lvQixPQUFPL2dCLEtBQUssS0FBSyxRQUNoQyxJQUFJLENBQUNuWCxJQUFJLENBQUVtNEIsZUFDWCxJQUFJLENBQUNoaEIsS0FBSyxDQUFFK2dCLE9BQU8vZ0IsS0FBSyxFQUFFZ2hCO1FBQzVCO1FBQ0E1WixNQUFNLFNBQVU5Z0IsSUFBSSxFQUFFZ2hCLFVBQVUsRUFBRTZZLE9BQU87WUFDeEMsSUFBSWUsWUFBWSxTQUFVamEsS0FBSztnQkFDOUIsSUFBSUcsT0FBT0gsTUFBTUcsSUFBSTtnQkFDckIsT0FBT0gsTUFBTUcsSUFBSTtnQkFDakJBLEtBQU0rWTtZQUNQO1lBRUEsSUFBSyxPQUFPNzVCLFNBQVMsVUFBVztnQkFDL0I2NUIsVUFBVTdZO2dCQUNWQSxhQUFhaGhCO2dCQUNiQSxPQUFPbUU7WUFDUjtZQUNBLElBQUs2YyxZQUFhO2dCQUNqQixJQUFJLENBQUN0SCxLQUFLLENBQUUxWixRQUFRLE1BQU0sRUFBRTtZQUM3QjtZQUVBLE9BQU8sSUFBSSxDQUFDdUMsSUFBSSxDQUFFO2dCQUNqQixJQUFJa2UsVUFBVSxNQUNidkksUUFBUWxZLFFBQVEsUUFBUUEsT0FBTyxjQUMvQjY2QixTQUFTdjVCLE9BQU91NUIsTUFBTSxFQUN0Qm5iLE9BQU9HLFNBQVM3ZCxHQUFHLENBQUUsSUFBSTtnQkFFMUIsSUFBS2tXLE9BQVE7b0JBQ1osSUFBS3dILElBQUksQ0FBRXhILE1BQU8sSUFBSXdILElBQUksQ0FBRXhILE1BQU8sQ0FBQzRJLElBQUksRUFBRzt3QkFDMUM4WixVQUFXbGIsSUFBSSxDQUFFeEgsTUFBTztvQkFDekI7Z0JBQ0QsT0FBTztvQkFDTixJQUFNQSxTQUFTd0gsS0FBTzt3QkFDckIsSUFBS0EsSUFBSSxDQUFFeEgsTUFBTyxJQUFJd0gsSUFBSSxDQUFFeEgsTUFBTyxDQUFDNEksSUFBSSxJQUFJNFcsS0FBSzl4QixJQUFJLENBQUVzUyxRQUFVOzRCQUNoRTBpQixVQUFXbGIsSUFBSSxDQUFFeEgsTUFBTzt3QkFDekI7b0JBQ0Q7Z0JBQ0Q7Z0JBRUEsSUFBTUEsUUFBUTJpQixPQUFPLzRCLE1BQU0sRUFBRW9XLFNBQVc7b0JBQ3ZDLElBQUsyaUIsTUFBTSxDQUFFM2lCLE1BQU8sQ0FBQ3hWLElBQUksS0FBSyxJQUFJLElBQy9CMUMsQ0FBQUEsUUFBUSxRQUFRNjZCLE1BQU0sQ0FBRTNpQixNQUFPLENBQUN3QixLQUFLLEtBQUsxWixJQUFHLEdBQU07d0JBRXJENjZCLE1BQU0sQ0FBRTNpQixNQUFPLENBQUMyZ0IsSUFBSSxDQUFDL1gsSUFBSSxDQUFFK1k7d0JBQzNCcFosVUFBVTt3QkFDVm9hLE9BQU90M0IsTUFBTSxDQUFFMlUsT0FBTztvQkFDdkI7Z0JBQ0Q7Z0JBRUEsOERBQThEO2dCQUM5RCw2REFBNkQ7Z0JBQzdELDhDQUE4QztnQkFDOUMsSUFBS3VJLFdBQVcsQ0FBQ29aLFNBQVU7b0JBQzFCdjRCLE9BQU9tZixPQUFPLENBQUUsSUFBSSxFQUFFemdCO2dCQUN2QjtZQUNEO1FBQ0Q7UUFDQTI2QixRQUFRLFNBQVUzNkIsSUFBSTtZQUNyQixJQUFLQSxTQUFTLE9BQVE7Z0JBQ3JCQSxPQUFPQSxRQUFRO1lBQ2hCO1lBQ0EsT0FBTyxJQUFJLENBQUN1QyxJQUFJLENBQUU7Z0JBQ2pCLElBQUkyVixPQUNId0gsT0FBT0csU0FBUzdkLEdBQUcsQ0FBRSxJQUFJLEdBQ3pCMFgsUUFBUWdHLElBQUksQ0FBRTFmLE9BQU8sUUFBUyxFQUM5QjJnQixRQUFRakIsSUFBSSxDQUFFMWYsT0FBTyxhQUFjLEVBQ25DNjZCLFNBQVN2NUIsT0FBT3U1QixNQUFNLEVBQ3RCLzRCLFNBQVM0WCxRQUFRQSxNQUFNNVgsTUFBTSxHQUFHO2dCQUVqQyx3Q0FBd0M7Z0JBQ3hDNGQsS0FBS2liLE1BQU0sR0FBRztnQkFFZCx3QkFBd0I7Z0JBQ3hCcjVCLE9BQU9vWSxLQUFLLENBQUUsSUFBSSxFQUFFMVosTUFBTSxFQUFFO2dCQUU1QixJQUFLMmdCLFNBQVNBLE1BQU1HLElBQUksRUFBRztvQkFDMUJILE1BQU1HLElBQUksQ0FBQ2hpQixJQUFJLENBQUUsSUFBSSxFQUFFO2dCQUN4QjtnQkFFQSxrREFBa0Q7Z0JBQ2xELElBQU1vWixRQUFRMmlCLE9BQU8vNEIsTUFBTSxFQUFFb1csU0FBVztvQkFDdkMsSUFBSzJpQixNQUFNLENBQUUzaUIsTUFBTyxDQUFDeFYsSUFBSSxLQUFLLElBQUksSUFBSW00QixNQUFNLENBQUUzaUIsTUFBTyxDQUFDd0IsS0FBSyxLQUFLMVosTUFBTzt3QkFDdEU2NkIsTUFBTSxDQUFFM2lCLE1BQU8sQ0FBQzJnQixJQUFJLENBQUMvWCxJQUFJLENBQUU7d0JBQzNCK1osT0FBT3QzQixNQUFNLENBQUUyVSxPQUFPO29CQUN2QjtnQkFDRDtnQkFFQSwyREFBMkQ7Z0JBQzNELElBQU1BLFFBQVEsR0FBR0EsUUFBUXBXLFFBQVFvVyxRQUFVO29CQUMxQyxJQUFLd0IsS0FBSyxDQUFFeEIsTUFBTyxJQUFJd0IsS0FBSyxDQUFFeEIsTUFBTyxDQUFDeWlCLE1BQU0sRUFBRzt3QkFDOUNqaEIsS0FBSyxDQUFFeEIsTUFBTyxDQUFDeWlCLE1BQU0sQ0FBQzc3QixJQUFJLENBQUUsSUFBSTtvQkFDakM7Z0JBQ0Q7Z0JBRUEsMEJBQTBCO2dCQUMxQixPQUFPNGdCLEtBQUtpYixNQUFNO1lBQ25CO1FBQ0Q7SUFDRDtJQUVBcjVCLE9BQU9pQixJQUFJLENBQUU7UUFBRTtRQUFVO1FBQVE7S0FBUSxFQUFFLFNBQVVrRSxFQUFFLEVBQUUvQyxJQUFJO1FBQzVELElBQUlvM0IsUUFBUXg1QixPQUFPRyxFQUFFLENBQUVpQyxLQUFNO1FBQzdCcEMsT0FBT0csRUFBRSxDQUFFaUMsS0FBTSxHQUFHLFNBQVV5MkIsS0FBSyxFQUFFNUQsTUFBTSxFQUFFL3pCLFFBQVE7WUFDcEQsT0FBTzIzQixTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUN4Q1csTUFBTTk3QixLQUFLLENBQUUsSUFBSSxFQUFFMkQsYUFDbkIsSUFBSSxDQUFDNjNCLE9BQU8sQ0FBRXZDLE1BQU92MEIsTUFBTSxPQUFReTJCLE9BQU81RCxRQUFRL3pCO1FBQ3BEO0lBQ0Q7SUFFQSwyQ0FBMkM7SUFDM0NsQixPQUFPaUIsSUFBSSxDQUFFO1FBQ1p3NEIsV0FBVzlDLE1BQU87UUFDbEIrQyxTQUFTL0MsTUFBTztRQUNoQmdELGFBQWFoRCxNQUFPO1FBQ3BCaUQsUUFBUTtZQUFFbkgsU0FBUztRQUFPO1FBQzFCb0gsU0FBUztZQUFFcEgsU0FBUztRQUFPO1FBQzNCcUgsWUFBWTtZQUFFckgsU0FBUztRQUFTO0lBQ2pDLEdBQUcsU0FBVXJ3QixJQUFJLEVBQUV5bEIsS0FBSztRQUN2QjduQixPQUFPRyxFQUFFLENBQUVpQyxLQUFNLEdBQUcsU0FBVXkyQixLQUFLLEVBQUU1RCxNQUFNLEVBQUUvekIsUUFBUTtZQUNwRCxPQUFPLElBQUksQ0FBQ2c0QixPQUFPLENBQUVyUixPQUFPZ1IsT0FBTzVELFFBQVEvekI7UUFDNUM7SUFDRDtJQUVBbEIsT0FBT3U1QixNQUFNLEdBQUcsRUFBRTtJQUNsQnY1QixPQUFPeTFCLEVBQUUsQ0FBQ2dCLElBQUksR0FBRztRQUNoQixJQUFJaUMsT0FDSHg1QixJQUFJLEdBQ0pxNkIsU0FBU3Y1QixPQUFPdTVCLE1BQU07UUFFdkJ0RCxRQUFRL04sS0FBS0MsR0FBRztRQUVoQixNQUFRanBCLElBQUlxNkIsT0FBTy80QixNQUFNLEVBQUV0QixJQUFNO1lBQ2hDdzVCLFFBQVFhLE1BQU0sQ0FBRXI2QixFQUFHO1lBRW5CLCtFQUErRTtZQUMvRSxJQUFLLENBQUN3NUIsV0FBV2EsTUFBTSxDQUFFcjZCLEVBQUcsS0FBS3c1QixPQUFRO2dCQUN4Q2EsT0FBT3QzQixNQUFNLENBQUUvQyxLQUFLO1lBQ3JCO1FBQ0Q7UUFFQSxJQUFLLENBQUNxNkIsT0FBTy80QixNQUFNLEVBQUc7WUFDckJSLE9BQU95MUIsRUFBRSxDQUFDalcsSUFBSTtRQUNmO1FBQ0F5VyxRQUFRcHpCO0lBQ1Q7SUFFQTdDLE9BQU95MUIsRUFBRSxDQUFDaUQsS0FBSyxHQUFHLFNBQVVBLEtBQUs7UUFDaEMxNEIsT0FBT3U1QixNQUFNLENBQUM1N0IsSUFBSSxDQUFFKzZCO1FBQ3BCMTRCLE9BQU95MUIsRUFBRSxDQUFDcG1CLEtBQUs7SUFDaEI7SUFFQXJQLE9BQU95MUIsRUFBRSxDQUFDZSxRQUFRLEdBQUc7SUFDckJ4MkIsT0FBT3kxQixFQUFFLENBQUNwbUIsS0FBSyxHQUFHO1FBQ2pCLElBQUs2bUIsWUFBYTtZQUNqQjtRQUNEO1FBRUFBLGFBQWE7UUFDYkc7SUFDRDtJQUVBcjJCLE9BQU95MUIsRUFBRSxDQUFDalcsSUFBSSxHQUFHO1FBQ2hCMFcsYUFBYTtJQUNkO0lBRUFsMkIsT0FBT3kxQixFQUFFLENBQUNzRCxNQUFNLEdBQUc7UUFDbEJnQixNQUFNO1FBQ05DLE1BQU07UUFFTixnQkFBZ0I7UUFDaEJwWCxVQUFVO0lBQ1g7SUFHQSw2REFBNkQ7SUFDN0Q1aUIsT0FBT0csRUFBRSxDQUFDODVCLEtBQUssR0FBRyxTQUFVQyxJQUFJLEVBQUV4N0IsSUFBSTtRQUNyQ3c3QixPQUFPbDZCLE9BQU95MUIsRUFBRSxHQUFHejFCLE9BQU95MUIsRUFBRSxDQUFDc0QsTUFBTSxDQUFFbUIsS0FBTSxJQUFJQSxPQUFPQTtRQUN0RHg3QixPQUFPQSxRQUFRO1FBRWYsT0FBTyxJQUFJLENBQUMwWixLQUFLLENBQUUxWixNQUFNLFNBQVUrSyxJQUFJLEVBQUU0VixLQUFLO1lBQzdDLElBQUk4YSxVQUFVcDlCLFFBQU93ZSxVQUFVLENBQUU5UixNQUFNeXdCO1lBQ3ZDN2EsTUFBTUcsSUFBSSxHQUFHO2dCQUNaemlCLFFBQU9xOUIsWUFBWSxDQUFFRDtZQUN0QjtRQUNEO0lBQ0Q7SUFHRTtRQUNELElBQUk5c0IsUUFBUXpRLFNBQVN5QyxhQUFhLENBQUUsVUFDbkNnTSxTQUFTek8sU0FBU3lDLGFBQWEsQ0FBRSxXQUNqQ3k1QixNQUFNenRCLE9BQU8zTCxXQUFXLENBQUU5QyxTQUFTeUMsYUFBYSxDQUFFO1FBRW5EZ08sTUFBTTNPLElBQUksR0FBRztRQUViLDhCQUE4QjtRQUM5Qiw4Q0FBOEM7UUFDOUNQLFFBQVFrOEIsT0FBTyxHQUFHaHRCLE1BQU12SSxLQUFLLEtBQUs7UUFFbEMsd0JBQXdCO1FBQ3hCLDJEQUEyRDtRQUMzRDNHLFFBQVFtOEIsV0FBVyxHQUFHeEIsSUFBSTluQixRQUFRO1FBRWxDLHdCQUF3QjtRQUN4QixrREFBa0Q7UUFDbEQzRCxRQUFRelEsU0FBU3lDLGFBQWEsQ0FBRTtRQUNoQ2dPLE1BQU12SSxLQUFLLEdBQUc7UUFDZHVJLE1BQU0zTyxJQUFJLEdBQUc7UUFDYlAsUUFBUW84QixVQUFVLEdBQUdsdEIsTUFBTXZJLEtBQUssS0FBSztJQUN0QztJQUdBLElBQUkwMUIsVUFDSDNzQixhQUFhN04sT0FBT3lOLElBQUksQ0FBQ0ksVUFBVTtJQUVwQzdOLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQjBMLE1BQU0sU0FBVXhMLElBQUksRUFBRTBDLEtBQUs7WUFDMUIsT0FBT2lZLE9BQVEsSUFBSSxFQUFFL2MsT0FBTzROLElBQUksRUFBRXhMLE1BQU0wQyxPQUFPekQsVUFBVWIsTUFBTSxHQUFHO1FBQ25FO1FBRUFpNkIsWUFBWSxTQUFVcjRCLElBQUk7WUFDekIsT0FBTyxJQUFJLENBQUNuQixJQUFJLENBQUU7Z0JBQ2pCakIsT0FBT3k2QixVQUFVLENBQUUsSUFBSSxFQUFFcjRCO1lBQzFCO1FBQ0Q7SUFDRDtJQUVBcEMsT0FBT2tDLE1BQU0sQ0FBRTtRQUNkMEwsTUFBTSxTQUFVeE0sSUFBSSxFQUFFZ0IsSUFBSSxFQUFFMEMsS0FBSztZQUNoQyxJQUFJaEUsS0FBS3VlLE9BQ1JxYixRQUFRdDVCLEtBQUs5QyxRQUFRO1lBRXRCLGdFQUFnRTtZQUNoRSxJQUFLbzhCLFVBQVUsS0FBS0EsVUFBVSxLQUFLQSxVQUFVLEdBQUk7Z0JBQ2hEO1lBQ0Q7WUFFQSxxREFBcUQ7WUFDckQsSUFBSyxPQUFPdDVCLEtBQUs3QixZQUFZLEtBQUssYUFBYztnQkFDL0MsT0FBT1MsT0FBT3FlLElBQUksQ0FBRWpkLE1BQU1nQixNQUFNMEM7WUFDakM7WUFFQSwwREFBMEQ7WUFDMUQsd0NBQXdDO1lBQ3hDLElBQUs0MUIsVUFBVSxLQUFLLENBQUMxNkIsT0FBT2lFLFFBQVEsQ0FBRTdDLE9BQVM7Z0JBQzlDaWUsUUFBUXJmLE9BQU8yNkIsU0FBUyxDQUFFdjRCLEtBQUtnRCxXQUFXLEdBQUksSUFDM0NwRixDQUFBQSxPQUFPeU4sSUFBSSxDQUFDckQsS0FBSyxDQUFDOUIsSUFBSSxDQUFDaEUsSUFBSSxDQUFFbEMsUUFBU280QixXQUFXMzNCLFNBQVE7WUFDN0Q7WUFFQSxJQUFLaUMsVUFBVWpDLFdBQVk7Z0JBQzFCLElBQUtpQyxVQUFVLE1BQU87b0JBQ3JCOUUsT0FBT3k2QixVQUFVLENBQUVyNUIsTUFBTWdCO29CQUN6QjtnQkFDRDtnQkFFQSxJQUFLaWQsU0FBUyxTQUFTQSxTQUN0QixDQUFFdmUsTUFBTXVlLE1BQU1sQixHQUFHLENBQUUvYyxNQUFNMEQsT0FBTzFDLEtBQUssTUFBUVMsV0FBWTtvQkFDekQsT0FBTy9CO2dCQUNSO2dCQUVBTSxLQUFLNUIsWUFBWSxDQUFFNEMsTUFBTTBDLFFBQVE7Z0JBQ2pDLE9BQU9BO1lBQ1I7WUFFQSxJQUFLdWEsU0FBUyxTQUFTQSxTQUFTLENBQUV2ZSxNQUFNdWUsTUFBTTNlLEdBQUcsQ0FBRVUsTUFBTWdCLEtBQUssTUFBUSxNQUFPO2dCQUM1RSxPQUFPdEI7WUFDUjtZQUVBQSxNQUFNZCxPQUFPZ0ssSUFBSSxDQUFDNEQsSUFBSSxDQUFFeE0sTUFBTWdCO1lBRTlCLGlFQUFpRTtZQUNqRSxPQUFPdEIsT0FBTyxPQUFPK0IsWUFBWS9CO1FBQ2xDO1FBRUE2NUIsV0FBVztZQUNWajhCLE1BQU07Z0JBQ0x5ZixLQUFLLFNBQVUvYyxJQUFJLEVBQUUwRCxLQUFLO29CQUN6QixJQUFLLENBQUMzRyxRQUFRbzhCLFVBQVUsSUFBSXoxQixVQUFVLFdBQ3JDUCxTQUFVbkQsTUFBTSxVQUFZO3dCQUM1QixJQUFJakMsTUFBTWlDLEtBQUswRCxLQUFLO3dCQUNwQjFELEtBQUs1QixZQUFZLENBQUUsUUFBUXNGO3dCQUMzQixJQUFLM0YsS0FBTTs0QkFDVmlDLEtBQUswRCxLQUFLLEdBQUczRjt3QkFDZDt3QkFDQSxPQUFPMkY7b0JBQ1I7Z0JBQ0Q7WUFDRDtRQUNEO1FBRUEyMUIsWUFBWSxTQUFVcjVCLElBQUksRUFBRTBELEtBQUs7WUFDaEMsSUFBSTFDLE1BQ0hsRCxJQUFJLEdBRUosNkRBQTZEO1lBQzdELGtFQUFrRTtZQUNsRTA3QixZQUFZOTFCLFNBQVNBLE1BQU1zRixLQUFLLENBQUVxTjtZQUVuQyxJQUFLbWpCLGFBQWF4NUIsS0FBSzlDLFFBQVEsS0FBSyxHQUFJO2dCQUN2QyxNQUFVOEQsT0FBT3c0QixTQUFTLENBQUUxN0IsSUFBSyxDQUFLO29CQUNyQ2tDLEtBQUtnSyxlQUFlLENBQUVoSjtnQkFDdkI7WUFDRDtRQUNEO0lBQ0Q7SUFFQSwrQkFBK0I7SUFDL0JvNEIsV0FBVztRQUNWcmMsS0FBSyxTQUFVL2MsSUFBSSxFQUFFMEQsS0FBSyxFQUFFMUMsSUFBSTtZQUMvQixJQUFLMEMsVUFBVSxPQUFRO2dCQUV0Qiw4Q0FBOEM7Z0JBQzlDOUUsT0FBT3k2QixVQUFVLENBQUVyNUIsTUFBTWdCO1lBQzFCLE9BQU87Z0JBQ05oQixLQUFLNUIsWUFBWSxDQUFFNEMsTUFBTUE7WUFDMUI7WUFDQSxPQUFPQTtRQUNSO0lBQ0Q7SUFFQXBDLE9BQU9pQixJQUFJLENBQUVqQixPQUFPeU4sSUFBSSxDQUFDckQsS0FBSyxDQUFDOUIsSUFBSSxDQUFDeVgsTUFBTSxDQUFDM1YsS0FBSyxDQUFFLFNBQVUsU0FBVWpGLEVBQUUsRUFBRS9DLElBQUk7UUFDN0UsSUFBSXk0QixTQUFTaHRCLFVBQVUsQ0FBRXpMLEtBQU0sSUFBSXBDLE9BQU9nSyxJQUFJLENBQUM0RCxJQUFJO1FBRW5EQyxVQUFVLENBQUV6TCxLQUFNLEdBQUcsU0FBVWhCLElBQUksRUFBRWdCLElBQUksRUFBRWdULEtBQUs7WUFDL0MsSUFBSXRVLEtBQUtxa0IsUUFDUjJWLGdCQUFnQjE0QixLQUFLZ0QsV0FBVztZQUVqQyxJQUFLLENBQUNnUSxPQUFRO2dCQUViLCtFQUErRTtnQkFDL0UrUCxTQUFTdFgsVUFBVSxDQUFFaXRCLGNBQWU7Z0JBQ3BDanRCLFVBQVUsQ0FBRWl0QixjQUFlLEdBQUdoNkI7Z0JBQzlCQSxNQUFNKzVCLE9BQVF6NUIsTUFBTWdCLE1BQU1nVCxVQUFXLE9BQ3BDMGxCLGdCQUNBO2dCQUNEanRCLFVBQVUsQ0FBRWl0QixjQUFlLEdBQUczVjtZQUMvQjtZQUNBLE9BQU9ya0I7UUFDUjtJQUNEO0lBS0EsSUFBSWk2QixhQUFhLHVDQUNoQkMsYUFBYTtJQUVkaDdCLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQm1jLE1BQU0sU0FBVWpjLElBQUksRUFBRTBDLEtBQUs7WUFDMUIsT0FBT2lZLE9BQVEsSUFBSSxFQUFFL2MsT0FBT3FlLElBQUksRUFBRWpjLE1BQU0wQyxPQUFPekQsVUFBVWIsTUFBTSxHQUFHO1FBQ25FO1FBRUF5NkIsWUFBWSxTQUFVNzRCLElBQUk7WUFDekIsT0FBTyxJQUFJLENBQUNuQixJQUFJLENBQUU7Z0JBQ2pCLE9BQU8sSUFBSSxDQUFFakIsT0FBT2s3QixPQUFPLENBQUU5NEIsS0FBTSxJQUFJQSxLQUFNO1lBQzlDO1FBQ0Q7SUFDRDtJQUVBcEMsT0FBT2tDLE1BQU0sQ0FBRTtRQUNkbWMsTUFBTSxTQUFVamQsSUFBSSxFQUFFZ0IsSUFBSSxFQUFFMEMsS0FBSztZQUNoQyxJQUFJaEUsS0FBS3VlLE9BQ1JxYixRQUFRdDVCLEtBQUs5QyxRQUFRO1lBRXRCLGdFQUFnRTtZQUNoRSxJQUFLbzhCLFVBQVUsS0FBS0EsVUFBVSxLQUFLQSxVQUFVLEdBQUk7Z0JBQ2hEO1lBQ0Q7WUFFQSxJQUFLQSxVQUFVLEtBQUssQ0FBQzE2QixPQUFPaUUsUUFBUSxDQUFFN0MsT0FBUztnQkFFOUMsNEJBQTRCO2dCQUM1QmdCLE9BQU9wQyxPQUFPazdCLE9BQU8sQ0FBRTk0QixLQUFNLElBQUlBO2dCQUNqQ2lkLFFBQVFyZixPQUFPazFCLFNBQVMsQ0FBRTl5QixLQUFNO1lBQ2pDO1lBRUEsSUFBSzBDLFVBQVVqQyxXQUFZO2dCQUMxQixJQUFLd2MsU0FBUyxTQUFTQSxTQUN0QixDQUFFdmUsTUFBTXVlLE1BQU1sQixHQUFHLENBQUUvYyxNQUFNMEQsT0FBTzFDLEtBQUssTUFBUVMsV0FBWTtvQkFDekQsT0FBTy9CO2dCQUNSO2dCQUVBLE9BQVNNLElBQUksQ0FBRWdCLEtBQU0sR0FBRzBDO1lBQ3pCO1lBRUEsSUFBS3VhLFNBQVMsU0FBU0EsU0FBUyxDQUFFdmUsTUFBTXVlLE1BQU0zZSxHQUFHLENBQUVVLE1BQU1nQixLQUFLLE1BQVEsTUFBTztnQkFDNUUsT0FBT3RCO1lBQ1I7WUFFQSxPQUFPTSxJQUFJLENBQUVnQixLQUFNO1FBQ3BCO1FBRUE4eUIsV0FBVztZQUNWcmtCLFVBQVU7Z0JBQ1RuUSxLQUFLLFNBQVVVLElBQUk7b0JBRWxCLDRCQUE0QjtvQkFDNUIsMENBQTBDO29CQUMxQyxtREFBbUQ7b0JBQ25ELDhDQUE4QztvQkFDOUMsSUFBSSs1QixXQUFXbjdCLE9BQU9nSyxJQUFJLENBQUM0RCxJQUFJLENBQUV4TSxNQUFNO29CQUV2QyxJQUFLKzVCLFVBQVc7d0JBQ2YsT0FBT3hMLFNBQVV3TCxVQUFVO29CQUM1QjtvQkFFQSxJQUNDSixXQUFXejJCLElBQUksQ0FBRWxELEtBQUttRCxRQUFRLEtBQzlCeTJCLFdBQVcxMkIsSUFBSSxDQUFFbEQsS0FBS21ELFFBQVEsS0FDOUJuRCxLQUFLd1AsSUFBSSxFQUNSO3dCQUNELE9BQU87b0JBQ1I7b0JBRUEsT0FBTyxDQUFDO2dCQUNUO1lBQ0Q7UUFDRDtRQUVBc3FCLFNBQVM7WUFDUixPQUFPO1lBQ1AsU0FBUztRQUNWO0lBQ0Q7SUFFQSx3QkFBd0I7SUFDeEIsdUNBQXVDO0lBQ3ZDLGlEQUFpRDtJQUNqRCxnQkFBZ0I7SUFDaEIsa0RBQWtEO0lBQ2xELHNCQUFzQjtJQUN0QixnRUFBZ0U7SUFDaEUsMENBQTBDO0lBQzFDLElBQUssQ0FBQy84QixRQUFRbThCLFdBQVcsRUFBRztRQUMzQnQ2QixPQUFPazFCLFNBQVMsQ0FBQ2xrQixRQUFRLEdBQUc7WUFDM0J0USxLQUFLLFNBQVVVLElBQUk7Z0JBRWxCLHVDQUF1QyxHQUV2QyxJQUFJa08sU0FBU2xPLEtBQUt6QixVQUFVO2dCQUM1QixJQUFLMlAsVUFBVUEsT0FBTzNQLFVBQVUsRUFBRztvQkFDbEMyUCxPQUFPM1AsVUFBVSxDQUFDc1IsYUFBYTtnQkFDaEM7Z0JBQ0EsT0FBTztZQUNSO1lBQ0FrTixLQUFLLFNBQVUvYyxJQUFJO2dCQUVsQix1Q0FBdUMsR0FFdkMsSUFBSWtPLFNBQVNsTyxLQUFLekIsVUFBVTtnQkFDNUIsSUFBSzJQLFFBQVM7b0JBQ2JBLE9BQU8yQixhQUFhO29CQUVwQixJQUFLM0IsT0FBTzNQLFVBQVUsRUFBRzt3QkFDeEIyUCxPQUFPM1AsVUFBVSxDQUFDc1IsYUFBYTtvQkFDaEM7Z0JBQ0Q7WUFDRDtRQUNEO0lBQ0Q7SUFFQWpSLE9BQU9pQixJQUFJLENBQUU7UUFDWjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNBLEVBQUU7UUFDRmpCLE9BQU9rN0IsT0FBTyxDQUFFLElBQUksQ0FBQzkxQixXQUFXLEdBQUksR0FBRyxJQUFJO0lBQzVDO0lBS0MsdURBQXVEO0lBQ3ZELHFFQUFxRTtJQUNyRSxTQUFTZzJCLGlCQUFrQnQyQixLQUFLO1FBQy9CLElBQUlxTixTQUFTck4sTUFBTXNGLEtBQUssQ0FBRXFOLGtCQUFtQixFQUFFO1FBQy9DLE9BQU90RixPQUFPbEgsSUFBSSxDQUFFO0lBQ3JCO0lBR0QsU0FBU293QixTQUFVajZCLElBQUk7UUFDdEIsT0FBT0EsS0FBSzdCLFlBQVksSUFBSTZCLEtBQUs3QixZQUFZLENBQUUsWUFBYTtJQUM3RDtJQUVBLFNBQVMrN0IsZUFBZ0J4MkIsS0FBSztRQUM3QixJQUFLbkMsTUFBTUMsT0FBTyxDQUFFa0MsUUFBVTtZQUM3QixPQUFPQTtRQUNSO1FBQ0EsSUFBSyxPQUFPQSxVQUFVLFVBQVc7WUFDaEMsT0FBT0EsTUFBTXNGLEtBQUssQ0FBRXFOLGtCQUFtQixFQUFFO1FBQzFDO1FBQ0EsT0FBTyxFQUFFO0lBQ1Y7SUFFQXpYLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQnE1QixVQUFVLFNBQVV6MkIsS0FBSztZQUN4QixJQUFJMDJCLFlBQVk3a0IsS0FBSzhrQixVQUFVcnVCLFdBQVdsTyxHQUFHdzhCO1lBRTdDLElBQUt0OUIsV0FBWTBHLFFBQVU7Z0JBQzFCLE9BQU8sSUFBSSxDQUFDN0QsSUFBSSxDQUFFLFNBQVVhLENBQUM7b0JBQzVCOUIsT0FBUSxJQUFJLEVBQUd1N0IsUUFBUSxDQUFFejJCLE1BQU10SCxJQUFJLENBQUUsSUFBSSxFQUFFc0UsR0FBR3U1QixTQUFVLElBQUk7Z0JBQzdEO1lBQ0Q7WUFFQUcsYUFBYUYsZUFBZ0J4MkI7WUFFN0IsSUFBSzAyQixXQUFXaDdCLE1BQU0sRUFBRztnQkFDeEIsT0FBTyxJQUFJLENBQUNTLElBQUksQ0FBRTtvQkFDakJ3NkIsV0FBV0osU0FBVSxJQUFJO29CQUN6QjFrQixNQUFNLElBQUksQ0FBQ3JZLFFBQVEsS0FBSyxLQUFPLE1BQU04OEIsaUJBQWtCSyxZQUFhO29CQUVwRSxJQUFLOWtCLEtBQU07d0JBQ1YsSUFBTXpYLElBQUksR0FBR0EsSUFBSXM4QixXQUFXaDdCLE1BQU0sRUFBRXRCLElBQU07NEJBQ3pDa08sWUFBWW91QixVQUFVLENBQUV0OEIsRUFBRzs0QkFDM0IsSUFBS3lYLElBQUkvWSxPQUFPLENBQUUsTUFBTXdQLFlBQVksT0FBUSxHQUFJO2dDQUMvQ3VKLE9BQU92SixZQUFZOzRCQUNwQjt3QkFDRDt3QkFFQSx3REFBd0Q7d0JBQ3hEc3VCLGFBQWFOLGlCQUFrQnprQjt3QkFDL0IsSUFBSzhrQixhQUFhQyxZQUFhOzRCQUM5QixJQUFJLENBQUNsOEIsWUFBWSxDQUFFLFNBQVNrOEI7d0JBQzdCO29CQUNEO2dCQUNEO1lBQ0Q7WUFFQSxPQUFPLElBQUk7UUFDWjtRQUVBQyxhQUFhLFNBQVU3MkIsS0FBSztZQUMzQixJQUFJMDJCLFlBQVk3a0IsS0FBSzhrQixVQUFVcnVCLFdBQVdsTyxHQUFHdzhCO1lBRTdDLElBQUt0OUIsV0FBWTBHLFFBQVU7Z0JBQzFCLE9BQU8sSUFBSSxDQUFDN0QsSUFBSSxDQUFFLFNBQVVhLENBQUM7b0JBQzVCOUIsT0FBUSxJQUFJLEVBQUcyN0IsV0FBVyxDQUFFNzJCLE1BQU10SCxJQUFJLENBQUUsSUFBSSxFQUFFc0UsR0FBR3U1QixTQUFVLElBQUk7Z0JBQ2hFO1lBQ0Q7WUFFQSxJQUFLLENBQUNoNkIsVUFBVWIsTUFBTSxFQUFHO2dCQUN4QixPQUFPLElBQUksQ0FBQ29OLElBQUksQ0FBRSxTQUFTO1lBQzVCO1lBRUE0dEIsYUFBYUYsZUFBZ0J4MkI7WUFFN0IsSUFBSzAyQixXQUFXaDdCLE1BQU0sRUFBRztnQkFDeEIsT0FBTyxJQUFJLENBQUNTLElBQUksQ0FBRTtvQkFDakJ3NkIsV0FBV0osU0FBVSxJQUFJO29CQUV6QixvRUFBb0U7b0JBQ3BFMWtCLE1BQU0sSUFBSSxDQUFDclksUUFBUSxLQUFLLEtBQU8sTUFBTTg4QixpQkFBa0JLLFlBQWE7b0JBRXBFLElBQUs5a0IsS0FBTTt3QkFDVixJQUFNelgsSUFBSSxHQUFHQSxJQUFJczhCLFdBQVdoN0IsTUFBTSxFQUFFdEIsSUFBTTs0QkFDekNrTyxZQUFZb3VCLFVBQVUsQ0FBRXQ4QixFQUFHOzRCQUUzQix5QkFBeUI7NEJBQ3pCLE1BQVF5WCxJQUFJL1ksT0FBTyxDQUFFLE1BQU13UCxZQUFZLE9BQVEsQ0FBQyxFQUFJO2dDQUNuRHVKLE1BQU1BLElBQUkxVCxPQUFPLENBQUUsTUFBTW1LLFlBQVksS0FBSzs0QkFDM0M7d0JBQ0Q7d0JBRUEsd0RBQXdEO3dCQUN4RHN1QixhQUFhTixpQkFBa0J6a0I7d0JBQy9CLElBQUs4a0IsYUFBYUMsWUFBYTs0QkFDOUIsSUFBSSxDQUFDbDhCLFlBQVksQ0FBRSxTQUFTazhCO3dCQUM3QjtvQkFDRDtnQkFDRDtZQUNEO1lBRUEsT0FBTyxJQUFJO1FBQ1o7UUFFQUUsYUFBYSxTQUFVOTJCLEtBQUssRUFBRSsyQixRQUFRO1lBQ3JDLElBQUlMLFlBQVlwdUIsV0FBV2xPLEdBQUc2VyxNQUM3QnJYLE9BQU8sT0FBT29HLE9BQ2RnM0IsZUFBZXA5QixTQUFTLFlBQVlpRSxNQUFNQyxPQUFPLENBQUVrQztZQUVwRCxJQUFLMUcsV0FBWTBHLFFBQVU7Z0JBQzFCLE9BQU8sSUFBSSxDQUFDN0QsSUFBSSxDQUFFLFNBQVUvQixDQUFDO29CQUM1QmMsT0FBUSxJQUFJLEVBQUc0N0IsV0FBVyxDQUN6QjkyQixNQUFNdEgsSUFBSSxDQUFFLElBQUksRUFBRTBCLEdBQUdtOEIsU0FBVSxJQUFJLEdBQUlRLFdBQ3ZDQTtnQkFFRjtZQUNEO1lBRUEsSUFBSyxPQUFPQSxhQUFhLGFBQWFDLGNBQWU7Z0JBQ3BELE9BQU9ELFdBQVcsSUFBSSxDQUFDTixRQUFRLENBQUV6MkIsU0FBVSxJQUFJLENBQUM2MkIsV0FBVyxDQUFFNzJCO1lBQzlEO1lBRUEwMkIsYUFBYUYsZUFBZ0J4MkI7WUFFN0IsT0FBTyxJQUFJLENBQUM3RCxJQUFJLENBQUU7Z0JBQ2pCLElBQUs2NkIsY0FBZTtvQkFFbkIsZ0NBQWdDO29CQUNoQy9sQixPQUFPL1YsT0FBUSxJQUFJO29CQUVuQixJQUFNZCxJQUFJLEdBQUdBLElBQUlzOEIsV0FBV2g3QixNQUFNLEVBQUV0QixJQUFNO3dCQUN6Q2tPLFlBQVlvdUIsVUFBVSxDQUFFdDhCLEVBQUc7d0JBRTNCLG1EQUFtRDt3QkFDbkQsSUFBSzZXLEtBQUtnbUIsUUFBUSxDQUFFM3VCLFlBQWM7NEJBQ2pDMkksS0FBSzRsQixXQUFXLENBQUV2dUI7d0JBQ25CLE9BQU87NEJBQ04ySSxLQUFLd2xCLFFBQVEsQ0FBRW51Qjt3QkFDaEI7b0JBQ0Q7Z0JBRUQsMEJBQTBCO2dCQUMxQixPQUFPLElBQUt0SSxVQUFVakMsYUFBYW5FLFNBQVMsV0FBWTtvQkFDdkQwTyxZQUFZaXVCLFNBQVUsSUFBSTtvQkFDMUIsSUFBS2p1QixXQUFZO3dCQUVoQix5QkFBeUI7d0JBQ3pCbVIsU0FBU0osR0FBRyxDQUFFLElBQUksRUFBRSxpQkFBaUIvUTtvQkFDdEM7b0JBRUEsOERBQThEO29CQUM5RCwwRUFBMEU7b0JBQzFFLG9FQUFvRTtvQkFDcEUsMERBQTBEO29CQUMxRCxJQUFLLElBQUksQ0FBQzVOLFlBQVksRUFBRzt3QkFDeEIsSUFBSSxDQUFDQSxZQUFZLENBQUUsU0FDbEI0TixhQUFhdEksVUFBVSxRQUN0QixLQUNBeVosU0FBUzdkLEdBQUcsQ0FBRSxJQUFJLEVBQUUsb0JBQXFCO29CQUU1QztnQkFDRDtZQUNEO1FBQ0Q7UUFFQXE3QixVQUFVLFNBQVU5N0IsUUFBUTtZQUMzQixJQUFJbU4sV0FBV2hNLE1BQ2RsQyxJQUFJO1lBRUxrTyxZQUFZLE1BQU1uTixXQUFXO1lBQzdCLE1BQVVtQixPQUFPLElBQUksQ0FBRWxDLElBQUssQ0FBSztnQkFDaEMsSUFBS2tDLEtBQUs5QyxRQUFRLEtBQUssS0FDdEIsQ0FBRSxNQUFNODhCLGlCQUFrQkMsU0FBVWo2QixTQUFXLEdBQUUsRUFBSXhELE9BQU8sQ0FBRXdQLGFBQWMsQ0FBQyxHQUFJO29CQUNqRixPQUFPO2dCQUNSO1lBQ0Q7WUFFQSxPQUFPO1FBQ1I7SUFDRDtJQUtBLElBQUk0dUIsVUFBVTtJQUVkaDhCLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQi9DLEtBQUssU0FBVTJGLEtBQUs7WUFDbkIsSUFBSXVhLE9BQU92ZSxLQUFLOHFCLGlCQUNmeHFCLE9BQU8sSUFBSSxDQUFFLEVBQUc7WUFFakIsSUFBSyxDQUFDQyxVQUFVYixNQUFNLEVBQUc7Z0JBQ3hCLElBQUtZLE1BQU87b0JBQ1hpZSxRQUFRcmYsT0FBT2k4QixRQUFRLENBQUU3NkIsS0FBSzFDLElBQUksQ0FBRSxJQUNuQ3NCLE9BQU9pOEIsUUFBUSxDQUFFNzZCLEtBQUttRCxRQUFRLENBQUNhLFdBQVcsR0FBSTtvQkFFL0MsSUFBS2lhLFNBQ0osU0FBU0EsU0FDVCxDQUFFdmUsTUFBTXVlLE1BQU0zZSxHQUFHLENBQUVVLE1BQU0sUUFBUSxNQUFReUIsV0FDeEM7d0JBQ0QsT0FBTy9CO29CQUNSO29CQUVBQSxNQUFNTSxLQUFLMEQsS0FBSztvQkFFaEIsa0NBQWtDO29CQUNsQyxJQUFLLE9BQU9oRSxRQUFRLFVBQVc7d0JBQzlCLE9BQU9BLElBQUltQyxPQUFPLENBQUUrNEIsU0FBUztvQkFDOUI7b0JBRUEsbURBQW1EO29CQUNuRCxPQUFPbDdCLE9BQU8sT0FBTyxLQUFLQTtnQkFDM0I7Z0JBRUE7WUFDRDtZQUVBOHFCLGtCQUFrQnh0QixXQUFZMEc7WUFFOUIsT0FBTyxJQUFJLENBQUM3RCxJQUFJLENBQUUsU0FBVS9CLENBQUM7Z0JBQzVCLElBQUlDO2dCQUVKLElBQUssSUFBSSxDQUFDYixRQUFRLEtBQUssR0FBSTtvQkFDMUI7Z0JBQ0Q7Z0JBRUEsSUFBS3N0QixpQkFBa0I7b0JBQ3RCenNCLE1BQU0yRixNQUFNdEgsSUFBSSxDQUFFLElBQUksRUFBRTBCLEdBQUdjLE9BQVEsSUFBSSxFQUFHYixHQUFHO2dCQUM5QyxPQUFPO29CQUNOQSxNQUFNMkY7Z0JBQ1A7Z0JBRUEsd0RBQXdEO2dCQUN4RCxJQUFLM0YsT0FBTyxNQUFPO29CQUNsQkEsTUFBTTtnQkFFUCxPQUFPLElBQUssT0FBT0EsUUFBUSxVQUFXO29CQUNyQ0EsT0FBTztnQkFFUixPQUFPLElBQUt3RCxNQUFNQyxPQUFPLENBQUV6RCxNQUFRO29CQUNsQ0EsTUFBTWEsT0FBT21CLEdBQUcsQ0FBRWhDLEtBQUssU0FBVTJGLEtBQUs7d0JBQ3JDLE9BQU9BLFNBQVMsT0FBTyxLQUFLQSxRQUFRO29CQUNyQztnQkFDRDtnQkFFQXVhLFFBQVFyZixPQUFPaThCLFFBQVEsQ0FBRSxJQUFJLENBQUN2OUIsSUFBSSxDQUFFLElBQUlzQixPQUFPaThCLFFBQVEsQ0FBRSxJQUFJLENBQUMxM0IsUUFBUSxDQUFDYSxXQUFXLEdBQUk7Z0JBRXRGLHdEQUF3RDtnQkFDeEQsSUFBSyxDQUFDaWEsU0FBUyxDQUFHLFVBQVNBLEtBQUksS0FBT0EsTUFBTWxCLEdBQUcsQ0FBRSxJQUFJLEVBQUVoZixLQUFLLGFBQWMwRCxXQUFZO29CQUNyRixJQUFJLENBQUNpQyxLQUFLLEdBQUczRjtnQkFDZDtZQUNEO1FBQ0Q7SUFDRDtJQUVBYSxPQUFPa0MsTUFBTSxDQUFFO1FBQ2QrNUIsVUFBVTtZQUNUM1osUUFBUTtnQkFDUDVoQixLQUFLLFNBQVVVLElBQUk7b0JBRWxCLElBQUlqQyxNQUFNYSxPQUFPZ0ssSUFBSSxDQUFDNEQsSUFBSSxDQUFFeE0sTUFBTTtvQkFDbEMsT0FBT2pDLE9BQU8sT0FDYkEsTUFFQSw2QkFBNkI7b0JBQzdCLHlEQUF5RDtvQkFDekQsZ0NBQWdDO29CQUNoQyw4REFBOEQ7b0JBQzlEaThCLGlCQUFrQnA3QixPQUFPVixJQUFJLENBQUU4QjtnQkFDakM7WUFDRDtZQUNBaUssUUFBUTtnQkFDUDNLLEtBQUssU0FBVVUsSUFBSTtvQkFDbEIsSUFBSTBELE9BQU93ZCxRQUFRcGpCLEdBQ2xCaUQsVUFBVWYsS0FBS2UsT0FBTyxFQUN0QnlVLFFBQVF4VixLQUFLNlAsYUFBYSxFQUMxQm9ULE1BQU1qakIsS0FBSzFDLElBQUksS0FBSyxjQUNwQitpQixTQUFTNEMsTUFBTSxPQUFPLEVBQUUsRUFDeEJtTixNQUFNbk4sTUFBTXpOLFFBQVEsSUFBSXpVLFFBQVEzQixNQUFNO29CQUV2QyxJQUFLb1csUUFBUSxHQUFJO3dCQUNoQjFYLElBQUlzeUI7b0JBRUwsT0FBTzt3QkFDTnR5QixJQUFJbWxCLE1BQU16TixRQUFRO29CQUNuQjtvQkFFQSx3Q0FBd0M7b0JBQ3hDLE1BQVExWCxJQUFJc3lCLEtBQUt0eUIsSUFBTTt3QkFDdEJvakIsU0FBU25nQixPQUFPLENBQUVqRCxFQUFHO3dCQUVyQix1QkFBdUI7d0JBQ3ZCLDZEQUE2RDt3QkFDN0QsSUFBSyxDQUFFb2pCLE9BQU90UixRQUFRLElBQUk5UixNQUFNMFgsS0FBSSxLQUVsQyxtRUFBbUU7d0JBQ25FLENBQUMwTCxPQUFPL1ksUUFBUSxJQUNkLEVBQUMrWSxPQUFPM2lCLFVBQVUsQ0FBQzRKLFFBQVEsSUFDNUIsQ0FBQ2hGLFNBQVUrZCxPQUFPM2lCLFVBQVUsRUFBRSxXQUFXLEdBQU07NEJBRWpELHdDQUF3Qzs0QkFDeENtRixRQUFROUUsT0FBUXNpQixRQUFTbmpCLEdBQUc7NEJBRTVCLHlDQUF5Qzs0QkFDekMsSUFBS2tsQixLQUFNO2dDQUNWLE9BQU92Zjs0QkFDUjs0QkFFQSxnQ0FBZ0M7NEJBQ2hDMmMsT0FBTzlqQixJQUFJLENBQUVtSDt3QkFDZDtvQkFDRDtvQkFFQSxPQUFPMmM7Z0JBQ1I7Z0JBRUF0RCxLQUFLLFNBQVUvYyxJQUFJLEVBQUUwRCxLQUFLO29CQUN6QixJQUFJbzNCLFdBQVc1WixRQUNkbmdCLFVBQVVmLEtBQUtlLE9BQU8sRUFDdEJzZixTQUFTemhCLE9BQU84RCxTQUFTLENBQUVnQixRQUMzQjVGLElBQUlpRCxRQUFRM0IsTUFBTTtvQkFFbkIsTUFBUXRCLElBQU07d0JBQ2JvakIsU0FBU25nQixPQUFPLENBQUVqRCxFQUFHO3dCQUVyQixpQ0FBaUMsR0FFakMsSUFBS29qQixPQUFPdFIsUUFBUSxHQUNuQmhSLE9BQU9nRSxPQUFPLENBQUVoRSxPQUFPaThCLFFBQVEsQ0FBQzNaLE1BQU0sQ0FBQzVoQixHQUFHLENBQUU0aEIsU0FBVWIsVUFBVyxDQUFDLEdBQ2pFOzRCQUNEeWEsWUFBWTt3QkFDYjtvQkFFQSxnQ0FBZ0MsR0FDakM7b0JBRUEsdUVBQXVFO29CQUN2RSxJQUFLLENBQUNBLFdBQVk7d0JBQ2pCOTZCLEtBQUs2UCxhQUFhLEdBQUcsQ0FBQztvQkFDdkI7b0JBQ0EsT0FBT3dRO2dCQUNSO1lBQ0Q7UUFDRDtJQUNEO0lBRUEsc0NBQXNDO0lBQ3RDemhCLE9BQU9pQixJQUFJLENBQUU7UUFBRTtRQUFTO0tBQVksRUFBRTtRQUNyQ2pCLE9BQU9pOEIsUUFBUSxDQUFFLElBQUksQ0FBRSxHQUFHO1lBQ3pCOWQsS0FBSyxTQUFVL2MsSUFBSSxFQUFFMEQsS0FBSztnQkFDekIsSUFBS25DLE1BQU1DLE9BQU8sQ0FBRWtDLFFBQVU7b0JBQzdCLE9BQVMxRCxLQUFLMlAsT0FBTyxHQUFHL1EsT0FBT2dFLE9BQU8sQ0FBRWhFLE9BQVFvQixNQUFPakMsR0FBRyxJQUFJMkYsU0FBVSxDQUFDO2dCQUMxRTtZQUNEO1FBQ0Q7UUFDQSxJQUFLLENBQUMzRyxRQUFRazhCLE9BQU8sRUFBRztZQUN2QnI2QixPQUFPaThCLFFBQVEsQ0FBRSxJQUFJLENBQUUsQ0FBQ3Y3QixHQUFHLEdBQUcsU0FBVVUsSUFBSTtnQkFDM0MsT0FBT0EsS0FBSzdCLFlBQVksQ0FBRSxhQUFjLE9BQU8sT0FBTzZCLEtBQUswRCxLQUFLO1lBQ2pFO1FBQ0Q7SUFDRDtJQUtBLDhDQUE4QztJQUM5QyxJQUFJMEwsV0FBV3pULFFBQU95VCxRQUFRO0lBRTlCLElBQUk1UixRQUFRO1FBQUVtRyxNQUFNbWpCLEtBQUtDLEdBQUc7SUFBRztJQUUvQixJQUFJZ1UsU0FBVztJQUlmLDRCQUE0QjtJQUM1Qm44QixPQUFPbzhCLFFBQVEsR0FBRyxTQUFVaGUsSUFBSTtRQUMvQixJQUFJbFAsS0FBS210QjtRQUNULElBQUssQ0FBQ2plLFFBQVEsT0FBT0EsU0FBUyxVQUFXO1lBQ3hDLE9BQU87UUFDUjtRQUVBLDBCQUEwQjtRQUMxQixtREFBbUQ7UUFDbkQsSUFBSTtZQUNIbFAsTUFBTSxJQUFNblMsUUFBT3UvQixTQUFTLEdBQUtDLGVBQWUsQ0FBRW5lLE1BQU07UUFDekQsRUFBRSxPQUFRdFUsR0FBSSxDQUFDO1FBRWZ1eUIsa0JBQWtCbnRCLE9BQU9BLElBQUl2RSxvQkFBb0IsQ0FBRSxjQUFlLENBQUUsRUFBRztRQUN2RSxJQUFLLENBQUN1RSxPQUFPbXRCLGlCQUFrQjtZQUM5QnI4QixPQUFPbUQsS0FBSyxDQUFFLGtCQUNiazVCLENBQUFBLGtCQUNDcjhCLE9BQU9tQixHQUFHLENBQUVrN0IsZ0JBQWdCeHlCLFVBQVUsRUFBRSxTQUFVZ0MsRUFBRTtnQkFDbkQsT0FBT0EsR0FBR2xJLFdBQVc7WUFDdEIsR0FBSXNILElBQUksQ0FBRSxRQUNWbVQsSUFBRztRQUVOO1FBQ0EsT0FBT2xQO0lBQ1I7SUFHQSxJQUFJc3RCLGNBQWMsbUNBQ2pCQywwQkFBMEIsU0FBVTN5QixDQUFDO1FBQ3BDQSxFQUFFMGMsZUFBZTtJQUNsQjtJQUVEeG1CLE9BQU9rQyxNQUFNLENBQUVsQyxPQUFPdWtCLEtBQUssRUFBRTtRQUU1QitDLFNBQVMsU0FBVS9DLEtBQUssRUFBRW5HLElBQUksRUFBRWhkLElBQUksRUFBRXM3QixZQUFZO1lBRWpELElBQUl4OUIsR0FBR3lYLEtBQUtnSixLQUFLZ2QsWUFBWUMsUUFBUXpYLFFBQVF2SyxTQUFTaWlCLGFBQ3JEQyxZQUFZO2dCQUFFMTdCLFFBQVF4RTthQUFVLEVBQ2hDOEIsT0FBT1gsT0FBT1AsSUFBSSxDQUFFK21CLE9BQU8sVUFBV0EsTUFBTTdsQixJQUFJLEdBQUc2bEIsT0FDbkRRLGFBQWFobkIsT0FBT1AsSUFBSSxDQUFFK21CLE9BQU8sZUFBZ0JBLE1BQU1yZ0IsU0FBUyxDQUFDZ0IsS0FBSyxDQUFFLE9BQVEsRUFBRTtZQUVuRnlSLE1BQU1rbUIsY0FBY2xkLE1BQU12ZSxPQUFPQSxRQUFReEU7WUFFekMsNENBQTRDO1lBQzVDLElBQUt3RSxLQUFLOUMsUUFBUSxLQUFLLEtBQUs4QyxLQUFLOUMsUUFBUSxLQUFLLEdBQUk7Z0JBQ2pEO1lBQ0Q7WUFFQSwyRUFBMkU7WUFDM0UsSUFBS2srQixZQUFZbDRCLElBQUksQ0FBRTVGLE9BQU9zQixPQUFPdWtCLEtBQUssQ0FBQ2EsU0FBUyxHQUFLO2dCQUN4RDtZQUNEO1lBRUEsSUFBSzFtQixLQUFLZCxPQUFPLENBQUUsT0FBUSxDQUFDLEdBQUk7Z0JBRS9CLHNFQUFzRTtnQkFDdEVtbkIsYUFBYXJtQixLQUFLd0csS0FBSyxDQUFFO2dCQUN6QnhHLE9BQU9xbUIsV0FBV3JaLEtBQUs7Z0JBQ3ZCcVosV0FBVy9pQixJQUFJO1lBQ2hCO1lBQ0E0NkIsU0FBU2wrQixLQUFLZCxPQUFPLENBQUUsT0FBUSxLQUFLLE9BQU9jO1lBRTNDLGlGQUFpRjtZQUNqRjZsQixRQUFRQSxLQUFLLENBQUV2a0IsT0FBTzhDLE9BQU8sQ0FBRSxHQUM5QnloQixRQUNBLElBQUl2a0IsT0FBTzhtQixLQUFLLENBQUVwb0IsTUFBTSxPQUFPNmxCLFVBQVUsWUFBWUE7WUFFdEQseUVBQXlFO1lBQ3pFQSxNQUFNb0QsU0FBUyxHQUFHK1UsZUFBZSxJQUFJO1lBQ3JDblksTUFBTXJnQixTQUFTLEdBQUc2Z0IsV0FBVzlaLElBQUksQ0FBRTtZQUNuQ3NaLE1BQU0rQixVQUFVLEdBQUcvQixNQUFNcmdCLFNBQVMsR0FDakMsSUFBSXNCLE9BQVEsWUFBWXVmLFdBQVc5WixJQUFJLENBQUUsbUJBQW9CLGFBQzdEO1lBRUQsZ0RBQWdEO1lBQ2hEc1osTUFBTTVWLE1BQU0sR0FBRzlMO1lBQ2YsSUFBSyxDQUFDMGhCLE1BQU0vaEIsTUFBTSxFQUFHO2dCQUNwQitoQixNQUFNL2hCLE1BQU0sR0FBR3BCO1lBQ2hCO1lBRUEsK0VBQStFO1lBQy9FZ2QsT0FBT0EsUUFBUSxPQUNkO2dCQUFFbUc7YUFBTyxHQUNUdmtCLE9BQU84RCxTQUFTLENBQUVzYSxNQUFNO2dCQUFFbUc7YUFBTztZQUVsQyxpREFBaUQ7WUFDakQzSixVQUFVNWEsT0FBT3VrQixLQUFLLENBQUMzSixPQUFPLENBQUVsYyxLQUFNLElBQUksQ0FBQztZQUMzQyxJQUFLLENBQUNnK0IsZ0JBQWdCOWhCLFFBQVEwTSxPQUFPLElBQUkxTSxRQUFRME0sT0FBTyxDQUFDNXBCLEtBQUssQ0FBRTBELE1BQU1nZCxVQUFXLE9BQVE7Z0JBQ3hGO1lBQ0Q7WUFFQSwrRUFBK0U7WUFDL0UsMEZBQTBGO1lBQzFGLElBQUssQ0FBQ3NlLGdCQUFnQixDQUFDOWhCLFFBQVF1TSxRQUFRLElBQUksQ0FBQzNvQixTQUFVNEMsT0FBUztnQkFFOUR1N0IsYUFBYS9oQixRQUFRMEssWUFBWSxJQUFJNW1CO2dCQUNyQyxJQUFLLENBQUM4OUIsWUFBWWw0QixJQUFJLENBQUVxNEIsYUFBYWorQixPQUFTO29CQUM3Q2lZLE1BQU1BLElBQUloWCxVQUFVO2dCQUNyQjtnQkFDQSxNQUFRZ1gsS0FBS0EsTUFBTUEsSUFBSWhYLFVBQVUsQ0FBRztvQkFDbkNtOUIsVUFBVW4vQixJQUFJLENBQUVnWjtvQkFDaEJnSixNQUFNaEo7Z0JBQ1A7Z0JBRUEsOEVBQThFO2dCQUM5RSxJQUFLZ0osUUFBVXZlLENBQUFBLEtBQUtpRCxhQUFhLElBQUl6SCxRQUFPLEdBQU07b0JBQ2pEa2dDLFVBQVVuL0IsSUFBSSxDQUFFZ2lCLElBQUluVCxXQUFXLElBQUltVCxJQUFJb2QsWUFBWSxJQUFJaGdDO2dCQUN4RDtZQUNEO1lBRUEsa0NBQWtDO1lBQ2xDbUMsSUFBSTtZQUNKLE1BQVEsQ0FBRXlYLE1BQU1tbUIsU0FBUyxDQUFFNTlCLElBQUssS0FBTSxDQUFDcWxCLE1BQU00QixvQkFBb0IsR0FBSztnQkFDckUwVyxjQUFjbG1CO2dCQUNkNE4sTUFBTTdsQixJQUFJLEdBQUdRLElBQUksSUFDaEJ5OUIsYUFDQS9oQixRQUFRMkssUUFBUSxJQUFJN21CO2dCQUVyQixpQkFBaUI7Z0JBQ2pCeW1CLFNBQVMsQ0FBRTVHLFNBQVM3ZCxHQUFHLENBQUVpVyxLQUFLLGFBQWN4WixPQUFPK25CLE1BQU0sQ0FBRSxLQUFLLENBQUcsQ0FBRVgsTUFBTTdsQixJQUFJLENBQUUsSUFDaEY2ZixTQUFTN2QsR0FBRyxDQUFFaVcsS0FBSztnQkFDcEIsSUFBS3dPLFFBQVM7b0JBQ2JBLE9BQU96bkIsS0FBSyxDQUFFaVosS0FBS3lIO2dCQUNwQjtnQkFFQSxpQkFBaUI7Z0JBQ2pCK0csU0FBU3lYLFVBQVVqbUIsR0FBRyxDQUFFaW1CLE9BQVE7Z0JBQ2hDLElBQUt6WCxVQUFVQSxPQUFPem5CLEtBQUssSUFBSW1nQixXQUFZbEgsTUFBUTtvQkFDbEQ0TixNQUFNNVYsTUFBTSxHQUFHd1csT0FBT3puQixLQUFLLENBQUVpWixLQUFLeUg7b0JBQ2xDLElBQUttRyxNQUFNNVYsTUFBTSxLQUFLLE9BQVE7d0JBQzdCNFYsTUFBTWdDLGNBQWM7b0JBQ3JCO2dCQUNEO1lBQ0Q7WUFDQWhDLE1BQU03bEIsSUFBSSxHQUFHQTtZQUViLG9EQUFvRDtZQUNwRCxJQUFLLENBQUNnK0IsZ0JBQWdCLENBQUNuWSxNQUFNdUQsa0JBQWtCLElBQUs7Z0JBRW5ELElBQUssQ0FBRSxDQUFDbE4sUUFBUWdJLFFBQVEsSUFDdkJoSSxRQUFRZ0ksUUFBUSxDQUFDbGxCLEtBQUssQ0FBRW8vQixVQUFVejNCLEdBQUcsSUFBSStZLFVBQVcsS0FBSSxLQUN4RFAsV0FBWXpjLE9BQVM7b0JBRXJCLDBFQUEwRTtvQkFDMUUsbUZBQW1GO29CQUNuRixJQUFLdzdCLFVBQVV4K0IsV0FBWWdELElBQUksQ0FBRTFDLEtBQU0sS0FBTSxDQUFDRixTQUFVNEMsT0FBUzt3QkFFaEUsZ0VBQWdFO3dCQUNoRXVlLE1BQU12ZSxJQUFJLENBQUV3N0IsT0FBUTt3QkFFcEIsSUFBS2pkLEtBQU07NEJBQ1Z2ZSxJQUFJLENBQUV3N0IsT0FBUSxHQUFHO3dCQUNsQjt3QkFFQSw2RUFBNkU7d0JBQzdFNThCLE9BQU91a0IsS0FBSyxDQUFDYSxTQUFTLEdBQUcxbUI7d0JBRXpCLElBQUs2bEIsTUFBTTRCLG9CQUFvQixJQUFLOzRCQUNuQzBXLFlBQVlud0IsZ0JBQWdCLENBQUVoTyxNQUFNKzlCO3dCQUNyQzt3QkFFQXI3QixJQUFJLENBQUUxQyxLQUFNO3dCQUVaLElBQUs2bEIsTUFBTTRCLG9CQUFvQixJQUFLOzRCQUNuQzBXLFlBQVlqZ0IsbUJBQW1CLENBQUVsZSxNQUFNKzlCO3dCQUN4Qzt3QkFFQXo4QixPQUFPdWtCLEtBQUssQ0FBQ2EsU0FBUyxHQUFHdmlCO3dCQUV6QixJQUFLOGMsS0FBTTs0QkFDVnZlLElBQUksQ0FBRXc3QixPQUFRLEdBQUdqZDt3QkFDbEI7b0JBQ0Q7Z0JBQ0Q7WUFDRDtZQUVBLE9BQU80RSxNQUFNNVYsTUFBTTtRQUNwQjtRQUVBLHlEQUF5RDtRQUN6RCx5Q0FBeUM7UUFDekN3YixVQUFVLFNBQVV6ckIsSUFBSSxFQUFFMEMsSUFBSSxFQUFFbWpCLEtBQUs7WUFDcEMsSUFBSXphLElBQUk5SixPQUFPa0MsTUFBTSxDQUNwQixJQUFJbEMsT0FBTzhtQixLQUFLLElBQ2hCdkMsT0FDQTtnQkFDQzdsQixNQUFNQTtnQkFDTjBwQixhQUFhO1lBQ2Q7WUFHRHBvQixPQUFPdWtCLEtBQUssQ0FBQytDLE9BQU8sQ0FBRXhkLEdBQUcsTUFBTTFJO1FBQ2hDO0lBRUQ7SUFFQXBCLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUVqQm9sQixTQUFTLFNBQVU1b0IsSUFBSSxFQUFFMGYsSUFBSTtZQUM1QixPQUFPLElBQUksQ0FBQ25kLElBQUksQ0FBRTtnQkFDakJqQixPQUFPdWtCLEtBQUssQ0FBQytDLE9BQU8sQ0FBRTVvQixNQUFNMGYsTUFBTSxJQUFJO1lBQ3ZDO1FBQ0Q7UUFDQTRlLGdCQUFnQixTQUFVdCtCLElBQUksRUFBRTBmLElBQUk7WUFDbkMsSUFBSWhkLE9BQU8sSUFBSSxDQUFFLEVBQUc7WUFDcEIsSUFBS0EsTUFBTztnQkFDWCxPQUFPcEIsT0FBT3VrQixLQUFLLENBQUMrQyxPQUFPLENBQUU1b0IsTUFBTTBmLE1BQU1oZCxNQUFNO1lBQ2hEO1FBQ0Q7SUFDRDtJQUdBLElBQ0M2N0IsV0FBVyxTQUNYQyxRQUFRLFVBQ1JDLGtCQUFrQix5Q0FDbEJDLGVBQWU7SUFFaEIsU0FBU0MsWUFBYTFJLE1BQU0sRUFBRXQyQixHQUFHLEVBQUVpL0IsV0FBVyxFQUFFeG1CLEdBQUc7UUFDbEQsSUFBSTFVO1FBRUosSUFBS08sTUFBTUMsT0FBTyxDQUFFdkUsTUFBUTtZQUUzQix3QkFBd0I7WUFDeEIyQixPQUFPaUIsSUFBSSxDQUFFNUMsS0FBSyxTQUFVYSxDQUFDLEVBQUU0WixDQUFDO2dCQUMvQixJQUFLd2tCLGVBQWVMLFNBQVMzNEIsSUFBSSxDQUFFcXdCLFNBQVc7b0JBRTdDLHFDQUFxQztvQkFDckM3ZCxJQUFLNmQsUUFBUTdiO2dCQUVkLE9BQU87b0JBRU4sa0VBQWtFO29CQUNsRXVrQixZQUNDMUksU0FBUyxNQUFRLFFBQU83YixNQUFNLFlBQVlBLEtBQUssT0FBTzVaLElBQUksRUFBQyxJQUFNLEtBQ2pFNFosR0FDQXdrQixhQUNBeG1CO2dCQUVGO1lBQ0Q7UUFFRCxPQUFPLElBQUssQ0FBQ3dtQixlQUFlejlCLE9BQVF4QixTQUFVLFVBQVc7WUFFeEQseUJBQXlCO1lBQ3pCLElBQU0rRCxRQUFRL0QsSUFBTTtnQkFDbkJnL0IsWUFBYTFJLFNBQVMsTUFBTXZ5QixPQUFPLEtBQUsvRCxHQUFHLENBQUUrRCxLQUFNLEVBQUVrN0IsYUFBYXhtQjtZQUNuRTtRQUVELE9BQU87WUFFTix5QkFBeUI7WUFDekJBLElBQUs2ZCxRQUFRdDJCO1FBQ2Q7SUFDRDtJQUVBLGtEQUFrRDtJQUNsRCxpQ0FBaUM7SUFDakMyQixPQUFPdTlCLEtBQUssR0FBRyxTQUFVNzNCLENBQUMsRUFBRTQzQixXQUFXO1FBQ3RDLElBQUkzSSxRQUNINkksSUFBSSxFQUFFLEVBQ04xbUIsTUFBTSxTQUFVdEwsR0FBRyxFQUFFaXlCLGVBQWU7WUFFbkMsNkRBQTZEO1lBQzdELElBQUkzNEIsUUFBUTFHLFdBQVlxL0IsbUJBQ3ZCQSxvQkFDQUE7WUFFREQsQ0FBQyxDQUFFQSxFQUFFaDlCLE1BQU0sQ0FBRSxHQUFHazlCLG1CQUFvQmx5QixPQUFRLE1BQzNDa3lCLG1CQUFvQjU0QixTQUFTLE9BQU8sS0FBS0E7UUFDM0M7UUFFRCxJQUFLWSxLQUFLLE1BQU87WUFDaEIsT0FBTztRQUNSO1FBRUEsMEVBQTBFO1FBQzFFLElBQUsvQyxNQUFNQyxPQUFPLENBQUU4QyxNQUFTQSxFQUFFcEYsTUFBTSxJQUFJLENBQUNOLE9BQU8wQyxhQUFhLENBQUVnRCxJQUFRO1lBRXZFLDhCQUE4QjtZQUM5QjFGLE9BQU9pQixJQUFJLENBQUV5RSxHQUFHO2dCQUNmb1IsSUFBSyxJQUFJLENBQUMxVSxJQUFJLEVBQUUsSUFBSSxDQUFDMEMsS0FBSztZQUMzQjtRQUVELE9BQU87WUFFTiwrREFBK0Q7WUFDL0QsZ0RBQWdEO1lBQ2hELElBQU02dkIsVUFBVWp2QixFQUFJO2dCQUNuQjIzQixZQUFhMUksUUFBUWp2QixDQUFDLENBQUVpdkIsT0FBUSxFQUFFMkksYUFBYXhtQjtZQUNoRDtRQUNEO1FBRUEscUNBQXFDO1FBQ3JDLE9BQU8wbUIsRUFBRXZ5QixJQUFJLENBQUU7SUFDaEI7SUFFQWpMLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQnk3QixXQUFXO1lBQ1YsT0FBTzM5QixPQUFPdTlCLEtBQUssQ0FBRSxJQUFJLENBQUNLLGNBQWM7UUFDekM7UUFDQUEsZ0JBQWdCO1lBQ2YsT0FBTyxJQUFJLENBQUN6OEIsR0FBRyxDQUFFO2dCQUVoQixpRUFBaUU7Z0JBQ2pFLElBQUl1TSxXQUFXMU4sT0FBT3FlLElBQUksQ0FBRSxJQUFJLEVBQUU7Z0JBQ2xDLE9BQU8zUSxXQUFXMU4sT0FBTzhELFNBQVMsQ0FBRTRKLFlBQWEsSUFBSTtZQUN0RCxHQUFJVixNQUFNLENBQUU7Z0JBQ1gsSUFBSXRPLE9BQU8sSUFBSSxDQUFDQSxJQUFJO2dCQUVwQiwwREFBMEQ7Z0JBQzFELE9BQU8sSUFBSSxDQUFDMEQsSUFBSSxJQUFJLENBQUNwQyxPQUFRLElBQUksRUFBR3dWLEVBQUUsQ0FBRSxnQkFDdkM0bkIsYUFBYTk0QixJQUFJLENBQUUsSUFBSSxDQUFDQyxRQUFRLEtBQU0sQ0FBQzQ0QixnQkFBZ0I3NEIsSUFBSSxDQUFFNUYsU0FDM0QsS0FBSSxDQUFDcVMsT0FBTyxJQUFJLENBQUM2USxlQUFldGQsSUFBSSxDQUFFNUYsS0FBSztZQUMvQyxHQUFJeUMsR0FBRyxDQUFFLFNBQVVnRSxFQUFFLEVBQUUvRCxJQUFJO2dCQUMxQixJQUFJakMsTUFBTWEsT0FBUSxJQUFJLEVBQUdiLEdBQUc7Z0JBRTVCLElBQUtBLE9BQU8sTUFBTztvQkFDbEIsT0FBTztnQkFDUjtnQkFFQSxJQUFLd0QsTUFBTUMsT0FBTyxDQUFFekQsTUFBUTtvQkFDM0IsT0FBT2EsT0FBT21CLEdBQUcsQ0FBRWhDLEtBQUssU0FBVUEsR0FBRzt3QkFDcEMsT0FBTzs0QkFBRWlELE1BQU1oQixLQUFLZ0IsSUFBSTs0QkFBRTBDLE9BQU8zRixJQUFJOEQsT0FBTyxDQUFFaTZCLE9BQU87d0JBQVM7b0JBQy9EO2dCQUNEO2dCQUVBLE9BQU87b0JBQUU5NkIsTUFBTWhCLEtBQUtnQixJQUFJO29CQUFFMEMsT0FBTzNGLElBQUk4RCxPQUFPLENBQUVpNkIsT0FBTztnQkFBUztZQUMvRCxHQUFJeDhCLEdBQUc7UUFDUjtJQUNEO0lBR0EsSUFDQ205QixNQUFNLFFBQ05DLFFBQVEsUUFDUkMsYUFBYSxpQkFDYkMsV0FBVyw4QkFFWCw0REFBNEQ7SUFDNURDLGlCQUFpQiw2REFDakJDLGFBQWEsa0JBQ2JDLFlBQVksU0FFWjs7Ozs7Ozs7RUFRQyxHQUNEbEcsYUFBYSxDQUFDLEdBRWQ7Ozs7RUFJQyxHQUNEbUcsYUFBYSxDQUFDLEdBRWQsMkZBQTJGO0lBQzNGQyxXQUFXLEtBQUs1Z0MsTUFBTSxDQUFFLE1BRXhCLDZDQUE2QztJQUM3QzZnQyxlQUFlMWhDLFNBQVN5QyxhQUFhLENBQUU7SUFFeENpL0IsYUFBYTF0QixJQUFJLEdBQUdKLFNBQVNJLElBQUk7SUFFakMsdUVBQXVFO0lBQ3ZFLFNBQVMydEIsNEJBQTZCQyxTQUFTO1FBRTlDLHFEQUFxRDtRQUNyRCxPQUFPLFNBQVVDLGtCQUFrQixFQUFFL2tCLElBQUk7WUFFeEMsSUFBSyxPQUFPK2tCLHVCQUF1QixVQUFXO2dCQUM3Qy9rQixPQUFPK2tCO2dCQUNQQSxxQkFBcUI7WUFDdEI7WUFFQSxJQUFJQyxVQUNIeC9CLElBQUksR0FDSnkvQixZQUFZRixtQkFBbUJyNUIsV0FBVyxHQUFHZ0YsS0FBSyxDQUFFcU4sa0JBQW1CLEVBQUU7WUFFMUUsSUFBS3JaLFdBQVlzYixPQUFTO2dCQUV6Qiw4Q0FBOEM7Z0JBQzlDLE1BQVVnbEIsV0FBV0MsU0FBUyxDQUFFei9CLElBQUssQ0FBSztvQkFFekMsdUJBQXVCO29CQUN2QixJQUFLdy9CLFFBQVEsQ0FBRSxFQUFHLEtBQUssS0FBTTt3QkFDNUJBLFdBQVdBLFNBQVNyaEMsS0FBSyxDQUFFLE1BQU87d0JBQ2hDbWhDLENBQUFBLFNBQVMsQ0FBRUUsU0FBVSxHQUFHRixTQUFTLENBQUVFLFNBQVUsSUFBSSxFQUFFLEVBQUduZixPQUFPLENBQUU3RjtvQkFFbEUsbUJBQW1CO29CQUNuQixPQUFPO3dCQUNKOGtCLENBQUFBLFNBQVMsQ0FBRUUsU0FBVSxHQUFHRixTQUFTLENBQUVFLFNBQVUsSUFBSSxFQUFFLEVBQUcvZ0MsSUFBSSxDQUFFK2I7b0JBQy9EO2dCQUNEO1lBQ0Q7UUFDRDtJQUNEO0lBRUEseURBQXlEO0lBQ3pELFNBQVNrbEIsOEJBQStCSixTQUFTLEVBQUVyOEIsT0FBTyxFQUFFbTJCLGVBQWUsRUFBRXVHLEtBQUs7UUFFakYsSUFBSUMsWUFBWSxDQUFDLEdBQ2hCQyxtQkFBcUJQLGNBQWNKO1FBRXBDLFNBQVNZLFFBQVNOLFFBQVE7WUFDekIsSUFBSTF0QjtZQUNKOHRCLFNBQVMsQ0FBRUosU0FBVSxHQUFHO1lBQ3hCMStCLE9BQU9pQixJQUFJLENBQUV1OUIsU0FBUyxDQUFFRSxTQUFVLElBQUksRUFBRSxFQUFFLFNBQVU5bUIsQ0FBQyxFQUFFcW5CLGtCQUFrQjtnQkFDeEUsSUFBSUMsc0JBQXNCRCxtQkFBb0I5OEIsU0FBU20yQixpQkFBaUJ1RztnQkFDeEUsSUFBSyxPQUFPSyx3QkFBd0IsWUFDbkMsQ0FBQ0gsb0JBQW9CLENBQUNELFNBQVMsQ0FBRUksb0JBQXFCLEVBQUc7b0JBRXpELzhCLFFBQVF3OEIsU0FBUyxDQUFDcGYsT0FBTyxDQUFFMmY7b0JBQzNCRixRQUFTRTtvQkFDVCxPQUFPO2dCQUNSLE9BQU8sSUFBS0gsa0JBQW1CO29CQUM5QixPQUFPLENBQUcvdEIsQ0FBQUEsV0FBV2t1QixtQkFBa0I7Z0JBQ3hDO1lBQ0Q7WUFDQSxPQUFPbHVCO1FBQ1I7UUFFQSxPQUFPZ3VCLFFBQVM3OEIsUUFBUXc4QixTQUFTLENBQUUsRUFBRyxLQUFNLENBQUNHLFNBQVMsQ0FBRSxJQUFLLElBQUlFLFFBQVM7SUFDM0U7SUFFQSxvQ0FBb0M7SUFDcEMsc0RBQXNEO0lBQ3RELGtCQUFrQjtJQUNsQixTQUFTRyxXQUFZMzhCLE1BQU0sRUFBRTdELEdBQUc7UUFDL0IsSUFBSTZNLEtBQUsvSSxNQUNSMjhCLGNBQWNwL0IsT0FBT3EvQixZQUFZLENBQUNELFdBQVcsSUFBSSxDQUFDO1FBRW5ELElBQU01ekIsT0FBTzdNLElBQU07WUFDbEIsSUFBS0EsR0FBRyxDQUFFNk0sSUFBSyxLQUFLM0ksV0FBWTtnQkFDN0J1OEIsQ0FBQUEsV0FBVyxDQUFFNXpCLElBQUssR0FBR2hKLFNBQVdDLFFBQVVBLENBQUFBLE9BQU8sQ0FBQyxFQUFJLENBQUcsQ0FBRStJLElBQUssR0FBRzdNLEdBQUcsQ0FBRTZNLElBQUs7WUFDaEY7UUFDRDtRQUNBLElBQUsvSSxNQUFPO1lBQ1h6QyxPQUFPa0MsTUFBTSxDQUFFLE1BQU1NLFFBQVFDO1FBQzlCO1FBRUEsT0FBT0Q7SUFDUjtJQUVBOzs7Q0FHQyxHQUNELFNBQVM4OEIsb0JBQXFCOUIsQ0FBQyxFQUFFcUIsS0FBSyxFQUFFVSxTQUFTO1FBRWhELElBQUlDLElBQUk5Z0MsTUFBTStnQyxlQUFlQyxlQUM1QnBwQixXQUFXa25CLEVBQUVsbkIsUUFBUSxFQUNyQnFvQixZQUFZbkIsRUFBRW1CLFNBQVM7UUFFeEIsMkRBQTJEO1FBQzNELE1BQVFBLFNBQVMsQ0FBRSxFQUFHLEtBQUssSUFBTTtZQUNoQ0EsVUFBVWp6QixLQUFLO1lBQ2YsSUFBSzh6QixPQUFPMzhCLFdBQVk7Z0JBQ3ZCMjhCLEtBQUtoQyxFQUFFbUMsUUFBUSxJQUFJZCxNQUFNZSxpQkFBaUIsQ0FBRTtZQUM3QztRQUNEO1FBRUEsbURBQW1EO1FBQ25ELElBQUtKLElBQUs7WUFDVCxJQUFNOWdDLFFBQVE0WCxTQUFXO2dCQUN4QixJQUFLQSxRQUFRLENBQUU1WCxLQUFNLElBQUk0WCxRQUFRLENBQUU1WCxLQUFNLENBQUM0RixJQUFJLENBQUVrN0IsS0FBTztvQkFDdERiLFVBQVVwZixPQUFPLENBQUU3Z0I7b0JBQ25CO2dCQUNEO1lBQ0Q7UUFDRDtRQUVBLCtEQUErRDtRQUMvRCxJQUFLaWdDLFNBQVMsQ0FBRSxFQUFHLElBQUlZLFdBQVk7WUFDbENFLGdCQUFnQmQsU0FBUyxDQUFFLEVBQUc7UUFDL0IsT0FBTztZQUVOLDRCQUE0QjtZQUM1QixJQUFNamdDLFFBQVE2Z0MsVUFBWTtnQkFDekIsSUFBSyxDQUFDWixTQUFTLENBQUUsRUFBRyxJQUFJbkIsRUFBRXFDLFVBQVUsQ0FBRW5oQyxPQUFPLE1BQU1pZ0MsU0FBUyxDQUFFLEVBQUcsQ0FBRSxFQUFHO29CQUNyRWMsZ0JBQWdCL2dDO29CQUNoQjtnQkFDRDtnQkFDQSxJQUFLLENBQUNnaEMsZUFBZ0I7b0JBQ3JCQSxnQkFBZ0JoaEM7Z0JBQ2pCO1lBQ0Q7WUFFQSx3QkFBd0I7WUFDeEIrZ0MsZ0JBQWdCQSxpQkFBaUJDO1FBQ2xDO1FBRUEseUJBQXlCO1FBQ3pCLDRDQUE0QztRQUM1Qyx3Q0FBd0M7UUFDeEMsSUFBS0QsZUFBZ0I7WUFDcEIsSUFBS0Esa0JBQWtCZCxTQUFTLENBQUUsRUFBRyxFQUFHO2dCQUN2Q0EsVUFBVXBmLE9BQU8sQ0FBRWtnQjtZQUNwQjtZQUNBLE9BQU9GLFNBQVMsQ0FBRUUsY0FBZTtRQUNsQztJQUNEO0lBRUE7O0NBRUMsR0FDRCxTQUFTSyxZQUFhdEMsQ0FBQyxFQUFFdUMsUUFBUSxFQUFFbEIsS0FBSyxFQUFFbUIsU0FBUztRQUNsRCxJQUFJQyxPQUFPQyxTQUFTQyxNQUFNeGdCLEtBQUtwSixNQUM5QnNwQixhQUFhLENBQUMsR0FFZCw0RUFBNEU7UUFDNUVsQixZQUFZbkIsRUFBRW1CLFNBQVMsQ0FBQ3RoQyxLQUFLO1FBRTlCLDZDQUE2QztRQUM3QyxJQUFLc2hDLFNBQVMsQ0FBRSxFQUFHLEVBQUc7WUFDckIsSUFBTXdCLFFBQVEzQyxFQUFFcUMsVUFBVSxDQUFHO2dCQUM1QkEsVUFBVSxDQUFFTSxLQUFLLzZCLFdBQVcsR0FBSSxHQUFHbzRCLEVBQUVxQyxVQUFVLENBQUVNLEtBQU07WUFDeEQ7UUFDRDtRQUVBRCxVQUFVdkIsVUFBVWp6QixLQUFLO1FBRXpCLHNDQUFzQztRQUN0QyxNQUFRdzBCLFFBQVU7WUFFakIsSUFBSzFDLEVBQUU0QyxjQUFjLENBQUVGLFFBQVMsRUFBRztnQkFDbENyQixLQUFLLENBQUVyQixFQUFFNEMsY0FBYyxDQUFFRixRQUFTLENBQUUsR0FBR0g7WUFDeEM7WUFFQSxtQ0FBbUM7WUFDbkMsSUFBSyxDQUFDeHBCLFFBQVF5cEIsYUFBYXhDLEVBQUU2QyxVQUFVLEVBQUc7Z0JBQ3pDTixXQUFXdkMsRUFBRTZDLFVBQVUsQ0FBRU4sVUFBVXZDLEVBQUVrQixRQUFRO1lBQzlDO1lBRUFub0IsT0FBTzJwQjtZQUNQQSxVQUFVdkIsVUFBVWp6QixLQUFLO1lBRXpCLElBQUt3MEIsU0FBVTtnQkFFZCwwREFBMEQ7Z0JBQzFELElBQUtBLFlBQVksS0FBTTtvQkFFdEJBLFVBQVUzcEI7Z0JBRVgseUVBQXlFO2dCQUN6RSxPQUFPLElBQUtBLFNBQVMsT0FBT0EsU0FBUzJwQixTQUFVO29CQUU5QywwQkFBMEI7b0JBQzFCQyxPQUFPTixVQUFVLENBQUV0cEIsT0FBTyxNQUFNMnBCLFFBQVMsSUFBSUwsVUFBVSxDQUFFLE9BQU9LLFFBQVM7b0JBRXpFLDZCQUE2QjtvQkFDN0IsSUFBSyxDQUFDQyxNQUFPO3dCQUNaLElBQU1GLFNBQVNKLFdBQWE7NEJBRTNCLDJCQUEyQjs0QkFDM0JsZ0IsTUFBTXNnQixNQUFNLzZCLEtBQUssQ0FBRTs0QkFDbkIsSUFBS3lhLEdBQUcsQ0FBRSxFQUFHLEtBQUt1Z0IsU0FBVTtnQ0FFM0IsNkNBQTZDO2dDQUM3Q0MsT0FBT04sVUFBVSxDQUFFdHBCLE9BQU8sTUFBTW9KLEdBQUcsQ0FBRSxFQUFHLENBQUUsSUFDekNrZ0IsVUFBVSxDQUFFLE9BQU9sZ0IsR0FBRyxDQUFFLEVBQUcsQ0FBRTtnQ0FDOUIsSUFBS3dnQixNQUFPO29DQUVYLGtDQUFrQztvQ0FDbEMsSUFBS0EsU0FBUyxNQUFPO3dDQUNwQkEsT0FBT04sVUFBVSxDQUFFSSxNQUFPO29DQUUzQiw4Q0FBOEM7b0NBQzlDLE9BQU8sSUFBS0osVUFBVSxDQUFFSSxNQUFPLEtBQUssTUFBTzt3Q0FDMUNDLFVBQVV2Z0IsR0FBRyxDQUFFLEVBQUc7d0NBQ2xCZ2YsVUFBVXBmLE9BQU8sQ0FBRUksR0FBRyxDQUFFLEVBQUc7b0NBQzVCO29DQUNBO2dDQUNEOzRCQUNEO3dCQUNEO29CQUNEO29CQUVBLDBDQUEwQztvQkFDMUMsSUFBS3dnQixTQUFTLE1BQU87d0JBRXBCLDZEQUE2RDt3QkFDN0QsSUFBS0EsUUFBUTNDLEVBQUU4QyxNQUFNLEVBQUc7NEJBQ3ZCUCxXQUFXSSxLQUFNSjt3QkFDbEIsT0FBTzs0QkFDTixJQUFJO2dDQUNIQSxXQUFXSSxLQUFNSjs0QkFDbEIsRUFBRSxPQUFRajJCLEdBQUk7Z0NBQ2IsT0FBTztvQ0FDTjhQLE9BQU87b0NBQ1B6VyxPQUFPZzlCLE9BQU9yMkIsSUFBSSx3QkFBd0J5TSxPQUFPLFNBQVMycEI7Z0NBQzNEOzRCQUNEO3dCQUNEO29CQUNEO2dCQUNEO1lBQ0Q7UUFDRDtRQUVBLE9BQU87WUFBRXRtQixPQUFPO1lBQVd3RSxNQUFNMmhCO1FBQVM7SUFDM0M7SUFFQS8vQixPQUFPa0MsTUFBTSxDQUFFO1FBRWQsbURBQW1EO1FBQ25EcStCLFFBQVE7UUFFUiw4Q0FBOEM7UUFDOUNDLGNBQWMsQ0FBQztRQUNmQyxNQUFNLENBQUM7UUFFUHBCLGNBQWM7WUFDYnFCLEtBQUtsd0IsU0FBU0ksSUFBSTtZQUNsQmxTLE1BQU07WUFDTmlpQyxTQUFTMUMsZUFBZTM1QixJQUFJLENBQUVrTSxTQUFTb3dCLFFBQVE7WUFDL0Nwa0MsUUFBUTtZQUNScWtDLGFBQWE7WUFDYkMsT0FBTztZQUNQQyxhQUFhO1lBRWI7Ozs7Ozs7Ozs7RUFVQSxHQUVBQyxTQUFTO2dCQUNSLEtBQUszQztnQkFDTC8rQixNQUFNO2dCQUNOdXNCLE1BQU07Z0JBQ04zYyxLQUFLO2dCQUNMK3hCLE1BQU07WUFDUDtZQUVBM3FCLFVBQVU7Z0JBQ1RwSCxLQUFLO2dCQUNMMmMsTUFBTTtnQkFDTm9WLE1BQU07WUFDUDtZQUVBYixnQkFBZ0I7Z0JBQ2ZseEIsS0FBSztnQkFDTDVQLE1BQU07Z0JBQ04yaEMsTUFBTTtZQUNQO1lBRUEsa0JBQWtCO1lBQ2xCLG1GQUFtRjtZQUNuRnBCLFlBQVk7Z0JBRVgsMkJBQTJCO2dCQUMzQixVQUFVNTJCO2dCQUVWLDBDQUEwQztnQkFDMUMsYUFBYTtnQkFFYixxQ0FBcUM7Z0JBQ3JDLGFBQWEyVixLQUFLQyxLQUFLO2dCQUV2QixvQkFBb0I7Z0JBQ3BCLFlBQVk3ZSxPQUFPbzhCLFFBQVE7WUFDNUI7WUFFQSwrQ0FBK0M7WUFDL0MsOENBQThDO1lBQzlDLDRDQUE0QztZQUM1QyxpQ0FBaUM7WUFDakNnRCxhQUFhO2dCQUNac0IsS0FBSztnQkFDTHhnQyxTQUFTO1lBQ1Y7UUFDRDtRQUVBLHFEQUFxRDtRQUNyRCw4Q0FBOEM7UUFDOUMsa0RBQWtEO1FBQ2xEZ2hDLFdBQVcsU0FBVTErQixNQUFNLEVBQUUyK0IsUUFBUTtZQUNwQyxPQUFPQSxXQUVOLDZCQUE2QjtZQUM3QmhDLFdBQVlBLFdBQVkzOEIsUUFBUXhDLE9BQU9xL0IsWUFBWSxHQUFJOEIsWUFFdkQseUJBQXlCO1lBQ3pCaEMsV0FBWW4vQixPQUFPcS9CLFlBQVksRUFBRTc4QjtRQUNuQztRQUVBNCtCLGVBQWU3Qyw0QkFBNkJ0RztRQUM1Q29KLGVBQWU5Qyw0QkFBNkJIO1FBRTVDLGNBQWM7UUFDZGtELE1BQU0sU0FBVVosR0FBRyxFQUFFditCLE9BQU87WUFFM0Isa0RBQWtEO1lBQ2xELElBQUssT0FBT3UrQixRQUFRLFVBQVc7Z0JBQzlCditCLFVBQVV1K0I7Z0JBQ1ZBLE1BQU03OUI7WUFDUDtZQUVBLGdDQUFnQztZQUNoQ1YsVUFBVUEsV0FBVyxDQUFDO1lBRXRCLElBQUlvL0IsV0FFSCwrQkFBK0I7WUFDL0JDLFVBRUEsbUJBQW1CO1lBQ25CQyx1QkFDQUMsaUJBRUEsaUJBQWlCO1lBQ2pCQyxjQUVBLGtCQUFrQjtZQUNsQkMsV0FFQSxtRUFBbUU7WUFDbkVqbEIsV0FFQSxnREFBZ0Q7WUFDaERrbEIsYUFFQSxnQkFBZ0I7WUFDaEIzaUMsR0FFQSwyQkFBMkI7WUFDM0I0aUMsVUFFQSxrQ0FBa0M7WUFDbEN0RSxJQUFJeDlCLE9BQU9raEMsU0FBUyxDQUFFLENBQUMsR0FBRy8rQixVQUUxQixvQkFBb0I7WUFDcEI0L0Isa0JBQWtCdkUsRUFBRXQ5QixPQUFPLElBQUlzOUIsR0FFL0Isd0ZBQXdGO1lBQ3hGd0UscUJBQXFCeEUsRUFBRXQ5QixPQUFPLElBQzNCNmhDLENBQUFBLGdCQUFnQnpqQyxRQUFRLElBQUl5akMsZ0JBQWdCemhDLE1BQU0sSUFDcEROLE9BQVEraEMsbUJBQ1IvaEMsT0FBT3VrQixLQUFLLEVBRWIsWUFBWTtZQUNaekssV0FBVzlaLE9BQU95WixRQUFRLElBQzFCd29CLG1CQUFtQmppQyxPQUFPOFgsU0FBUyxDQUFFLGdCQUVyQyw2QkFBNkI7WUFDN0JvcUIsYUFBYTFFLEVBQUUwRSxVQUFVLElBQUksQ0FBQyxHQUU5QixzQ0FBc0M7WUFDdENDLGlCQUFpQixDQUFDLEdBQ2xCQyxzQkFBc0IsQ0FBQyxHQUV2Qix3QkFBd0I7WUFDeEJDLFdBQVcsWUFFWCxXQUFXO1lBQ1h4RCxRQUFRO2dCQUNQaGlCLFlBQVk7Z0JBRVoscUNBQXFDO2dCQUNyQytpQixtQkFBbUIsU0FBVXAwQixHQUFHO29CQUMvQixJQUFJcEI7b0JBQ0osSUFBS3VTLFdBQVk7d0JBQ2hCLElBQUssQ0FBQytrQixpQkFBa0I7NEJBQ3ZCQSxrQkFBa0IsQ0FBQzs0QkFDbkIsTUFBVXQzQixRQUFRNHpCLFNBQVN4ekIsSUFBSSxDQUFFaTNCLHVCQUE0QjtnQ0FDNURDLGVBQWUsQ0FBRXQzQixLQUFLLENBQUUsRUFBRyxDQUFDaEYsV0FBVyxLQUFLLElBQUssR0FDaEQsQ0FBRXM4QixlQUFlLENBQUV0M0IsS0FBSyxDQUFFLEVBQUcsQ0FBQ2hGLFdBQVcsS0FBSyxJQUFLLElBQUksRUFBRSxFQUN2RDNILE1BQU0sQ0FBRTJNLEtBQUssQ0FBRSxFQUFHOzRCQUN0Qjt3QkFDRDt3QkFDQUEsUUFBUXMzQixlQUFlLENBQUVsMkIsSUFBSXBHLFdBQVcsS0FBSyxJQUFLO29CQUNuRDtvQkFDQSxPQUFPZ0YsU0FBUyxPQUFPLE9BQU9BLE1BQU1hLElBQUksQ0FBRTtnQkFDM0M7Z0JBRUEsYUFBYTtnQkFDYnEzQix1QkFBdUI7b0JBQ3RCLE9BQU8zbEIsWUFBWThrQix3QkFBd0I7Z0JBQzVDO2dCQUVBLG9CQUFvQjtnQkFDcEJjLGtCQUFrQixTQUFVbmdDLElBQUksRUFBRTBDLEtBQUs7b0JBQ3RDLElBQUs2WCxhQUFhLE1BQU87d0JBQ3hCdmEsT0FBT2dnQyxtQkFBbUIsQ0FBRWhnQyxLQUFLZ0QsV0FBVyxHQUFJLEdBQy9DZzlCLG1CQUFtQixDQUFFaGdDLEtBQUtnRCxXQUFXLEdBQUksSUFBSWhEO3dCQUM5QysvQixjQUFjLENBQUUvL0IsS0FBTSxHQUFHMEM7b0JBQzFCO29CQUNBLE9BQU8sSUFBSTtnQkFDWjtnQkFFQSx5Q0FBeUM7Z0JBQ3pDMDlCLGtCQUFrQixTQUFVOWpDLElBQUk7b0JBQy9CLElBQUtpZSxhQUFhLE1BQU87d0JBQ3hCNmdCLEVBQUVtQyxRQUFRLEdBQUdqaEM7b0JBQ2Q7b0JBQ0EsT0FBTyxJQUFJO2dCQUNaO2dCQUVBLDZCQUE2QjtnQkFDN0J3akMsWUFBWSxTQUFVL2dDLEdBQUc7b0JBQ3hCLElBQUlwQztvQkFDSixJQUFLb0MsS0FBTTt3QkFDVixJQUFLd2IsV0FBWTs0QkFFaEIsb0NBQW9DOzRCQUNwQ2tpQixNQUFNaGxCLE1BQU0sQ0FBRTFZLEdBQUcsQ0FBRTA5QixNQUFNNEQsTUFBTSxDQUFFO3dCQUNsQyxPQUFPOzRCQUVOLDhEQUE4RDs0QkFDOUQsSUFBTTFqQyxRQUFRb0MsSUFBTTtnQ0FDbkIrZ0MsVUFBVSxDQUFFbmpDLEtBQU0sR0FBRztvQ0FBRW1qQyxVQUFVLENBQUVuakMsS0FBTTtvQ0FBRW9DLEdBQUcsQ0FBRXBDLEtBQU07aUNBQUU7NEJBQ3pEO3dCQUNEO29CQUNEO29CQUNBLE9BQU8sSUFBSTtnQkFDWjtnQkFFQSxxQkFBcUI7Z0JBQ3JCMmpDLE9BQU8sU0FBVUMsVUFBVTtvQkFDMUIsSUFBSUMsWUFBWUQsY0FBY047b0JBQzlCLElBQUtkLFdBQVk7d0JBQ2hCQSxVQUFVbUIsS0FBSyxDQUFFRTtvQkFDbEI7b0JBQ0E5N0IsS0FBTSxHQUFHODdCO29CQUNULE9BQU8sSUFBSTtnQkFDWjtZQUNEO1lBRUQsbUJBQW1CO1lBQ25COW9CLFNBQVNSLE9BQU8sQ0FBRXVsQjtZQUVsQiw0REFBNEQ7WUFDNUQsdUZBQXVGO1lBQ3ZGLDZDQUE2QztZQUM3Q3JCLEVBQUVrRCxHQUFHLEdBQUcsQ0FBRSxDQUFFQSxPQUFPbEQsRUFBRWtELEdBQUcsSUFBSWx3QixTQUFTSSxJQUFJLElBQUssRUFBQyxFQUM3QzNOLE9BQU8sQ0FBRWs3QixXQUFXM3RCLFNBQVNvd0IsUUFBUSxHQUFHO1lBRTFDLHVEQUF1RDtZQUN2RHBELEVBQUU5K0IsSUFBSSxHQUFHeUQsUUFBUWtYLE1BQU0sSUFBSWxYLFFBQVF6RCxJQUFJLElBQUk4K0IsRUFBRW5rQixNQUFNLElBQUlta0IsRUFBRTkrQixJQUFJO1lBRTdELHlCQUF5QjtZQUN6QjgrQixFQUFFbUIsU0FBUyxHQUFHLENBQUVuQixFQUFFa0IsUUFBUSxJQUFJLEdBQUUsRUFBSXQ1QixXQUFXLEdBQUdnRixLQUFLLENBQUVxTixrQkFBbUI7Z0JBQUU7YUFBSTtZQUVsRix1RkFBdUY7WUFDdkYsSUFBSytsQixFQUFFcUYsV0FBVyxJQUFJLE1BQU87Z0JBQzVCakIsWUFBWWhsQyxTQUFTeUMsYUFBYSxDQUFFO2dCQUVwQyxxQ0FBcUM7Z0JBQ3JDLDBFQUEwRTtnQkFDMUUsK0JBQStCO2dCQUMvQixJQUFJO29CQUNIdWlDLFVBQVVoeEIsSUFBSSxHQUFHNHNCLEVBQUVrRCxHQUFHO29CQUV0Qiw0QkFBNEI7b0JBQzVCLG9FQUFvRTtvQkFDcEVrQixVQUFVaHhCLElBQUksR0FBR2d4QixVQUFVaHhCLElBQUk7b0JBQy9CNHNCLEVBQUVxRixXQUFXLEdBQUd2RSxhQUFhc0MsUUFBUSxHQUFHLE9BQU90QyxhQUFhd0UsSUFBSSxLQUMvRGxCLFVBQVVoQixRQUFRLEdBQUcsT0FBT2dCLFVBQVVrQixJQUFJO2dCQUM1QyxFQUFFLE9BQVFoNUIsR0FBSTtvQkFFYixrRUFBa0U7b0JBQ2xFLHVEQUF1RDtvQkFDdkQwekIsRUFBRXFGLFdBQVcsR0FBRztnQkFDakI7WUFDRDtZQUVBLHVDQUF1QztZQUN2QyxJQUFLckYsRUFBRXBmLElBQUksSUFBSW9mLEVBQUVxRCxXQUFXLElBQUksT0FBT3JELEVBQUVwZixJQUFJLEtBQUssVUFBVztnQkFDNURvZixFQUFFcGYsSUFBSSxHQUFHcGUsT0FBT3U5QixLQUFLLENBQUVDLEVBQUVwZixJQUFJLEVBQUVvZixFQUFFRixXQUFXO1lBQzdDO1lBRUEsbUJBQW1CO1lBQ25Cc0IsOEJBQStCM0csWUFBWXVGLEdBQUdyN0IsU0FBUzA4QjtZQUV2RCx3REFBd0Q7WUFDeEQsSUFBS2xpQixXQUFZO2dCQUNoQixPQUFPa2lCO1lBQ1I7WUFFQSxrREFBa0Q7WUFDbEQsdUZBQXVGO1lBQ3ZGZ0QsY0FBYzdoQyxPQUFPdWtCLEtBQUssSUFBSWlaLEVBQUVoaEMsTUFBTTtZQUV0QyxrQ0FBa0M7WUFDbEMsSUFBS3FsQyxlQUFlN2hDLE9BQU91Z0MsTUFBTSxPQUFPLEdBQUk7Z0JBQzNDdmdDLE9BQU91a0IsS0FBSyxDQUFDK0MsT0FBTyxDQUFFO1lBQ3ZCO1lBRUEscUJBQXFCO1lBQ3JCa1csRUFBRTkrQixJQUFJLEdBQUc4K0IsRUFBRTkrQixJQUFJLENBQUNnZixXQUFXO1lBRTNCLG1DQUFtQztZQUNuQzhmLEVBQUV1RixVQUFVLEdBQUcsQ0FBQzdFLFdBQVc1NUIsSUFBSSxDQUFFazVCLEVBQUU5K0IsSUFBSTtZQUV2QywrREFBK0Q7WUFDL0QsdUNBQXVDO1lBQ3ZDLDJDQUEyQztZQUMzQzhpQyxXQUFXaEUsRUFBRWtELEdBQUcsQ0FBQ3o5QixPQUFPLENBQUU2NkIsT0FBTztZQUVqQyxxREFBcUQ7WUFDckQsSUFBSyxDQUFDTixFQUFFdUYsVUFBVSxFQUFHO2dCQUVwQiwwQ0FBMEM7Z0JBQzFDakIsV0FBV3RFLEVBQUVrRCxHQUFHLENBQUNyakMsS0FBSyxDQUFFbWtDLFNBQVNoaEMsTUFBTTtnQkFFdkMsbUVBQW1FO2dCQUNuRSxJQUFLZzlCLEVBQUVwZixJQUFJLElBQU1vZixDQUFBQSxFQUFFcUQsV0FBVyxJQUFJLE9BQU9yRCxFQUFFcGYsSUFBSSxLQUFLLFFBQU8sR0FBTTtvQkFDaEVvakIsWUFBWSxDQUFFckYsT0FBTzczQixJQUFJLENBQUVrOUIsWUFBYSxNQUFNLEdBQUUsSUFBTWhFLEVBQUVwZixJQUFJO29CQUU1RCxvRUFBb0U7b0JBQ3BFLE9BQU9vZixFQUFFcGYsSUFBSTtnQkFDZDtnQkFFQSwyQ0FBMkM7Z0JBQzNDLElBQUtvZixFQUFFanlCLEtBQUssS0FBSyxPQUFRO29CQUN4QmkyQixXQUFXQSxTQUFTditCLE9BQU8sQ0FBRTg2QixZQUFZO29CQUN6QytELFdBQVcsQ0FBRTNGLE9BQU83M0IsSUFBSSxDQUFFazlCLFlBQWEsTUFBTSxHQUFFLElBQU0sT0FBUzVpQyxNQUFNbUcsSUFBSSxLQUN2RSs4QjtnQkFDRjtnQkFFQSxzRUFBc0U7Z0JBQ3RFdEUsRUFBRWtELEdBQUcsR0FBR2MsV0FBV007WUFFcEIscUVBQXFFO1lBQ3JFLE9BQU8sSUFBS3RFLEVBQUVwZixJQUFJLElBQUlvZixFQUFFcUQsV0FBVyxJQUNsQyxDQUFFckQsRUFBRXVELFdBQVcsSUFBSSxFQUFDLEVBQUluakMsT0FBTyxDQUFFLHlDQUEwQyxHQUFJO2dCQUMvRTQvQixFQUFFcGYsSUFBSSxHQUFHb2YsRUFBRXBmLElBQUksQ0FBQ25iLE9BQU8sQ0FBRTQ2QixLQUFLO1lBQy9CO1lBRUEsZ0ZBQWdGO1lBQ2hGLElBQUtMLEVBQUV3RixVQUFVLEVBQUc7Z0JBQ25CLElBQUtoakMsT0FBT3dnQyxZQUFZLENBQUVnQixTQUFVLEVBQUc7b0JBQ3RDM0MsTUFBTTBELGdCQUFnQixDQUFFLHFCQUFxQnZpQyxPQUFPd2dDLFlBQVksQ0FBRWdCLFNBQVU7Z0JBQzdFO2dCQUNBLElBQUt4aEMsT0FBT3lnQyxJQUFJLENBQUVlLFNBQVUsRUFBRztvQkFDOUIzQyxNQUFNMEQsZ0JBQWdCLENBQUUsaUJBQWlCdmlDLE9BQU95Z0MsSUFBSSxDQUFFZSxTQUFVO2dCQUNqRTtZQUNEO1lBRUEsZ0RBQWdEO1lBQ2hELElBQUtoRSxFQUFFcGYsSUFBSSxJQUFJb2YsRUFBRXVGLFVBQVUsSUFBSXZGLEVBQUV1RCxXQUFXLEtBQUssU0FBUzUrQixRQUFRNCtCLFdBQVcsRUFBRztnQkFDL0VsQyxNQUFNMEQsZ0JBQWdCLENBQUUsZ0JBQWdCL0UsRUFBRXVELFdBQVc7WUFDdEQ7WUFFQSxtRUFBbUU7WUFDbkVsQyxNQUFNMEQsZ0JBQWdCLENBQ3JCLFVBQ0EvRSxFQUFFbUIsU0FBUyxDQUFFLEVBQUcsSUFBSW5CLEVBQUV3RCxPQUFPLENBQUV4RCxFQUFFbUIsU0FBUyxDQUFFLEVBQUcsQ0FBRSxHQUNoRG5CLEVBQUV3RCxPQUFPLENBQUV4RCxFQUFFbUIsU0FBUyxDQUFFLEVBQUcsQ0FBRSxHQUMxQm5CLENBQUFBLEVBQUVtQixTQUFTLENBQUUsRUFBRyxLQUFLLE1BQU0sT0FBT04sV0FBVyxhQUFhLEVBQUMsSUFDOURiLEVBQUV3RCxPQUFPLENBQUUsSUFBSztZQUdsQiwyQkFBMkI7WUFDM0IsSUFBTTloQyxLQUFLcytCLEVBQUV5RixPQUFPLENBQUc7Z0JBQ3RCcEUsTUFBTTBELGdCQUFnQixDQUFFcmpDLEdBQUdzK0IsRUFBRXlGLE9BQU8sQ0FBRS9qQyxFQUFHO1lBQzFDO1lBRUEsaURBQWlEO1lBQ2pELElBQUtzK0IsRUFBRTBGLFVBQVUsSUFDZDFGLENBQUFBLEVBQUUwRixVQUFVLENBQUMxbEMsSUFBSSxDQUFFdWtDLGlCQUFpQmxELE9BQU9yQixPQUFRLFNBQVM3Z0IsU0FBUSxHQUFNO2dCQUU1RSx1Q0FBdUM7Z0JBQ3ZDLE9BQU9raUIsTUFBTTZELEtBQUs7WUFDbkI7WUFFQSx1Q0FBdUM7WUFDdkNMLFdBQVc7WUFFWCxpQ0FBaUM7WUFDakNKLGlCQUFpQm5yQixHQUFHLENBQUUwbUIsRUFBRS9FLFFBQVE7WUFDaENvRyxNQUFNLzNCLElBQUksQ0FBRTAyQixFQUFFMkYsT0FBTztZQUNyQnRFLE1BQU10bEIsSUFBSSxDQUFFaWtCLEVBQUVyNkIsS0FBSztZQUVuQixnQkFBZ0I7WUFDaEJvK0IsWUFBWTNDLDhCQUErQlIsWUFBWVosR0FBR3I3QixTQUFTMDhCO1lBRW5FLGlDQUFpQztZQUNqQyxJQUFLLENBQUMwQyxXQUFZO2dCQUNqQno2QixLQUFNLENBQUMsR0FBRztZQUNYLE9BQU87Z0JBQ04rM0IsTUFBTWhpQixVQUFVLEdBQUc7Z0JBRW5CLG9CQUFvQjtnQkFDcEIsSUFBS2dsQixhQUFjO29CQUNsQkcsbUJBQW1CMWEsT0FBTyxDQUFFLFlBQVk7d0JBQUV1WDt3QkFBT3JCO3FCQUFHO2dCQUNyRDtnQkFFQSxxREFBcUQ7Z0JBQ3JELElBQUs3Z0IsV0FBWTtvQkFDaEIsT0FBT2tpQjtnQkFDUjtnQkFFQSxVQUFVO2dCQUNWLElBQUtyQixFQUFFc0QsS0FBSyxJQUFJdEQsRUFBRXJELE9BQU8sR0FBRyxHQUFJO29CQUMvQndILGVBQWU1a0MsUUFBT3dlLFVBQVUsQ0FBRTt3QkFDakNzakIsTUFBTTZELEtBQUssQ0FBRTtvQkFDZCxHQUFHbEYsRUFBRXJELE9BQU87Z0JBQ2I7Z0JBRUEsSUFBSTtvQkFDSHhkLFlBQVk7b0JBQ1o0a0IsVUFBVTZCLElBQUksQ0FBRWpCLGdCQUFnQnI3QjtnQkFDakMsRUFBRSxPQUFRZ0QsR0FBSTtvQkFFYixxQ0FBcUM7b0JBQ3JDLElBQUs2UyxXQUFZO3dCQUNoQixNQUFNN1M7b0JBQ1A7b0JBRUEsOEJBQThCO29CQUM5QmhELEtBQU0sQ0FBQyxHQUFHZ0Q7Z0JBQ1g7WUFDRDtZQUVBLHVDQUF1QztZQUN2QyxTQUFTaEQsS0FBTTI3QixNQUFNLEVBQUVZLGdCQUFnQixFQUFFOUQsU0FBUyxFQUFFMEQsT0FBTztnQkFDMUQsSUFBSWpELFdBQVdtRCxTQUFTaGdDLE9BQU80OEIsVUFBVXVELFVBQ3hDWCxhQUFhVTtnQkFFZCw0QkFBNEI7Z0JBQzVCLElBQUsxbUIsV0FBWTtvQkFDaEI7Z0JBQ0Q7Z0JBRUFBLFlBQVk7Z0JBRVosNkJBQTZCO2dCQUM3QixJQUFLZ2xCLGNBQWU7b0JBQ25CNWtDLFFBQU9xOUIsWUFBWSxDQUFFdUg7Z0JBQ3RCO2dCQUVBLHFEQUFxRDtnQkFDckQscURBQXFEO2dCQUNyREosWUFBWTErQjtnQkFFWix5QkFBeUI7Z0JBQ3pCNCtCLHdCQUF3QndCLFdBQVc7Z0JBRW5DLGlCQUFpQjtnQkFDakJwRSxNQUFNaGlCLFVBQVUsR0FBRzRsQixTQUFTLElBQUksSUFBSTtnQkFFcEMsMEJBQTBCO2dCQUMxQnpDLFlBQVl5QyxVQUFVLE9BQU9BLFNBQVMsT0FBT0EsV0FBVztnQkFFeEQsb0JBQW9CO2dCQUNwQixJQUFLbEQsV0FBWTtvQkFDaEJRLFdBQVdULG9CQUFxQjlCLEdBQUdxQixPQUFPVTtnQkFDM0M7Z0JBRUEsMkRBQTJEO2dCQUMzRCxJQUFLLENBQUNTLGFBQ0xoZ0MsT0FBT2dFLE9BQU8sQ0FBRSxVQUFVdzVCLEVBQUVtQixTQUFTLElBQUssQ0FBQyxLQUMzQzMrQixPQUFPZ0UsT0FBTyxDQUFFLFFBQVF3NUIsRUFBRW1CLFNBQVMsSUFBSyxHQUFJO29CQUM1Q25CLEVBQUVxQyxVQUFVLENBQUUsY0FBZSxHQUFHLFlBQVk7Z0JBQzdDO2dCQUVBLHNFQUFzRTtnQkFDdEVFLFdBQVdELFlBQWF0QyxHQUFHdUMsVUFBVWxCLE9BQU9tQjtnQkFFNUMsc0NBQXNDO2dCQUN0QyxJQUFLQSxXQUFZO29CQUVoQixnRkFBZ0Y7b0JBQ2hGLElBQUt4QyxFQUFFd0YsVUFBVSxFQUFHO3dCQUNuQk0sV0FBV3pFLE1BQU1lLGlCQUFpQixDQUFFO3dCQUNwQyxJQUFLMEQsVUFBVzs0QkFDZnRqQyxPQUFPd2dDLFlBQVksQ0FBRWdCLFNBQVUsR0FBRzhCO3dCQUNuQzt3QkFDQUEsV0FBV3pFLE1BQU1lLGlCQUFpQixDQUFFO3dCQUNwQyxJQUFLMEQsVUFBVzs0QkFDZnRqQyxPQUFPeWdDLElBQUksQ0FBRWUsU0FBVSxHQUFHOEI7d0JBQzNCO29CQUNEO29CQUVBLGdCQUFnQjtvQkFDaEIsSUFBS2IsV0FBVyxPQUFPakYsRUFBRTkrQixJQUFJLEtBQUssUUFBUzt3QkFDMUNpa0MsYUFBYTtvQkFFZCxrQkFBa0I7b0JBQ2xCLE9BQU8sSUFBS0YsV0FBVyxLQUFNO3dCQUM1QkUsYUFBYTtvQkFFZCxvQ0FBb0M7b0JBQ3BDLE9BQU87d0JBQ05BLGFBQWE1QyxTQUFTbm1CLEtBQUs7d0JBQzNCdXBCLFVBQVVwRCxTQUFTM2hCLElBQUk7d0JBQ3ZCamIsUUFBUTQ4QixTQUFTNThCLEtBQUs7d0JBQ3RCNjhCLFlBQVksQ0FBQzc4QjtvQkFDZDtnQkFDRCxPQUFPO29CQUVOLDZEQUE2RDtvQkFDN0RBLFFBQVF3L0I7b0JBQ1IsSUFBS0YsVUFBVSxDQUFDRSxZQUFhO3dCQUM1QkEsYUFBYTt3QkFDYixJQUFLRixTQUFTLEdBQUk7NEJBQ2pCQSxTQUFTO3dCQUNWO29CQUNEO2dCQUNEO2dCQUVBLG1DQUFtQztnQkFDbkM1RCxNQUFNNEQsTUFBTSxHQUFHQTtnQkFDZjVELE1BQU04RCxVQUFVLEdBQUcsQ0FBRVUsb0JBQW9CVixVQUFTLElBQU07Z0JBRXhELGdCQUFnQjtnQkFDaEIsSUFBSzNDLFdBQVk7b0JBQ2hCbG1CLFNBQVNtQixXQUFXLENBQUU4bUIsaUJBQWlCO3dCQUFFb0I7d0JBQVNSO3dCQUFZOUQ7cUJBQU87Z0JBQ3RFLE9BQU87b0JBQ04va0IsU0FBU3NCLFVBQVUsQ0FBRTJtQixpQkFBaUI7d0JBQUVsRDt3QkFBTzhEO3dCQUFZeC9CO3FCQUFPO2dCQUNuRTtnQkFFQSw2QkFBNkI7Z0JBQzdCMDdCLE1BQU1xRCxVQUFVLENBQUVBO2dCQUNsQkEsYUFBYXIvQjtnQkFFYixJQUFLZy9CLGFBQWM7b0JBQ2xCRyxtQkFBbUIxYSxPQUFPLENBQUUwWSxZQUFZLGdCQUFnQixhQUN2RDt3QkFBRW5CO3dCQUFPckI7d0JBQUd3QyxZQUFZbUQsVUFBVWhnQztxQkFBTztnQkFDM0M7Z0JBRUEsV0FBVztnQkFDWDgrQixpQkFBaUJycEIsUUFBUSxDQUFFbXBCLGlCQUFpQjtvQkFBRWxEO29CQUFPOEQ7aUJBQVk7Z0JBRWpFLElBQUtkLGFBQWM7b0JBQ2xCRyxtQkFBbUIxYSxPQUFPLENBQUUsZ0JBQWdCO3dCQUFFdVg7d0JBQU9yQjtxQkFBRztvQkFFeEQsaUNBQWlDO29CQUNqQyxJQUFLLENBQUcsRUFBRXg5QixPQUFPdWdDLE1BQU0sRUFBSzt3QkFDM0J2Z0MsT0FBT3VrQixLQUFLLENBQUMrQyxPQUFPLENBQUU7b0JBQ3ZCO2dCQUNEO1lBQ0Q7WUFFQSxPQUFPdVg7UUFDUjtRQUVBMEUsU0FBUyxTQUFVN0MsR0FBRyxFQUFFdGlCLElBQUksRUFBRWxkLFFBQVE7WUFDckMsT0FBT2xCLE9BQU9VLEdBQUcsQ0FBRWdnQyxLQUFLdGlCLE1BQU1sZCxVQUFVO1FBQ3pDO1FBRUFzaUMsV0FBVyxTQUFVOUMsR0FBRyxFQUFFeC9CLFFBQVE7WUFDakMsT0FBT2xCLE9BQU9VLEdBQUcsQ0FBRWdnQyxLQUFLNzlCLFdBQVczQixVQUFVO1FBQzlDO0lBQ0Q7SUFFQWxCLE9BQU9pQixJQUFJLENBQUU7UUFBRTtRQUFPO0tBQVEsRUFBRSxTQUFVa0UsRUFBRSxFQUFFa1UsTUFBTTtRQUNuRHJaLE1BQU0sQ0FBRXFaLE9BQVEsR0FBRyxTQUFVcW5CLEdBQUcsRUFBRXRpQixJQUFJLEVBQUVsZCxRQUFRLEVBQUV4QyxJQUFJO1lBRXJELCtDQUErQztZQUMvQyxJQUFLTixXQUFZZ2dCLE9BQVM7Z0JBQ3pCMWYsT0FBT0EsUUFBUXdDO2dCQUNmQSxXQUFXa2Q7Z0JBQ1hBLE9BQU92YjtZQUNSO1lBRUEsK0RBQStEO1lBQy9ELE9BQU83QyxPQUFPc2hDLElBQUksQ0FBRXRoQyxPQUFPa0MsTUFBTSxDQUFFO2dCQUNsQ3crQixLQUFLQTtnQkFDTGhpQyxNQUFNMmE7Z0JBQ05xbEIsVUFBVWhnQztnQkFDVjBmLE1BQU1BO2dCQUNOK2tCLFNBQVNqaUM7WUFDVixHQUFHbEIsT0FBTzBDLGFBQWEsQ0FBRWcrQixRQUFTQTtRQUNuQztJQUNEO0lBRUExZ0MsT0FBT29oQyxhQUFhLENBQUUsU0FBVTVELENBQUM7UUFDaEMsSUFBSXQrQjtRQUNKLElBQU1BLEtBQUtzK0IsRUFBRXlGLE9BQU8sQ0FBRztZQUN0QixJQUFLL2pDLEVBQUVrRyxXQUFXLE9BQU8sZ0JBQWlCO2dCQUN6Q280QixFQUFFdUQsV0FBVyxHQUFHdkQsRUFBRXlGLE9BQU8sQ0FBRS9qQyxFQUFHLElBQUk7WUFDbkM7UUFDRDtJQUNEO0lBR0FjLE9BQU84ckIsUUFBUSxHQUFHLFNBQVU0VSxHQUFHLEVBQUV2K0IsT0FBTyxFQUFFbEQsR0FBRztRQUM1QyxPQUFPZSxPQUFPc2hDLElBQUksQ0FBRTtZQUNuQlosS0FBS0E7WUFFTCxrRkFBa0Y7WUFDbEZoaUMsTUFBTTtZQUNOZ2dDLFVBQVU7WUFDVm56QixPQUFPO1lBQ1B1MUIsT0FBTztZQUNQdGtDLFFBQVE7WUFFUiwyREFBMkQ7WUFDM0QsdUVBQXVFO1lBQ3ZFLG1EQUFtRDtZQUNuRHFqQyxZQUFZO2dCQUNYLGVBQWUsWUFBWTtZQUM1QjtZQUNBUSxZQUFZLFNBQVVOLFFBQVE7Z0JBQzdCLy9CLE9BQU95RCxVQUFVLENBQUVzOEIsVUFBVTU5QixTQUFTbEQ7WUFDdkM7UUFDRDtJQUNEO0lBR0FlLE9BQU9HLEVBQUUsQ0FBQytCLE1BQU0sQ0FBRTtRQUNqQnVoQyxTQUFTLFNBQVU1WCxJQUFJO1lBQ3RCLElBQUlsSTtZQUVKLElBQUssSUFBSSxDQUFFLEVBQUcsRUFBRztnQkFDaEIsSUFBS3ZsQixXQUFZeXRCLE9BQVM7b0JBQ3pCQSxPQUFPQSxLQUFLcnVCLElBQUksQ0FBRSxJQUFJLENBQUUsRUFBRztnQkFDNUI7Z0JBRUEseUNBQXlDO2dCQUN6Q21tQixPQUFPM2pCLE9BQVE2ckIsTUFBTSxJQUFJLENBQUUsRUFBRyxDQUFDeG5CLGFBQWEsRUFBRzlDLEVBQUUsQ0FBRSxHQUFJZ0IsS0FBSyxDQUFFO2dCQUU5RCxJQUFLLElBQUksQ0FBRSxFQUFHLENBQUM1QyxVQUFVLEVBQUc7b0JBQzNCZ2tCLEtBQUs4SSxZQUFZLENBQUUsSUFBSSxDQUFFLEVBQUc7Z0JBQzdCO2dCQUVBOUksS0FBS3hpQixHQUFHLENBQUU7b0JBQ1QsSUFBSUMsT0FBTyxJQUFJO29CQUVmLE1BQVFBLEtBQUtzaUMsaUJBQWlCLENBQUc7d0JBQ2hDdGlDLE9BQU9BLEtBQUtzaUMsaUJBQWlCO29CQUM5QjtvQkFFQSxPQUFPdGlDO2dCQUNSLEdBQUltckIsTUFBTSxDQUFFLElBQUk7WUFDakI7WUFFQSxPQUFPLElBQUk7UUFDWjtRQUVBb1gsV0FBVyxTQUFVOVgsSUFBSTtZQUN4QixJQUFLenRCLFdBQVl5dEIsT0FBUztnQkFDekIsT0FBTyxJQUFJLENBQUM1cUIsSUFBSSxDQUFFLFNBQVUvQixDQUFDO29CQUM1QmMsT0FBUSxJQUFJLEVBQUcyakMsU0FBUyxDQUFFOVgsS0FBS3J1QixJQUFJLENBQUUsSUFBSSxFQUFFMEI7Z0JBQzVDO1lBQ0Q7WUFFQSxPQUFPLElBQUksQ0FBQytCLElBQUksQ0FBRTtnQkFDakIsSUFBSThVLE9BQU8vVixPQUFRLElBQUksR0FDdEJzVyxXQUFXUCxLQUFLTyxRQUFRO2dCQUV6QixJQUFLQSxTQUFTOVYsTUFBTSxFQUFHO29CQUN0QjhWLFNBQVNtdEIsT0FBTyxDQUFFNVg7Z0JBRW5CLE9BQU87b0JBQ045VixLQUFLd1csTUFBTSxDQUFFVjtnQkFDZDtZQUNEO1FBQ0Q7UUFFQWxJLE1BQU0sU0FBVWtJLElBQUk7WUFDbkIsSUFBSStYLGlCQUFpQnhsQyxXQUFZeXRCO1lBRWpDLE9BQU8sSUFBSSxDQUFDNXFCLElBQUksQ0FBRSxTQUFVL0IsQ0FBQztnQkFDNUJjLE9BQVEsSUFBSSxFQUFHeWpDLE9BQU8sQ0FBRUcsaUJBQWlCL1gsS0FBS3J1QixJQUFJLENBQUUsSUFBSSxFQUFFMEIsS0FBTTJzQjtZQUNqRTtRQUNEO1FBRUFnWSxRQUFRLFNBQVU1akMsUUFBUTtZQUN6QixJQUFJLENBQUNxUCxNQUFNLENBQUVyUCxVQUFXK1AsR0FBRyxDQUFFLFFBQVMvTyxJQUFJLENBQUU7Z0JBQzNDakIsT0FBUSxJQUFJLEVBQUc0c0IsV0FBVyxDQUFFLElBQUksQ0FBQy9pQixVQUFVO1lBQzVDO1lBQ0EsT0FBTyxJQUFJO1FBQ1o7SUFDRDtJQUdBN0osT0FBT3lOLElBQUksQ0FBQ2pHLE9BQU8sQ0FBQzh1QixNQUFNLEdBQUcsU0FBVWwxQixJQUFJO1FBQzFDLE9BQU8sQ0FBQ3BCLE9BQU95TixJQUFJLENBQUNqRyxPQUFPLENBQUNzOEIsT0FBTyxDQUFFMWlDO0lBQ3RDO0lBQ0FwQixPQUFPeU4sSUFBSSxDQUFDakcsT0FBTyxDQUFDczhCLE9BQU8sR0FBRyxTQUFVMWlDLElBQUk7UUFDM0MsT0FBTyxDQUFDLENBQUdBLENBQUFBLEtBQUtzdEIsV0FBVyxJQUFJdHRCLEtBQUswdUIsWUFBWSxJQUFJMXVCLEtBQUtteEIsY0FBYyxHQUFHL3hCLE1BQU07SUFDakY7SUFLQVIsT0FBT3EvQixZQUFZLENBQUMwRSxHQUFHLEdBQUc7UUFDekIsSUFBSTtZQUNILE9BQU8sSUFBSWhuQyxRQUFPaW5DLGNBQWM7UUFDakMsRUFBRSxPQUFRbDZCLEdBQUksQ0FBQztJQUNoQjtJQUVBLElBQUltNkIsbUJBQW1CO1FBRXJCLHdEQUF3RDtRQUN4RCxHQUFHO1FBRUgsdUJBQXVCO1FBQ3ZCLDZEQUE2RDtRQUM3RCxNQUFNO0lBQ1AsR0FDQUMsZUFBZWxrQyxPQUFPcS9CLFlBQVksQ0FBQzBFLEdBQUc7SUFFdkM1bEMsUUFBUWdtQyxJQUFJLEdBQUcsQ0FBQyxDQUFDRCxnQkFBa0IscUJBQXFCQTtJQUN4RC9sQyxRQUFRbWpDLElBQUksR0FBRzRDLGVBQWUsQ0FBQyxDQUFDQTtJQUVoQ2xrQyxPQUFPcWhDLGFBQWEsQ0FBRSxTQUFVbC9CLE9BQU87UUFDdEMsSUFBSWpCLFVBQVVrakM7UUFFZCxnRUFBZ0U7UUFDaEUsSUFBS2ptQyxRQUFRZ21DLElBQUksSUFBSUQsZ0JBQWdCLENBQUMvaEMsUUFBUTBnQyxXQUFXLEVBQUc7WUFDM0QsT0FBTztnQkFDTk8sTUFBTSxTQUFVSCxPQUFPLEVBQUV4SyxRQUFRO29CQUNoQyxJQUFJdjVCLEdBQ0g2a0MsTUFBTTVoQyxRQUFRNGhDLEdBQUc7b0JBRWxCQSxJQUFJTSxJQUFJLENBQ1BsaUMsUUFBUXpELElBQUksRUFDWnlELFFBQVF1K0IsR0FBRyxFQUNYditCLFFBQVEyK0IsS0FBSyxFQUNiMytCLFFBQVFtaUMsUUFBUSxFQUNoQm5pQyxRQUFRMFAsUUFBUTtvQkFHakIsa0NBQWtDO29CQUNsQyxJQUFLMVAsUUFBUW9pQyxTQUFTLEVBQUc7d0JBQ3hCLElBQU1ybEMsS0FBS2lELFFBQVFvaUMsU0FBUyxDQUFHOzRCQUM5QlIsR0FBRyxDQUFFN2tDLEVBQUcsR0FBR2lELFFBQVFvaUMsU0FBUyxDQUFFcmxDLEVBQUc7d0JBQ2xDO29CQUNEO29CQUVBLCtCQUErQjtvQkFDL0IsSUFBS2lELFFBQVF3OUIsUUFBUSxJQUFJb0UsSUFBSXZCLGdCQUFnQixFQUFHO3dCQUMvQ3VCLElBQUl2QixnQkFBZ0IsQ0FBRXJnQyxRQUFRdzlCLFFBQVE7b0JBQ3ZDO29CQUVBLDBCQUEwQjtvQkFDMUIsc0VBQXNFO29CQUN0RSw4REFBOEQ7b0JBQzlELHdFQUF3RTtvQkFDeEUscUVBQXFFO29CQUNyRSxJQUFLLENBQUN4OUIsUUFBUTBnQyxXQUFXLElBQUksQ0FBQ0ksT0FBTyxDQUFFLG1CQUFvQixFQUFHO3dCQUM3REEsT0FBTyxDQUFFLG1CQUFvQixHQUFHO29CQUNqQztvQkFFQSxjQUFjO29CQUNkLElBQU0vakMsS0FBSytqQyxRQUFVO3dCQUNwQmMsSUFBSXhCLGdCQUFnQixDQUFFcmpDLEdBQUcrakMsT0FBTyxDQUFFL2pDLEVBQUc7b0JBQ3RDO29CQUVBLFdBQVc7b0JBQ1hnQyxXQUFXLFNBQVV4QyxJQUFJO3dCQUN4QixPQUFPOzRCQUNOLElBQUt3QyxVQUFXO2dDQUNmQSxXQUFXa2pDLGdCQUFnQkwsSUFBSVMsTUFBTSxHQUNwQ1QsSUFBSVUsT0FBTyxHQUFHVixJQUFJVyxPQUFPLEdBQUdYLElBQUlZLFNBQVMsR0FDeENaLElBQUlhLGtCQUFrQixHQUFHO2dDQUUzQixJQUFLbG1DLFNBQVMsU0FBVTtvQ0FDdkJxbEMsSUFBSXJCLEtBQUs7Z0NBQ1YsT0FBTyxJQUFLaGtDLFNBQVMsU0FBVTtvQ0FFOUIsdUJBQXVCO29DQUN2Qix1Q0FBdUM7b0NBQ3ZDLHVEQUF1RDtvQ0FDdkQsSUFBSyxPQUFPcWxDLElBQUl0QixNQUFNLEtBQUssVUFBVzt3Q0FDckNoSyxTQUFVLEdBQUc7b0NBQ2QsT0FBTzt3Q0FDTkEsU0FFQyxtRUFBbUU7d0NBQ25Fc0wsSUFBSXRCLE1BQU0sRUFDVnNCLElBQUlwQixVQUFVO29DQUVoQjtnQ0FDRCxPQUFPO29DQUNObEssU0FDQ3dMLGdCQUFnQixDQUFFRixJQUFJdEIsTUFBTSxDQUFFLElBQUlzQixJQUFJdEIsTUFBTSxFQUM1Q3NCLElBQUlwQixVQUFVLEVBS2QsdUJBSHVCO29DQUN2QixvREFBb0Q7b0NBQ3BELHdEQUF3RDtvQ0FDdERvQixDQUFBQSxJQUFJYyxZQUFZLElBQUksTUFBSyxNQUFRLFVBQ25DLE9BQU9kLElBQUllLFlBQVksS0FBSyxXQUMzQjt3Q0FBRUMsUUFBUWhCLElBQUloRSxRQUFRO29DQUFDLElBQ3ZCO3dDQUFFemdDLE1BQU15a0MsSUFBSWUsWUFBWTtvQ0FBQyxHQUMxQmYsSUFBSXpCLHFCQUFxQjtnQ0FFM0I7NEJBQ0Q7d0JBQ0Q7b0JBQ0Q7b0JBRUEsbUJBQW1CO29CQUNuQnlCLElBQUlTLE1BQU0sR0FBR3RqQztvQkFDYmtqQyxnQkFBZ0JMLElBQUlVLE9BQU8sR0FBR1YsSUFBSVksU0FBUyxHQUFHempDLFNBQVU7b0JBRXhELHFCQUFxQjtvQkFDckIsNENBQTRDO29CQUM1Qyw0QkFBNEI7b0JBQzVCLElBQUs2aUMsSUFBSVcsT0FBTyxLQUFLN2hDLFdBQVk7d0JBQ2hDa2hDLElBQUlXLE9BQU8sR0FBR047b0JBQ2YsT0FBTzt3QkFDTkwsSUFBSWEsa0JBQWtCLEdBQUc7NEJBRXhCLGdEQUFnRDs0QkFDaEQsSUFBS2IsSUFBSWxuQixVQUFVLEtBQUssR0FBSTtnQ0FFM0Isb0NBQW9DO2dDQUNwQywwQ0FBMEM7Z0NBQzFDLHlDQUF5QztnQ0FDekMsb0NBQW9DO2dDQUNwQzlmLFFBQU93ZSxVQUFVLENBQUU7b0NBQ2xCLElBQUtyYSxVQUFXO3dDQUNma2pDO29DQUNEO2dDQUNEOzRCQUNEO3dCQUNEO29CQUNEO29CQUVBLDRCQUE0QjtvQkFDNUJsakMsV0FBV0EsU0FBVTtvQkFFckIsSUFBSTt3QkFFSCxvREFBb0Q7d0JBQ3BENmlDLElBQUlYLElBQUksQ0FBRWpoQyxRQUFRNGdDLFVBQVUsSUFBSTVnQyxRQUFRaWMsSUFBSSxJQUFJO29CQUNqRCxFQUFFLE9BQVF0VSxHQUFJO3dCQUViLHdFQUF3RTt3QkFDeEUsSUFBSzVJLFVBQVc7NEJBQ2YsTUFBTTRJO3dCQUNQO29CQUNEO2dCQUNEO2dCQUVBNDRCLE9BQU87b0JBQ04sSUFBS3hoQyxVQUFXO3dCQUNmQTtvQkFDRDtnQkFDRDtZQUNEO1FBQ0Q7SUFDRDtJQUtBLHlGQUF5RjtJQUN6RmxCLE9BQU9vaEMsYUFBYSxDQUFFLFNBQVU1RCxDQUFDO1FBQ2hDLElBQUtBLEVBQUVxRixXQUFXLEVBQUc7WUFDcEJyRixFQUFFbG5CLFFBQVEsQ0FBQ2xYLE1BQU0sR0FBRztRQUNyQjtJQUNEO0lBRUEsMEJBQTBCO0lBQzFCWSxPQUFPa2hDLFNBQVMsQ0FBRTtRQUNqQkYsU0FBUztZQUNSNWhDLFFBQVEsOENBQ1A7UUFDRjtRQUNBa1gsVUFBVTtZQUNUbFgsUUFBUTtRQUNUO1FBQ0F5Z0MsWUFBWTtZQUNYLGVBQWUsU0FBVXZnQyxJQUFJO2dCQUM1QlUsT0FBT3lELFVBQVUsQ0FBRW5FO2dCQUNuQixPQUFPQTtZQUNSO1FBQ0Q7SUFDRDtJQUVBLDhDQUE4QztJQUM5Q1UsT0FBT29oQyxhQUFhLENBQUUsVUFBVSxTQUFVNUQsQ0FBQztRQUMxQyxJQUFLQSxFQUFFanlCLEtBQUssS0FBSzFJLFdBQVk7WUFDNUIyNkIsRUFBRWp5QixLQUFLLEdBQUc7UUFDWDtRQUNBLElBQUtpeUIsRUFBRXFGLFdBQVcsRUFBRztZQUNwQnJGLEVBQUU5K0IsSUFBSSxHQUFHO1FBQ1Y7SUFDRDtJQUVBLGlDQUFpQztJQUNqQ3NCLE9BQU9xaEMsYUFBYSxDQUFFLFVBQVUsU0FBVTdELENBQUM7UUFFMUMsMEVBQTBFO1FBQzFFLElBQUtBLEVBQUVxRixXQUFXLElBQUlyRixFQUFFd0gsV0FBVyxFQUFHO1lBQ3JDLElBQUk1bEMsUUFBUThCO1lBQ1osT0FBTztnQkFDTmtpQyxNQUFNLFNBQVV4ckIsQ0FBQyxFQUFFNmdCLFFBQVE7b0JBQzFCcjVCLFNBQVNZLE9BQVEsWUFDZjROLElBQUksQ0FBRTR2QixFQUFFd0gsV0FBVyxJQUFJLENBQUMsR0FDeEIzbUIsSUFBSSxDQUFFO3dCQUFFNG1CLFNBQVN6SCxFQUFFMEgsYUFBYTt3QkFBRXZtQyxLQUFLNitCLEVBQUVrRCxHQUFHO29CQUFDLEdBQzdDdmMsRUFBRSxDQUFFLGNBQWNqakIsV0FBVyxTQUFVaWtDLEdBQUc7d0JBQzFDL2xDLE9BQU9xWixNQUFNO3dCQUNidlgsV0FBVzt3QkFDWCxJQUFLaWtDLEtBQU07NEJBQ1YxTSxTQUFVME0sSUFBSXptQyxJQUFJLEtBQUssVUFBVSxNQUFNLEtBQUt5bUMsSUFBSXptQyxJQUFJO3dCQUNyRDtvQkFDRDtvQkFFRCxrRUFBa0U7b0JBQ2xFOUIsU0FBUzZDLElBQUksQ0FBQ0MsV0FBVyxDQUFFTixNQUFNLENBQUUsRUFBRztnQkFDdkM7Z0JBQ0FzakMsT0FBTztvQkFDTixJQUFLeGhDLFVBQVc7d0JBQ2ZBO29CQUNEO2dCQUNEO1lBQ0Q7UUFDRDtJQUNEO0lBS0EsSUFBSWtrQyxlQUFlLEVBQUUsRUFDcEJDLFNBQVM7SUFFVix5QkFBeUI7SUFDekJybEMsT0FBT2toQyxTQUFTLENBQUU7UUFDakJvRSxPQUFPO1FBQ1BDLGVBQWU7WUFDZCxJQUFJcmtDLFdBQVdra0MsYUFBYS8vQixHQUFHLE1BQVFyRixPQUFPOEMsT0FBTyxHQUFHLE1BQVFsRSxNQUFNbUcsSUFBSTtZQUMxRSxJQUFJLENBQUU3RCxTQUFVLEdBQUc7WUFDbkIsT0FBT0E7UUFDUjtJQUNEO0lBRUEscUVBQXFFO0lBQ3JFbEIsT0FBT29oQyxhQUFhLENBQUUsY0FBYyxTQUFVNUQsQ0FBQyxFQUFFZ0ksZ0JBQWdCLEVBQUUzRyxLQUFLO1FBRXZFLElBQUk0RyxjQUFjQyxhQUFhQyxtQkFDOUJDLFdBQVdwSSxFQUFFOEgsS0FBSyxLQUFLLFNBQVdELENBQUFBLE9BQU8vZ0MsSUFBSSxDQUFFazVCLEVBQUVrRCxHQUFHLElBQ25ELFFBQ0EsT0FBT2xELEVBQUVwZixJQUFJLEtBQUssWUFDakIsQ0FBRW9mLEVBQUV1RCxXQUFXLElBQUksRUFBQyxFQUNsQm5qQyxPQUFPLENBQUUseUNBQTBDLEtBQ3JEeW5DLE9BQU8vZ0MsSUFBSSxDQUFFazVCLEVBQUVwZixJQUFJLEtBQU0sTUFBSztRQUdqQyw2RUFBNkU7UUFDN0UsSUFBS3duQixZQUFZcEksRUFBRW1CLFNBQVMsQ0FBRSxFQUFHLEtBQUssU0FBVTtZQUUvQyxzRUFBc0U7WUFDdEU4RyxlQUFlakksRUFBRStILGFBQWEsR0FBR25uQyxXQUFZby9CLEVBQUUrSCxhQUFhLElBQzNEL0gsRUFBRStILGFBQWEsS0FDZi9ILEVBQUUrSCxhQUFhO1lBRWhCLHdDQUF3QztZQUN4QyxJQUFLSyxVQUFXO2dCQUNmcEksQ0FBQyxDQUFFb0ksU0FBVSxHQUFHcEksQ0FBQyxDQUFFb0ksU0FBVSxDQUFDM2lDLE9BQU8sQ0FBRW9pQyxRQUFRLE9BQU9JO1lBQ3ZELE9BQU8sSUFBS2pJLEVBQUU4SCxLQUFLLEtBQUssT0FBUTtnQkFDL0I5SCxFQUFFa0QsR0FBRyxJQUFJLENBQUV2RSxPQUFPNzNCLElBQUksQ0FBRWs1QixFQUFFa0QsR0FBRyxJQUFLLE1BQU0sR0FBRSxJQUFNbEQsRUFBRThILEtBQUssR0FBRyxNQUFNRztZQUNqRTtZQUVBLDZEQUE2RDtZQUM3RGpJLEVBQUVxQyxVQUFVLENBQUUsY0FBZSxHQUFHO2dCQUMvQixJQUFLLENBQUM4RixtQkFBb0I7b0JBQ3pCM2xDLE9BQU9tRCxLQUFLLENBQUVzaUMsZUFBZTtnQkFDOUI7Z0JBQ0EsT0FBT0UsaUJBQWlCLENBQUUsRUFBRztZQUM5QjtZQUVBLHNCQUFzQjtZQUN0Qm5JLEVBQUVtQixTQUFTLENBQUUsRUFBRyxHQUFHO1lBRW5CLG1CQUFtQjtZQUNuQitHLGNBQWMzb0MsT0FBTSxDQUFFMG9DLGFBQWM7WUFDcEMxb0MsT0FBTSxDQUFFMG9DLGFBQWMsR0FBRztnQkFDeEJFLG9CQUFvQnRrQztZQUNyQjtZQUVBLDZDQUE2QztZQUM3Q3c5QixNQUFNaGxCLE1BQU0sQ0FBRTtnQkFFYiw2Q0FBNkM7Z0JBQzdDLElBQUs2ckIsZ0JBQWdCN2lDLFdBQVk7b0JBQ2hDN0MsT0FBUWpELFNBQVNrK0IsVUFBVSxDQUFFd0s7Z0JBRTlCLHNDQUFzQztnQkFDdEMsT0FBTztvQkFDTjFvQyxPQUFNLENBQUUwb0MsYUFBYyxHQUFHQztnQkFDMUI7Z0JBRUEsb0JBQW9CO2dCQUNwQixJQUFLbEksQ0FBQyxDQUFFaUksYUFBYyxFQUFHO29CQUV4QixrRUFBa0U7b0JBQ2xFakksRUFBRStILGFBQWEsR0FBR0MsaUJBQWlCRCxhQUFhO29CQUVoRCx3Q0FBd0M7b0JBQ3hDSCxhQUFhem5DLElBQUksQ0FBRThuQztnQkFDcEI7Z0JBRUEsbURBQW1EO2dCQUNuRCxJQUFLRSxxQkFBcUJ2bkMsV0FBWXNuQyxjQUFnQjtvQkFDckRBLFlBQWFDLGlCQUFpQixDQUFFLEVBQUc7Z0JBQ3BDO2dCQUVBQSxvQkFBb0JELGNBQWM3aUM7WUFDbkM7WUFFQSxxQkFBcUI7WUFDckIsT0FBTztRQUNSO0lBQ0Q7SUFLQSx5QkFBeUI7SUFDekIsK0VBQStFO0lBQy9FLDJFQUEyRTtJQUMzRSx5RUFBeUU7SUFDekUsaURBQWlEO0lBQ2pEMUUsUUFBUTBuQyxrQkFBa0IsR0FBRztRQUM1QixJQUFJdmtCLE9BQU8xa0IsU0FBU2twQyxjQUFjLENBQUNELGtCQUFrQixDQUFFLElBQUt2a0IsSUFBSTtRQUNoRUEsS0FBS2hVLFNBQVMsR0FBRztRQUNqQixPQUFPZ1UsS0FBS3pYLFVBQVUsQ0FBQ3JKLE1BQU0sS0FBSztJQUNuQztJQUdBLDJDQUEyQztJQUMzQyxrRkFBa0Y7SUFDbEYsdUJBQXVCO0lBQ3ZCLGtGQUFrRjtJQUNsRlIsT0FBT2lXLFNBQVMsR0FBRyxTQUFVbUksSUFBSSxFQUFFbGUsT0FBTyxFQUFFNmxDLFdBQVc7UUFDdEQsSUFBSyxPQUFPM25CLFNBQVMsVUFBVztZQUMvQixPQUFPLEVBQUU7UUFDVjtRQUNBLElBQUssT0FBT2xlLFlBQVksV0FBWTtZQUNuQzZsQyxjQUFjN2xDO1lBQ2RBLFVBQVU7UUFDWDtRQUVBLElBQUlzUyxNQUFNd3pCLFFBQVF4aUI7UUFFbEIsSUFBSyxDQUFDdGpCLFNBQVU7WUFFZix3RUFBd0U7WUFDeEUsbUNBQW1DO1lBQ25DLElBQUsvQixRQUFRMG5DLGtCQUFrQixFQUFHO2dCQUNqQzNsQyxVQUFVdEQsU0FBU2twQyxjQUFjLENBQUNELGtCQUFrQixDQUFFO2dCQUV0RCw2Q0FBNkM7Z0JBQzdDLG1DQUFtQztnQkFDbkMsNENBQTRDO2dCQUM1Q3J6QixPQUFPdFMsUUFBUWIsYUFBYSxDQUFFO2dCQUM5Qm1ULEtBQUs1QixJQUFJLEdBQUdoVSxTQUFTNFQsUUFBUSxDQUFDSSxJQUFJO2dCQUNsQzFRLFFBQVFULElBQUksQ0FBQ0MsV0FBVyxDQUFFOFM7WUFDM0IsT0FBTztnQkFDTnRTLFVBQVV0RDtZQUNYO1FBQ0Q7UUFFQW9wQyxTQUFTcHdCLFdBQVdwTCxJQUFJLENBQUU0VDtRQUMxQm9GLFVBQVUsQ0FBQ3VpQixlQUFlLEVBQUU7UUFFNUIsYUFBYTtRQUNiLElBQUtDLFFBQVM7WUFDYixPQUFPO2dCQUFFOWxDLFFBQVFiLGFBQWEsQ0FBRTJtQyxNQUFNLENBQUUsRUFBRzthQUFJO1FBQ2hEO1FBRUFBLFNBQVN6aUIsY0FBZTtZQUFFbkY7U0FBTSxFQUFFbGUsU0FBU3NqQjtRQUUzQyxJQUFLQSxXQUFXQSxRQUFRaGpCLE1BQU0sRUFBRztZQUNoQ1IsT0FBUXdqQixTQUFVL0ssTUFBTTtRQUN6QjtRQUVBLE9BQU96WSxPQUFPZSxLQUFLLENBQUUsRUFBRSxFQUFFaWxDLE9BQU9uOEIsVUFBVTtJQUMzQztJQUdBOztDQUVDLEdBQ0Q3SixPQUFPRyxFQUFFLENBQUMrbUIsSUFBSSxHQUFHLFNBQVV3WixHQUFHLEVBQUV1RixNQUFNLEVBQUUva0MsUUFBUTtRQUMvQyxJQUFJakIsVUFBVXZCLE1BQU1xaEMsVUFDbkJocUIsT0FBTyxJQUFJLEVBQ1h5TyxNQUFNa2MsSUFBSTlpQyxPQUFPLENBQUU7UUFFcEIsSUFBSzRtQixNQUFNLENBQUMsR0FBSTtZQUNmdmtCLFdBQVdtN0IsaUJBQWtCc0YsSUFBSXJqQyxLQUFLLENBQUVtbkI7WUFDeENrYyxNQUFNQSxJQUFJcmpDLEtBQUssQ0FBRSxHQUFHbW5CO1FBQ3JCO1FBRUEscUJBQXFCO1FBQ3JCLElBQUtwbUIsV0FBWTZuQyxTQUFXO1lBRTNCLG1DQUFtQztZQUNuQy9rQyxXQUFXK2tDO1lBQ1hBLFNBQVNwakM7UUFFVixrQ0FBa0M7UUFDbEMsT0FBTyxJQUFLb2pDLFVBQVUsT0FBT0EsV0FBVyxVQUFXO1lBQ2xEdm5DLE9BQU87UUFDUjtRQUVBLGtEQUFrRDtRQUNsRCxJQUFLcVgsS0FBS3ZWLE1BQU0sR0FBRyxHQUFJO1lBQ3RCUixPQUFPc2hDLElBQUksQ0FBRTtnQkFDWlosS0FBS0E7Z0JBRUwsbUVBQW1FO2dCQUNuRSwwQ0FBMEM7Z0JBQzFDLGdEQUFnRDtnQkFDaERoaUMsTUFBTUEsUUFBUTtnQkFDZGdnQyxVQUFVO2dCQUNWdGdCLE1BQU02bkI7WUFDUCxHQUFJbi9CLElBQUksQ0FBRSxTQUFVZytCLFlBQVk7Z0JBRS9CLDZDQUE2QztnQkFDN0MvRSxXQUFXMStCO2dCQUVYMFUsS0FBSzhWLElBQUksQ0FBRTVyQixXQUVWLHdFQUF3RTtnQkFDeEUseURBQXlEO2dCQUN6REQsT0FBUSxTQUFVdXNCLE1BQU0sQ0FBRXZzQixPQUFPaVcsU0FBUyxDQUFFNnVCLGVBQWlCOTZCLElBQUksQ0FBRS9KLFlBRW5FLGdDQUFnQztnQkFDaEM2a0M7WUFFRix3RUFBd0U7WUFDeEUsdURBQXVEO1lBQ3ZELDZEQUE2RDtZQUM3RCxHQUFJanJCLE1BQU0sQ0FBRTNZLFlBQVksU0FBVTI5QixLQUFLLEVBQUU0RCxNQUFNO2dCQUM5QzFzQixLQUFLOVUsSUFBSSxDQUFFO29CQUNWQyxTQUFTeEQsS0FBSyxDQUFFLElBQUksRUFBRXFpQyxZQUFZO3dCQUFFbEIsTUFBTWlHLFlBQVk7d0JBQUVyQzt3QkFBUTVEO3FCQUFPO2dCQUN4RTtZQUNEO1FBQ0Q7UUFFQSxPQUFPLElBQUk7SUFDWjtJQUtBNytCLE9BQU95TixJQUFJLENBQUNqRyxPQUFPLENBQUMwK0IsUUFBUSxHQUFHLFNBQVU5a0MsSUFBSTtRQUM1QyxPQUFPcEIsT0FBTzBCLElBQUksQ0FBRTFCLE9BQU91NUIsTUFBTSxFQUFFLFNBQVVwNUIsRUFBRTtZQUM5QyxPQUFPaUIsU0FBU2pCLEdBQUdpQixJQUFJO1FBQ3hCLEdBQUlaLE1BQU07SUFDWDtJQUtBUixPQUFPbW1DLE1BQU0sR0FBRztRQUNmQyxXQUFXLFNBQVVobEMsSUFBSSxFQUFFZSxPQUFPLEVBQUVqRCxDQUFDO1lBQ3BDLElBQUltbkMsYUFBYUMsU0FBU0MsV0FBV0MsUUFBUUMsV0FBV0MsWUFBWUMsbUJBQ25FblksV0FBV3h1QixPQUFPd2dCLEdBQUcsQ0FBRXBmLE1BQU0sYUFDN0J3bEMsVUFBVTVtQyxPQUFRb0IsT0FDbEJ5bUIsUUFBUSxDQUFDO1lBRVYsbUVBQW1FO1lBQ25FLElBQUsyRyxhQUFhLFVBQVc7Z0JBQzVCcHRCLEtBQUtrZixLQUFLLENBQUNrTyxRQUFRLEdBQUc7WUFDdkI7WUFFQWlZLFlBQVlHLFFBQVFULE1BQU07WUFDMUJJLFlBQVl2bUMsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNO1lBQzlCc2xDLGFBQWExbUMsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNO1lBQy9CdWxDLG9CQUFvQixDQUFFblksYUFBYSxjQUFjQSxhQUFhLE9BQU0sS0FDbkUsQ0FBRStYLFlBQVlHLFVBQVMsRUFBSTlvQyxPQUFPLENBQUUsVUFBVyxDQUFDO1lBRWpELGtEQUFrRDtZQUNsRCwrREFBK0Q7WUFDL0QsSUFBSytvQyxtQkFBb0I7Z0JBQ3hCTixjQUFjTyxRQUFRcFksUUFBUTtnQkFDOUJnWSxTQUFTSCxZQUFZNTVCLEdBQUc7Z0JBQ3hCNjVCLFVBQVVELFlBQVk5UixJQUFJO1lBRTNCLE9BQU87Z0JBQ05pUyxTQUFTM1gsV0FBWTBYLGNBQWU7Z0JBQ3BDRCxVQUFVelgsV0FBWTZYLGVBQWdCO1lBQ3ZDO1lBRUEsSUFBS3RvQyxXQUFZK0QsVUFBWTtnQkFFNUIsaUZBQWlGO2dCQUNqRkEsVUFBVUEsUUFBUTNFLElBQUksQ0FBRTRELE1BQU1sQyxHQUFHYyxPQUFPa0MsTUFBTSxDQUFFLENBQUMsR0FBR3VrQztZQUNyRDtZQUVBLElBQUt0a0MsUUFBUXNLLEdBQUcsSUFBSSxNQUFPO2dCQUMxQm9iLE1BQU1wYixHQUFHLEdBQUcsUUFBVUEsR0FBRyxHQUFHZzZCLFVBQVVoNkIsR0FBRyxHQUFLKzVCO1lBQy9DO1lBQ0EsSUFBS3JrQyxRQUFRb3lCLElBQUksSUFBSSxNQUFPO2dCQUMzQjFNLE1BQU0wTSxJQUFJLEdBQUcsUUFBVUEsSUFBSSxHQUFHa1MsVUFBVWxTLElBQUksR0FBSytSO1lBQ2xEO1lBRUEsSUFBSyxXQUFXbmtDLFNBQVU7Z0JBQ3pCQSxRQUFRMGtDLEtBQUssQ0FBQ3JwQyxJQUFJLENBQUU0RCxNQUFNeW1CO1lBRTNCLE9BQU87Z0JBQ04rZSxRQUFRcG1CLEdBQUcsQ0FBRXFIO1lBQ2Q7UUFDRDtJQUNEO0lBRUE3bkIsT0FBT0csRUFBRSxDQUFDK0IsTUFBTSxDQUFFO1FBRWpCLGtFQUFrRTtRQUNsRWlrQyxRQUFRLFNBQVVoa0MsT0FBTztZQUV4QiwrQkFBK0I7WUFDL0IsSUFBS2QsVUFBVWIsTUFBTSxFQUFHO2dCQUN2QixPQUFPMkIsWUFBWVUsWUFDbEIsSUFBSSxHQUNKLElBQUksQ0FBQzVCLElBQUksQ0FBRSxTQUFVL0IsQ0FBQztvQkFDckJjLE9BQU9tbUMsTUFBTSxDQUFDQyxTQUFTLENBQUUsSUFBSSxFQUFFamtDLFNBQVNqRDtnQkFDekM7WUFDRjtZQUVBLElBQUk0bkMsTUFBTUMsS0FDVDNsQyxPQUFPLElBQUksQ0FBRSxFQUFHO1lBRWpCLElBQUssQ0FBQ0EsTUFBTztnQkFDWjtZQUNEO1lBRUEsOEVBQThFO1lBQzlFLHdCQUF3QjtZQUN4QixxQ0FBcUM7WUFDckMsMENBQTBDO1lBQzFDLElBQUssQ0FBQ0EsS0FBS214QixjQUFjLEdBQUcveEIsTUFBTSxFQUFHO2dCQUNwQyxPQUFPO29CQUFFaU0sS0FBSztvQkFBRzhuQixNQUFNO2dCQUFFO1lBQzFCO1lBRUEscUZBQXFGO1lBQ3JGdVMsT0FBTzFsQyxLQUFLaXpCLHFCQUFxQjtZQUNqQzBTLE1BQU0zbEMsS0FBS2lELGFBQWEsQ0FBQ21JLFdBQVc7WUFDcEMsT0FBTztnQkFDTkMsS0FBS3E2QixLQUFLcjZCLEdBQUcsR0FBR3M2QixJQUFJQyxXQUFXO2dCQUMvQnpTLE1BQU11UyxLQUFLdlMsSUFBSSxHQUFHd1MsSUFBSUUsV0FBVztZQUNsQztRQUNEO1FBRUEsZ0ZBQWdGO1FBQ2hGLCtEQUErRDtRQUMvRHpZLFVBQVU7WUFDVCxJQUFLLENBQUMsSUFBSSxDQUFFLEVBQUcsRUFBRztnQkFDakI7WUFDRDtZQUVBLElBQUkwWSxjQUFjZixRQUFRbG5DLEtBQ3pCbUMsT0FBTyxJQUFJLENBQUUsRUFBRyxFQUNoQitsQyxlQUFlO2dCQUFFMTZCLEtBQUs7Z0JBQUc4bkIsTUFBTTtZQUFFO1lBRWxDLDRGQUE0RjtZQUM1RixJQUFLdjBCLE9BQU93Z0IsR0FBRyxDQUFFcGYsTUFBTSxnQkFBaUIsU0FBVTtnQkFFakQsc0VBQXNFO2dCQUN0RStrQyxTQUFTL2tDLEtBQUtpekIscUJBQXFCO1lBRXBDLE9BQU87Z0JBQ044UixTQUFTLElBQUksQ0FBQ0EsTUFBTTtnQkFFcEIsc0ZBQXNGO2dCQUN0RixxREFBcUQ7Z0JBQ3JEbG5DLE1BQU1tQyxLQUFLaUQsYUFBYTtnQkFDeEI2aUMsZUFBZTlsQyxLQUFLOGxDLFlBQVksSUFBSWpvQyxJQUFJMkUsZUFBZTtnQkFDdkQsTUFBUXNqQyxnQkFDTEEsQ0FBQUEsaUJBQWlCam9DLElBQUlxaUIsSUFBSSxJQUFJNGxCLGlCQUFpQmpvQyxJQUFJMkUsZUFBZSxLQUNuRTVELE9BQU93Z0IsR0FBRyxDQUFFMG1CLGNBQWMsZ0JBQWlCLFNBQVc7b0JBRXREQSxlQUFlQSxhQUFhdm5DLFVBQVU7Z0JBQ3ZDO2dCQUNBLElBQUt1bkMsZ0JBQWdCQSxpQkFBaUI5bEMsUUFBUThsQyxhQUFhNW9DLFFBQVEsS0FBSyxHQUFJO29CQUUzRSxpRkFBaUY7b0JBQ2pGNm9DLGVBQWVubkMsT0FBUWtuQyxjQUFlZixNQUFNO29CQUM1Q2dCLGFBQWExNkIsR0FBRyxJQUFJek0sT0FBT3dnQixHQUFHLENBQUUwbUIsY0FBYyxrQkFBa0I7b0JBQ2hFQyxhQUFhNVMsSUFBSSxJQUFJdjBCLE9BQU93Z0IsR0FBRyxDQUFFMG1CLGNBQWMsbUJBQW1CO2dCQUNuRTtZQUNEO1lBRUEsOENBQThDO1lBQzlDLE9BQU87Z0JBQ056NkIsS0FBSzA1QixPQUFPMTVCLEdBQUcsR0FBRzA2QixhQUFhMTZCLEdBQUcsR0FBR3pNLE9BQU93Z0IsR0FBRyxDQUFFcGYsTUFBTSxhQUFhO2dCQUNwRW16QixNQUFNNFIsT0FBTzVSLElBQUksR0FBRzRTLGFBQWE1UyxJQUFJLEdBQUd2MEIsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNLGNBQWM7WUFDekU7UUFDRDtRQUVBLGtFQUFrRTtRQUNsRSxxRkFBcUY7UUFDckYsMENBQTBDO1FBQzFDLHdDQUF3QztRQUN4QyxxRkFBcUY7UUFDckYsRUFBRTtRQUNGLHFFQUFxRTtRQUNyRSxzREFBc0Q7UUFDdEQsRUFBRTtRQUNGLG1GQUFtRjtRQUNuRjhsQyxjQUFjO1lBQ2IsT0FBTyxJQUFJLENBQUMvbEMsR0FBRyxDQUFFO2dCQUNoQixJQUFJK2xDLGVBQWUsSUFBSSxDQUFDQSxZQUFZO2dCQUVwQyxNQUFRQSxnQkFBZ0JsbkMsT0FBT3dnQixHQUFHLENBQUUwbUIsY0FBYyxnQkFBaUIsU0FBVztvQkFDN0VBLGVBQWVBLGFBQWFBLFlBQVk7Z0JBQ3pDO2dCQUVBLE9BQU9BLGdCQUFnQnRqQztZQUN4QjtRQUNEO0lBQ0Q7SUFFQSwwQ0FBMEM7SUFDMUM1RCxPQUFPaUIsSUFBSSxDQUFFO1FBQUUwMEIsWUFBWTtRQUFlRCxXQUFXO0lBQWMsR0FBRyxTQUFVcmMsTUFBTSxFQUFFZ0YsSUFBSTtRQUMzRixJQUFJNVIsTUFBTSxrQkFBa0I0UjtRQUU1QnJlLE9BQU9HLEVBQUUsQ0FBRWtaLE9BQVEsR0FBRyxTQUFVbGEsR0FBRztZQUNsQyxPQUFPNGQsT0FBUSxJQUFJLEVBQUUsU0FBVTNiLElBQUksRUFBRWlZLE1BQU0sRUFBRWxhLEdBQUc7Z0JBRS9DLGlDQUFpQztnQkFDakMsSUFBSTRuQztnQkFDSixJQUFLdm9DLFNBQVU0QyxPQUFTO29CQUN2QjJsQyxNQUFNM2xDO2dCQUNQLE9BQU8sSUFBS0EsS0FBSzlDLFFBQVEsS0FBSyxHQUFJO29CQUNqQ3lvQyxNQUFNM2xDLEtBQUtvTCxXQUFXO2dCQUN2QjtnQkFFQSxJQUFLck4sUUFBUTBELFdBQVk7b0JBQ3hCLE9BQU9ra0MsTUFBTUEsR0FBRyxDQUFFMW9CLEtBQU0sR0FBR2pkLElBQUksQ0FBRWlZLE9BQVE7Z0JBQzFDO2dCQUVBLElBQUswdEIsS0FBTTtvQkFDVkEsSUFBSUssUUFBUSxDQUNYLENBQUMzNkIsTUFBTXROLE1BQU00bkMsSUFBSUUsV0FBVyxFQUM1Qng2QixNQUFNdE4sTUFBTTRuQyxJQUFJQyxXQUFXO2dCQUc3QixPQUFPO29CQUNONWxDLElBQUksQ0FBRWlZLE9BQVEsR0FBR2xhO2dCQUNsQjtZQUNELEdBQUdrYSxRQUFRbGEsS0FBS2tDLFVBQVViLE1BQU07UUFDakM7SUFDRDtJQUVBLDhDQUE4QztJQUM5QyxxREFBcUQ7SUFDckQsNERBQTREO0lBQzVELDBFQUEwRTtJQUMxRSw2RUFBNkU7SUFDN0Usc0ZBQXNGO0lBQ3RGUixPQUFPaUIsSUFBSSxDQUFFO1FBQUU7UUFBTztLQUFRLEVBQUUsU0FBVWtFLEVBQUUsRUFBRWtaLElBQUk7UUFDakRyZSxPQUFPd3lCLFFBQVEsQ0FBRW5VLEtBQU0sR0FBR2dTLGFBQWNseUIsUUFBUWd4QixhQUFhLEVBQzVELFNBQVUvdEIsSUFBSSxFQUFFNHVCLFFBQVE7WUFDdkIsSUFBS0EsVUFBVztnQkFDZkEsV0FBV0QsT0FBUTN1QixNQUFNaWQ7Z0JBRXpCLG1EQUFtRDtnQkFDbkQsT0FBTytPLFVBQVU5b0IsSUFBSSxDQUFFMHJCLFlBQ3RCaHdCLE9BQVFvQixNQUFPb3RCLFFBQVEsRUFBRSxDQUFFblEsS0FBTSxHQUFHLE9BQ3BDMlI7WUFDRjtRQUNEO0lBRUY7SUFHQSxvRkFBb0Y7SUFDcEZod0IsT0FBT2lCLElBQUksQ0FBRTtRQUFFb21DLFFBQVE7UUFBVUMsT0FBTztJQUFRLEdBQUcsU0FBVWxsQyxJQUFJLEVBQUUxRCxJQUFJO1FBQ3RFc0IsT0FBT2lCLElBQUksQ0FBRTtZQUNad3pCLFNBQVMsVUFBVXJ5QjtZQUNuQm1WLFNBQVM3WTtZQUNULElBQUksVUFBVTBEO1FBQ2YsR0FBRyxTQUFVbWxDLFlBQVksRUFBRUMsUUFBUTtZQUVsQyw2Q0FBNkM7WUFDN0N4bkMsT0FBT0csRUFBRSxDQUFFcW5DLFNBQVUsR0FBRyxTQUFVaFQsTUFBTSxFQUFFMXZCLEtBQUs7Z0JBQzlDLElBQUlrWSxZQUFZM2IsVUFBVWIsTUFBTSxJQUFNK21DLENBQUFBLGdCQUFnQixPQUFPL1MsV0FBVyxTQUFRLEdBQy9FekMsUUFBUXdWLGdCQUFrQi9TLENBQUFBLFdBQVcsUUFBUTF2QixVQUFVLE9BQU8sV0FBVyxRQUFPO2dCQUVqRixPQUFPaVksT0FBUSxJQUFJLEVBQUUsU0FBVTNiLElBQUksRUFBRTFDLElBQUksRUFBRW9HLEtBQUs7b0JBQy9DLElBQUk3RjtvQkFFSixJQUFLVCxTQUFVNEMsT0FBUzt3QkFFdkIsMEVBQTBFO3dCQUMxRSxPQUFPb21DLFNBQVM1cEMsT0FBTyxDQUFFLGFBQWMsSUFDdEN3RCxJQUFJLENBQUUsVUFBVWdCLEtBQU0sR0FDdEJoQixLQUFLeEUsUUFBUSxDQUFDZ0gsZUFBZSxDQUFFLFdBQVd4QixLQUFNO29CQUNsRDtvQkFFQSwrQkFBK0I7b0JBQy9CLElBQUtoQixLQUFLOUMsUUFBUSxLQUFLLEdBQUk7d0JBQzFCVyxNQUFNbUMsS0FBS3dDLGVBQWU7d0JBRTFCLCtFQUErRTt3QkFDL0Usd0JBQXdCO3dCQUN4QixPQUFPYixLQUFLeXVCLEdBQUcsQ0FDZHB3QixLQUFLa2dCLElBQUksQ0FBRSxXQUFXbGYsS0FBTSxFQUFFbkQsR0FBRyxDQUFFLFdBQVdtRCxLQUFNLEVBQ3BEaEIsS0FBS2tnQixJQUFJLENBQUUsV0FBV2xmLEtBQU0sRUFBRW5ELEdBQUcsQ0FBRSxXQUFXbUQsS0FBTSxFQUNwRG5ELEdBQUcsQ0FBRSxXQUFXbUQsS0FBTTtvQkFFeEI7b0JBRUEsT0FBTzBDLFVBQVVqQyxZQUVoQiw0RUFBNEU7b0JBQzVFN0MsT0FBT3dnQixHQUFHLENBQUVwZixNQUFNMUMsTUFBTXF6QixTQUV4QixxQ0FBcUM7b0JBQ3JDL3hCLE9BQU9zZ0IsS0FBSyxDQUFFbGYsTUFBTTFDLE1BQU1vRyxPQUFPaXRCO2dCQUNuQyxHQUFHcnpCLE1BQU1zZSxZQUFZd1gsU0FBUzN4QixXQUFXbWE7WUFDMUM7UUFDRDtJQUNEO0lBR0FoZCxPQUFPaUIsSUFBSSxDQUFFO1FBQ1o7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0EsRUFBRSxTQUFVa0UsRUFBRSxFQUFFekcsSUFBSTtRQUNwQnNCLE9BQU9HLEVBQUUsQ0FBRXpCLEtBQU0sR0FBRyxTQUFVeUIsRUFBRTtZQUMvQixPQUFPLElBQUksQ0FBQ2drQixFQUFFLENBQUV6bEIsTUFBTXlCO1FBQ3ZCO0lBQ0Q7SUFLQUgsT0FBT0csRUFBRSxDQUFDK0IsTUFBTSxDQUFFO1FBRWpCczJCLE1BQU0sU0FBVXBVLEtBQUssRUFBRWhHLElBQUksRUFBRWplLEVBQUU7WUFDOUIsT0FBTyxJQUFJLENBQUNna0IsRUFBRSxDQUFFQyxPQUFPLE1BQU1oRyxNQUFNamU7UUFDcEM7UUFDQXNuQyxRQUFRLFNBQVVyakIsS0FBSyxFQUFFamtCLEVBQUU7WUFDMUIsT0FBTyxJQUFJLENBQUNxa0IsR0FBRyxDQUFFSixPQUFPLE1BQU1qa0I7UUFDL0I7UUFFQXVuQyxVQUFVLFNBQVV6bkMsUUFBUSxFQUFFbWtCLEtBQUssRUFBRWhHLElBQUksRUFBRWplLEVBQUU7WUFDNUMsT0FBTyxJQUFJLENBQUNna0IsRUFBRSxDQUFFQyxPQUFPbmtCLFVBQVVtZSxNQUFNamU7UUFDeEM7UUFDQXduQyxZQUFZLFNBQVUxbkMsUUFBUSxFQUFFbWtCLEtBQUssRUFBRWprQixFQUFFO1lBRXhDLDhDQUE4QztZQUM5QyxPQUFPa0IsVUFBVWIsTUFBTSxLQUFLLElBQzNCLElBQUksQ0FBQ2drQixHQUFHLENBQUV2a0IsVUFBVSxRQUNwQixJQUFJLENBQUN1a0IsR0FBRyxDQUFFSixPQUFPbmtCLFlBQVksTUFBTUU7UUFDckM7UUFFQXluQyxPQUFPLFNBQVVDLE1BQU0sRUFBRUMsS0FBSztZQUM3QixPQUFPLElBQUksQ0FDVDNqQixFQUFFLENBQUUsY0FBYzBqQixRQUNsQjFqQixFQUFFLENBQUUsY0FBYzJqQixTQUFTRDtRQUM5QjtJQUNEO0lBRUE3bkMsT0FBT2lCLElBQUksQ0FDVixDQUFFLDhEQUNGLDBFQUNBLHlEQUF3RCxFQUFJaUUsS0FBSyxDQUFFLE1BQ25FLFNBQVVDLEVBQUUsRUFBRS9DLElBQUk7UUFFakIsdUJBQXVCO1FBQ3ZCcEMsT0FBT0csRUFBRSxDQUFFaUMsS0FBTSxHQUFHLFNBQVVnYyxJQUFJLEVBQUVqZSxFQUFFO1lBQ3JDLE9BQU9rQixVQUFVYixNQUFNLEdBQUcsSUFDekIsSUFBSSxDQUFDMmpCLEVBQUUsQ0FBRS9oQixNQUFNLE1BQU1nYyxNQUFNamUsTUFDM0IsSUFBSSxDQUFDbW5CLE9BQU8sQ0FBRWxsQjtRQUNoQjtJQUNEO0lBTUQsOEJBQThCO0lBQzlCLGlDQUFpQztJQUNqQyxpRUFBaUU7SUFDakUsNkZBQTZGO0lBQzdGLElBQUkybEMsUUFBUTtJQUVaLGtFQUFrRTtJQUNsRSxhQUFhO0lBQ2IsK0VBQStFO0lBQy9FLHNEQUFzRDtJQUN0RC9uQyxPQUFPZ29DLEtBQUssR0FBRyxTQUFVN25DLEVBQUUsRUFBRUQsT0FBTztRQUNuQyxJQUFJeWYsS0FBSy9QLE1BQU1vNEI7UUFFZixJQUFLLE9BQU85bkMsWUFBWSxVQUFXO1lBQ2xDeWYsTUFBTXhmLEVBQUUsQ0FBRUQsUUFBUztZQUNuQkEsVUFBVUM7WUFDVkEsS0FBS3dmO1FBQ047UUFFQSw4REFBOEQ7UUFDOUQsOERBQThEO1FBQzlELElBQUssQ0FBQ3ZoQixXQUFZK0IsS0FBTztZQUN4QixPQUFPMEM7UUFDUjtRQUVBLGlCQUFpQjtRQUNqQitNLE9BQU92UyxNQUFNRyxJQUFJLENBQUU2RCxXQUFXO1FBQzlCMm1DLFFBQVE7WUFDUCxPQUFPN25DLEdBQUd6QyxLQUFLLENBQUV3QyxXQUFXLElBQUksRUFBRTBQLEtBQUtuUyxNQUFNLENBQUVKLE1BQU1HLElBQUksQ0FBRTZEO1FBQzVEO1FBRUEsdUZBQXVGO1FBQ3ZGMm1DLE1BQU1qakMsSUFBSSxHQUFHNUUsR0FBRzRFLElBQUksR0FBRzVFLEdBQUc0RSxJQUFJLElBQUkvRSxPQUFPK0UsSUFBSTtRQUU3QyxPQUFPaWpDO0lBQ1I7SUFFQWhvQyxPQUFPaW9DLFNBQVMsR0FBRyxTQUFVQyxJQUFJO1FBQ2hDLElBQUtBLE1BQU87WUFDWGxvQyxPQUFPeWMsU0FBUztRQUNqQixPQUFPO1lBQ056YyxPQUFPa1csS0FBSyxDQUFFO1FBQ2Y7SUFDRDtJQUNBbFcsT0FBTzRDLE9BQU8sR0FBR0QsTUFBTUMsT0FBTztJQUM5QjVDLE9BQU9tb0MsU0FBUyxHQUFHdnBCLEtBQUtDLEtBQUs7SUFDN0I3ZSxPQUFPdUUsUUFBUSxHQUFHQTtJQUNsQnZFLE9BQU81QixVQUFVLEdBQUdBO0lBQ3BCNEIsT0FBT3hCLFFBQVEsR0FBR0E7SUFDbEJ3QixPQUFPMmQsU0FBUyxHQUFHQTtJQUNuQjNkLE9BQU90QixJQUFJLEdBQUdtQjtJQUVkRyxPQUFPbW9CLEdBQUcsR0FBR0QsS0FBS0MsR0FBRztJQUVyQm5vQixPQUFPb29DLFNBQVMsR0FBRyxTQUFVL3BDLEdBQUc7UUFFL0IsNENBQTRDO1FBQzVDLDhDQUE4QztRQUM5QyxrREFBa0Q7UUFDbEQsSUFBSUssT0FBT3NCLE9BQU90QixJQUFJLENBQUVMO1FBQ3hCLE9BQU8sQ0FBRUssU0FBUyxZQUFZQSxTQUFTLFFBQU8sS0FFN0Msb0RBQW9EO1FBQ3BELG1GQUFtRjtRQUNuRix1Q0FBdUM7UUFDdkMsQ0FBQzJwQyxNQUFPaHFDLE1BQU13d0IsV0FBWXh3QjtJQUM1QjtJQUVBMkIsT0FBT3NvQyxJQUFJLEdBQUcsU0FBVWhwQyxJQUFJO1FBQzNCLE9BQU9BLFFBQVEsT0FDZCxLQUNBLENBQUVBLE9BQU8sRUFBQyxFQUFJMkQsT0FBTyxDQUFFOGtDLE9BQU87SUFDaEM7SUFJQSw4RUFBOEU7SUFDOUUsNEVBQTRFO0lBQzVFLDJFQUEyRTtJQUMzRSx5RUFBeUU7SUFDekUsMkVBQTJFO0lBQzNFLDhFQUE4RTtJQUM5RSxtRUFBbUU7SUFFbkUsMEVBQTBFO0lBQzFFLDRFQUE0RTtJQUM1RSw2RUFBNkU7SUFDN0Usa0ZBQWtGO0lBRWxGLElBQUssSUFBMEMsRUFBRztRQUNqRFEsaUNBQWtCLEVBQUUsbUNBQUU7WUFDckIsT0FBT3ZvQztRQUNSLENBQUM7QUFBQTtJQUNGO0lBS0EsSUFFQyx1Q0FBdUM7SUFDdkN5b0MsVUFBVTFyQyxRQUFPaUQsTUFBTSxFQUV2QixzQ0FBc0M7SUFDdEMwb0MsS0FBSzNyQyxRQUFPNHJDLENBQUM7SUFFZDNvQyxPQUFPNG9DLFVBQVUsR0FBRyxTQUFVbm1DLElBQUk7UUFDakMsSUFBSzFGLFFBQU80ckMsQ0FBQyxLQUFLM29DLFFBQVM7WUFDMUJqRCxRQUFPNHJDLENBQUMsR0FBR0Q7UUFDWjtRQUVBLElBQUtqbUMsUUFBUTFGLFFBQU9pRCxNQUFNLEtBQUtBLFFBQVM7WUFDdkNqRCxRQUFPaUQsTUFBTSxHQUFHeW9DO1FBQ2pCO1FBRUEsT0FBT3pvQztJQUNSO0lBRUEsK0NBQStDO0lBQy9DLG9FQUFvRTtJQUNwRSxrREFBa0Q7SUFDbEQsSUFBSyxPQUFPaEQsYUFBYSxhQUFjO1FBQ3RDRCxRQUFPaUQsTUFBTSxHQUFHakQsUUFBTzRyQyxDQUFDLEdBQUczb0M7SUFDNUI7SUFLQSxPQUFPQTtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0ZXJpYWwtdGFpbHdpbmQtZGFzaGJvYXJkLW5leHRqcy1wcm8vLi9ub2RlX21vZHVsZXMvLnBucG0vanF1ZXJ5QDMuNy4xL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanM/MzA3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNy4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIzLTA4LTI4VDEzOjM3WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCB0cmFjLTE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcbn0gOiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcbn07XG5cblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcblx0XHQvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcblx0XHQvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuXHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cblx0XHQvLyBTdXBwb3J0OiBRdFdlYiA8PTMuOC41LCBXZWJLaXQgPD01MzQuMzQsIHdraHRtbHRvcGRmIHRvb2wgPD0wLjEyLjVcblx0XHQvLyBQbHVzIGZvciBvbGQgV2ViS2l0LCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgY29sbGVjdGlvbnNcblx0XHQvLyAoZS5nLiwgYHR5cGVvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKSA9PT0gXCJmdW5jdGlvblwiYCkuIChnaC00NzU2KVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIiAmJlxuXHRcdFx0dHlwZW9mIG9iai5pdGVtICE9PSBcImZ1bmN0aW9uXCI7XG5cdH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhciB2ZXJzaW9uID0gXCIzLjcuMVwiLFxuXG5cdHJodG1sU3VmZml4ID0gL0hUTUwkL2ksXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRldmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gKCBpICsgMSApICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRvZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBpICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IFwiX19wcm90b19fXCIgfHwgdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSAmJiAhQXJyYXkuaXNBcnJheSggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICFjb3B5SXNBcnJheSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSB7fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgcHJvdmlkZWQgY29udGV4dDsgZmFsbHMgYmFjayB0byB0aGUgZ2xvYmFsIG9uZVxuXHQvLyBpZiBub3Qgc3BlY2lmaWVkLlxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSwgb3B0aW9ucywgZG9jICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9LCBkb2MgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmUgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG5cdHRleHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBub2RlLFxuXHRcdFx0cmV0ID0gXCJcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cblx0XHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0XHR3aGlsZSAoICggbm9kZSA9IGVsZW1bIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdFx0cmV0ICs9IGpRdWVyeS50ZXh0KCBub2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fVxuXHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudEVsZW1lbnQudGV4dENvbnRlbnQ7XG5cdFx0fVxuXHRcdGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHRpc1hNTERvYzogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWVzcGFjZSA9IGVsZW0gJiYgZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0XHRkb2NFbGVtID0gZWxlbSAmJiAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlXG5cdFx0Ly8gZG9jdW1lbnQgZnJhZ21lbnRzLlxuXHRcdHJldHVybiAhcmh0bWxTdWZmaXgudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGZsYXQoIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdFx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG5cdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59XG52YXIgcG9wID0gYXJyLnBvcDtcblxuXG52YXIgc29ydCA9IGFyci5zb3J0O1xuXG5cbnZhciBzcGxpY2UgPSBhcnIuc3BsaWNlO1xuXG5cbnZhciB3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiO1xuXG5cbnZhciBydHJpbUNTUyA9IG5ldyBSZWdFeHAoXG5cdFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsXG5cdFwiZ1wiXG4pO1xuXG5cblxuXG4vLyBOb3RlOiBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5qUXVlcnkuY29udGFpbnMgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0dmFyIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXG5cdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdC8vIElFIGRvZXNuJ3QgaGF2ZSBgY29udGFpbnNgIG9uIFNWRy5cblx0XHRhLmNvbnRhaW5zID9cblx0XHRcdGEuY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHQpICk7XG59O1xuXG5cblxuXG4vLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG52YXIgcmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxceDgwLVxcdUZGRkZcXHctXS9nO1xuXG5mdW5jdGlvbiBmY3NzZXNjYXBlKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdH1cblxuXHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0fVxuXG5cdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG59XG5cbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoIHNlbCArIFwiXCIgKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5cblxuXG52YXIgcHJlZmVycmVkRG9jID0gZG9jdW1lbnQsXG5cdHB1c2hOYXRpdmUgPSBwdXNoO1xuXG4oIGZ1bmN0aW9uKCkge1xuXG52YXIgaSxcblx0RXhwcixcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cdHB1c2ggPSBwdXNoTmF0aXZlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0ZG9jdW1lbnQsXG5cdGRvY3VtZW50RWxlbWVudCxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0bWF0Y2hlcyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxcIiArXG5cdFx0XCJsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lkZW50LXRva2VuLWRpYWdyYW1cblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblxuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmxlYWRpbmdDb21iaW5hdG9yID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmRlc2NlbmQgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCJ8PlwiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRJRDogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdENMQVNTOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFRBRzogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdEFUVFI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFBTRVVETzogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0Q0hJTEQ6IG5ldyBSZWdFeHAoXG5cdFx0XHRcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuXHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgK1xuXHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0Ym9vbDogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRuZWVkc0NvbnRleHQ6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLCBcImdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggZXNjYXBlLCBub25IZXggKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGUuc2xpY2UoIDEgKSAtIDB4MTAwMDA7XG5cblx0XHRpZiAoIG5vbkhleCApIHtcblxuXHRcdFx0Ly8gU3RyaXAgdGhlIGJhY2tzbGFzaCBwcmVmaXggZnJvbSBhIG5vbi1oZXggZXNjYXBlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gbm9uSGV4O1xuXHRcdH1cblxuXHRcdC8vIFJlcGxhY2UgYSBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2Ugd2l0aCB0aGUgZW5jb2RlZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExK1xuXHRcdC8vIEZvciB2YWx1ZXMgb3V0c2lkZSB0aGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lIChCTVApLCBtYW51YWxseSBjb25zdHJ1Y3QgYVxuXHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0cmV0dXJuIGhpZ2ggPCAwID9cblx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lczsgc2VlIGBzZXREb2N1bWVudGAuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFL0VkZ2UuXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBub2RlTmFtZSggZWxlbSwgXCJmaWVsZHNldFwiICk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoIGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkgKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHtcblx0XHRhcHBseTogZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBlbHMgKSApO1xuXHRcdH0sXG5cdFx0Y2FsbDogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICkgKTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGZpbmQoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAoIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAoIG0gPSBtYXRjaFsgMSBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHB1c2guY2FsbCggcmVzdWx0cywgZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmICggZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICYmXG5cdFx0XHRcdFx0XHRcdGZpbmQuY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHB1c2guY2FsbCggcmVzdWx0cywgZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMiBdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIG0gPSBtYXRjaFsgMyBdICkgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCAhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhlIHRlY2huaXF1ZSBoYXMgdG8gYmUgdXNlZCBhcyB3ZWxsIHdoZW4gYSBsZWFkaW5nIGNvbWJpbmF0b3IgaXMgdXNlZFxuXHRcdFx0XHQvLyBhcyBzdWNoIHNlbGVjdG9ycyBhcmUgbm90IHJlY29nbml6ZWQgYnkgcXVlcnlTZWxlY3RvckFsbC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApIHx8IHJsZWFkaW5nQ29tYmluYXRvci50ZXN0KCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBXZSBjYW4gdXNlIDpzY29wZSBpbnN0ZWFkIG9mIHRoZSBJRCBoYWNrIGlmIHRoZSBicm93c2VyXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydHMgaXQgJiBpZiB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIGNvbnRleHQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlblxuXHRcdFx0XHRcdC8vIHN0cmljdC1jb21wYXJpbmcgdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgIT0gY29udGV4dCB8fCAhc3VwcG9ydC5zY29wZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdGlmICggKCBuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkgKSApIHtcblx0XHRcdFx0XHRcdFx0bmlkID0galF1ZXJ5LmVzY2FwZVNlbGVjdG9yKCBuaWQgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsICggbmlkID0gZXhwYW5kbyApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbIGkgXSA9ICggbmlkID8gXCIjXCIgKyBuaWQgOiBcIjpzY29wZVwiICkgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHRcdHRvU2VsZWN0b3IoIGdyb3Vwc1sgaSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllc1xuXHRcdC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvaXNzdWVzLzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuICggY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSApO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IGpRdWVyeSBzZWxlY3RvciBtb2R1bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgfHwgbm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKSApICYmXG5cdFx0XHRlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTErXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbICggaiA9IG1hdGNoSW5kZXhlc1sgaSBdICkgXSApIHtcblx0XHRcdFx0XHRzZWVkWyBqIF0gPSAhKCBtYXRjaGVzWyBqIF0gPSBzZWVkWyBqIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgalF1ZXJ5IHNlbGVjdG9yIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbbm9kZV0gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0RG9jdW1lbnQoIG5vZGUgKSB7XG5cdHZhciBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFqUXVlcnkuaXNYTUxEb2MoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDcgb25seSwgSUUgOSAtIDExK1xuXHQvLyBPbGRlciBicm93c2VycyBkaWRuJ3Qgc3VwcG9ydCB1bnByZWZpeGVkIGBtYXRjaGVzYC5cblx0bWF0Y2hlcyA9IGRvY3VtZW50RWxlbWVudC5tYXRjaGVzIHx8XG5cdFx0ZG9jdW1lbnRFbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY3VtZW50RWxlbWVudC5tc01hdGNoZXNTZWxlY3RvcjtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yc1xuXHQvLyAoc2VlIHRyYWMtMTM5MzYpLlxuXHQvLyBMaW1pdCB0aGUgZml4IHRvIElFICYgRWRnZSBMZWdhY3k7IGRlc3BpdGUgRWRnZSAxNSsgaW1wbGVtZW50aW5nIGBtYXRjaGVzYCxcblx0Ly8gYWxsIElFIDkrIGFuZCBFZGdlIExlZ2FjeSB2ZXJzaW9ucyBpbXBsZW1lbnQgYG1zTWF0Y2hlc1NlbGVjdG9yYCBhcyB3ZWxsLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5tc01hdGNoZXNTZWxlY3RvciAmJlxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRwcmVmZXJyZWREb2MgIT0gZG9jdW1lbnQgJiZcblx0XHQoIHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ICkgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBlbCApLmlkID0galF1ZXJ5LmV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fFxuXHRcdFx0IWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBqUXVlcnkuZXhwYW5kbyApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZS5cblx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdHJldHVybiBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBJRS9FZGdlIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG5cdHN1cHBvcnQuc2NvcGUgPSBhc3NlcnQoIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpzY29wZVwiICk7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBDaHJvbWUgMTA1IC0gMTExIG9ubHksIFNhZmFyaSAxNS40IC0gMTYuMyBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0aGUgYDpoYXMoKWAgYXJndW1lbnQgaXMgcGFyc2VkIHVuZm9yZ2l2aW5nbHkuXG5cdC8vIFdlIGluY2x1ZGUgYCpgIGluIHRoZSB0ZXN0IHRvIGRldGVjdCBidWdneSBpbXBsZW1lbnRhdGlvbnMgdGhhdCBhcmVcblx0Ly8gX3NlbGVjdGl2ZWx5XyBmb3JnaXZpbmcgKHNwZWNpZmljYWxseSB3aGVuIHRoZSBsaXN0IGluY2x1ZGVzIGF0IGxlYXN0XG5cdC8vIG9uZSB2YWxpZCBzZWxlY3RvcikuXG5cdC8vIE5vdGUgdGhhdCB3ZSB0cmVhdCBjb21wbGV0ZSBsYWNrIG9mIHN1cHBvcnQgZm9yIGA6aGFzKClgIGFzIGlmIGl0IHdlcmVcblx0Ly8gc3BlYy1jb21wbGlhbnQgc3VwcG9ydCwgd2hpY2ggaXMgZmluZSBiZWNhdXNlIHVzZSBvZiBgOmhhcygpYCBpbiBzdWNoXG5cdC8vIGVudmlyb25tZW50cyB3aWxsIGZhaWwgaW4gdGhlIHFTQSBwYXRoIGFuZCBmYWxsIGJhY2sgdG8galF1ZXJ5IHRyYXZlcnNhbFxuXHQvLyBhbnl3YXkuXG5cdHN1cHBvcnQuY3NzSGFzID0gYXNzZXJ0KCBmdW5jdGlvbigpIHtcblx0XHR0cnkge1xuXHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvciggXCI6aGFzKCosOmpxZmFrZSlcIiApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9ICk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyLklEID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJpZFwiICkgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmQuSUQgPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyLklEID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZC5JRCA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kLlRBRyA9IGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kLkNMQVNTID0gZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdC8vIEJ1aWxkIFFTQSByZWdleFxuXHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0dmFyIGlucHV0O1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9XG5cdFx0XHRcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIicgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIGRpc2FibGVkPSdkaXNhYmxlZCc+XCIgK1xuXHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogaU9TIDw9NyAtIDggb25seVxuXHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHkgaW4gc29tZSBYTUwgZG9jdW1lbnRzXG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbc2VsZWN0ZWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA8PTcgLSA4IG9ubHlcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwifj1cIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA4IG9ubHlcblx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIuIy4rWyt+XVwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MTA1KywgRmlyZWZveCA8PTEwNCssIFNhZmFyaSA8PTE1LjQrXG5cdFx0Ly8gSW4gc29tZSBvZiB0aGUgZG9jdW1lbnQga2luZHMsIHRoZXNlIHNlbGVjdG9ycyB3b3VsZG4ndCB3b3JrIG5hdGl2ZWx5LlxuXHRcdC8vIFRoaXMgaXMgcHJvYmFibHkgT0sgYnV0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3ZSB3YW50IHRvIG1haW50YWluXG5cdFx0Ly8gaGFuZGxpbmcgdGhlbSB0aHJvdWdoIGpRdWVyeSB0cmF2ZXJzYWwgaW4galF1ZXJ5IDMueC5cblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpjaGVja2VkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6Y2hlY2tlZFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0xMDUrLCBGaXJlZm94IDw9MTA0KywgU2FmYXJpIDw9MTUuNCtcblx0XHQvLyBJbiBzb21lIG9mIHRoZSBkb2N1bWVudCBraW5kcywgdGhlc2Ugc2VsZWN0b3JzIHdvdWxkbid0IHdvcmsgbmF0aXZlbHkuXG5cdFx0Ly8gVGhpcyBpcyBwcm9iYWJseSBPSyBidXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdlIHdhbnQgdG8gbWFpbnRhaW5cblx0XHQvLyBoYW5kbGluZyB0aGVtIHRocm91Z2ggalF1ZXJ5IHRyYXZlcnNhbCBpbiBqUXVlcnkgMy54LlxuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpkaXNhYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG5cdFx0Ly8gQWRkaW5nIGEgdGVtcG9yYXJ5IGF0dHJpYnV0ZSB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBzZWxlY3Rpb24gd29ya3Ncblx0XHQvLyBhcm91bmQgdGhlIGlzc3VlLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiXCIgKTtcblx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIipuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqPVwiICtcblx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0aWYgKCAhc3VwcG9ydC5jc3NIYXMgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgMTA1IC0gMTEwKywgU2FmYXJpIDE1LjQgLSAxNi4zK1xuXHRcdC8vIE91ciByZWd1bGFyIGB0cnktY2F0Y2hgIG1lY2hhbmlzbSBmYWlscyB0byBkZXRlY3QgbmF0aXZlbHktdW5zdXBwb3J0ZWRcblx0XHQvLyBwc2V1ZG8tY2xhc3NlcyBpbnNpZGUgYDpoYXMoKWAgKHN1Y2ggYXMgYDpoYXMoOmNvbnRhaW5zKFwiRm9vXCIpKWApXG5cdFx0Ly8gaW4gYnJvd3NlcnMgdGhhdCBwYXJzZSB0aGUgYDpoYXMoKWAgYXJndW1lbnQgYXMgYSBmb3JnaXZpbmcgc2VsZWN0b3IgbGlzdC5cblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvc2VsZWN0b3JzLyNyZWxhdGlvbmFsIG5vdyByZXF1aXJlcyB0aGUgYXJndW1lbnRcblx0XHQvLyB0byBiZSBwYXJzZWQgdW5mb3JnaXZpbmdseSwgYnV0IGJyb3dzZXJzIGhhdmUgbm90IHlldCBmdWxseSBhZGp1c3RlZC5cblx0XHRyYnVnZ3lRU0EucHVzaCggXCI6aGFzXCIgKTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oIFwifFwiICkgKTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoICFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUgKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGZpbmQuY29udGFpbnMoIHByZWZlcnJlZERvYywgYSApICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0ZmluZC5jb250YWlucyggcHJlZmVycmVkRG9jLCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn1cblxuZmluZC5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gZmluZCggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cbmZpbmQubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdHNldERvY3VtZW50KCBlbGVtICk7XG5cblx0aWYgKCBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmluZCggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cbmZpbmQuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5cbmZpbmQuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgdHJhYy0xMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdGlmICggdmFsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xufTtcblxuZmluZC5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5qUXVlcnkudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHQvL1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wK1xuXHQvLyBUZXN0aW5nIGZvciBkZXRlY3RpbmcgZHVwbGljYXRlcyBpcyB1bnByZWRpY3RhYmxlIHNvIGluc3RlYWQgYXNzdW1lIHdlIGNhbid0XG5cdC8vIGRlcGVuZCBvbiBkdXBsaWNhdGUgZGV0ZWN0aW9uIGluIGFsbCBicm93c2VycyB3aXRob3V0IGEgc3RhYmxlIHNvcnQuXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LnNvcnRTdGFibGU7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgc2xpY2UuY2FsbCggcmVzdWx0cywgMCApO1xuXHRzb3J0LmNhbGwoIHJlc3VsdHMsIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKCBlbGVtID0gcmVzdWx0c1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0c3BsaWNlLmNhbGwoIHJlc3VsdHMsIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxualF1ZXJ5LmZuLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkudW5pcXVlU29ydCggc2xpY2UuYXBwbHkoIHRoaXMgKSApICk7XG59O1xuXG5FeHByID0galF1ZXJ5LmV4cHIgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0QVRUUjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWyAzIF0gPSAoIG1hdGNoWyAzIF0gfHwgbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCIgKVxuXHRcdFx0XHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMiBdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWyAzIF0gPSBcIiBcIiArIG1hdGNoWyAzIF0gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdENISUxEOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAxIF0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRcdGZpbmQuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWyA0IF0gPSArKCBtYXRjaFsgNCBdID9cblx0XHRcdFx0XHRtYXRjaFsgNSBdICsgKCBtYXRjaFsgNiBdIHx8IDEgKSA6XG5cdFx0XHRcdFx0MiAqICggbWF0Y2hbIDMgXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG1hdGNoWyA1IF0gPSArKCAoIG1hdGNoWyA3IF0gKyBtYXRjaFsgOCBdICkgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdGZpbmQuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRQU0VVRE86IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWyA2IF0gJiYgbWF0Y2hbIDIgXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHIuQ0hJTEQudGVzdCggbWF0Y2hbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KCBleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSApICYmXG5cblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdCggZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFRBRzogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgZXhwZWN0ZWROb2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGVsZW0sIGV4cGVjdGVkTm9kZU5hbWUgKTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Q0xBU1M6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdCggcGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgK1xuXHRcdFx0XHRcdFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSApICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChcblx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fFxuXHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHxcblx0XHRcdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0QVRUUjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IGZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ID09PSBjaGVjaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIiE9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCAhPT0gY2hlY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCJePVwiICkge1xuXHRcdFx0XHRcdHJldHVybiBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIio9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCIkPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRcdHJldHVybiAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKVxuXHRcdFx0XHRcdFx0LmluZGV4T2YoIGNoZWNrICkgPiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcInw9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRDSElMRDogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9IG5vZGVbIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGVOYW1lKCBub2RlLCBuYW1lICkgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBwYXJlbnRbIGV4cGFuZG8gXSB8fCAoIHBhcmVudFsgZXhwYW5kbyBdID0ge30gKTtcblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZU5hbWUoIG5vZGUsIG5hbWUgKSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRQU0VVRE86IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRmaW5kLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgalF1ZXJ5IGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mLmNhbGwoIHNlZWQsIG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0bm90OiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblxuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGkgXSA9ICEoIG1hdGNoZXNbIGkgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHQvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8yOTkpXG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdGhhczogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBmaW5kKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdGNvbnRhaW5zOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBqUXVlcnkudGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdGxhbmc6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QoIGxhbmcgfHwgXCJcIiApICkge1xuXHRcdFx0XHRmaW5kLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwieG1sOmxhbmdcIiApIHx8IGVsZW0uZ2V0QXR0cmlidXRlKCBcImxhbmdcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoIGVsZW0gPSBlbGVtLnBhcmVudE5vZGUgKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdHRhcmdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0cm9vdDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0sXG5cblx0XHRmb2N1czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJlxuXHRcdFx0XHRkb2N1bWVudC5oYXNGb2N1cygpICYmXG5cdFx0XHRcdCEhKCBlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4ICk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdGVuYWJsZWQ6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdGRpc2FibGVkOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0Y2hlY2tlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHRyZXR1cm4gKCBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgISFlbGVtLmNoZWNrZWQgKSB8fFxuXHRcdFx0XHQoIG5vZGVOYW1lKCBlbGVtLCBcIm9wdGlvblwiICkgJiYgISFlbGVtLnNlbGVjdGVkICk7XG5cdFx0fSxcblxuXHRcdHNlbGVjdGVkOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuXHRcdFx0Ly8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHRyZWF0IHRoZSBkZWZhdWx0IG9wdGlvbiBhc1xuXHRcdFx0Ly8gc2VsZWN0ZWQgd2hlbiBpbiBhbiBvcHRncm91cC5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRlbXB0eTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvcy5lbXB0eSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0aGVhZGVyOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0aW5wdXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRidXR0b246IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHxcblx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKTtcblx0XHR9LFxuXG5cdFx0dGV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDwxMCBvbmx5XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXJcblx0XHRcdFx0Ly8gd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKCBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgKSA9PSBudWxsIHx8XG5cdFx0XHRcdFx0YXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0Zmlyc3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0gKSxcblxuXHRcdGxhc3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSApLFxuXG5cdFx0ZXE6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0gKSxcblxuXHRcdGV2ZW46IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRvZGQ6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRsdDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRpZiAoIGFyZ3VtZW50IDwgMCApIHtcblx0XHRcdFx0aSA9IGFyZ3VtZW50ICsgbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmICggYXJndW1lbnQgPiBsZW5ndGggKSB7XG5cdFx0XHRcdGkgPSBsZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gYXJndW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRndDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApXG5cdH1cbn07XG5cbkV4cHIucHNldWRvcy5udGggPSBFeHByLnBzZXVkb3MuZXE7XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxuZnVuY3Rpb24gdG9rZW5pemUoIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAoIG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbIDAgXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAoIHRva2VucyA9IFtdICkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKCBtYXRjaCA9IHJsZWFkaW5nQ29tYmluYXRvci5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFsgMCBdLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiBcIiApXG5cdFx0XHR9ICk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAoIG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSApICYmICggIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQoIG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApICkgKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdGlmICggcGFyc2VPbmx5ICkge1xuXHRcdHJldHVybiBzb0Zhci5sZW5ndGg7XG5cdH1cblxuXHRyZXR1cm4gc29GYXIgP1xuXHRcdGZpbmQuZXJyb3IoIHNlbGVjdG9yICkgOlxuXG5cdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufVxuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zWyBpIF0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblxuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBub2RlTmFtZSggZWxlbSwgc2tpcCApICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoICggb2xkQ2FjaGUgPSBvdXRlckNhY2hlWyBrZXkgXSApICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuICggbmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoICggbmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbIGkgXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1sgMCBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGZpbmQoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sIG1hdGNoZXJPdXQsXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHxcblx0XHRcdFx0bXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsXG5cdFx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcztcblxuXHRcdGlmICggbWF0Y2hlciApIHtcblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXJcblx0XHRcdC8vIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRtYXRjaGVyT3V0ID0gcG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdHJlc3VsdHM7XG5cblx0XHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlckluO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKCBlbGVtID0gdGVtcFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFsgaSBdIF0gPSAhKCBtYXRjaGVySW5bIHBvc3RNYXBbIGkgXSBdID0gZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAoIG1hdGNoZXJJblsgaSBdID0gZWxlbSApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsICggbWF0Y2hlck91dCA9IFtdICksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICYmXG5cdFx0XHRcdFx0XHQoIHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZi5jYWxsKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbIGkgXSApID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbIHRlbXAgXSA9ICEoIHJlc3VsdHNbIHRlbXAgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDAgXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlWyBcIiBcIiBdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KCBjaGVja0NvbnRleHQgPSBjb250ZXh0ICkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblxuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnRcblx0XHRcdC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvaXNzdWVzLzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggbWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaSBdLnR5cGUgXSApICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyICkgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbIGkgXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1sgaSBdLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaiBdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApXG5cdFx0XHRcdFx0XHRcdC5jb25jYXQoIHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9IClcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICggdG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkgKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmQuVEFHKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9ICggZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEgKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IGlPUyA8PTcgLSA5IG9ubHlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZ1xuXHRcdFx0Ly8gZWxlbWVudHMgYnkgaWQuIChzZWUgdHJhYy0xNDE0Milcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRwdXNoLmNhbGwoIHJlc3VsdHMsIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gc2V0TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblxuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKCB1bm1hdGNoZWRbIGkgXSB8fCBzZXRNYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkWyBpIF0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoWyBpIF0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLFxuXHRcdFx0bWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBqUXVlcnkncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIGpRdWVyeSBzZWxlY3RvciBjb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuZnVuY3Rpb24gc2VsZWN0KCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoIHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IgKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAoIHRva2VuID0gdG9rZW5zWyAwIF0gKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZC5JRChcblx0XHRcdFx0dG9rZW4ubWF0Y2hlc1sgMCBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdGNvbnRleHRcblx0XHRcdCkgfHwgW10gKVsgMCBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwci5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbIGkgXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAoIHR5cGUgPSB0b2tlbi50eXBlICkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICggZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdICkgKSB7XG5cblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKCBzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbIDAgXS50eXBlICkgJiZcblx0XHRcdFx0XHRcdHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkgKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgLSA0LjErXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdCggXCJcIiApLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oIFwiXCIgKSA9PT0gZXhwYW5kbztcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIC0gNC4xK1xuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApICkgJiAxO1xufSApO1xuXG5qUXVlcnkuZmluZCA9IGZpbmQ7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWUgPSBqUXVlcnkudW5pcXVlU29ydDtcblxuLy8gVGhlc2UgaGF2ZSBhbHdheXMgYmVlbiBwcml2YXRlLCBidXQgdGhleSB1c2VkIHRvIGJlIGRvY3VtZW50ZWQgYXMgcGFydCBvZlxuLy8gU2l6emxlIHNvIGxldCdzIG1haW50YWluIHRoZW0gZm9yIG5vdyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcHVycG9zZXMuXG5maW5kLmNvbXBpbGUgPSBjb21waWxlO1xuZmluZC5zZWxlY3QgPSBzZWxlY3Q7XG5maW5kLnNldERvY3VtZW50ID0gc2V0RG9jdW1lbnQ7XG5maW5kLnRva2VuaXplID0gdG9rZW5pemU7XG5cbmZpbmQuZXNjYXBlID0galF1ZXJ5LmVzY2FwZVNlbGVjdG9yO1xuZmluZC5nZXRUZXh0ID0galF1ZXJ5LnRleHQ7XG5maW5kLmlzWE1MID0galF1ZXJ5LmlzWE1MRG9jO1xuZmluZC5zZWxlY3RvcnMgPSBqUXVlcnkuZXhwcjtcbmZpbmQuc3VwcG9ydCA9IGpRdWVyeS5zdXBwb3J0O1xuZmluZC51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZVNvcnQ7XG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG59ICkoKTtcblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAodHJhYy05NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAodHJhYy0xMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8galF1ZXJ5I2ZpbmRcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCBlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3Rcblx0XHRcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuXHRcdFx0Z2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5lcnJvciApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBlcnJvciwgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRFcnJvckhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLmVycm9yID0galF1ZXJ5LkRlZmVycmVkLmdldEVycm9ySG9vaygpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGRlcHJlY2F0ZWQgYWxpYXMgb2YgdGhlIGFib3ZlLiBXaGlsZSB0aGUgbmFtZSBzdWdnZXN0c1xuXHRcdFx0XHRcdFx0XHRcdC8vIHJldHVybmluZyB0aGUgc3RhY2ssIG5vdCBhbiBlcnJvciBpbnN0YW5jZSwgalF1ZXJ5IGp1c3QgcGFzc2VzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaXQgZGlyZWN0bHkgdG8gYGNvbnNvbGUud2FybmAgc28gYm90aCB3aWxsIHdvcms7IGFuIGluc3RhbmNlXG5cdFx0XHRcdFx0XHRcdFx0Ly8ganVzdCBiZXR0ZXIgY29vcGVyYXRlcyB3aXRoIHNvdXJjZSBtYXBzLlxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLmVycm9yID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIHByaW1hcnkgRGVmZXJyZWRcblx0XHRcdHByaW1hcnkgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0cHJpbWFyeS5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgcHJpbWFyeS5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBwcmltYXJ5LnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIHByaW1hcnkuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHByaW1hcnkudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgcHJpbWFyeS5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJpbWFyeS5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbi8vIElmIGBqUXVlcnkuRGVmZXJyZWQuZ2V0RXJyb3JIb29rYCBpcyBkZWZpbmVkLCBgYXN5bmNFcnJvcmAgaXMgYW4gZXJyb3Jcbi8vIGNhcHR1cmVkIGJlZm9yZSB0aGUgYXN5bmMgYmFycmllciB0byBnZXQgdGhlIG9yaWdpbmFsIGVycm9yIGNhdXNlXG4vLyB3aGljaCBtYXkgb3RoZXJ3aXNlIGJlIGhpZGRlbi5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBhc3luY0Vycm9yICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSxcblx0XHRcdGVycm9yLnN0YWNrLCBhc3luY0Vycm9yICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSB0cmFjLTY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIF9rZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIF9hbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAodHJhYy05NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgdHJhYy04MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAodHJhYy0xNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuXHRcdFx0KCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAodHJhYy0xMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKHRyYWMtMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuXHQvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxvcHRpb24+PC9vcHRpb24+XCI7XG5cdHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xufSApKCk7XG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKHRyYWMtMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbmlmICggIXN1cHBvcnQub3B0aW9uICkge1xuXHR3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb24gPSBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF07XG59XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICh0cmFjLTE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGF0dGFjaGVkLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAodHJhYy0xMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG52YXIgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBPbmx5IGF0dGFjaCBldmVudHMgdG8gb2JqZWN0cyB0aGF0IGFjY2VwdCBkYXRhXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblxuXHRcdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICksXG5cblx0XHRcdGhhbmRsZXJzID0gKFxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKHRyYWMtMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICh0cmFjLTY5MTEsIHRyYWMtODE2NSwgdHJhYy0xMTM4MiwgdHJhYy0xMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICh0cmFjLTEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IHRvIGVuc3VyZSBjb3JyZWN0IHN0YXRlIGZvciBjaGVja2FibGUgaW5wdXRzXG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHQvLyBkYXRhUHJpdi5zZXQoIGVsLCBcImNsaWNrXCIsIC4uLiApXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyaW5nIGEgY2xpY2tcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgc3VwcHJlc3MgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHQvLyBBbHNvIHByZXZlbnQgaXQgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cdFx0XHRcdHJldHVybiByY2hlY2thYmxlVHlwZS50ZXN0KCB0YXJnZXQudHlwZSApICYmXG5cdFx0XHRcdFx0dGFyZ2V0LmNsaWNrICYmIG5vZGVOYW1lKCB0YXJnZXQsIFwiaW5wdXRcIiApICYmXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0YXJnZXQsIFwiY2xpY2tcIiApIHx8XG5cdFx0XHRcdFx0bm9kZU5hbWUoIHRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBFbnN1cmUgdGhlIHByZXNlbmNlIG9mIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaGFuZGxlcyBtYW51YWxseS10cmlnZ2VyZWRcbi8vIHN5bnRoZXRpYyBldmVudHMgYnkgaW50ZXJydXB0aW5nIHByb2dyZXNzIHVudGlsIHJlaW52b2tlZCBpbiByZXNwb25zZSB0b1xuLy8gKm5hdGl2ZSogZXZlbnRzIHRoYXQgaXQgZmlyZXMgZGlyZWN0bHksIGVuc3VyaW5nIHRoYXQgc3RhdGUgY2hhbmdlcyBoYXZlXG4vLyBhbHJlYWR5IG9jY3VycmVkIGJlZm9yZSBvdGhlciBsaXN0ZW5lcnMgYXJlIGludm9rZWQuXG5mdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZSggZWwsIHR5cGUsIGlzU2V0dXAgKSB7XG5cblx0Ly8gTWlzc2luZyBgaXNTZXR1cGAgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFpc1NldHVwICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHRpZiAoICFzYXZlZCApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGFyZ3VtZW50cyBmb3IgdXNlIHdoZW4gaGFuZGxpbmcgdGhlIGlubmVyIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRcdC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBhcmd1bWVudCAoYW4gZXZlbnQgb2JqZWN0KSwgc28gdGhpcyBhcnJheVxuXHRcdFx0XHRcdC8vIHdpbGwgbm90IGJlIGNvbmZ1c2VkIHdpdGggYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdC5cblx0XHRcdFx0XHRzYXZlZCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgc2F2ZWQgKTtcblxuXHRcdFx0XHRcdC8vIFRyaWdnZXIgdGhlIG5hdGl2ZSBldmVudCBhbmQgY2FwdHVyZSBpdHMgcmVzdWx0XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxuXHRcdFx0XHQvLyAoZm9jdXMgb3IgYmx1ciksIGFzc3VtZSB0aGF0IHRoZSBzdXJyb2dhdGUgYWxyZWFkeSBwcm9wYWdhdGVkIGZyb20gdHJpZ2dlcmluZ1xuXHRcdFx0XHQvLyB0aGUgbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cblx0XHRcdFx0Ly8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcblx0XHRcdFx0Ly8gYnViYmxpbmcgc3Vycm9nYXRlIHByb3BhZ2F0ZXMgKmFmdGVyKiB0aGUgbm9uLWJ1YmJsaW5nIGJhc2UpLCBidXQgdGhhdCBzZWVtc1xuXHRcdFx0XHQvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge30gKS5kZWxlZ2F0ZVR5cGUgKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG5cdFx0XHQvLyBGaXJlIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCB3aXRoIHRoZSBvcmlnaW5hbCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHNhdmVkICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBqUXVlcnkuZXZlbnQudHJpZ2dlcihcblx0XHRcdFx0XHRzYXZlZFsgMCBdLFxuXHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHQpICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudCBieSBhbGwgalF1ZXJ5IGhhbmRsZXJzIHdoaWxlIGFsbG93aW5nXG5cdFx0XHRcdC8vIG5hdGl2ZSBoYW5kbGVycyBvbiB0aGUgc2FtZSBlbGVtZW50IHRvIHJ1bi4gT24gdGFyZ2V0LCB0aGlzIGlzIGFjaGlldmVkXG5cdFx0XHRcdC8vIGJ5IHN0b3BwaW5nIGltbWVkaWF0ZSBwcm9wYWdhdGlvbiBqdXN0IG9uIHRoZSBqUXVlcnkgZXZlbnQuIEhvd2V2ZXIsXG5cdFx0XHRcdC8vIHRoZSBuYXRpdmUgZXZlbnQgaXMgcmUtd3JhcHBlZCBieSBhIGpRdWVyeSBvbmUgb24gZWFjaCBsZXZlbCBvZiB0aGVcblx0XHRcdFx0Ly8gcHJvcGFnYXRpb24gc28gdGhlIG9ubHkgd2F5IHRvIHN0b3AgaXQgZm9yIGpRdWVyeSBpcyB0byBzdG9wIGl0IGZvclxuXHRcdFx0XHQvLyBldmVyeW9uZSB2aWEgbmF0aXZlIGBzdG9wUHJvcGFnYXRpb24oKWAuIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBmb3Jcblx0XHRcdFx0Ly8gZm9jdXMvYmx1ciB3aGljaCBkb24ndCBidWJibGUsIGJ1dCBpdCBkb2VzIGFsc28gc3RvcCBjbGljayBvbiBjaGVja2JveGVzXG5cdFx0XHRcdC8vIGFuZCByYWRpb3MuIFdlIGFjY2VwdCB0aGlzIGxpbWl0YXRpb24uXG5cdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAodHJhYy01MDQsIHRyYWMtMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblx0d2hpY2g6IHRydWVcbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cblx0ZnVuY3Rpb24gZm9jdXNNYXBwZWRIYW5kbGVyKCBuYXRpdmVFdmVudCApIHtcblx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErXG5cdFx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgZm9jdXNpbi9mb2N1c291dCBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzXG5cdFx0XHQvLyBmb2N1cy9ibHVyLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGZvcm1lciBhcmUgc3luY2hyb25vdXMgaW4gSUUgd2hpbGUgdGhlIGxhdHRlclxuXHRcdFx0Ly8gYXJlIGFzeW5jLiBJbiBvdGhlciBicm93c2VycywgYWxsIHRob3NlIGhhbmRsZXJzIGFyZSBpbnZva2VkIHN5bmNocm9ub3VzbHkuXG5cblx0XHRcdC8vIGBoYW5kbGVgIGZyb20gcHJpdmF0ZSBkYXRhIHdvdWxkIGFscmVhZHkgd3JhcCB0aGUgZXZlbnQsIGJ1dCB3ZSBuZWVkXG5cdFx0XHQvLyB0byBjaGFuZ2UgdGhlIGB0eXBlYCBoZXJlLlxuXHRcdFx0dmFyIGhhbmRsZSA9IGRhdGFQcml2LmdldCggdGhpcywgXCJoYW5kbGVcIiApLFxuXHRcdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cdFx0XHRldmVudC50eXBlID0gbmF0aXZlRXZlbnQudHlwZSA9PT0gXCJmb2N1c2luXCIgPyBcImZvY3VzXCIgOiBcImJsdXJcIjtcblx0XHRcdGV2ZW50LmlzU2ltdWxhdGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRmlyc3QsIGhhbmRsZSBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0XHRoYW5kbGUoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHRcdC8vIC4uLnRoZW4sIGhhbmRsZSBmb2N1cy9ibHVyXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZm9jdXMvYmx1ciBkb24ndCBidWJibGUgd2hpbGUgZm9jdXNpbi9mb2N1c291dCBkbzsgc2ltdWxhdGUgdGhlIGZvcm1lciBieSBvbmx5XG5cdFx0XHQvLyBpbnZva2luZyB0aGUgaGFuZGxlciBhdCB0aGUgbG93ZXIgbGV2ZWwuXG5cdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCApIHtcblxuXHRcdFx0XHQvLyBUaGUgc2V0dXAgcGFydCBjYWxscyBgbGV2ZXJhZ2VOYXRpdmVgLCB3aGljaCwgaW4gdHVybiwgY2FsbHNcblx0XHRcdFx0Ly8gYGpRdWVyeS5ldmVudC5hZGRgLCBzbyBldmVudCBoYW5kbGUgd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBzZXRcblx0XHRcdFx0Ly8gYnkgdGhpcyBwb2ludC5cblx0XHRcdFx0aGFuZGxlKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBub24tSUUgYnJvd3NlcnMsIGF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnRcblx0XHRcdC8vIHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dC5cblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZGVsZWdhdGVUeXBlLCBuYXRpdmVFdmVudC50YXJnZXQsXG5cdFx0XHRcdGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICkgKTtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR2YXIgYXR0YWNoZXM7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdFx0XHRcdC8vIFdlIHVzZSB0aGUgc2FtZSBuYXRpdmUgaGFuZGxlciBmb3IgZm9jdXNpbiAmIGZvY3VzIChhbmQgZm9jdXNvdXQgJiBibHVyKVxuXHRcdFx0XHQvLyBzbyB3ZSBuZWVkIHRvIGNvb3JkaW5hdGUgc2V0dXAgJiB0ZWFyZG93biBwYXJ0cyBiZXR3ZWVuIHRob3NlIGV2ZW50cy5cblx0XHRcdFx0Ly8gVXNlIGBkZWxlZ2F0ZVR5cGVgIGFzIHRoZSBrZXkgYXMgYHR5cGVgIGlzIGFscmVhZHkgdXNlZCBieSBgbGV2ZXJhZ2VOYXRpdmVgLlxuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggdGhpcywgZGVsZWdhdGVUeXBlICk7XG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhdHRhY2hlcztcblxuXHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCB0aGlzLCBkZWxlZ2F0ZVR5cGUgKSAtIDE7XG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIHRoaXMsIGRlbGVnYXRlVHlwZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgZGVsZWdhdGVUeXBlLCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBpbmRpY2F0ZSBzdGFuZGFyZCB0ZWFyZG93biBzaG91bGQgYmUgYXBwbGllZFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIFN1cHByZXNzIG5hdGl2ZSBmb2N1cyBvciBibHVyIGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGVcblx0XHQvLyBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcblx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZXZlbnQudGFyZ2V0LCB0eXBlICk7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG5cdC8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcblx0Ly8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcblx0Ly9cblx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG5cdC8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuXHQvLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcblx0Ly8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcblx0Ly9cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHQvLyBUbyBwcmVzZXJ2ZSByZWxhdGl2ZSBmb2N1c2luL2ZvY3VzICYgZm9jdXNvdXQvYmx1ciBldmVudCBvcmRlciBndWFyYW50ZWVkIG9uIHRoZSAzLnggYnJhbmNoLFxuXHQvLyBhdHRhY2ggYSBzaW5nbGUgaGFuZGxlciBmb3IgYm90aCBldmVudHMgaW4gSUUuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBkZWxlZ2F0ZVR5cGUgXSA9IHtcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEhhbmRsZTogcmVndWxhciBub2RlcyAodmlhIGB0aGlzLm93bmVyRG9jdW1lbnRgKSwgd2luZG93XG5cdFx0XHQvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG5cdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0ZGF0YUhvbGRlciA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSA/IHRoaXMgOiBkb2MsXG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdFx0Ly8gV2UgdXNlIHRoZSBzYW1lIG5hdGl2ZSBoYW5kbGVyIGZvciBmb2N1c2luICYgZm9jdXMgKGFuZCBmb2N1c291dCAmIGJsdXIpXG5cdFx0XHQvLyBzbyB3ZSBuZWVkIHRvIGNvb3JkaW5hdGUgc2V0dXAgJiB0ZWFyZG93biBwYXJ0cyBiZXR3ZWVuIHRob3NlIGV2ZW50cy5cblx0XHRcdC8vIFVzZSBgZGVsZWdhdGVUeXBlYCBhcyB0aGUga2V5IGFzIGB0eXBlYCBpcyBhbHJlYWR5IHVzZWQgYnkgYGxldmVyYWdlTmF0aXZlYC5cblx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblx0XHRcdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkYXRhUHJpdi5zZXQoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0fSxcblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0ZGF0YUhvbGRlciA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSA/IHRoaXMgOiBkb2MsXG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUgKSAtIDE7XG5cblx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSwgYXR0YWNoZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhXFxbQ0RBVEFcXFt8XFxdXFxdPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5nZXQoIHNyYyApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkZXN0LCBcImhhbmRsZSBldmVudHNcIiApO1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gZmxhdCggYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICh0cmFjLTgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlLWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9LCBkb2MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVbndyYXAgYSBDREFUQSBzZWN0aW9uIGNvbnRhaW5pbmcgc2NyaXB0IGNvbnRlbnRzLiBUaGlzIHNob3VsZG4ndCBiZVxuXHRcdFx0XHRcdFx0XHQvLyBuZWVkZWQgYXMgaW4gWE1MIGRvY3VtZW50cyB0aGV5J3JlIGFscmVhZHkgbm90IHZpc2libGUgd2hlblxuXHRcdFx0XHRcdFx0XHQvLyBpbnNwZWN0aW5nIGVsZW1lbnQgY29udGVudHMgYW5kIGluIEhUTUwgZG9jdW1lbnRzIHRoZXkgaGF2ZSBub1xuXHRcdFx0XHRcdFx0XHQvLyBtZWFuaW5nIGJ1dCB3ZSdyZSBwcmVzZXJ2aW5nIHRoYXQgbG9naWMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBjb21wbGV0ZWx5IGluIDQuMC4gU2VlIGdoLTQ5MDQuXG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgalF1ZXJ5I2ZpbmQgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczpcblx0XHRcdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIHJjdXN0b21Qcm9wID0gL14tLS87XG5cblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKHRyYWMtMTUwOTgsIHRyYWMtMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICh0cmFjLTg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcblx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDcwK1xuXHRcdC8vIE9ubHkgRmlyZWZveCBpbmNsdWRlcyBib3JkZXIgd2lkdGhzXG5cdFx0Ly8gaW4gY29tcHV0ZWQgZGltZW5zaW9ucy4gKGdoLTQ1MjkpXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcblx0XHRcdGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcblx0XHRcdFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcblx0XHRcdFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdFx0XHR0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiO1xuXHRcdFx0XHR0ci5zdHlsZS5jc3NUZXh0ID0gXCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JvcmRlcjoxcHggc29saWRcIjtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgODYrXG5cdFx0XHRcdC8vIEhlaWdodCBzZXQgdGhyb3VnaCBjc3NUZXh0IGRvZXMgbm90IGdldCBhcHBsaWVkLlxuXHRcdFx0XHQvLyBDb21wdXRlZCBoZWlnaHQgdGhlbiBjb21lcyBiYWNrIGFzIDAuXG5cdFx0XHRcdHRyLnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCI5cHhcIjtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDggQ2hyb21lIDg2K1xuXHRcdFx0XHQvLyBJbiBvdXIgYm9keUJhY2tncm91bmQuaHRtbCBpZnJhbWUsXG5cdFx0XHRcdC8vIGRpc3BsYXkgZm9yIGFsbCBkaXYgZWxlbWVudHMgaXMgc2V0IHRvIFwiaW5saW5lXCIsXG5cdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBhIHByb2JsZW0gb25seSBpbiBBbmRyb2lkIDggQ2hyb21lIDg2LlxuXHRcdFx0XHQvLyBFbnN1cmluZyB0aGUgZGl2IGlzIGBkaXNwbGF5OiBibG9ja2Bcblx0XHRcdFx0Ly8gZ2V0cyBhcm91bmQgdGhpcyBpc3N1ZS5cblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudFxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdGFibGUgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHIgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHJDaGlsZCApO1xuXG5cdFx0XHRcdHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggdHIgKTtcblx0XHRcdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSAoIHBhcnNlSW50KCB0clN0eWxlLmhlaWdodCwgMTAgKSArXG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRyU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwICkgK1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0clN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCApICkgPT09IHRyLm9mZnNldEhlaWdodDtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRhYmxlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVUckRpbWVuc2lvbnNWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCB0cmFjLTEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpIChnaC0zMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0Ly8gSUUgb25seSBzdXBwb3J0cyBgXCJmbG9hdFwiYCBpbiBgZ2V0UHJvcGVydHlWYWx1ZWA7IGluIGNvbXB1dGVkIHN0eWxlc1xuXHRcdC8vIGl0J3Mgb25seSBhdmFpbGFibGUgYXMgYFwiY3NzRmxvYXRcImAuIFdlIG5vIGxvbmdlciBtb2RpZnkgcHJvcGVydGllc1xuXHRcdC8vIHNlbnQgdG8gYC5jc3MoKWAgYXBhcnQgZnJvbSBjYW1lbENhc2luZywgc28gd2UgbmVlZCB0byBjaGVjayBib3RoLlxuXHRcdC8vIE5vcm1hbGx5LCB0aGlzIHdvdWxkIGNyZWF0ZSBkaWZmZXJlbmNlIGluIGJlaGF2aW9yOiBpZlxuXHRcdC8vIGBnZXRQcm9wZXJ0eVZhbHVlYCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZywgdGhlIHZhbHVlIHJldHVybmVkXG5cdFx0Ly8gYnkgYC5jc3MoKWAgd291bGQgYmUgYHVuZGVmaW5lZGAuIFRoaXMgaXMgdXN1YWxseSB0aGUgY2FzZSBmb3Jcblx0XHQvLyBkaXNjb25uZWN0ZWQgZWxlbWVudHMuIEhvd2V2ZXIsIGluIElFIGV2ZW4gZGlzY29ubmVjdGVkIGVsZW1lbnRzXG5cdFx0Ly8gd2l0aCBubyBzdHlsZXMgcmV0dXJuIGBcIm5vbmVcImAgZm9yIGBnZXRQcm9wZXJ0eVZhbHVlKCBcImZsb2F0XCIgKWBcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggaXNDdXN0b21Qcm9wICYmIHJldCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAxMDUrLCBDaHJvbWUgPD0xMDUrXG5cdFx0XHQvLyBTcGVjIHJlcXVpcmVzIHRyaW1taW5nIHdoaXRlc3BhY2UgZm9yIGN1c3RvbSBwcm9wZXJ0aWVzIChnaC00OTI2KS5cblx0XHRcdC8vIEZpcmVmb3ggb25seSB0cmltcyBsZWFkaW5nIHdoaXRlc3BhY2UuIENocm9tZSBqdXN0IGNvbGxhcHNlc1xuXHRcdFx0Ly8gYm90aCBsZWFkaW5nICYgdHJhaWxpbmcgd2hpdGVzcGFjZSB0byBhIHNpbmdsZSBzcGFjZS5cblx0XHRcdC8vXG5cdFx0XHQvLyBGYWxsIGJhY2sgdG8gYHVuZGVmaW5lZGAgaWYgZW1wdHkgc3RyaW5nIHJldHVybmVkLlxuXHRcdFx0Ly8gVGhpcyBjb2xsYXBzZXMgYSBtaXNzaW5nIGRlZmluaXRpb24gd2l0aCBwcm9wZXJ0eSBkZWZpbmVkXG5cdFx0XHQvLyBhbmQgc2V0IHRvIGFuIGVtcHR5IHN0cmluZyBidXQgdGhlcmUncyBubyBzdGFuZGFyZCBBUElcblx0XHRcdC8vIGFsbG93aW5nIHVzIHRvIGRpZmZlcmVudGlhdGUgdGhlbSB3aXRob3V0IGEgcGVyZm9ybWFuY2UgcGVuYWx0eVxuXHRcdFx0Ly8gYW5kIHJldHVybmluZyBgdW5kZWZpbmVkYCBhbGlnbnMgd2l0aCBvbGRlciBqUXVlcnkuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gcnRyaW1DU1MgdHJlYXRzIFUrMDAwRCBDQVJSSUFHRSBSRVRVUk4gYW5kIFUrMDAwQyBGT1JNIEZFRURcblx0XHRcdC8vIGFzIHdoaXRlc3BhY2Ugd2hpbGUgQ1NTIGRvZXMgbm90LCBidXQgdGhpcyBpcyBub3QgYSBwcm9ibGVtXG5cdFx0XHQvLyBiZWNhdXNlIENTUyBwcmVwcm9jZXNzaW5nIHJlcGxhY2VzIHRoZW0gd2l0aCBVKzAwMEEgTElORSBGRUVEXG5cdFx0XHQvLyAod2hpY2ggKmlzKiBDU1Mgd2hpdGVzcGFjZSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lucHV0LXByZXByb2Nlc3Npbmdcblx0XHRcdHJldCA9IHJldC5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICkgfHwgdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIF9lbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMCxcblx0XHRtYXJnaW5EZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0Ly8gQ291bnQgbWFyZ2luIGRlbHRhIHNlcGFyYXRlbHkgdG8gb25seSBhZGQgaXQgYWZ0ZXIgc2Nyb2xsIGd1dHRlciBhZGp1c3RtZW50LlxuXHRcdC8vIFRoaXMgaXMgbmVlZGVkIHRvIG1ha2UgbmVnYXRpdmUgbWFyZ2lucyB3b3JrIHdpdGggYG91dGVySGVpZ2h0KCB0cnVlIClgIChnaC0zOTgyKS5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdG1hcmdpbkRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YSArIG1hcmdpbkRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBVc2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZS5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXG5cdFx0IXN1cHBvcnQucmVsaWFibGVUckRpbWVuc2lvbnMoKSAmJiBub2RlTmFtZSggZWxlbSwgXCJ0clwiICkgfHxcblxuXHRcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHRcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0XHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcblx0XHRhc3BlY3RSYXRpbzogdHJ1ZSxcblx0XHRib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuXHRcdGNvbHVtbkNvdW50OiB0cnVlLFxuXHRcdGZsZXhHcm93OiB0cnVlLFxuXHRcdGZsZXhTaHJpbms6IHRydWUsXG5cdFx0Zm9udFdlaWdodDogdHJ1ZSxcblx0XHRncmlkQXJlYTogdHJ1ZSxcblx0XHRncmlkQ29sdW1uOiB0cnVlLFxuXHRcdGdyaWRDb2x1bW5FbmQ6IHRydWUsXG5cdFx0Z3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuXHRcdGdyaWRSb3c6IHRydWUsXG5cdFx0Z3JpZFJvd0VuZDogdHJ1ZSxcblx0XHRncmlkUm93U3RhcnQ6IHRydWUsXG5cdFx0bGluZUhlaWdodDogdHJ1ZSxcblx0XHRvcGFjaXR5OiB0cnVlLFxuXHRcdG9yZGVyOiB0cnVlLFxuXHRcdG9ycGhhbnM6IHRydWUsXG5cdFx0c2NhbGU6IHRydWUsXG5cdFx0d2lkb3dzOiB0cnVlLFxuXHRcdHpJbmRleDogdHJ1ZSxcblx0XHR6b29tOiB0cnVlLFxuXG5cdFx0Ly8gU1ZHLXJlbGF0ZWRcblx0XHRmaWxsT3BhY2l0eTogdHJ1ZSxcblx0XHRmbG9vZE9wYWNpdHk6IHRydWUsXG5cdFx0c3RvcE9wYWNpdHk6IHRydWUsXG5cdFx0c3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcblx0XHRzdHJva2VPcGFjaXR5OiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICh0cmFjLTczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyB0cmFjLTkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAodHJhYy03MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIF9pLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKHRyYWMtMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwgKHRyYWMtMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjdXIsIGN1clZhbHVlLCBjbGFzc05hbWUsIGksIGZpbmFsVmFsdWU7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3NOYW1lcy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRjdXIgPSB0aGlzLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhc3NOYW1lICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjdXIsIGN1clZhbHVlLCBjbGFzc05hbWUsIGksIGZpbmFsVmFsdWU7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzTmFtZXMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSB0aGlzLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjbGFzc05hbWUsIGksIHNlbGYsXG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICh0cmFjLTE0Njg2LCB0cmFjLTE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAodHJhYy0yNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWwsIHBhcnNlckVycm9yRWxlbTtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge31cblxuXHRwYXJzZXJFcnJvckVsZW0gPSB4bWwgJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKVsgMCBdO1xuXHRpZiAoICF4bWwgfHwgcGFyc2VyRXJyb3JFbGVtICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyAoXG5cdFx0XHRwYXJzZXJFcnJvckVsZW0gP1xuXHRcdFx0XHRqUXVlcnkubWFwKCBwYXJzZXJFcnJvckVsZW0uY2hpbGROb2RlcywgZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0XHRcdHJldHVybiBlbC50ZXh0Q29udGVudDtcblx0XHRcdFx0fSApLmpvaW4oIFwiXFxuXCIgKSA6XG5cdFx0XHRcdGRhdGFcblx0XHQpICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKHRyYWMtOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKHRyYWMtOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApIClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAodHJhYy02MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9ICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApLm1hcCggZnVuY3Rpb24oIF9pLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyB0cmFjLTc2NTMsIHRyYWMtODEyNSwgdHJhYy04MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICh0cmFjLTEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxub3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzIHRyYWMtOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKHRyYWMtMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgdHJhYy0xMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKHRyYWMtMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyB0cmFjLTk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlLmd1aWQrKyApICtcblx0XHRcdFx0XHR1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIGEgbm9vcCBjb252ZXJ0ZXIgZm9yIG1pc3Npbmcgc2NyaXB0IGJ1dCBub3QgaWYganNvbnBcblx0XHRcdGlmICggIWlzU3VjY2VzcyAmJlxuXHRcdFx0XHRqUXVlcnkuaW5BcnJheSggXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMgKSA+IC0xICYmXG5cdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBcImpzb25cIiwgcy5kYXRhVHlwZXMgKSA8IDAgKSB7XG5cdFx0XHRcdHMuY29udmVydGVyc1sgXCJ0ZXh0IHNjcmlwdFwiIF0gPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBfaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdHZhciBpO1xuXHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRpZiAoIGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIiApIHtcblx0XHRcdHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbIGkgXSB8fCBcIlwiO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMsIGRvYyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKHRyYWMtMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucywgZG9jICk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vIHRyYWMtMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlIHRyYWMtODYwNSwgdHJhYy0xNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gdHJhYy0xNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlLmd1aWQrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7XG5cdFx0cGFkZGluZzogXCJpbm5lclwiICsgbmFtZSxcblx0XHRjb250ZW50OiB0eXBlLFxuXHRcdFwiXCI6IFwib3V0ZXJcIiArIG5hbWVcblx0fSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggX2ksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0Lm9uKCBcIm1vdXNlZW50ZXJcIiwgZm5PdmVyIClcblx0XHRcdC5vbiggXCJtb3VzZWxlYXZlXCIsIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKFxuXHQoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXG5cdFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXHR9XG4pO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbi8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuLy8gUmVxdWlyZSB0aGF0IHRoZSBcIndoaXRlc3BhY2UgcnVuXCIgc3RhcnRzIGZyb20gYSBub24td2hpdGVzcGFjZVxuLy8gdG8gYXZvaWQgTyhOXjIpIGJlaGF2aW9yIHdoZW4gdGhlIGVuZ2luZSB3b3VsZCB0cnkgbWF0Y2hpbmcgXCJcXHMrJFwiIGF0IGVhY2ggc3BhY2UgcG9zaXRpb24uXG52YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3woW15cXHNcXHVGRUZGXFx4QTBdKVtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxualF1ZXJ5LnRyaW0gPSBmdW5jdGlvbiggdGV4dCApIHtcblx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XCJcIiA6XG5cdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKTtcbn07XG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKHRyYWMtNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKHRyYWMtMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZG9jdW1lbnQiLCJ3IiwiRXJyb3IiLCJ3aW5kb3ciLCJub0dsb2JhbCIsImFyciIsImdldFByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJzbGljZSIsImZsYXQiLCJhcnJheSIsImNhbGwiLCJjb25jYXQiLCJhcHBseSIsInB1c2giLCJpbmRleE9mIiwiY2xhc3MydHlwZSIsInRvU3RyaW5nIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJmblRvU3RyaW5nIiwiT2JqZWN0RnVuY3Rpb25TdHJpbmciLCJzdXBwb3J0IiwiaXNGdW5jdGlvbiIsIm9iaiIsIm5vZGVUeXBlIiwiaXRlbSIsImlzV2luZG93IiwicHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyIsInR5cGUiLCJzcmMiLCJub25jZSIsIm5vTW9kdWxlIiwiRE9NRXZhbCIsImNvZGUiLCJub2RlIiwiZG9jIiwiaSIsInZhbCIsInNjcmlwdCIsImNyZWF0ZUVsZW1lbnQiLCJ0ZXh0IiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiaGVhZCIsImFwcGVuZENoaWxkIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidG9UeXBlIiwidmVyc2lvbiIsInJodG1sU3VmZml4IiwialF1ZXJ5Iiwic2VsZWN0b3IiLCJjb250ZXh0IiwiZm4iLCJpbml0IiwicHJvdG90eXBlIiwianF1ZXJ5IiwiY29uc3RydWN0b3IiLCJsZW5ndGgiLCJ0b0FycmF5IiwiZ2V0IiwibnVtIiwicHVzaFN0YWNrIiwiZWxlbXMiLCJyZXQiLCJtZXJnZSIsInByZXZPYmplY3QiLCJlYWNoIiwiY2FsbGJhY2siLCJtYXAiLCJlbGVtIiwiYXJndW1lbnRzIiwiZmlyc3QiLCJlcSIsImxhc3QiLCJldmVuIiwiZ3JlcCIsIl9lbGVtIiwib2RkIiwibGVuIiwiaiIsImVuZCIsInNvcnQiLCJzcGxpY2UiLCJleHRlbmQiLCJvcHRpb25zIiwibmFtZSIsImNvcHkiLCJjb3B5SXNBcnJheSIsImNsb25lIiwidGFyZ2V0IiwiZGVlcCIsImlzUGxhaW5PYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJ1bmRlZmluZWQiLCJleHBhbmRvIiwiTWF0aCIsInJhbmRvbSIsInJlcGxhY2UiLCJpc1JlYWR5IiwiZXJyb3IiLCJtc2ciLCJub29wIiwicHJvdG8iLCJDdG9yIiwiaXNFbXB0eU9iamVjdCIsImdsb2JhbEV2YWwiLCJpc0FycmF5TGlrZSIsInRleHRDb250ZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwibm9kZVZhbHVlIiwibWFrZUFycmF5IiwicmVzdWx0cyIsImluQXJyYXkiLCJpc1hNTERvYyIsIm5hbWVzcGFjZSIsIm5hbWVzcGFjZVVSSSIsImRvY0VsZW0iLCJvd25lckRvY3VtZW50IiwidGVzdCIsIm5vZGVOYW1lIiwic2Vjb25kIiwiaW52ZXJ0IiwiY2FsbGJhY2tJbnZlcnNlIiwibWF0Y2hlcyIsImNhbGxiYWNrRXhwZWN0IiwiYXJnIiwidmFsdWUiLCJndWlkIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzcGxpdCIsIl9pIiwidG9Mb3dlckNhc2UiLCJwb3AiLCJ3aGl0ZXNwYWNlIiwicnRyaW1DU1MiLCJSZWdFeHAiLCJjb250YWlucyIsImEiLCJiIiwiYnVwIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJyY3NzZXNjYXBlIiwiZmNzc2VzY2FwZSIsImNoIiwiYXNDb2RlUG9pbnQiLCJjaGFyQ29kZUF0IiwiZXNjYXBlU2VsZWN0b3IiLCJzZWwiLCJwcmVmZXJyZWREb2MiLCJwdXNoTmF0aXZlIiwiRXhwciIsIm91dGVybW9zdENvbnRleHQiLCJzb3J0SW5wdXQiLCJoYXNEdXBsaWNhdGUiLCJkb2N1bWVudElzSFRNTCIsInJidWdneVFTQSIsImRpcnJ1bnMiLCJkb25lIiwiY2xhc3NDYWNoZSIsImNyZWF0ZUNhY2hlIiwidG9rZW5DYWNoZSIsImNvbXBpbGVyQ2FjaGUiLCJub25uYXRpdmVTZWxlY3RvckNhY2hlIiwic29ydE9yZGVyIiwiYm9vbGVhbnMiLCJpZGVudGlmaWVyIiwiYXR0cmlidXRlcyIsInBzZXVkb3MiLCJyd2hpdGVzcGFjZSIsInJjb21tYSIsInJsZWFkaW5nQ29tYmluYXRvciIsInJkZXNjZW5kIiwicnBzZXVkbyIsInJpZGVudGlmaWVyIiwibWF0Y2hFeHByIiwiSUQiLCJDTEFTUyIsIlRBRyIsIkFUVFIiLCJQU0VVRE8iLCJDSElMRCIsImJvb2wiLCJuZWVkc0NvbnRleHQiLCJyaW5wdXRzIiwicmhlYWRlciIsInJxdWlja0V4cHIiLCJyc2libGluZyIsInJ1bmVzY2FwZSIsImZ1bmVzY2FwZSIsImVzY2FwZSIsIm5vbkhleCIsImhpZ2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ1bmxvYWRIYW5kbGVyIiwic2V0RG9jdW1lbnQiLCJpbkRpc2FibGVkRmllbGRzZXQiLCJhZGRDb21iaW5hdG9yIiwiZGlzYWJsZWQiLCJkaXIiLCJuZXh0Iiwic2FmZUFjdGl2ZUVsZW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiZXJyIiwiY2hpbGROb2RlcyIsImUiLCJlbHMiLCJmaW5kIiwic2VlZCIsIm0iLCJuaWQiLCJtYXRjaCIsImdyb3VwcyIsIm5ld1NlbGVjdG9yIiwibmV3Q29udGV4dCIsImV4ZWMiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwidGVzdENvbnRleHQiLCJzY29wZSIsInRva2VuaXplIiwidG9TZWxlY3RvciIsImpvaW4iLCJxdWVyeVNlbGVjdG9yQWxsIiwicXNhRXJyb3IiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZWxlY3QiLCJrZXlzIiwiY2FjaGUiLCJrZXkiLCJjYWNoZUxlbmd0aCIsInNoaWZ0IiwibWFya0Z1bmN0aW9uIiwiYXNzZXJ0IiwiZWwiLCJjcmVhdGVJbnB1dFBzZXVkbyIsImNyZWF0ZUJ1dHRvblBzZXVkbyIsImNyZWF0ZURpc2FibGVkUHNldWRvIiwiaXNEaXNhYmxlZCIsImNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8iLCJhcmd1bWVudCIsIm1hdGNoSW5kZXhlcyIsInN1YldpbmRvdyIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiZGVmYXVsdFZpZXciLCJ0b3AiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiZGlzY29ubmVjdGVkTWF0Y2giLCJjc3NIYXMiLCJxdWVyeVNlbGVjdG9yIiwiZmlsdGVyIiwiYXR0cklkIiwiZ2V0QXR0cmlidXRlTm9kZSIsInRhZyIsImNsYXNzTmFtZSIsImlucHV0IiwiaW5uZXJIVE1MIiwiY29tcGFyZSIsInNvcnREZXRhY2hlZCIsImV4cHIiLCJlbGVtZW50cyIsIm1hdGNoZXNTZWxlY3RvciIsImF0dHIiLCJhdHRySGFuZGxlIiwidW5pcXVlU29ydCIsImR1cGxpY2F0ZXMiLCJzb3J0U3RhYmxlIiwiY3JlYXRlUHNldWRvIiwicmVsYXRpdmUiLCJwcmVGaWx0ZXIiLCJleGNlc3MiLCJ1bnF1b3RlZCIsIm5vZGVOYW1lU2VsZWN0b3IiLCJleHBlY3RlZE5vZGVOYW1lIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJyZXN1bHQiLCJ3aGF0IiwiX2FyZ3VtZW50Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsIl9jb250ZXh0IiwieG1sIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInN0YXJ0IiwicGFyZW50IiwidXNlQ2FjaGUiLCJkaWZmIiwiZmlyc3RDaGlsZCIsImxhc3RDaGlsZCIsInBzZXVkbyIsImFyZ3MiLCJzZXRGaWx0ZXJzIiwiaWR4IiwibWF0Y2hlZCIsIm5vdCIsIm1hdGNoZXIiLCJjb21waWxlIiwidW5tYXRjaGVkIiwiaGFzIiwibGFuZyIsImVsZW1MYW5nIiwiaGFzaCIsImxvY2F0aW9uIiwicm9vdCIsImZvY3VzIiwiaGFzRm9jdXMiLCJocmVmIiwidGFiSW5kZXgiLCJlbmFibGVkIiwiY2hlY2tlZCIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsImVtcHR5IiwibmV4dFNpYmxpbmciLCJoZWFkZXIiLCJidXR0b24iLCJfbWF0Y2hJbmRleGVzIiwibHQiLCJndCIsIm50aCIsInJhZGlvIiwiY2hlY2tib3giLCJmaWxlIiwicGFzc3dvcmQiLCJpbWFnZSIsInN1Ym1pdCIsInJlc2V0IiwiZmlsdGVycyIsInBhcnNlT25seSIsInRva2VucyIsInNvRmFyIiwicHJlRmlsdGVycyIsImNhY2hlZCIsImNvbWJpbmF0b3IiLCJiYXNlIiwic2tpcCIsImNoZWNrTm9uRWxlbWVudHMiLCJkb25lTmFtZSIsIm9sZENhY2hlIiwibmV3Q2FjaGUiLCJlbGVtZW50TWF0Y2hlciIsIm1hdGNoZXJzIiwibXVsdGlwbGVDb250ZXh0cyIsImNvbnRleHRzIiwiY29uZGVuc2UiLCJuZXdVbm1hdGNoZWQiLCJtYXBwZWQiLCJzZXRNYXRjaGVyIiwicG9zdEZpbHRlciIsInBvc3RGaW5kZXIiLCJwb3N0U2VsZWN0b3IiLCJ0ZW1wIiwibWF0Y2hlck91dCIsInByZU1hcCIsInBvc3RNYXAiLCJwcmVleGlzdGluZyIsIm1hdGNoZXJJbiIsIm1hdGNoZXJGcm9tVG9rZW5zIiwiY2hlY2tDb250ZXh0IiwibGVhZGluZ1JlbGF0aXZlIiwiaW1wbGljaXRSZWxhdGl2ZSIsIm1hdGNoQ29udGV4dCIsIm1hdGNoQW55Q29udGV4dCIsIm1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyIsImVsZW1lbnRNYXRjaGVycyIsInNldE1hdGNoZXJzIiwiYnlTZXQiLCJieUVsZW1lbnQiLCJzdXBlck1hdGNoZXIiLCJvdXRlcm1vc3QiLCJtYXRjaGVkQ291bnQiLCJzZXRNYXRjaGVkIiwiY29udGV4dEJhY2t1cCIsImRpcnJ1bnNVbmlxdWUiLCJ0b2tlbiIsImNvbXBpbGVkIiwidW5pcXVlIiwiZ2V0VGV4dCIsImlzWE1MIiwic2VsZWN0b3JzIiwidW50aWwiLCJ0cnVuY2F0ZSIsImlzIiwic2libGluZ3MiLCJuIiwicm5lZWRzQ29udGV4dCIsInJzaW5nbGVUYWciLCJ3aW5ub3ciLCJxdWFsaWZpZXIiLCJzZWxmIiwicm9vdGpRdWVyeSIsInBhcnNlSFRNTCIsInJlYWR5IiwicnBhcmVudHNwcmV2IiwiZ3VhcmFudGVlZFVuaXF1ZSIsImNoaWxkcmVuIiwiY29udGVudHMiLCJwcmV2IiwidGFyZ2V0cyIsImwiLCJjbG9zZXN0IiwiY3VyIiwiaW5kZXgiLCJwcmV2QWxsIiwiYWRkIiwiYWRkQmFjayIsInNpYmxpbmciLCJwYXJlbnRzIiwicGFyZW50c1VudGlsIiwibmV4dEFsbCIsIm5leHRVbnRpbCIsInByZXZVbnRpbCIsImNvbnRlbnREb2N1bWVudCIsImNvbnRlbnQiLCJyZXZlcnNlIiwicm5vdGh0bWx3aGl0ZSIsImNyZWF0ZU9wdGlvbnMiLCJvYmplY3QiLCJfIiwiZmxhZyIsIkNhbGxiYWNrcyIsImZpcmluZyIsIm1lbW9yeSIsImZpcmVkIiwibG9ja2VkIiwibGlzdCIsInF1ZXVlIiwiZmlyaW5nSW5kZXgiLCJmaXJlIiwib25jZSIsInN0b3BPbkZhbHNlIiwicmVtb3ZlIiwiZGlzYWJsZSIsImxvY2siLCJmaXJlV2l0aCIsIklkZW50aXR5IiwidiIsIlRocm93ZXIiLCJleCIsImFkb3B0VmFsdWUiLCJyZXNvbHZlIiwicmVqZWN0Iiwibm9WYWx1ZSIsIm1ldGhvZCIsInByb21pc2UiLCJmYWlsIiwidGhlbiIsIkRlZmVycmVkIiwiZnVuYyIsInR1cGxlcyIsInN0YXRlIiwiYWx3YXlzIiwiZGVmZXJyZWQiLCJwaXBlIiwiZm5zIiwibmV3RGVmZXIiLCJ0dXBsZSIsInJldHVybmVkIiwicHJvZ3Jlc3MiLCJub3RpZnkiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJvblByb2dyZXNzIiwibWF4RGVwdGgiLCJkZXB0aCIsImhhbmRsZXIiLCJzcGVjaWFsIiwidGhhdCIsIm1pZ2h0VGhyb3ciLCJUeXBlRXJyb3IiLCJub3RpZnlXaXRoIiwicmVzb2x2ZVdpdGgiLCJwcm9jZXNzIiwiZXhjZXB0aW9uSG9vayIsInJlamVjdFdpdGgiLCJnZXRFcnJvckhvb2siLCJnZXRTdGFja0hvb2siLCJzZXRUaW1lb3V0Iiwic3RhdGVTdHJpbmciLCJ3aGVuIiwic2luZ2xlVmFsdWUiLCJyZW1haW5pbmciLCJyZXNvbHZlQ29udGV4dHMiLCJyZXNvbHZlVmFsdWVzIiwicHJpbWFyeSIsInVwZGF0ZUZ1bmMiLCJyZXJyb3JOYW1lcyIsImFzeW5jRXJyb3IiLCJjb25zb2xlIiwid2FybiIsIm1lc3NhZ2UiLCJzdGFjayIsInJlYWR5RXhjZXB0aW9uIiwicmVhZHlMaXN0IiwiY2F0Y2giLCJyZWFkeVdhaXQiLCJ3YWl0IiwiY29tcGxldGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYWR5U3RhdGUiLCJkb1Njcm9sbCIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwicmF3IiwiYnVsayIsIl9rZXkiLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsIl9hbGwiLCJsZXR0ZXIiLCJ0b1VwcGVyQ2FzZSIsImNhbWVsQ2FzZSIsInN0cmluZyIsImFjY2VwdERhdGEiLCJvd25lciIsIkRhdGEiLCJ1aWQiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsInNldCIsImRhdGEiLCJwcm9wIiwiaGFzRGF0YSIsImRhdGFQcml2IiwiZGF0YVVzZXIiLCJyYnJhY2UiLCJybXVsdGlEYXNoIiwiZ2V0RGF0YSIsIkpTT04iLCJwYXJzZSIsImRhdGFBdHRyIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJhdHRycyIsImRlcXVldWUiLCJzdGFydExlbmd0aCIsImhvb2tzIiwiX3F1ZXVlSG9va3MiLCJ1bnNoaWZ0Iiwic3RvcCIsInNldHRlciIsImNsZWFyUXVldWUiLCJ0bXAiLCJjb3VudCIsImRlZmVyIiwicG51bSIsInNvdXJjZSIsInJjc3NOdW0iLCJjc3NFeHBhbmQiLCJpc0F0dGFjaGVkIiwiY29tcG9zZWQiLCJnZXRSb290Tm9kZSIsImlzSGlkZGVuV2l0aGluVHJlZSIsInN0eWxlIiwiZGlzcGxheSIsImNzcyIsImFkanVzdENTUyIsInZhbHVlUGFydHMiLCJ0d2VlbiIsImFkanVzdGVkIiwic2NhbGUiLCJtYXhJdGVyYXRpb25zIiwiY3VycmVudFZhbHVlIiwiaW5pdGlhbCIsInVuaXQiLCJjc3NOdW1iZXIiLCJpbml0aWFsSW5Vbml0IiwiZGVmYXVsdERpc3BsYXlNYXAiLCJnZXREZWZhdWx0RGlzcGxheSIsImJvZHkiLCJzaG93SGlkZSIsInNob3ciLCJ2YWx1ZXMiLCJoaWRlIiwidG9nZ2xlIiwicmNoZWNrYWJsZVR5cGUiLCJydGFnTmFtZSIsInJzY3JpcHRUeXBlIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZGl2IiwiY2hlY2tDbG9uZSIsImNsb25lTm9kZSIsIm5vQ2xvbmVDaGVja2VkIiwiZGVmYXVsdFZhbHVlIiwib3B0aW9uIiwid3JhcE1hcCIsInRoZWFkIiwiY29sIiwidHIiLCJ0ZCIsIl9kZWZhdWx0IiwidGJvZHkiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwib3B0Z3JvdXAiLCJnZXRBbGwiLCJzZXRHbG9iYWxFdmFsIiwicmVmRWxlbWVudHMiLCJyaHRtbCIsImJ1aWxkRnJhZ21lbnQiLCJzY3JpcHRzIiwic2VsZWN0aW9uIiwiaWdub3JlZCIsIndyYXAiLCJhdHRhY2hlZCIsIm5vZGVzIiwiY3JlYXRlVGV4dE5vZGUiLCJodG1sUHJlZmlsdGVyIiwicnR5cGVuYW1lc3BhY2UiLCJyZXR1cm5UcnVlIiwicmV0dXJuRmFsc2UiLCJvbiIsInR5cGVzIiwib25lIiwib3JpZ0ZuIiwiZXZlbnQiLCJvZmYiLCJoYW5kbGVPYmpJbiIsImV2ZW50SGFuZGxlIiwiZXZlbnRzIiwidCIsImhhbmRsZU9iaiIsImhhbmRsZXJzIiwibmFtZXNwYWNlcyIsIm9yaWdUeXBlIiwiZWxlbURhdGEiLCJjcmVhdGUiLCJoYW5kbGUiLCJ0cmlnZ2VyZWQiLCJkaXNwYXRjaCIsImRlbGVnYXRlVHlwZSIsImJpbmRUeXBlIiwiZGVsZWdhdGVDb3VudCIsInNldHVwIiwibWFwcGVkVHlwZXMiLCJvcmlnQ291bnQiLCJ0ZWFyZG93biIsInJlbW92ZUV2ZW50IiwibmF0aXZlRXZlbnQiLCJoYW5kbGVyUXVldWUiLCJmaXgiLCJkZWxlZ2F0ZVRhcmdldCIsInByZURpc3BhdGNoIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjdXJyZW50VGFyZ2V0IiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJybmFtZXNwYWNlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwb3N0RGlzcGF0Y2giLCJtYXRjaGVkSGFuZGxlcnMiLCJtYXRjaGVkU2VsZWN0b3JzIiwiYWRkUHJvcCIsImhvb2siLCJFdmVudCIsImVudW1lcmFibGUiLCJvcmlnaW5hbEV2ZW50Iiwid3JpdGFibGUiLCJsb2FkIiwibm9CdWJibGUiLCJjbGljayIsImxldmVyYWdlTmF0aXZlIiwidHJpZ2dlciIsImJlZm9yZXVubG9hZCIsInJldHVyblZhbHVlIiwiaXNTZXR1cCIsInNhdmVkIiwiaXNUcmlnZ2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicHJvcHMiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwicmVsYXRlZFRhcmdldCIsInRpbWVTdGFtcCIsIkRhdGUiLCJub3ciLCJpc1NpbXVsYXRlZCIsImFsdEtleSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiY2hhbmdlZFRvdWNoZXMiLCJjdHJsS2V5IiwiZGV0YWlsIiwiZXZlbnRQaGFzZSIsIm1ldGFLZXkiLCJwYWdlWCIsInBhZ2VZIiwic2hpZnRLZXkiLCJ2aWV3IiwiY2hhckNvZGUiLCJrZXlDb2RlIiwiYnV0dG9ucyIsImNsaWVudFgiLCJjbGllbnRZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJwb2ludGVySWQiLCJwb2ludGVyVHlwZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwidGFyZ2V0VG91Y2hlcyIsInRvRWxlbWVudCIsInRvdWNoZXMiLCJ3aGljaCIsImJsdXIiLCJmb2N1c01hcHBlZEhhbmRsZXIiLCJkb2N1bWVudE1vZGUiLCJzaW11bGF0ZSIsImF0dGFjaGVzIiwiZGF0YUhvbGRlciIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmxlYXZlIiwib3JpZyIsInJlbGF0ZWQiLCJybm9Jbm5lcmh0bWwiLCJyY2hlY2tlZCIsInJjbGVhblNjcmlwdCIsIm1hbmlwdWxhdGlvblRhcmdldCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0IiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0IiwicGRhdGFPbGQiLCJ1ZGF0YU9sZCIsInVkYXRhQ3VyIiwiZml4SW5wdXQiLCJkb21NYW5pcCIsImNvbGxlY3Rpb24iLCJoYXNTY3JpcHRzIiwiaU5vQ2xvbmUiLCJ2YWx1ZUlzRnVuY3Rpb24iLCJodG1sIiwiX2V2YWxVcmwiLCJrZWVwRGF0YSIsImNsZWFuRGF0YSIsImRhdGFBbmRFdmVudHMiLCJkZWVwRGF0YUFuZEV2ZW50cyIsInNyY0VsZW1lbnRzIiwiZGVzdEVsZW1lbnRzIiwiaW5QYWdlIiwiZGV0YWNoIiwiYXBwZW5kIiwicHJlcGVuZCIsImluc2VydEJlZm9yZSIsImJlZm9yZSIsImFmdGVyIiwicmVwbGFjZVdpdGgiLCJyZXBsYWNlQ2hpbGQiLCJhcHBlbmRUbyIsInByZXBlbmRUbyIsImluc2VydEFmdGVyIiwicmVwbGFjZUFsbCIsIm9yaWdpbmFsIiwiaW5zZXJ0Iiwicm51bW5vbnB4IiwicmN1c3RvbVByb3AiLCJnZXRTdHlsZXMiLCJvcGVuZXIiLCJnZXRDb21wdXRlZFN0eWxlIiwic3dhcCIsIm9sZCIsInJib3hTdHlsZSIsImNvbXB1dGVTdHlsZVRlc3RzIiwiY29udGFpbmVyIiwiY3NzVGV4dCIsImRpdlN0eWxlIiwicGl4ZWxQb3NpdGlvblZhbCIsInJlbGlhYmxlTWFyZ2luTGVmdFZhbCIsInJvdW5kUGl4ZWxNZWFzdXJlcyIsIm1hcmdpbkxlZnQiLCJyaWdodCIsInBpeGVsQm94U3R5bGVzVmFsIiwiYm94U2l6aW5nUmVsaWFibGVWYWwiLCJ3aWR0aCIsInBvc2l0aW9uIiwic2Nyb2xsYm94U2l6ZVZhbCIsIm9mZnNldFdpZHRoIiwibWVhc3VyZSIsInJvdW5kIiwicGFyc2VGbG9hdCIsInJlbGlhYmxlVHJEaW1lbnNpb25zVmFsIiwiYmFja2dyb3VuZENsaXAiLCJjbGVhckNsb25lU3R5bGUiLCJib3hTaXppbmdSZWxpYWJsZSIsInBpeGVsQm94U3R5bGVzIiwicGl4ZWxQb3NpdGlvbiIsInJlbGlhYmxlTWFyZ2luTGVmdCIsInNjcm9sbGJveFNpemUiLCJyZWxpYWJsZVRyRGltZW5zaW9ucyIsInRhYmxlIiwidHJDaGlsZCIsInRyU3R5bGUiLCJoZWlnaHQiLCJwYXJzZUludCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJjdXJDU1MiLCJjb21wdXRlZCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJpc0N1c3RvbVByb3AiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiYWRkR2V0SG9va0lmIiwiY29uZGl0aW9uRm4iLCJob29rRm4iLCJjc3NQcmVmaXhlcyIsImVtcHR5U3R5bGUiLCJ2ZW5kb3JQcm9wcyIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsImZpbmFsUHJvcE5hbWUiLCJmaW5hbCIsImNzc1Byb3BzIiwicmRpc3BsYXlzd2FwIiwiY3NzU2hvdyIsInZpc2liaWxpdHkiLCJjc3NOb3JtYWxUcmFuc2Zvcm0iLCJsZXR0ZXJTcGFjaW5nIiwiZm9udFdlaWdodCIsInNldFBvc2l0aXZlTnVtYmVyIiwic3VidHJhY3QiLCJtYXgiLCJib3hNb2RlbEFkanVzdG1lbnQiLCJkaW1lbnNpb24iLCJib3giLCJpc0JvcmRlckJveCIsInN0eWxlcyIsImNvbXB1dGVkVmFsIiwiZXh0cmEiLCJkZWx0YSIsIm1hcmdpbkRlbHRhIiwiY2VpbCIsImdldFdpZHRoT3JIZWlnaHQiLCJib3hTaXppbmdOZWVkZWQiLCJ2YWx1ZUlzQm9yZGVyQm94Iiwib2Zmc2V0UHJvcCIsImdldENsaWVudFJlY3RzIiwiY3NzSG9va3MiLCJvcGFjaXR5IiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJhc3BlY3RSYXRpbyIsImJvcmRlckltYWdlU2xpY2UiLCJjb2x1bW5Db3VudCIsImZsZXhHcm93IiwiZmxleFNocmluayIsImdyaWRBcmVhIiwiZ3JpZENvbHVtbiIsImdyaWRDb2x1bW5FbmQiLCJncmlkQ29sdW1uU3RhcnQiLCJncmlkUm93IiwiZ3JpZFJvd0VuZCIsImdyaWRSb3dTdGFydCIsImxpbmVIZWlnaHQiLCJvcmRlciIsIm9ycGhhbnMiLCJ3aWRvd3MiLCJ6SW5kZXgiLCJ6b29tIiwiZmlsbE9wYWNpdHkiLCJmbG9vZE9wYWNpdHkiLCJzdG9wT3BhY2l0eSIsInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2VPcGFjaXR5Iiwib3JpZ05hbWUiLCJzZXRQcm9wZXJ0eSIsImlzRmluaXRlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2Nyb2xsYm94U2l6ZUJ1Z2d5IiwibGVmdCIsIm1hcmdpbiIsInBhZGRpbmciLCJib3JkZXIiLCJwcmVmaXgiLCJzdWZmaXgiLCJleHBhbmQiLCJleHBhbmRlZCIsInBhcnRzIiwiVHdlZW4iLCJlYXNpbmciLCJwcm9wSG9va3MiLCJydW4iLCJwZXJjZW50IiwiZWFzZWQiLCJkdXJhdGlvbiIsInBvcyIsInN0ZXAiLCJmeCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJsaW5lYXIiLCJwIiwic3dpbmciLCJjb3MiLCJQSSIsImZ4Tm93IiwiaW5Qcm9ncmVzcyIsInJmeHR5cGVzIiwicnJ1biIsInNjaGVkdWxlIiwiaGlkZGVuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaW50ZXJ2YWwiLCJ0aWNrIiwiY3JlYXRlRnhOb3ciLCJnZW5GeCIsImluY2x1ZGVXaWR0aCIsImNyZWF0ZVR3ZWVuIiwiYW5pbWF0aW9uIiwiQW5pbWF0aW9uIiwidHdlZW5lcnMiLCJkZWZhdWx0UHJlZmlsdGVyIiwib3B0cyIsIm9sZGZpcmUiLCJwcm9wVHdlZW4iLCJyZXN0b3JlRGlzcGxheSIsImlzQm94IiwiYW5pbSIsImRhdGFTaG93IiwidW5xdWV1ZWQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInByb3BGaWx0ZXIiLCJzcGVjaWFsRWFzaW5nIiwicHJvcGVydGllcyIsInN0b3BwZWQiLCJwcmVmaWx0ZXJzIiwiY3VycmVudFRpbWUiLCJzdGFydFRpbWUiLCJ0d2VlbnMiLCJvcmlnaW5hbFByb3BlcnRpZXMiLCJvcmlnaW5hbE9wdGlvbnMiLCJnb3RvRW5kIiwiYmluZCIsImNvbXBsZXRlIiwidGltZXIiLCJ0d2VlbmVyIiwicHJlZmlsdGVyIiwic3BlZWQiLCJvcHQiLCJzcGVlZHMiLCJmYWRlVG8iLCJ0byIsImFuaW1hdGUiLCJvcHRhbGwiLCJkb0FuaW1hdGlvbiIsImZpbmlzaCIsInN0b3BRdWV1ZSIsInRpbWVycyIsImNzc0ZuIiwic2xpZGVEb3duIiwic2xpZGVVcCIsInNsaWRlVG9nZ2xlIiwiZmFkZUluIiwiZmFkZU91dCIsImZhZGVUb2dnbGUiLCJzbG93IiwiZmFzdCIsImRlbGF5IiwidGltZSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjaGVja09uIiwib3B0U2VsZWN0ZWQiLCJyYWRpb1ZhbHVlIiwiYm9vbEhvb2siLCJyZW1vdmVBdHRyIiwiblR5cGUiLCJhdHRySG9va3MiLCJhdHRyTmFtZXMiLCJnZXR0ZXIiLCJsb3dlcmNhc2VOYW1lIiwicmZvY3VzYWJsZSIsInJjbGlja2FibGUiLCJyZW1vdmVQcm9wIiwicHJvcEZpeCIsInRhYmluZGV4Iiwic3RyaXBBbmRDb2xsYXBzZSIsImdldENsYXNzIiwiY2xhc3Nlc1RvQXJyYXkiLCJhZGRDbGFzcyIsImNsYXNzTmFtZXMiLCJjdXJWYWx1ZSIsImZpbmFsVmFsdWUiLCJyZW1vdmVDbGFzcyIsInRvZ2dsZUNsYXNzIiwic3RhdGVWYWwiLCJpc1ZhbGlkVmFsdWUiLCJoYXNDbGFzcyIsInJyZXR1cm4iLCJ2YWxIb29rcyIsIm9wdGlvblNldCIsInJxdWVyeSIsInBhcnNlWE1MIiwicGFyc2VyRXJyb3JFbGVtIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwicmZvY3VzTW9ycGgiLCJzdG9wUHJvcGFnYXRpb25DYWxsYmFjayIsIm9ubHlIYW5kbGVycyIsImJ1YmJsZVR5cGUiLCJvbnR5cGUiLCJsYXN0RWxlbWVudCIsImV2ZW50UGF0aCIsInBhcmVudFdpbmRvdyIsInRyaWdnZXJIYW5kbGVyIiwicmJyYWNrZXQiLCJyQ1JMRiIsInJzdWJtaXR0ZXJUeXBlcyIsInJzdWJtaXR0YWJsZSIsImJ1aWxkUGFyYW1zIiwidHJhZGl0aW9uYWwiLCJwYXJhbSIsInMiLCJ2YWx1ZU9yRnVuY3Rpb24iLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZXJpYWxpemUiLCJzZXJpYWxpemVBcnJheSIsInIyMCIsInJoYXNoIiwicmFudGlDYWNoZSIsInJoZWFkZXJzIiwicmxvY2FsUHJvdG9jb2wiLCJybm9Db250ZW50IiwicnByb3RvY29sIiwidHJhbnNwb3J0cyIsImFsbFR5cGVzIiwib3JpZ2luQW5jaG9yIiwiYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwic3RydWN0dXJlIiwiZGF0YVR5cGVFeHByZXNzaW9uIiwiZGF0YVR5cGUiLCJkYXRhVHlwZXMiLCJpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsImpxWEhSIiwiaW5zcGVjdGVkIiwic2Vla2luZ1RyYW5zcG9ydCIsImluc3BlY3QiLCJwcmVmaWx0ZXJPckZhY3RvcnkiLCJkYXRhVHlwZU9yVHJhbnNwb3J0IiwiYWpheEV4dGVuZCIsImZsYXRPcHRpb25zIiwiYWpheFNldHRpbmdzIiwiYWpheEhhbmRsZVJlc3BvbnNlcyIsInJlc3BvbnNlcyIsImN0IiwiZmluYWxEYXRhVHlwZSIsImZpcnN0RGF0YVR5cGUiLCJtaW1lVHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwiY29udmVydGVycyIsImFqYXhDb252ZXJ0IiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJjb252MiIsImN1cnJlbnQiLCJjb252IiwicmVzcG9uc2VGaWVsZHMiLCJkYXRhRmlsdGVyIiwidGhyb3dzIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm90b2NvbCIsInByb2Nlc3NEYXRhIiwiYXN5bmMiLCJjb250ZW50VHlwZSIsImFjY2VwdHMiLCJqc29uIiwiYWpheFNldHVwIiwic2V0dGluZ3MiLCJhamF4UHJlZmlsdGVyIiwiYWpheFRyYW5zcG9ydCIsImFqYXgiLCJ0cmFuc3BvcnQiLCJjYWNoZVVSTCIsInJlc3BvbnNlSGVhZGVyc1N0cmluZyIsInJlc3BvbnNlSGVhZGVycyIsInRpbWVvdXRUaW1lciIsInVybEFuY2hvciIsImZpcmVHbG9iYWxzIiwidW5jYWNoZWQiLCJjYWxsYmFja0NvbnRleHQiLCJnbG9iYWxFdmVudENvbnRleHQiLCJjb21wbGV0ZURlZmVycmVkIiwic3RhdHVzQ29kZSIsInJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdEhlYWRlcnNOYW1lcyIsInN0ckFib3J0IiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwic2V0UmVxdWVzdEhlYWRlciIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJjcm9zc0RvbWFpbiIsImhvc3QiLCJoYXNDb250ZW50IiwiaWZNb2RpZmllZCIsImhlYWRlcnMiLCJiZWZvcmVTZW5kIiwic3VjY2VzcyIsInNlbmQiLCJuYXRpdmVTdGF0dXNUZXh0IiwibW9kaWZpZWQiLCJnZXRKU09OIiwiZ2V0U2NyaXB0Iiwid3JhcEFsbCIsImZpcnN0RWxlbWVudENoaWxkIiwid3JhcElubmVyIiwiaHRtbElzRnVuY3Rpb24iLCJ1bndyYXAiLCJ2aXNpYmxlIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJ4aHJTdWNjZXNzU3RhdHVzIiwieGhyU3VwcG9ydGVkIiwiY29ycyIsImVycm9yQ2FsbGJhY2siLCJvcGVuIiwidXNlcm5hbWUiLCJ4aHJGaWVsZHMiLCJvbmxvYWQiLCJvbmVycm9yIiwib25hYm9ydCIsIm9udGltZW91dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlVGV4dCIsImJpbmFyeSIsInNjcmlwdEF0dHJzIiwiY2hhcnNldCIsInNjcmlwdENoYXJzZXQiLCJldnQiLCJvbGRDYWxsYmFja3MiLCJyanNvbnAiLCJqc29ucCIsImpzb25wQ2FsbGJhY2siLCJvcmlnaW5hbFNldHRpbmdzIiwiY2FsbGJhY2tOYW1lIiwib3ZlcndyaXR0ZW4iLCJyZXNwb25zZUNvbnRhaW5lciIsImpzb25Qcm9wIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiaW1wbGVtZW50YXRpb24iLCJrZWVwU2NyaXB0cyIsInBhcnNlZCIsInBhcmFtcyIsImFuaW1hdGVkIiwib2Zmc2V0Iiwic2V0T2Zmc2V0IiwiY3VyUG9zaXRpb24iLCJjdXJMZWZ0IiwiY3VyQ1NTVG9wIiwiY3VyVG9wIiwiY3VyT2Zmc2V0IiwiY3VyQ1NTTGVmdCIsImNhbGN1bGF0ZVBvc2l0aW9uIiwiY3VyRWxlbSIsInVzaW5nIiwicmVjdCIsIndpbiIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJvZmZzZXRQYXJlbnQiLCJwYXJlbnRPZmZzZXQiLCJzY3JvbGxUbyIsIkhlaWdodCIsIldpZHRoIiwiZGVmYXVsdEV4dHJhIiwiZnVuY05hbWUiLCJ1bmJpbmQiLCJkZWxlZ2F0ZSIsInVuZGVsZWdhdGUiLCJob3ZlciIsImZuT3ZlciIsImZuT3V0IiwicnRyaW0iLCJwcm94eSIsImhvbGRSZWFkeSIsImhvbGQiLCJwYXJzZUpTT04iLCJpc051bWVyaWMiLCJpc05hTiIsInRyaW0iLCJkZWZpbmUiLCJhbWQiLCJfalF1ZXJ5IiwiXyQiLCIkIiwibm9Db25mbGljdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/jquery@3.7.1/node_modules/jquery/dist/jquery.js\n");

/***/ })

};
;