"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-jvectormap+core@1.0.4_jquery@3.7.1_react-dom@18.2.0_react@18.2.0__react@18.2.0";
exports.ids = ["vendor-chunks/@react-jvectormap+core@1.0.4_jquery@3.7.1_react-dom@18.2.0_react@18.2.0__react@18.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-jvectormap+core@1.0.4_jquery@3.7.1_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@react-jvectormap/core/dist/index.js":
/*!********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-jvectormap+core@1.0.4_jquery@3.7.1_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@react-jvectormap/core/dist/index.js ***!
  \********************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! jquery */ \"(ssr)/./node_modules/.pnpm/jquery@3.7.1/node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.1.0_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n    else { var i, a; }\n})(self, function(__WEBPACK_EXTERNAL_MODULE_jquery__, __WEBPACK_EXTERNAL_MODULE_react__) {\n    return /******/ (()=>{\n        /******/ var __webpack_modules__ = {\n            /***/ \"./src/components/MapContainer/MapContainer.tsx\": /*!******************************************************!*\\\n  !*** ./src/components/MapContainer/MapContainer.tsx ***!\n  \\******************************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"MapContainer\": () => (/* binding */ MapContainer)\\n/* harmony export */ });\\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ \"../../node_modules/classnames/index.js\");\\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);\\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles.module.scss */ \"./src/components/MapContainer/styles.module.scss\");\\n\\n\\n\\nconst MapContainer = ({\\n  containerRef,\\n  className,\\n  style\\n}) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\\n  style: style,\\n  className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(_styles_module_scss__WEBPACK_IMPORTED_MODULE_2__[\"default\"].root, className),\\n  ref: containerRef\\n});\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/components/MapContainer/MapContainer.tsx?');\n            /***/ },\n            /***/ \"./src/components/MapContainer/index.ts\": /*!**********************************************!*\\\n  !*** ./src/components/MapContainer/index.ts ***!\n  \\**********************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"MapContainer\": () => (/* reexport safe */ _MapContainer__WEBPACK_IMPORTED_MODULE_0__.MapContainer)\\n/* harmony export */ });\\n/* harmony import */ var _MapContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapContainer */ \"./src/components/MapContainer/MapContainer.tsx\");\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/components/MapContainer/index.ts?');\n            /***/ },\n            /***/ \"./src/components/MultiMap/MultiMap.tsx\": /*!**********************************************!*\\\n  !*** ./src/components/MultiMap/MultiMap.tsx ***!\n  \\**********************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"MultiMap\": () => (/* binding */ MultiMap)\\n/* harmony export */ });\\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ \"jquery\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);\\n/* harmony import */ var _MapContainer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapContainer */ \"./src/components/MapContainer/index.ts\");\\n\\n\\n\\nconst MultiMap = ({\\n  mapRef,\\n  style,\\n  className,\\n  ...props\\n}) => {\\n  const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\\n    const mapContainer = containerRef.current;\\n    const {\\n      main,\\n      ...rest\\n    } = props;\\n    const {\\n      map: {\\n        name,\\n        content\\n      },\\n      ...restMain\\n    } = main;\\n    jquery__WEBPACK_IMPORTED_MODULE_1___default().fn.vectorMap(\"addMap\", name, content);\\n\\n    if (mapContainer) {\\n      jquery__WEBPACK_IMPORTED_MODULE_1___default()(mapContainer).multiMap({\\n        main: { ...restMain,\\n          map: name\\n        },\\n        ...rest\\n      });\\n    }\\n  }, [mapRef, props]);\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MapContainer__WEBPACK_IMPORTED_MODULE_2__.MapContainer, {\\n    style: style,\\n    className: className,\\n    containerRef: containerRef\\n  });\\n};\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/components/MultiMap/MultiMap.tsx?');\n            /***/ },\n            /***/ \"./src/components/MultiMap/index.ts\": /*!******************************************!*\\\n  !*** ./src/components/MultiMap/index.ts ***!\n  \\******************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"MultiMap\": () => (/* reexport safe */ _MultiMap__WEBPACK_IMPORTED_MODULE_0__.MultiMap)\\n/* harmony export */ });\\n/* harmony import */ var _MultiMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MultiMap */ \"./src/components/MultiMap/MultiMap.tsx\");\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/components/MultiMap/index.ts?');\n            /***/ },\n            /***/ \"./src/components/VectorMap/VectorMap.tsx\": /*!************************************************!*\\\n  !*** ./src/components/VectorMap/VectorMap.tsx ***!\n  \\************************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"VectorMap\": () => (/* binding */ VectorMap)\\n/* harmony export */ });\\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ \"jquery\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);\\n/* harmony import */ var _MapContainer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapContainer */ \"./src/components/MapContainer/index.ts\");\\n\\n\\n\\nconst VectorMap = ({\\n  map,\\n  mapRef,\\n  style,\\n  className,\\n  series,\\n  ...props\\n}) => {\\n  const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\\n    const mapContainer = containerRef.current;\\n\\n    if (!map) {\\n      console.error(\"[react-jvectormap]: no map was loaded!\");\\n    }\\n\\n    const {\\n      name,\\n      content\\n    } = map;\\n    jquery__WEBPACK_IMPORTED_MODULE_1___default().fn.vectorMap(\"addMap\", name, content);\\n\\n    if (mapContainer) {\\n      jquery__WEBPACK_IMPORTED_MODULE_1___default()(mapContainer).vectorMap({\\n        map: name,\\n        series,\\n        ...props\\n      });\\n\\n      if (map && (mapRef === null || mapRef === void 0 ? void 0 : mapRef.current) === null) {\\n        mapRef.current = jquery__WEBPACK_IMPORTED_MODULE_1___default()(mapContainer).vectorMap(\"get\", \"mapObject\");\\n      }\\n    }\\n  }, [map, mapRef, props, series]);\\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\\n    const mapContainer = containerRef.current;\\n\\n    if (series && mapContainer) {\\n      const map = jquery__WEBPACK_IMPORTED_MODULE_1___default()(mapContainer).vectorMap(\"get\", \"mapObject\");\\n      const {\\n        markers = [],\\n        regions = []\\n      } = series;\\n      regions.forEach(({\\n        values\\n      }, index) => {\\n        var _map$series;\\n\\n        if (values && (_map$series = map.series) !== null && _map$series !== void 0 && _map$series.regions) {\\n          var _map$series2, _map$series2$regions$;\\n\\n          (_map$series2 = map.series) === null || _map$series2 === void 0 ? void 0 : (_map$series2$regions$ = _map$series2.regions[index]) === null || _map$series2$regions$ === void 0 ? void 0 : _map$series2$regions$.clearAndSet(values);\\n        }\\n      });\\n      markers.forEach(({\\n        values\\n      }, index) => {\\n        var _map$series3;\\n\\n        if (values && (_map$series3 = map.series) !== null && _map$series3 !== void 0 && _map$series3.markers) {\\n          var _map$series4, _map$series4$markers$;\\n\\n          (_map$series4 = map.series) === null || _map$series4 === void 0 ? void 0 : (_map$series4$markers$ = _map$series4.markers[index]) === null || _map$series4$markers$ === void 0 ? void 0 : _map$series4$markers$.clearAndSet(values);\\n        }\\n      });\\n    }\\n  }, [series]);\\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MapContainer__WEBPACK_IMPORTED_MODULE_2__.MapContainer, {\\n    className: className,\\n    style: style,\\n    containerRef: containerRef\\n  });\\n};\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/components/VectorMap/VectorMap.tsx?');\n            /***/ },\n            /***/ \"./src/components/VectorMap/index.ts\": /*!*******************************************!*\\\n  !*** ./src/components/VectorMap/index.ts ***!\n  \\*******************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"VectorMap\": () => (/* reexport safe */ _VectorMap__WEBPACK_IMPORTED_MODULE_0__.VectorMap)\\n/* harmony export */ });\\n/* harmony import */ var _VectorMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VectorMap */ \"./src/components/VectorMap/VectorMap.tsx\");\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/components/VectorMap/index.ts?');\n            /***/ },\n            /***/ \"./src/components/index.ts\": /*!*********************************!*\\\n  !*** ./src/components/index.ts ***!\n  \\*********************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"VectorMap\": () => (/* reexport safe */ _VectorMap__WEBPACK_IMPORTED_MODULE_0__.VectorMap),\\n/* harmony export */   \"MultiMap\": () => (/* reexport safe */ _MultiMap__WEBPACK_IMPORTED_MODULE_1__.MultiMap)\\n/* harmony export */ });\\n/* harmony import */ var _VectorMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VectorMap */ \"./src/components/VectorMap/index.ts\");\\n/* harmony import */ var _MultiMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MultiMap */ \"./src/components/MultiMap/index.ts\");\\n\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/components/index.ts?');\n            /***/ },\n            /***/ \"./src/index.ts\": /*!**********************!*\\\n  !*** ./src/index.ts ***!\n  \\**********************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"MultiMap\": () => (/* reexport safe */ _components__WEBPACK_IMPORTED_MODULE_2__.MultiMap),\\n/* harmony export */   \"VectorMap\": () => (/* reexport safe */ _components__WEBPACK_IMPORTED_MODULE_2__.VectorMap),\\n/* harmony export */   \"AttributeSeriesBuilder\": () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.AttributeSeriesBuilder),\\n/* harmony export */   \"LabelsBuilder\": () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.LabelsBuilder),\\n/* harmony export */   \"LabelsPropsBuilder\": () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.LabelsPropsBuilder),\\n/* harmony export */   \"MarkerBuilder\": () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.MarkerBuilder),\\n/* harmony export */   \"MultiMapBuilder\": () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.MultiMapBuilder),\\n/* harmony export */   \"SeriesBuilder\": () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.SeriesBuilder),\\n/* harmony export */   \"StyleBuilder\": () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.StyleBuilder),\\n/* harmony export */   \"VectorMapBuilder\": () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.VectorMapBuilder)\\n/* harmony export */ });\\n/* harmony import */ var _react_jvectormap_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-jvectormap/lib */ \"../jvectormap/index.js\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ \"jquery\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);\\n/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components */ \"./src/components/index.ts\");\\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./src/utils/index.ts\");\\n\\n\\n\\n\\n(0,_react_jvectormap_lib__WEBPACK_IMPORTED_MODULE_0__.loadJVectorMap)((jquery__WEBPACK_IMPORTED_MODULE_1___default()));\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/index.ts?');\n            /***/ },\n            /***/ \"./src/utils/builders/AttributeSeriesBuilder.ts\": /*!******************************************************!*\\\n  !*** ./src/utils/builders/AttributeSeriesBuilder.ts ***!\n  \\******************************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"AttributeSeriesBuilder\": () => (/* binding */ AttributeSeriesBuilder)\\n/* harmony export */ });\\nclass AttributeSeriesBuilder {\\n  constructor(attribute) {\\n    this.attribute = attribute;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setAttribute(value) {\\n    this.attribute = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setScale(value) {\\n    this.scale = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setValues(value) {\\n    this.values = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setNormalizeFunction(value) {\\n    this.normalizeFunction = value;\\n    return this;\\n  }\\n\\n  build() {\\n    return {\\n      scale: this.scale,\\n      values: this.values,\\n      attribute: this.attribute,\\n      normalizeFunction: this.normalizeFunction\\n    };\\n  }\\n\\n}\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/builders/AttributeSeriesBuilder.ts?');\n            /***/ },\n            /***/ \"./src/utils/builders/LabelsBuilder.ts\": /*!*********************************************!*\\\n  !*** ./src/utils/builders/LabelsBuilder.ts ***!\n  \\*********************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"LabelsBuilder\": () => (/* binding */ LabelsBuilder)\\n/* harmony export */ });\\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils/builders/utils.ts\");\\n\\nclass LabelsBuilder {\\n  /**\\n   *\\n   * @param values\\n   */\\n  addMarkersLabelProps(...values) {\\n    if (!this.markers) {\\n      this.markers = [];\\n    }\\n\\n    this.markers.push(...values);\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param values\\n   */\\n\\n\\n  addRegionsLabelProps(...values) {\\n    if (!this.regions) {\\n      this.regions = [];\\n    }\\n\\n    this.regions.push(...values);\\n    return this;\\n  }\\n\\n  build() {\\n    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stripUndefinedValues)({\\n      markers: this.markers,\\n      regions: this.regions\\n    });\\n  }\\n\\n}\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/builders/LabelsBuilder.ts?');\n            /***/ },\n            /***/ \"./src/utils/builders/LabelsPropsBuilder.ts\": /*!**************************************************!*\\\n  !*** ./src/utils/builders/LabelsPropsBuilder.ts ***!\n  \\**************************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"LabelsPropsBuilder\": () => (/* binding */ LabelsPropsBuilder)\\n/* harmony export */ });\\nclass LabelsPropsBuilder {\\n  constructor(render, offsets) {\\n    this.render = render;\\n    this.offsets = offsets;\\n  }\\n  /**\\n   *\\n   * @param render\\n   */\\n\\n\\n  setRender(render) {\\n    this.render = render;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param offsets\\n   */\\n\\n\\n  setOffsets(offsets) {\\n    this.offsets = offsets;\\n    return this;\\n  }\\n  /**\\n   *\\n   */\\n\\n\\n  build() {\\n    return {\\n      render: this.render,\\n      offsets: this.offsets\\n    };\\n  }\\n\\n}\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/builders/LabelsPropsBuilder.ts?');\n            /***/ },\n            /***/ \"./src/utils/builders/MarkerBuilder.ts\": /*!*********************************************!*\\\n  !*** ./src/utils/builders/MarkerBuilder.ts ***!\n  \\*********************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"MarkerBuilder\": () => (/* binding */ MarkerBuilder)\\n/* harmony export */ });\\nclass MarkerBuilder {\\n  constructor(value) {\\n    this.name = value;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setName(value) {\\n    this.name = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setCoords(value) {\\n    this.latLng = undefined;\\n    this.coords = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setLatLng(value) {\\n    this.coords = undefined;\\n    this.latLng = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setStyle(value) {\\n    this.style = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   */\\n\\n\\n  build() {\\n    const commonProps = {\\n      name: this.name,\\n      style: this.style\\n    };\\n\\n    if (this.coords) {\\n      return { ...commonProps,\\n        coords: this.coords\\n      };\\n    } else if (this.latLng) {\\n      return { ...commonProps,\\n        latLng: this.latLng\\n      };\\n    }\\n\\n    return { ...commonProps,\\n      latLng: [0, 0]\\n    };\\n  }\\n\\n}\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/builders/MarkerBuilder.ts?');\n            /***/ },\n            /***/ \"./src/utils/builders/MultiMapBuilder.ts\": /*!***********************************************!*\\\n  !*** ./src/utils/builders/MultiMapBuilder.ts ***!\n  \\***********************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"MultiMapBuilder\": () => (/* binding */ MultiMapBuilder)\\n/* harmony export */ });\\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils/builders/utils.ts\");\\n\\nclass MultiMapBuilder {\\n  constructor(mainMap, maxLevel = 1) {\\n    this.main = {\\n      map: mainMap\\n    };\\n    this.maxLevel = maxLevel;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setMainMap(value) {\\n    this.main.map = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setMaxLevel(value) {\\n    this.maxLevel = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setMapNameByCode(value) {\\n    this.mapNameByCode = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setUrlByCode(value) {\\n    this.mapUrlByCode = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setGetDrillDownMap(value) {\\n    this.getDrillDownMap = value;\\n    return this;\\n  }\\n\\n  build() {\\n    const baseProps = {\\n      main: this.main,\\n      maxLevel: this.maxLevel\\n    };\\n    return { ...baseProps,\\n      ...(0,_utils__WEBPACK_IMPORTED_MODULE_0__.stripUndefinedValues)({\\n        mapNameByCode: this.mapNameByCode,\\n        mapUrlByCode: this.mapUrlByCode,\\n        getDrillDownMap: this.getDrillDownMap\\n      })\\n    };\\n  }\\n\\n}\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/builders/MultiMapBuilder.ts?');\n            /***/ },\n            /***/ \"./src/utils/builders/SeriesBuilder.ts\": /*!*********************************************!*\\\n  !*** ./src/utils/builders/SeriesBuilder.ts ***!\n  \\*********************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"SeriesBuilder\": () => (/* binding */ SeriesBuilder)\\n/* harmony export */ });\\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils/builders/utils.ts\");\\n\\nclass SeriesBuilder {\\n  /**\\n   *\\n   * @param values\\n   */\\n  addMarkersSeries(...values) {\\n    if (!this.markers) {\\n      this.markers = [];\\n    }\\n\\n    this.markers.push(...values);\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param values\\n   */\\n\\n\\n  addRegionsSeries(...values) {\\n    if (!this.regions) {\\n      this.regions = [];\\n    }\\n\\n    this.regions.push(...values);\\n    return this;\\n  }\\n\\n  build() {\\n    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stripUndefinedValues)({\\n      markers: this.markers,\\n      regions: this.regions\\n    });\\n  }\\n\\n}\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/builders/SeriesBuilder.ts?');\n            /***/ },\n            /***/ \"./src/utils/builders/StyleBuilder.ts\": /*!********************************************!*\\\n  !*** ./src/utils/builders/StyleBuilder.ts ***!\n  \\********************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"StyleBuilder\": () => (/* binding */ StyleBuilder)\\n/* harmony export */ });\\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils/builders/utils.ts\");\\n\\nclass StyleBuilder {\\n  /**\\n   *\\n   * @param value\\n   */\\n  setInitial(value) {\\n    this.initial = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setSelected(value) {\\n    this.selected = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setHover(value) {\\n    this.hover = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setSelectedHover(value) {\\n    this.selectedHover = value;\\n    return this;\\n  }\\n\\n  build() {\\n    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stripUndefinedValues)({\\n      selected: this.selected,\\n      selectedHover: this.selectedHover,\\n      hover: this.hover,\\n      initial: this.initial\\n    });\\n  }\\n\\n}\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/builders/StyleBuilder.ts?');\n            /***/ },\n            /***/ \"./src/utils/builders/VectorMapBuilder.ts\": /*!************************************************!*\\\n  !*** ./src/utils/builders/VectorMapBuilder.ts ***!\n  \\************************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"VectorMapBuilder\": () => (/* binding */ VectorMapBuilder)\\n/* harmony export */ });\\nclass VectorMapBuilder {\\n  selectedRegions = [];\\n\\n  constructor(map) {\\n    this.map = map;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setMap(value) {\\n    this.map = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setBackgroundColor(value) {\\n    this.backgroundColor = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setZoomMin(value) {\\n    this.zoomMin = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setZoomMax(value) {\\n    this.zoomMax = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param marker\\n   */\\n\\n\\n  addMarker(marker) {\\n    if (!this.markers) {\\n      this.markers = [];\\n    }\\n\\n    this.markers.push(marker);\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setMarkerStyle(value) {\\n    this.markerStyle = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setRegionStyle(value) {\\n    this.regionStyle = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   * @private\\n   */\\n\\n\\n  setMarkersSelectable(value) {\\n    this.markersSelectable = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setMarkers(value) {\\n    this.markers = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @private\\n   * @param value\\n   */\\n\\n\\n  setRegionsSelectable(value) {\\n    this.regionsSelectable = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @private\\n   * @param value\\n   */\\n\\n\\n  setOnRegionTipShow(value) {\\n    this.onRegionTipShow = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setSeries(value) {\\n    this.series = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param values\\n   */\\n\\n\\n  setLabels(values) {\\n    this.labels = values;\\n    return this;\\n  }\\n  /**\\n   *\\n   * @param value\\n   */\\n\\n\\n  setSelectedRegions(value) {\\n    this.selectedRegions = value;\\n    return this;\\n  }\\n  /**\\n   *\\n   */\\n\\n\\n  build() {\\n    return {\\n      map: this.map,\\n      series: this.series,\\n      backgroundColor: this.backgroundColor,\\n      zoomMax: this.zoomMax,\\n      zoomMin: this.zoomMin,\\n      markerStyle: this.markerStyle,\\n      regionStyle: this.regionStyle,\\n      markersSelectable: this.markersSelectable,\\n      regionsSelectable: this.regionsSelectable,\\n      markers: this.markers,\\n      labels: this.labels,\\n      selectedRegions: this.selectedRegions\\n    };\\n  }\\n\\n}\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/builders/VectorMapBuilder.ts?');\n            /***/ },\n            /***/ \"./src/utils/builders/index.ts\": /*!*************************************!*\\\n  !*** ./src/utils/builders/index.ts ***!\n  \\*************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"VectorMapBuilder\": () => (/* reexport safe */ _VectorMapBuilder__WEBPACK_IMPORTED_MODULE_0__.VectorMapBuilder),\\n/* harmony export */   \"MarkerBuilder\": () => (/* reexport safe */ _MarkerBuilder__WEBPACK_IMPORTED_MODULE_1__.MarkerBuilder),\\n/* harmony export */   \"StyleBuilder\": () => (/* reexport safe */ _StyleBuilder__WEBPACK_IMPORTED_MODULE_2__.StyleBuilder),\\n/* harmony export */   \"AttributeSeriesBuilder\": () => (/* reexport safe */ _AttributeSeriesBuilder__WEBPACK_IMPORTED_MODULE_3__.AttributeSeriesBuilder),\\n/* harmony export */   \"SeriesBuilder\": () => (/* reexport safe */ _SeriesBuilder__WEBPACK_IMPORTED_MODULE_4__.SeriesBuilder),\\n/* harmony export */   \"LabelsBuilder\": () => (/* reexport safe */ _LabelsBuilder__WEBPACK_IMPORTED_MODULE_5__.LabelsBuilder),\\n/* harmony export */   \"LabelsPropsBuilder\": () => (/* reexport safe */ _LabelsPropsBuilder__WEBPACK_IMPORTED_MODULE_6__.LabelsPropsBuilder),\\n/* harmony export */   \"MultiMapBuilder\": () => (/* reexport safe */ _MultiMapBuilder__WEBPACK_IMPORTED_MODULE_7__.MultiMapBuilder)\\n/* harmony export */ });\\n/* harmony import */ var _VectorMapBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VectorMapBuilder */ \"./src/utils/builders/VectorMapBuilder.ts\");\\n/* harmony import */ var _MarkerBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkerBuilder */ \"./src/utils/builders/MarkerBuilder.ts\");\\n/* harmony import */ var _StyleBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StyleBuilder */ \"./src/utils/builders/StyleBuilder.ts\");\\n/* harmony import */ var _AttributeSeriesBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AttributeSeriesBuilder */ \"./src/utils/builders/AttributeSeriesBuilder.ts\");\\n/* harmony import */ var _SeriesBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SeriesBuilder */ \"./src/utils/builders/SeriesBuilder.ts\");\\n/* harmony import */ var _LabelsBuilder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LabelsBuilder */ \"./src/utils/builders/LabelsBuilder.ts\");\\n/* harmony import */ var _LabelsPropsBuilder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LabelsPropsBuilder */ \"./src/utils/builders/LabelsPropsBuilder.ts\");\\n/* harmony import */ var _MultiMapBuilder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MultiMapBuilder */ \"./src/utils/builders/MultiMapBuilder.ts\");\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/builders/index.ts?');\n            /***/ },\n            /***/ \"./src/utils/builders/utils.ts\": /*!*************************************!*\\\n  !*** ./src/utils/builders/utils.ts ***!\n  \\*************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"stripUndefinedValues\": () => (/* binding */ stripUndefinedValues)\\n/* harmony export */ });\\n/**\\n * remove undefined values from object\\n * @param object\\n */\\nconst stripUndefinedValues = object => Object.fromEntries(Object.entries(object).filter(entry => entry[1] !== undefined));\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/builders/utils.ts?');\n            /***/ },\n            /***/ \"./src/utils/index.ts\": /*!****************************!*\\\n  !*** ./src/utils/index.ts ***!\n  \\****************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"AttributeSeriesBuilder\": () => (/* reexport safe */ _builders__WEBPACK_IMPORTED_MODULE_0__.AttributeSeriesBuilder),\\n/* harmony export */   \"LabelsBuilder\": () => (/* reexport safe */ _builders__WEBPACK_IMPORTED_MODULE_0__.LabelsBuilder),\\n/* harmony export */   \"LabelsPropsBuilder\": () => (/* reexport safe */ _builders__WEBPACK_IMPORTED_MODULE_0__.LabelsPropsBuilder),\\n/* harmony export */   \"MarkerBuilder\": () => (/* reexport safe */ _builders__WEBPACK_IMPORTED_MODULE_0__.MarkerBuilder),\\n/* harmony export */   \"MultiMapBuilder\": () => (/* reexport safe */ _builders__WEBPACK_IMPORTED_MODULE_0__.MultiMapBuilder),\\n/* harmony export */   \"SeriesBuilder\": () => (/* reexport safe */ _builders__WEBPACK_IMPORTED_MODULE_0__.SeriesBuilder),\\n/* harmony export */   \"StyleBuilder\": () => (/* reexport safe */ _builders__WEBPACK_IMPORTED_MODULE_0__.StyleBuilder),\\n/* harmony export */   \"VectorMapBuilder\": () => (/* reexport safe */ _builders__WEBPACK_IMPORTED_MODULE_0__.VectorMapBuilder)\\n/* harmony export */ });\\n/* harmony import */ var _builders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./builders */ \"./src/utils/builders/index.ts\");\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/utils/index.ts?');\n            /***/ },\n            /***/ \"../../node_modules/classnames/index.js\": /*!**********************************************!*\\\n  !*** ../../node_modules/classnames/index.js ***!\n  \\**********************************************/ /***/ (module, exports)=>{\n                eval(\"var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n  Copyright (c) 2018 Jed Watson.\\n  Licensed under the MIT License (MIT), see\\n  http://jedwatson.github.io/classnames\\n*/\\n/* global define */\\n\\n(function () {\\n\t'use strict';\\n\\n\tvar hasOwn = {}.hasOwnProperty;\\n\\n\tfunction classNames() {\\n\t\tvar classes = [];\\n\\n\t\tfor (var i = 0; i < arguments.length; i++) {\\n\t\t\tvar arg = arguments[i];\\n\t\t\tif (!arg) continue;\\n\\n\t\t\tvar argType = typeof arg;\\n\\n\t\t\tif (argType === 'string' || argType === 'number') {\\n\t\t\t\tclasses.push(arg);\\n\t\t\t} else if (Array.isArray(arg)) {\\n\t\t\t\tif (arg.length) {\\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\\n\t\t\t\t\tif (inner) {\\n\t\t\t\t\t\tclasses.push(inner);\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t} else if (argType === 'object') {\\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\\n\t\t\t\t\tfor (var key in arg) {\\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\\n\t\t\t\t\t\t\tclasses.push(key);\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t} else {\\n\t\t\t\t\tclasses.push(arg.toString());\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\treturn classes.join(' ');\\n\t}\\n\\n\tif ( true && module.exports) {\\n\t\tclassNames.default = classNames;\\n\t\tmodule.exports = classNames;\\n\t} else if (true) {\\n\t\t// register as 'classnames', consistent with npm package name\\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\\n\t\t\treturn classNames;\\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n\t} else {}\\n}());\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../../node_modules/classnames/index.js?\");\n            /***/ },\n            /***/ \"../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./src/components/MapContainer/styles.module.scss\": /*!*********************************************************************************************************************************************!*\\\n  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./src/components/MapContainer/styles.module.scss ***!\n  \\*********************************************************************************************************************************************/ /***/ (module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"../../node_modules/css-loader/dist/runtime/noSourceMaps.js\");\\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/api.js */ \"../../node_modules/css-loader/dist/runtime/api.js\");\\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/getUrl.js */ \"../../node_modules/css-loader/dist/runtime/getUrl.js\");\\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\\n// Imports\\n\\n\\n\\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! data:image/gif;base64,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 */ \"data:image/gif;base64,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\"), __webpack_require__.b);\\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\\n// Module\\n___CSS_LOADER_EXPORT___.push([module.id, \".jvectormap-tip {\\\\n  position: absolute;\\\\n  display: none;\\\\n  border: solid 1px #cdcdcd;\\\\n  border-radius: 3px;\\\\n  background: #292929;\\\\n  color: white;\\\\n  font-family: sans-serif, Verdana;\\\\n  font-size: smaller;\\\\n  padding: 3px;\\\\n}\\\\n\\\\n._u5cITtZnGk9D_6uoElx {\\\\n  height: 100%;\\\\n  width: 100%;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx svg {\\\\n  touch-action: none;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-container {\\\\n  width: 100%;\\\\n  height: 100%;\\\\n  position: relative;\\\\n  overflow: hidden;\\\\n  touch-action: none;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-zoomin {\\\\n  position: absolute;\\\\n  left: 10px;\\\\n  border-radius: 3px;\\\\n  background: #292929;\\\\n  padding: 3px;\\\\n  color: white;\\\\n  cursor: pointer;\\\\n  line-height: 10px;\\\\n  text-align: center;\\\\n  box-sizing: content-box;\\\\n  width: 10px;\\\\n  height: 10px;\\\\n  top: 10px;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-zoomout {\\\\n  position: absolute;\\\\n  left: 10px;\\\\n  border-radius: 3px;\\\\n  background: #292929;\\\\n  padding: 3px;\\\\n  color: white;\\\\n  cursor: pointer;\\\\n  line-height: 10px;\\\\n  text-align: center;\\\\n  box-sizing: content-box;\\\\n  width: 10px;\\\\n  height: 10px;\\\\n  top: 30px;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-goback {\\\\n  position: absolute;\\\\n  left: 10px;\\\\n  border-radius: 3px;\\\\n  background: #292929;\\\\n  color: white;\\\\n  cursor: pointer;\\\\n  line-height: 10px;\\\\n  text-align: center;\\\\n  box-sizing: content-box;\\\\n  bottom: 10px;\\\\n  z-index: 1000;\\\\n  padding: 6px;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-spinner {\\\\n  position: absolute;\\\\n  left: 0;\\\\n  top: 0;\\\\n  right: 0;\\\\n  bottom: 0;\\\\n  background: center no-repeat url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \");\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-title {\\\\n  font-weight: bold;\\\\n  font-size: 14px;\\\\n  text-align: center;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt {\\\\n  position: absolute;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt-h {\\\\n  bottom: 0;\\\\n  right: 0;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt-h .jvectormap-legend {\\\\n  float: left;\\\\n  margin: 0 10px 10px 0;\\\\n  padding: 3px 3px 1px 3px;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt-h .jvectormap-legend .jvectormap-legend-tick {\\\\n  float: left;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt-h .jvectormap-legend-tick {\\\\n  width: 40px;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt-h .jvectormap-legend-tick-sample {\\\\n  height: 15px;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt-h .jvectormap-legend-tick-text {\\\\n  text-align: center;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt-v {\\\\n  top: 0;\\\\n  right: 0;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt-v .jvectormap-legend {\\\\n  margin: 10px 10px 0 0;\\\\n  padding: 3px;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt-v .jvectormap-legend-tick-sample {\\\\n  height: 20px;\\\\n  width: 20px;\\\\n  display: inline-block;\\\\n  vertical-align: middle;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-cnt-v .jvectormap-legend-tick-text {\\\\n  display: inline-block;\\\\n  vertical-align: middle;\\\\n  line-height: 20px;\\\\n  padding-left: 3px;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend {\\\\n  background: black;\\\\n  color: white;\\\\n  border-radius: 3px;\\\\n}\\\\n._u5cITtZnGk9D_6uoElx .jvectormap-legend-tick-text {\\\\n  font-size: 12px;\\\\n}\", \"\"]);\\n// Exports\\n___CSS_LOADER_EXPORT___.locals = {\\n\t\"root\": \"_u5cITtZnGk9D_6uoElx\"\\n};\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/components/MapContainer/styles.module.scss?../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js');\n            /***/ },\n            /***/ \"../../node_modules/css-loader/dist/runtime/api.js\": /*!*********************************************************!*\\\n  !*** ../../node_modules/css-loader/dist/runtime/api.js ***!\n  \\*********************************************************/ /***/ (module)=>{\n                \"use strict\";\n                eval('\\n\\n/*\\n  MIT License http://www.opensource.org/licenses/mit-license.php\\n  Author Tobias Koppers @sokra\\n*/\\nmodule.exports = function (cssWithMappingToString) {\\n  var list = []; // return the list of modules as css string\\n\\n  list.toString = function toString() {\\n    return this.map(function (item) {\\n      var content = \"\";\\n      var needLayer = typeof item[5] !== \"undefined\";\\n\\n      if (item[4]) {\\n        content += \"@supports (\".concat(item[4], \") {\");\\n      }\\n\\n      if (item[2]) {\\n        content += \"@media \".concat(item[2], \" {\");\\n      }\\n\\n      if (needLayer) {\\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\\n      }\\n\\n      content += cssWithMappingToString(item);\\n\\n      if (needLayer) {\\n        content += \"}\";\\n      }\\n\\n      if (item[2]) {\\n        content += \"}\";\\n      }\\n\\n      if (item[4]) {\\n        content += \"}\";\\n      }\\n\\n      return content;\\n    }).join(\"\");\\n  }; // import a list of modules into the list\\n\\n\\n  list.i = function i(modules, media, dedupe, supports, layer) {\\n    if (typeof modules === \"string\") {\\n      modules = [[null, modules, undefined]];\\n    }\\n\\n    var alreadyImportedModules = {};\\n\\n    if (dedupe) {\\n      for (var _i = 0; _i < this.length; _i++) {\\n        var id = this[_i][0];\\n\\n        if (id != null) {\\n          alreadyImportedModules[id] = true;\\n        }\\n      }\\n    }\\n\\n    for (var _i2 = 0; _i2 < modules.length; _i2++) {\\n      var item = [].concat(modules[_i2]);\\n\\n      if (dedupe && alreadyImportedModules[item[0]]) {\\n        continue;\\n      }\\n\\n      if (typeof layer !== \"undefined\") {\\n        if (typeof item[5] === \"undefined\") {\\n          item[5] = layer;\\n        } else {\\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\\n          item[5] = layer;\\n        }\\n      }\\n\\n      if (media) {\\n        if (!item[2]) {\\n          item[2] = media;\\n        } else {\\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\\n          item[2] = media;\\n        }\\n      }\\n\\n      if (supports) {\\n        if (!item[4]) {\\n          item[4] = \"\".concat(supports);\\n        } else {\\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\\n          item[4] = supports;\\n        }\\n      }\\n\\n      list.push(item);\\n    }\\n  };\\n\\n  return list;\\n};\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../../node_modules/css-loader/dist/runtime/api.js?');\n            /***/ },\n            /***/ \"../../node_modules/css-loader/dist/runtime/getUrl.js\": /*!************************************************************!*\\\n  !*** ../../node_modules/css-loader/dist/runtime/getUrl.js ***!\n  \\************************************************************/ /***/ (module)=>{\n                \"use strict\";\n                eval('\\n\\nmodule.exports = function (url, options) {\\n  if (!options) {\\n    options = {};\\n  }\\n\\n  if (!url) {\\n    return url;\\n  }\\n\\n  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them\\n\\n  if (/^[\\'\"].*[\\'\"]$/.test(url)) {\\n    url = url.slice(1, -1);\\n  }\\n\\n  if (options.hash) {\\n    url += options.hash;\\n  } // Should url be wrapped?\\n  // See https://drafts.csswg.org/css-values-3/#urls\\n\\n\\n  if (/[\"\\'() \\\\t\\\\n]|(%20)/.test(url) || options.needQuotes) {\\n    return \"\\\\\"\".concat(url.replace(/\"/g, \\'\\\\\\\\\"\\').replace(/\\\\n/g, \"\\\\\\\\n\"), \"\\\\\"\");\\n  }\\n\\n  return url;\\n};\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../../node_modules/css-loader/dist/runtime/getUrl.js?');\n            /***/ },\n            /***/ \"../../node_modules/css-loader/dist/runtime/noSourceMaps.js\": /*!******************************************************************!*\\\n  !*** ../../node_modules/css-loader/dist/runtime/noSourceMaps.js ***!\n  \\******************************************************************/ /***/ (module)=>{\n                \"use strict\";\n                eval(\"\\n\\nmodule.exports = function (i) {\\n  return i[1];\\n};\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../../node_modules/css-loader/dist/runtime/noSourceMaps.js?\");\n            /***/ },\n            /***/ \"./src/components/MapContainer/styles.module.scss\": /*!********************************************************!*\\\n  !*** ./src/components/MapContainer/styles.module.scss ***!\n  \\********************************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"../../node_modules/style-loader/dist/runtime/styleDomAPI.js\");\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"../../node_modules/style-loader/dist/runtime/insertBySelector.js\");\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"../../node_modules/style-loader/dist/runtime/insertStyleElement.js\");\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"../../node_modules/style-loader/dist/runtime/styleTagTransform.js\");\\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_module_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!./styles.module.scss */ \"../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./src/components/MapContainer/styles.module.scss\");\\n\\n      \\n      \\n      \\n      \\n      \\n      \\n      \\n      \\n      \\n\\nvar options = {};\\n\\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\\n\\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\\n    \\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\\n\\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_module_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\\n\\n\\n\\n\\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_module_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_module_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_styles_module_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/./src/components/MapContainer/styles.module.scss?');\n            /***/ },\n            /***/ \"../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\": /*!********************************************************************************!*\\\n  !*** ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!\n  \\********************************************************************************/ /***/ (module)=>{\n                \"use strict\";\n                eval('\\n\\nvar stylesInDOM = [];\\n\\nfunction getIndexByIdentifier(identifier) {\\n  var result = -1;\\n\\n  for (var i = 0; i < stylesInDOM.length; i++) {\\n    if (stylesInDOM[i].identifier === identifier) {\\n      result = i;\\n      break;\\n    }\\n  }\\n\\n  return result;\\n}\\n\\nfunction modulesToDom(list, options) {\\n  var idCountMap = {};\\n  var identifiers = [];\\n\\n  for (var i = 0; i < list.length; i++) {\\n    var item = list[i];\\n    var id = options.base ? item[0] + options.base : item[0];\\n    var count = idCountMap[id] || 0;\\n    var identifier = \"\".concat(id, \" \").concat(count);\\n    idCountMap[id] = count + 1;\\n    var indexByIdentifier = getIndexByIdentifier(identifier);\\n    var obj = {\\n      css: item[1],\\n      media: item[2],\\n      sourceMap: item[3],\\n      supports: item[4],\\n      layer: item[5]\\n    };\\n\\n    if (indexByIdentifier !== -1) {\\n      stylesInDOM[indexByIdentifier].references++;\\n      stylesInDOM[indexByIdentifier].updater(obj);\\n    } else {\\n      var updater = addElementStyle(obj, options);\\n      options.byIndex = i;\\n      stylesInDOM.splice(i, 0, {\\n        identifier: identifier,\\n        updater: updater,\\n        references: 1\\n      });\\n    }\\n\\n    identifiers.push(identifier);\\n  }\\n\\n  return identifiers;\\n}\\n\\nfunction addElementStyle(obj, options) {\\n  var api = options.domAPI(options);\\n  api.update(obj);\\n\\n  var updater = function updater(newObj) {\\n    if (newObj) {\\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\\n        return;\\n      }\\n\\n      api.update(obj = newObj);\\n    } else {\\n      api.remove();\\n    }\\n  };\\n\\n  return updater;\\n}\\n\\nmodule.exports = function (list, options) {\\n  options = options || {};\\n  list = list || [];\\n  var lastIdentifiers = modulesToDom(list, options);\\n  return function update(newList) {\\n    newList = newList || [];\\n\\n    for (var i = 0; i < lastIdentifiers.length; i++) {\\n      var identifier = lastIdentifiers[i];\\n      var index = getIndexByIdentifier(identifier);\\n      stylesInDOM[index].references--;\\n    }\\n\\n    var newLastIdentifiers = modulesToDom(newList, options);\\n\\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\\n      var _identifier = lastIdentifiers[_i];\\n\\n      var _index = getIndexByIdentifier(_identifier);\\n\\n      if (stylesInDOM[_index].references === 0) {\\n        stylesInDOM[_index].updater();\\n\\n        stylesInDOM.splice(_index, 1);\\n      }\\n    }\\n\\n    lastIdentifiers = newLastIdentifiers;\\n  };\\n};\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?');\n            /***/ },\n            /***/ \"../../node_modules/style-loader/dist/runtime/insertBySelector.js\": /*!************************************************************************!*\\\n  !*** ../../node_modules/style-loader/dist/runtime/insertBySelector.js ***!\n  \\************************************************************************/ /***/ (module)=>{\n                \"use strict\";\n                eval('\\n\\nvar memo = {};\\n/* istanbul ignore next  */\\n\\nfunction getTarget(target) {\\n  if (typeof memo[target] === \"undefined\") {\\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\\n\\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\\n      try {\\n        // This will throw an exception if access to iframe is blocked\\n        // due to cross-origin restrictions\\n        styleTarget = styleTarget.contentDocument.head;\\n      } catch (e) {\\n        // istanbul ignore next\\n        styleTarget = null;\\n      }\\n    }\\n\\n    memo[target] = styleTarget;\\n  }\\n\\n  return memo[target];\\n}\\n/* istanbul ignore next  */\\n\\n\\nfunction insertBySelector(insert, style) {\\n  var target = getTarget(insert);\\n\\n  if (!target) {\\n    throw new Error(\"Couldn\\'t find a style target. This probably means that the value for the \\'insert\\' parameter is invalid.\");\\n  }\\n\\n  target.appendChild(style);\\n}\\n\\nmodule.exports = insertBySelector;\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../../node_modules/style-loader/dist/runtime/insertBySelector.js?');\n            /***/ },\n            /***/ \"../../node_modules/style-loader/dist/runtime/insertStyleElement.js\": /*!**************************************************************************!*\\\n  !*** ../../node_modules/style-loader/dist/runtime/insertStyleElement.js ***!\n  \\**************************************************************************/ /***/ (module)=>{\n                \"use strict\";\n                eval('\\n\\n/* istanbul ignore next  */\\nfunction insertStyleElement(options) {\\n  var element = document.createElement(\"style\");\\n  options.setAttributes(element, options.attributes);\\n  options.insert(element, options.options);\\n  return element;\\n}\\n\\nmodule.exports = insertStyleElement;\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../../node_modules/style-loader/dist/runtime/insertStyleElement.js?');\n            /***/ },\n            /***/ \"../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\": /*!**************************************************************************************!*\\\n  !*** ../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!\n  \\**************************************************************************************/ /***/ (module, __unused_webpack_exports, __webpack_require__)=>{\n                \"use strict\";\n                eval('\\n\\n/* istanbul ignore next  */\\nfunction setAttributesWithoutAttributes(styleElement) {\\n  var nonce =  true ? __webpack_require__.nc : 0;\\n\\n  if (nonce) {\\n    styleElement.setAttribute(\"nonce\", nonce);\\n  }\\n}\\n\\nmodule.exports = setAttributesWithoutAttributes;\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?');\n            /***/ },\n            /***/ \"../../node_modules/style-loader/dist/runtime/styleDomAPI.js\": /*!*******************************************************************!*\\\n  !*** ../../node_modules/style-loader/dist/runtime/styleDomAPI.js ***!\n  \\*******************************************************************/ /***/ (module)=>{\n                \"use strict\";\n                eval('\\n\\n/* istanbul ignore next  */\\nfunction apply(styleElement, options, obj) {\\n  var css = \"\";\\n\\n  if (obj.supports) {\\n    css += \"@supports (\".concat(obj.supports, \") {\");\\n  }\\n\\n  if (obj.media) {\\n    css += \"@media \".concat(obj.media, \" {\");\\n  }\\n\\n  var needLayer = typeof obj.layer !== \"undefined\";\\n\\n  if (needLayer) {\\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\\n  }\\n\\n  css += obj.css;\\n\\n  if (needLayer) {\\n    css += \"}\";\\n  }\\n\\n  if (obj.media) {\\n    css += \"}\";\\n  }\\n\\n  if (obj.supports) {\\n    css += \"}\";\\n  }\\n\\n  var sourceMap = obj.sourceMap;\\n\\n  if (sourceMap && typeof btoa !== \"undefined\") {\\n    css += \"\\\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\\n  } // For old IE\\n\\n  /* istanbul ignore if  */\\n\\n\\n  options.styleTagTransform(css, styleElement, options.options);\\n}\\n\\nfunction removeStyleElement(styleElement) {\\n  // istanbul ignore if\\n  if (styleElement.parentNode === null) {\\n    return false;\\n  }\\n\\n  styleElement.parentNode.removeChild(styleElement);\\n}\\n/* istanbul ignore next  */\\n\\n\\nfunction domAPI(options) {\\n  var styleElement = options.insertStyleElement(options);\\n  return {\\n    update: function update(obj) {\\n      apply(styleElement, options, obj);\\n    },\\n    remove: function remove() {\\n      removeStyleElement(styleElement);\\n    }\\n  };\\n}\\n\\nmodule.exports = domAPI;\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../../node_modules/style-loader/dist/runtime/styleDomAPI.js?');\n            /***/ },\n            /***/ \"../../node_modules/style-loader/dist/runtime/styleTagTransform.js\": /*!*************************************************************************!*\\\n  !*** ../../node_modules/style-loader/dist/runtime/styleTagTransform.js ***!\n  \\*************************************************************************/ /***/ (module)=>{\n                \"use strict\";\n                eval(\"\\n\\n/* istanbul ignore next  */\\nfunction styleTagTransform(css, styleElement) {\\n  if (styleElement.styleSheet) {\\n    styleElement.styleSheet.cssText = css;\\n  } else {\\n    while (styleElement.firstChild) {\\n      styleElement.removeChild(styleElement.firstChild);\\n    }\\n\\n    styleElement.appendChild(document.createTextNode(css));\\n  }\\n}\\n\\nmodule.exports = styleTagTransform;\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../../node_modules/style-loader/dist/runtime/styleTagTransform.js?\");\n            /***/ },\n            /***/ \"../jquery-mousewheel/jquery.mousewheel.js\": /*!*************************************************!*\\\n  !*** ../jquery-mousewheel/jquery.mousewheel.js ***!\n  \\*************************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"loadJQueryMouseWheel\": () => (/* binding */ loadJQueryMouseWheel)\\n/* harmony export */ });\\n/*!\\n * jQuery Mousewheel 3.1.13\\n * Copyright OpenJS Foundation and other contributors\\n */\\n\\nconst loadJQueryMouseWheel = ($) =>\\n  (function (factory) {\\n    factory($);\\n  })(function ($) {\\n    var toFix = [\\n        \"wheel\",\\n        \"mousewheel\",\\n        \"DOMMouseScroll\",\\n        \"MozMousePixelScroll\",\\n      ],\\n      toBind =\\n        \"onwheel\" in window.document || window.document.documentMode >= 9\\n          ? [\"wheel\"]\\n          : [\"mousewheel\", \"DomMouseScroll\", \"MozMousePixelScroll\"],\\n      slice = Array.prototype.slice,\\n      nullLowestDeltaTimeout,\\n      lowestDelta;\\n\\n    if ($.event.fixHooks) {\\n      for (var i = toFix.length; i; ) {\\n        $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;\\n      }\\n    }\\n\\n    var special = ($.event.special.mousewheel = {\\n      version: \"3.1.12\",\\n\\n      setup: function () {\\n        if (this.addEventListener) {\\n          for (var i = toBind.length; i; ) {\\n            this.addEventListener(toBind[--i], handler, false);\\n          }\\n        } else {\\n          this.onmousewheel = handler;\\n        }\\n\\n        // Store the line height and page height for this particular element\\n        $.data(this, \"mousewheel-line-height\", special.getLineHeight(this));\\n        $.data(this, \"mousewheel-page-height\", special.getPageHeight(this));\\n      },\\n\\n      teardown: function () {\\n        if (this.removeEventListener) {\\n          for (var i = toBind.length; i; ) {\\n            this.removeEventListener(toBind[--i], handler, false);\\n          }\\n        } else {\\n          this.onmousewheel = null;\\n        }\\n\\n        // Clean up the data we added to the element\\n        $.removeData(this, \"mousewheel-line-height\");\\n        $.removeData(this, \"mousewheel-page-height\");\\n      },\\n\\n      getLineHeight: function (elem) {\\n        var $elem = $(elem),\\n          $parent = $elem[\"offsetParent\" in $.fn ? \"offsetParent\" : \"parent\"]();\\n        if (!$parent.length) {\\n          $parent = $(\"body\");\\n        }\\n        return (\\n          parseInt($parent.css(\"fontSize\"), 10) ||\\n          parseInt($elem.css(\"fontSize\"), 10) ||\\n          16\\n        );\\n      },\\n\\n      getPageHeight: function (elem) {\\n        return $(elem).height();\\n      },\\n\\n      settings: {\\n        adjustOldDeltas: true, // see shouldAdjustOldDeltas() below\\n        normalizeOffset: true, // calls getBoundingClientRect for each event\\n      },\\n    });\\n\\n    $.fn.extend({\\n      mousewheel: function (fn) {\\n        return fn ? this.on(\"mousewheel\", fn) : this.trigger(\"mousewheel\");\\n      },\\n\\n      unmousewheel: function (fn) {\\n        return this.off(\"mousewheel\", fn);\\n      },\\n    });\\n\\n    function handler(event) {\\n      var orgEvent = event || window.event,\\n        args = slice.call(arguments, 1),\\n        delta = 0,\\n        deltaX = 0,\\n        deltaY = 0,\\n        absDelta = 0;\\n      event = $.event.fix(orgEvent);\\n      event.type = \"mousewheel\";\\n\\n      // Old school scrollwheel delta\\n      if (\"detail\" in orgEvent) {\\n        deltaY = orgEvent.detail * -1;\\n      }\\n      if (\"wheelDelta\" in orgEvent) {\\n        deltaY = orgEvent.wheelDelta;\\n      }\\n      if (\"wheelDeltaY\" in orgEvent) {\\n        deltaY = orgEvent.wheelDeltaY;\\n      }\\n      if (\"wheelDeltaX\" in orgEvent) {\\n        deltaX = orgEvent.wheelDeltaX * -1;\\n      }\\n\\n      // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\\n      if (\"axis\" in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {\\n        deltaX = deltaY * -1;\\n        deltaY = 0;\\n      }\\n\\n      // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy\\n      delta = deltaY === 0 ? deltaX : deltaY;\\n\\n      // New school wheel delta (wheel event)\\n      if (\"deltaY\" in orgEvent) {\\n        deltaY = orgEvent.deltaY * -1;\\n        delta = deltaY;\\n      }\\n      if (\"deltaX\" in orgEvent) {\\n        deltaX = orgEvent.deltaX;\\n        if (deltaY === 0) {\\n          delta = deltaX * -1;\\n        }\\n      }\\n\\n      // No change actually happened, no reason to go any further\\n      if (deltaY === 0 && deltaX === 0) {\\n        return;\\n      }\\n\\n      // Need to convert lines and pages to pixels if we aren\\'t already in pixels\\n      // There are three delta modes:\\n      //   * deltaMode 0 is by pixels, nothing to do\\n      //   * deltaMode 1 is by lines\\n      //   * deltaMode 2 is by pages\\n      if (orgEvent.deltaMode === 1) {\\n        var lineHeight = $.data(this, \"mousewheel-line-height\");\\n        delta *= lineHeight;\\n        deltaY *= lineHeight;\\n        deltaX *= lineHeight;\\n      } else if (orgEvent.deltaMode === 2) {\\n        var pageHeight = $.data(this, \"mousewheel-page-height\");\\n        delta *= pageHeight;\\n        deltaY *= pageHeight;\\n        deltaX *= pageHeight;\\n      }\\n\\n      // Store lowest absolute delta to normalize the delta values\\n      absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));\\n\\n      if (!lowestDelta || absDelta < lowestDelta) {\\n        lowestDelta = absDelta;\\n\\n        // Adjust older deltas if necessary\\n        if (shouldAdjustOldDeltas(orgEvent, absDelta)) {\\n          lowestDelta /= 40;\\n        }\\n      }\\n\\n      // Adjust older deltas if necessary\\n      if (shouldAdjustOldDeltas(orgEvent, absDelta)) {\\n        // Divide all the things by 40!\\n        delta /= 40;\\n        deltaX /= 40;\\n        deltaY /= 40;\\n      }\\n\\n      // Get a whole, normalized value for the deltas\\n      delta = Math[delta >= 1 ? \"floor\" : \"ceil\"](delta / lowestDelta);\\n      deltaX = Math[deltaX >= 1 ? \"floor\" : \"ceil\"](deltaX / lowestDelta);\\n      deltaY = Math[deltaY >= 1 ? \"floor\" : \"ceil\"](deltaY / lowestDelta);\\n\\n      // Normalise offsetX and offsetY properties\\n      if (special.settings.normalizeOffset && this.getBoundingClientRect) {\\n        var boundingRect = this.getBoundingClientRect();\\n        event.offsetX = event.clientX - boundingRect.left;\\n        event.offsetY = event.clientY - boundingRect.top;\\n      }\\n\\n      // Add information to the event object\\n      event.deltaX = deltaX;\\n      event.deltaY = deltaY;\\n      event.deltaFactor = lowestDelta;\\n\\n      // Go ahead and set deltaMode to 0 since we converted to pixels\\n      // Although this is a little odd since we overwrite the deltaX/Y\\n      // properties with normalized deltas.\\n      event.deltaMode = 0;\\n\\n      // Add event and delta to the front of the arguments\\n      args.unshift(event, delta, deltaX, deltaY);\\n\\n      // Clearout lowestDelta after sometime to better\\n      // handle multiple device types that give different\\n      // a different lowestDelta\\n      // Ex: trackpad = 3 and mouse wheel = 120\\n      if (nullLowestDeltaTimeout) {\\n        window.clearTimeout(nullLowestDeltaTimeout);\\n      }\\n      nullLowestDeltaTimeout = window.setTimeout(nullLowestDelta, 200);\\n\\n      return ($.event.dispatch || $.event.handle).apply(this, args);\\n    }\\n\\n    function nullLowestDelta() {\\n      lowestDelta = null;\\n    }\\n\\n    function shouldAdjustOldDeltas(orgEvent, absDelta) {\\n      // If this is an older event and the delta is divisable by 120,\\n      // then we are assuming that the browser is treating this as an\\n      // older mouse wheel event and that we should divide the deltas\\n      // by 40 to try and get a more usable deltaFactor.\\n      // Side note, this actually impacts the reported scroll distance\\n      // in older browsers and can cause scrolling to be slower than native.\\n      // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.\\n      return (\\n        special.settings.adjustOldDeltas &&\\n        orgEvent.type === \"mousewheel\" &&\\n        absDelta % 120 === 0\\n      );\\n    }\\n  });\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../jquery-mousewheel/jquery.mousewheel.js?');\n            /***/ },\n            /***/ \"../jvectormap/index.js\": /*!******************************!*\\\n  !*** ../jvectormap/index.js ***!\n  \\******************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \"loadJVectorMap\": () => (/* reexport safe */ _jquery_jvectormap_min__WEBPACK_IMPORTED_MODULE_0__.loadJVectorMap)\\n/* harmony export */ });\\n/* harmony import */ var _jquery_jvectormap_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jquery.jvectormap.min */ \"../jvectormap/jquery.jvectormap.min.js\");\\n\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../jvectormap/index.js?');\n            /***/ },\n            /***/ \"../jvectormap/jquery.jvectormap.min.js\": /*!**********************************************!*\\\n  !*** ../jvectormap/jquery.jvectormap.min.js ***!\n  \\**********************************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n                \"use strict\";\n                eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"loadJVectorMap\\\": () => (/* binding */ loadJVectorMap)\\n/* harmony export */ });\\n/* harmony import */ var _react_jvectormap_jquery_mousewheel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-jvectormap/jquery-mousewheel */ \\\"../jquery-mousewheel/jquery.mousewheel.js\\\");\\n\\n\\n/**\\n * jVectorMap version 2.0.5\\n *\\n * Copyright 2011-2014, Kirill Lebedev\\n *\\n * inspired from: https://github.com/alex-pex/jvectormap/blob/master/jvectormap-next/src/jquery-jvectormap.js\\n */\\nconst loadJVectorMap = ($) =>\\n  (function (factory) {\\n    factory($);\\n  })(function ($) {\\n    (0,_react_jvectormap_jquery_mousewheel__WEBPACK_IMPORTED_MODULE_0__.loadJQueryMouseWheel)($);\\n    jvm.$ = $;\\n    window.jvm = jvm;\\n\\n    const apiParams = {\\n      set: {\\n        colors: 1,\\n        values: 1,\\n        backgroundColor: 1,\\n        scaleColors: 1,\\n        normalizeFunction: 1,\\n        focus: 1,\\n      },\\n      get: {\\n        selectedRegions: 1,\\n        selectedMarkers: 1,\\n        mapObject: 1,\\n        regionName: 1,\\n      },\\n    };\\n\\n    $.fn.multiMap = function (options) {\\n      options.container = this;\\n      new jvm.MultiMap(options);\\n      return this;\\n    };\\n\\n    $.fn.vectorMap = function (options) {\\n      let map, methodName;\\n      map = this.children(\\\".jvectormap-container\\\").data(\\\"mapObject\\\");\\n      if (options === \\\"remove\\\") {\\n        this.remove();\\n      } else if (options === \\\"addMap\\\") {\\n        jvm.Map.maps[arguments[1]] = arguments[2];\\n      } else if (\\n        (options === \\\"set\\\" || options === \\\"get\\\") &&\\n        apiParams[options][arguments[1]]\\n      ) {\\n        methodName =\\n          arguments[1].charAt(0).toUpperCase() + arguments[1].substr(1);\\n        return map[options + methodName].apply(\\n          map,\\n          Array.prototype.slice.call(arguments, 2),\\n        );\\n      } else if (!map) {\\n        options = options || {};\\n        options.container = this;\\n        map = new jvm.Map(options);\\n      }\\n\\n      return this;\\n    };\\n  });\\n/**\\n * @namespace jvm Holds core methods and classes used by jVectorMap.\\n */\\nvar jvm = {\\n  /**\\n   * Inherits child's prototype from the parent's one.\\n   * @param {Function} child\\n   * @param {Function} parent\\n   */\\n  inherits: function (child, parent) {\\n    function temp() {}\\n    temp.prototype = parent.prototype;\\n    child.prototype = new temp();\\n    child.prototype.constructor = child;\\n    child.parentClass = parent;\\n  },\\n\\n  /**\\n   * Mixes in methods from the source constructor to the target one.\\n   * @param {Function} target\\n   * @param {Function} source\\n   */\\n  mixin: function (target, source) {\\n    var prop;\\n\\n    for (prop in source.prototype) {\\n      if (source.prototype.hasOwnProperty(prop)) {\\n        target.prototype[prop] = source.prototype[prop];\\n      }\\n    }\\n  },\\n\\n  min: function (values) {\\n    var min = Number.MAX_VALUE,\\n      i;\\n\\n    if (values instanceof Array) {\\n      for (i = 0; i < values.length; i++) {\\n        if (values[i] < min) {\\n          min = values[i];\\n        }\\n      }\\n    } else {\\n      for (i in values) {\\n        if (values[i] < min) {\\n          min = values[i];\\n        }\\n      }\\n    }\\n    return min;\\n  },\\n\\n  max: function (values) {\\n    var max = Number.MIN_VALUE,\\n      i;\\n\\n    if (values instanceof Array) {\\n      for (i = 0; i < values.length; i++) {\\n        if (values[i] > max) {\\n          max = values[i];\\n        }\\n      }\\n    } else {\\n      for (i in values) {\\n        if (values[i] > max) {\\n          max = values[i];\\n        }\\n      }\\n    }\\n    return max;\\n  },\\n\\n  keys: function (object) {\\n    var keys = [],\\n      key;\\n\\n    for (key in object) {\\n      keys.push(key);\\n    }\\n    return keys;\\n  },\\n\\n  values: function (object) {\\n    var values = [],\\n      key,\\n      i;\\n\\n    for (i = 0; i < arguments.length; i++) {\\n      object = arguments[i];\\n      for (key in object) {\\n        values.push(object[key]);\\n      }\\n    }\\n    return values;\\n  },\\n\\n  whenImageLoaded: function (url) {\\n    var deferred = new jvm.$.Deferred(),\\n      img = jvm.$(\\\"<img/>\\\");\\n\\n    img\\n      .on(\\\"error\\\", function () {\\n        deferred.reject();\\n      })\\n      .on(\\\"load\\\", function () {\\n        deferred.resolve(img);\\n      });\\n    img.attr(\\\"src\\\", url);\\n\\n    return deferred;\\n  },\\n\\n  isImageUrl: function (s) {\\n    return /\\\\.\\\\w{3,4}$/.test(s);\\n  },\\n};\\n\\n/**\\n * indexOf polyfill for IE < 9\\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf\\n */\\nif (!Array.prototype.indexOf) {\\n  Array.prototype.indexOf = function (searchElement, fromIndex) {\\n    var k;\\n\\n    // 1. Let O be the result of calling ToObject passing\\n    //    the this value as the argument.\\n    if (this == null) {\\n      throw new TypeError('\\\"this\\\" is null or not defined');\\n    }\\n\\n    var O = Object(this);\\n\\n    // 2. Let lenValue be the result of calling the Get\\n    //    internal method of O with the argument \\\"length\\\".\\n    // 3. Let len be ToUint32(lenValue).\\n    var len = O.length >>> 0;\\n\\n    // 4. If len is 0, return -1.\\n    if (len === 0) {\\n      return -1;\\n    }\\n\\n    // 5. If argument fromIndex was passed let n be\\n    //    ToInteger(fromIndex); else let n be 0.\\n    var n = +fromIndex || 0;\\n\\n    if (Math.abs(n) === Infinity) {\\n      n = 0;\\n    }\\n\\n    // 6. If n >= len, return -1.\\n    if (n >= len) {\\n      return -1;\\n    }\\n\\n    // 7. If n >= 0, then Let k be n.\\n    // 8. Else, n<0, Let k be len - abs(n).\\n    //    If k is less than 0, then let k be 0.\\n    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\\n\\n    // 9. Repeat, while k < len\\n    while (k < len) {\\n      // a. Let Pk be ToString(k).\\n      //   This is implicit for LHS operands of the in operator\\n      // b. Let kPresent be the result of calling the\\n      //    HasProperty internal method of O with argument Pk.\\n      //   This step can be combined with c\\n      // c. If kPresent is true, then\\n      //    i.  Let elementK be the result of calling the Get\\n      //        internal method of O with the argument ToString(k).\\n      //   ii.  Let same be the result of applying the\\n      //        Strict Equality Comparison Algorithm to\\n      //        searchElement and elementK.\\n      //  iii.  If same is true, return k.\\n      if (k in O && O[k] === searchElement) {\\n        return k;\\n      }\\n      k++;\\n    }\\n    return -1;\\n  };\\n}\\n/**\\n * Basic wrapper for DOM element.\\n * @constructor\\n * @param {String} name Tag name of the element\\n * @param {Object} config Set of parameters to initialize element with\\n */\\njvm.AbstractElement = function(name, config){\\n  /**\\n   * Underlying DOM element\\n   * @type {DOMElement}\\n   * @private\\n   */\\n  this.node = this.createElement(name);\\n\\n  /**\\n   * Name of underlying element\\n   * @type {String}\\n   * @private\\n   */\\n  this.name = name;\\n\\n  /**\\n   * Internal store of attributes\\n   * @type {Object}\\n   * @private\\n   */\\n  this.properties = {};\\n\\n  if (config) {\\n    this.set(config);\\n  }\\n};\\n\\n/**\\n * Set attribute of the underlying DOM element.\\n * @param {String} name Name of attribute\\n * @param {Number|String} config Set of parameters to initialize element with\\n */\\njvm.AbstractElement.prototype.set = function(property, value){\\n  var key;\\n\\n  if (typeof property === 'object') {\\n    for (key in property) {\\n      this.properties[key] = property[key];\\n      this.applyAttr(key, property[key]);\\n    }\\n  } else {\\n    this.properties[property] = value;\\n    this.applyAttr(property, value);\\n  }\\n};\\n\\n/**\\n * Returns value of attribute.\\n * @param {String} name Name of attribute\\n */\\njvm.AbstractElement.prototype.get = function(property){\\n  return this.properties[property];\\n};\\n\\n/**\\n * Applies attribute value to the underlying DOM element.\\n * @param {String} name Name of attribute\\n * @param {Number|String} config Value of attribute to apply\\n * @private\\n */\\njvm.AbstractElement.prototype.applyAttr = function(property, value){\\n  if (!Number.isNaN(value)) {\\n    this.node.setAttribute(property, value);\\n  }\\n};\\n\\njvm.AbstractElement.prototype.remove = function(){\\n  jvm.$(this.node).remove();\\n};/**\\n * Implements abstract vector canvas.\\n * @constructor\\n * @param {HTMLElement} container Container to put element to.\\n * @param {Number} width Width of canvas.\\n * @param {Number} height Height of canvas.\\n */\\njvm.AbstractCanvasElement = function(container, width, height){\\n  this.container = container;\\n  this.setSize(width, height);\\n  this.rootElement = new jvm[this.classPrefix+'GroupElement']();\\n  this.node.appendChild( this.rootElement.node );\\n  this.container.appendChild(this.node);\\n}\\n\\n/**\\n * Add element to the certain group inside of the canvas.\\n * @param {HTMLElement} element Element to add to canvas.\\n * @param {HTMLElement} group Group to add element into or into root group if not provided.\\n */\\njvm.AbstractCanvasElement.prototype.add = function(element, group){\\n  group = group || this.rootElement;\\n  group.add(element);\\n  element.canvas = this;\\n}\\n\\n/**\\n * Create path and add it to the canvas.\\n * @param {Object} config Parameters of path to create.\\n * @param {Object} style Styles of the path to create.\\n * @param {HTMLElement} group Group to add path into.\\n */\\njvm.AbstractCanvasElement.prototype.addPath = function(config, style, group){\\n  var el = new jvm[this.classPrefix+'PathElement'](config, style);\\n\\n  this.add(el, group);\\n  return el;\\n};\\n\\n/**\\n * Create circle and add it to the canvas.\\n * @param {Object} config Parameters of path to create.\\n * @param {Object} style Styles of the path to create.\\n * @param {HTMLElement} group Group to add circle into.\\n */\\njvm.AbstractCanvasElement.prototype.addCircle = function(config, style, group){\\n  var el = new jvm[this.classPrefix+'CircleElement'](config, style);\\n\\n  this.add(el, group);\\n  return el;\\n};\\n\\n/**\\n * Create circle and add it to the canvas.\\n * @param {Object} config Parameters of path to create.\\n * @param {Object} style Styles of the path to create.\\n * @param {HTMLElement} group Group to add circle into.\\n */\\njvm.AbstractCanvasElement.prototype.addImage = function(config, style, group){\\n  var el = new jvm[this.classPrefix+'ImageElement'](config, style);\\n\\n  this.add(el, group);\\n  return el;\\n};\\n\\n/**\\n * Create text and add it to the canvas.\\n * @param {Object} config Parameters of path to create.\\n * @param {Object} style Styles of the path to create.\\n * @param {HTMLElement} group Group to add circle into.\\n */\\njvm.AbstractCanvasElement.prototype.addText = function(config, style, group){\\n  var el = new jvm[this.classPrefix+'TextElement'](config, style);\\n\\n  this.add(el, group);\\n  return el;\\n};\\n\\n/**\\n * Add group to the another group inside of the canvas.\\n * @param {HTMLElement} group Group to add circle into or root group if not provided.\\n */\\njvm.AbstractCanvasElement.prototype.addGroup = function(parentGroup){\\n  var el = new jvm[this.classPrefix+'GroupElement']();\\n\\n  if (parentGroup) {\\n    parentGroup.node.appendChild(el.node);\\n  } else {\\n    this.node.appendChild(el.node);\\n  }\\n  el.canvas = this;\\n  return el;\\n};/**\\n * Abstract shape element. Shape element represents some visual vector or raster object.\\n * @constructor\\n * @param {String} name Tag name of the element.\\n * @param {Object} config Set of parameters to initialize element with.\\n * @param {Object} style Object with styles to set on element initialization.\\n */\\njvm.AbstractShapeElement = function(name, config, style){\\n  this.style = style || {};\\n  this.style.current = this.style.current || {};\\n  this.isHovered = false;\\n  this.isSelected = false;\\n  this.updateStyle();\\n};\\n\\n/**\\n * Set element's style.\\n * @param {Object|String} property Could be string to set only one property or object to set several style properties at once.\\n * @param {String} value Value to set in case only one property should be set.\\n */\\njvm.AbstractShapeElement.prototype.setStyle = function(property, value){\\n  var styles = {};\\n\\n  if (typeof property === 'object') {\\n    styles = property;\\n  } else {\\n    styles[property] = value;\\n  }\\n  jvm.$.extend(this.style.current, styles);\\n  this.updateStyle();\\n};\\n\\n\\njvm.AbstractShapeElement.prototype.updateStyle = function(){\\n  var attrs = {};\\n\\n  jvm.AbstractShapeElement.mergeStyles(attrs, this.style.initial);\\n  jvm.AbstractShapeElement.mergeStyles(attrs, this.style.current);\\n  if (this.isHovered) {\\n    jvm.AbstractShapeElement.mergeStyles(attrs, this.style.hover);\\n  }\\n  if (this.isSelected) {\\n    jvm.AbstractShapeElement.mergeStyles(attrs, this.style.selected);\\n    if (this.isHovered) {\\n      jvm.AbstractShapeElement.mergeStyles(attrs, this.style.selectedHover);\\n    }\\n  }\\n  this.set(attrs);\\n};\\n\\njvm.AbstractShapeElement.mergeStyles = function(styles, newStyles){\\n  var key;\\n\\n  newStyles = newStyles || {};\\n  for (key in newStyles) {\\n    if (newStyles[key] === null) {\\n      delete styles[key];\\n    } else {\\n      styles[key] = newStyles[key];\\n    }\\n  }\\n}/**\\n * Wrapper for SVG element.\\n * @constructor\\n * @extends jvm.AbstractElement\\n * @param {String} name Tag name of the element\\n * @param {Object} config Set of parameters to initialize element with\\n */\\n\\njvm.SVGElement = function(name, config){\\n  jvm.SVGElement.parentClass.apply(this, arguments);\\n}\\n\\njvm.inherits(jvm.SVGElement, jvm.AbstractElement);\\n\\njvm.SVGElement.svgns = \\\"http://www.w3.org/2000/svg\\\";\\n\\n/**\\n * Creates DOM element.\\n * @param {String} tagName Name of element\\n * @private\\n * @returns DOMElement\\n */\\njvm.SVGElement.prototype.createElement = function( tagName ){\\n  return document.createElementNS( jvm.SVGElement.svgns, tagName );\\n};\\n\\n/**\\n * Adds CSS class for underlying DOM element.\\n * @param {String} className Name of CSS class name\\n */\\njvm.SVGElement.prototype.addClass = function( className ){\\n  this.node.setAttribute('class', className);\\n};\\n\\n/**\\n * Returns constructor for element by name prefixed with 'VML'.\\n * @param {String} ctr Name of basic constructor to return\\n * proper implementation for.\\n * @returns Function\\n * @private\\n */\\njvm.SVGElement.prototype.getElementCtr = function( ctr ){\\n  return jvm['SVG'+ctr];\\n};\\n\\njvm.SVGElement.prototype.getBBox = function(){\\n  return this.node.getBBox();\\n};jvm.SVGGroupElement = function(){\\n  jvm.SVGGroupElement.parentClass.call(this, 'g');\\n}\\n\\njvm.inherits(jvm.SVGGroupElement, jvm.SVGElement);\\n\\njvm.SVGGroupElement.prototype.add = function(element){\\n  this.node.appendChild( element.node );\\n};jvm.SVGCanvasElement = function (container, width, height) {\\n  this.classPrefix = \\\"SVG\\\";\\n  jvm.SVGCanvasElement.parentClass.call(this, \\\"svg\\\");\\n\\n  this.defsElement = new jvm.SVGElement(\\\"defs\\\");\\n  this.node.appendChild(this.defsElement.node);\\n\\n  jvm.AbstractCanvasElement.apply(this, arguments);\\n};\\n\\njvm.inherits(jvm.SVGCanvasElement, jvm.SVGElement);\\njvm.mixin(jvm.SVGCanvasElement, jvm.AbstractCanvasElement);\\n\\njvm.SVGCanvasElement.prototype.setSize = function (width, height) {\\n  this.width = width;\\n  this.height = height;\\n  this.node.setAttribute(\\\"width\\\", width);\\n  this.node.setAttribute(\\\"height\\\", height);\\n};\\n\\njvm.SVGCanvasElement.prototype.applyTransformParams = function (\\n  scale,\\n  transX,\\n  transY,\\n) {\\n  this.scale = scale;\\n  this.transX = transX;\\n  this.transY = transY;\\n  if (!isNaN(transX) && !isNaN(transY) && !isNaN(scale)) {\\n    this.rootElement.node.setAttribute(\\n      \\\"transform\\\",\\n      \\\"scale(\\\" + scale + \\\") translate(\\\" + transX + \\\", \\\" + transY + \\\")\\\",\\n    );\\n  }\\n};\\njvm.SVGShapeElement = function(name, config, style){\\n  jvm.SVGShapeElement.parentClass.call(this, name, config);\\n  jvm.AbstractShapeElement.apply(this, arguments);\\n};\\n\\njvm.inherits(jvm.SVGShapeElement, jvm.SVGElement);\\njvm.mixin(jvm.SVGShapeElement, jvm.AbstractShapeElement);\\n\\njvm.SVGShapeElement.prototype.applyAttr = function(attr, value){\\n  var patternEl,\\n      imageEl,\\n      that = this;\\n\\n  if (attr === 'fill' && jvm.isImageUrl(value)) {\\n    if (!jvm.SVGShapeElement.images[value]) {\\n      jvm.whenImageLoaded(value).then(function(img){\\n        imageEl = new jvm.SVGElement('image');\\n        imageEl.node.setAttributeNS('http://www.w3.org/1999/xlink', 'href', value);\\n        imageEl.applyAttr('x', '0');\\n        imageEl.applyAttr('y', '0');\\n        imageEl.applyAttr('width', img[0].width);\\n        imageEl.applyAttr('height', img[0].height);\\n\\n        patternEl = new jvm.SVGElement('pattern');\\n        patternEl.applyAttr('id', 'image'+jvm.SVGShapeElement.imageCounter);\\n        patternEl.applyAttr('x', 0);\\n        patternEl.applyAttr('y', 0);\\n        patternEl.applyAttr('width', img[0].width / 2);\\n        patternEl.applyAttr('height', img[0].height / 2);\\n        patternEl.applyAttr('viewBox', '0 0 '+img[0].width+' '+img[0].height);\\n        patternEl.applyAttr('patternUnits', 'userSpaceOnUse');\\n        patternEl.node.appendChild( imageEl.node );\\n\\n        that.canvas.defsElement.node.appendChild( patternEl.node );\\n\\n        jvm.SVGShapeElement.images[value] = jvm.SVGShapeElement.imageCounter++;\\n\\n        that.applyAttr('fill', 'url(#image'+jvm.SVGShapeElement.images[value]+')');\\n      });\\n    } else {\\n      this.applyAttr('fill', 'url(#image'+jvm.SVGShapeElement.images[value]+')');\\n    }\\n  } else {\\n    jvm.SVGShapeElement.parentClass.prototype.applyAttr.apply(this, arguments);\\n  }\\n};\\n\\njvm.SVGShapeElement.imageCounter = 1;\\njvm.SVGShapeElement.images = {};jvm.SVGPathElement = function(config, style){\\n  jvm.SVGPathElement.parentClass.call(this, 'path', config, style);\\n  this.node.setAttribute('fill-rule', 'evenodd');\\n}\\n\\njvm.inherits(jvm.SVGPathElement, jvm.SVGShapeElement);jvm.SVGCircleElement = function(config, style){\\n  jvm.SVGCircleElement.parentClass.call(this, 'circle', config, style);\\n};\\n\\njvm.inherits(jvm.SVGCircleElement, jvm.SVGShapeElement);jvm.SVGImageElement = function(config, style){\\n  jvm.SVGImageElement.parentClass.call(this, 'image', config, style);\\n};\\n\\njvm.inherits(jvm.SVGImageElement, jvm.SVGShapeElement);\\n\\njvm.SVGImageElement.prototype.applyAttr = function(attr, value){\\n  var that = this,\\n      imageOffset,\\n      imageUrl;\\n\\n  if (attr == 'image') {\\n    if (typeof value == 'object') {\\n      imageUrl = value.url;\\n      this.offset = value.offset;\\n    } else {\\n      imageUrl = value;\\n      this.offset = [0, 0];\\n    }\\n\\n    jvm.whenImageLoaded(imageUrl).then(function(img){\\n      that.node.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imageUrl);\\n      that.width = img[0].width;\\n      that.height = img[0].height;\\n      that.applyAttr('width', that.width);\\n      that.applyAttr('height', that.height);\\n\\n      that.applyAttr('x', that.cx - that.width / 2 + that.offset[0]);\\n      that.applyAttr('y', that.cy - that.height / 2 + that.offset[1]);\\n\\n      jvm.$(that.node).trigger('imageloaded', [img]);\\n    });\\n  } else if(attr == 'cx') {\\n    this.cx = value;\\n    if (this.width) {\\n      this.applyAttr('x', value - this.width / 2 + this.offset[0]);\\n    }\\n  } else if(attr == 'cy') {\\n    this.cy = value;\\n    if (this.height) {\\n      this.applyAttr('y', value - this.height / 2 + this.offset[1]);\\n    }\\n  } else {\\n    jvm.SVGImageElement.parentClass.prototype.applyAttr.apply(this, arguments);\\n  }\\n};jvm.SVGTextElement = function(config, style){\\n  jvm.SVGTextElement.parentClass.call(this, 'text', config, style);\\n}\\n\\njvm.inherits(jvm.SVGTextElement, jvm.SVGShapeElement);\\n\\njvm.SVGTextElement.prototype.applyAttr = function(attr, value){\\n  if (attr === 'text') {\\n    this.node.textContent = value;\\n  } else {\\n    jvm.SVGTextElement.parentClass.prototype.applyAttr.apply(this, arguments);\\n  }\\n};/**\\n * Wrapper for VML element.\\n * @constructor\\n * @extends jvm.AbstractElement\\n * @param {String} name Tag name of the element\\n * @param {Object} config Set of parameters to initialize element with\\n */\\n\\njvm.VMLElement = function(name, config){\\n  if (!jvm.VMLElement.VMLInitialized) {\\n    jvm.VMLElement.initializeVML();\\n  }\\n\\n  jvm.VMLElement.parentClass.apply(this, arguments);\\n};\\n\\njvm.inherits(jvm.VMLElement, jvm.AbstractElement);\\n\\n/**\\n * Shows if VML was already initialized for the current document or not.\\n * @static\\n * @private\\n * @type {Boolean}\\n */\\njvm.VMLElement.VMLInitialized = false;\\n\\n/**\\n * Initializes VML handling before creating the first element\\n * (adds CSS class and creates namespace). Adds one of two forms\\n * of createElement method depending of support by browser.\\n * @static\\n * @private\\n */\\n\\n // The following method of VML handling is borrowed from the\\n // Raphael library by Dmitry Baranovsky.\\n\\njvm.VMLElement.initializeVML = function(){\\n  try {\\n    if (!document.namespaces.rvml) {\\n      document.namespaces.add(\\\"rvml\\\",\\\"urn:schemas-microsoft-com:vml\\\");\\n    }\\n    /**\\n     * Creates DOM element.\\n     * @param {String} tagName Name of element\\n     * @private\\n     * @returns DOMElement\\n     */\\n    jvm.VMLElement.prototype.createElement = function (tagName) {\\n      return document.createElement('<rvml:' + tagName + ' class=\\\"rvml\\\">');\\n    };\\n  } catch (e) {\\n    /**\\n     * @private\\n     */\\n    jvm.VMLElement.prototype.createElement = function (tagName) {\\n      return document.createElement('<' + tagName + ' xmlns=\\\"urn:schemas-microsoft.com:vml\\\" class=\\\"rvml\\\">');\\n    };\\n  }\\n  document.createStyleSheet().addRule(\\\".rvml\\\", \\\"behavior:url(#default#VML)\\\");\\n  jvm.VMLElement.VMLInitialized = true;\\n};\\n\\n/**\\n * Returns constructor for element by name prefixed with 'VML'.\\n * @param {String} ctr Name of basic constructor to return\\n * proper implementation for.\\n * @returns Function\\n * @private\\n */\\njvm.VMLElement.prototype.getElementCtr = function( ctr ){\\n  return jvm['VML'+ctr];\\n};\\n\\n/**\\n * Adds CSS class for underlying DOM element.\\n * @param {String} className Name of CSS class name\\n */\\njvm.VMLElement.prototype.addClass = function( className ){\\n  jvm.$(this.node).addClass(className);\\n};\\n\\n/**\\n * Applies attribute value to the underlying DOM element.\\n * @param {String} name Name of attribute\\n * @param {Number|String} config Value of attribute to apply\\n * @private\\n */\\njvm.VMLElement.prototype.applyAttr = function( attr, value ){\\n  this.node[attr] = value;\\n};\\n\\n/**\\n * Returns boundary box for the element.\\n * @returns {Object} Boundary box with numeric fields: x, y, width, height\\n * @override\\n */\\njvm.VMLElement.prototype.getBBox = function(){\\n  var node = jvm.$(this.node);\\n\\n  return {\\n    x: node.position().left / this.canvas.scale,\\n    y: node.position().top / this.canvas.scale,\\n    width: node.width() / this.canvas.scale,\\n    height: node.height() / this.canvas.scale\\n  };\\n};jvm.VMLGroupElement = function(){\\n  jvm.VMLGroupElement.parentClass.call(this, 'group');\\n\\n  this.node.style.left = '0px';\\n  this.node.style.top = '0px';\\n  this.node.coordorigin = \\\"0 0\\\";\\n};\\n\\njvm.inherits(jvm.VMLGroupElement, jvm.VMLElement);\\n\\njvm.VMLGroupElement.prototype.add = function(element){\\n  this.node.appendChild( element.node );\\n};jvm.VMLCanvasElement = function(container, width, height){\\n  this.classPrefix = 'VML';\\n  jvm.VMLCanvasElement.parentClass.call(this, 'group');\\n  jvm.AbstractCanvasElement.apply(this, arguments);\\n  this.node.style.position = 'absolute';\\n};\\n\\njvm.inherits(jvm.VMLCanvasElement, jvm.VMLElement);\\njvm.mixin(jvm.VMLCanvasElement, jvm.AbstractCanvasElement);\\n\\njvm.VMLCanvasElement.prototype.setSize = function(width, height){\\n  var paths,\\n      groups,\\n      i,\\n      l;\\n\\n  this.width = width;\\n  this.height = height;\\n  this.node.style.width = width + \\\"px\\\";\\n  this.node.style.height = height + \\\"px\\\";\\n  this.node.coordsize = width+' '+height;\\n  this.node.coordorigin = \\\"0 0\\\";\\n  if (this.rootElement) {\\n    paths = this.rootElement.node.getElementsByTagName('shape');\\n    for(i = 0, l = paths.length; i < l; i++) {\\n      paths[i].coordsize = width+' '+height;\\n      paths[i].style.width = width+'px';\\n      paths[i].style.height = height+'px';\\n    }\\n    groups = this.node.getElementsByTagName('group');\\n    for(i = 0, l = groups.length; i < l; i++) {\\n      groups[i].coordsize = width+' '+height;\\n      groups[i].style.width = width+'px';\\n      groups[i].style.height = height+'px';\\n    }\\n  }\\n};\\n\\njvm.VMLCanvasElement.prototype.applyTransformParams = function(scale, transX, transY) {\\n  this.scale = scale;\\n  this.transX = transX;\\n  this.transY = transY;\\n  this.rootElement.node.coordorigin = (this.width-transX-this.width/100)+','+(this.height-transY-this.height/100);\\n  this.rootElement.node.coordsize = this.width/scale+','+this.height/scale;\\n};jvm.VMLShapeElement = function(name, config){\\n  jvm.VMLShapeElement.parentClass.call(this, name, config);\\n\\n  this.fillElement = new jvm.VMLElement('fill');\\n  this.strokeElement = new jvm.VMLElement('stroke');\\n  this.node.appendChild(this.fillElement.node);\\n  this.node.appendChild(this.strokeElement.node);\\n  this.node.stroked = false;\\n\\n  jvm.AbstractShapeElement.apply(this, arguments);\\n};\\n\\njvm.inherits(jvm.VMLShapeElement, jvm.VMLElement);\\njvm.mixin(jvm.VMLShapeElement, jvm.AbstractShapeElement);\\n\\njvm.VMLShapeElement.prototype.applyAttr = function(attr, value){\\n  switch (attr) {\\n    case 'fill':\\n      this.node.fillcolor = value;\\n      break;\\n    case 'fill-opacity':\\n      this.fillElement.node.opacity = Math.round(value*100)+'%';\\n      break;\\n    case 'stroke':\\n      if (value === 'none') {\\n        this.node.stroked = false;\\n      } else {\\n        this.node.stroked = true;\\n      }\\n      this.node.strokecolor = value;\\n      break;\\n    case 'stroke-opacity':\\n      this.strokeElement.node.opacity = Math.round(value*100)+'%';\\n      break;\\n    case 'stroke-width':\\n      if (parseInt(value, 10) === 0) {\\n        this.node.stroked = false;\\n      } else {\\n        this.node.stroked = true;\\n      }\\n      this.node.strokeweight = value;\\n      break;\\n    case 'd':\\n      this.node.path = jvm.VMLPathElement.pathSvgToVml(value);\\n      break;\\n    default:\\n      jvm.VMLShapeElement.parentClass.prototype.applyAttr.apply(this, arguments);\\n  }\\n};jvm.VMLPathElement = function(config, style){\\n  var scale = new jvm.VMLElement('skew');\\n\\n  jvm.VMLPathElement.parentClass.call(this, 'shape', config, style);\\n\\n  this.node.coordorigin = \\\"0 0\\\";\\n\\n  scale.node.on = true;\\n  scale.node.matrix = '0.01,0,0,0.01,0,0';\\n  scale.node.offset = '0,0';\\n\\n  this.node.appendChild(scale.node);\\n};\\n\\njvm.inherits(jvm.VMLPathElement, jvm.VMLShapeElement);\\n\\njvm.VMLPathElement.prototype.applyAttr = function(attr, value){\\n  if (attr === 'd') {\\n    this.node.path = jvm.VMLPathElement.pathSvgToVml(value);\\n  } else {\\n    jvm.VMLShapeElement.prototype.applyAttr.call(this, attr, value);\\n  }\\n};\\n\\njvm.VMLPathElement.pathSvgToVml = function(path) {\\n  var cx = 0, cy = 0, ctrlx, ctrly;\\n\\n  path = path.replace(/(-?\\\\d+)e(-?\\\\d+)/g, '0');\\n  return path.replace(/([MmLlHhVvCcSs])\\\\s*((?:-?\\\\d*(?:\\\\.\\\\d+)?\\\\s*,?\\\\s*)+)/g, function(segment, letter, coords, index){\\n    coords = coords.replace(/(\\\\d)-/g, '$1,-')\\n            .replace(/^\\\\s+/g, '')\\n            .replace(/\\\\s+$/g, '')\\n            .replace(/\\\\s+/g, ',').split(',');\\n    if (!coords[0]) coords.shift();\\n    for (var i=0, l=coords.length; i<l; i++) {\\n      coords[i] = Math.round(100*coords[i]);\\n    }\\n    switch (letter) {\\n      case 'm':\\n        cx += coords[0];\\n        cy += coords[1];\\n        return 't'+coords.join(',');\\n      case 'M':\\n        cx = coords[0];\\n        cy = coords[1];\\n        return 'm'+coords.join(',');\\n      case 'l':\\n        cx += coords[0];\\n        cy += coords[1];\\n        return 'r'+coords.join(',');\\n      case 'L':\\n        cx = coords[0];\\n        cy = coords[1];\\n        return 'l'+coords.join(',');\\n      case 'h':\\n        cx += coords[0];\\n        return 'r'+coords[0]+',0';\\n      case 'H':\\n        cx = coords[0];\\n        return 'l'+cx+','+cy;\\n      case 'v':\\n        cy += coords[0];\\n        return 'r0,'+coords[0];\\n      case 'V':\\n        cy = coords[0];\\n        return 'l'+cx+','+cy;\\n      case 'c':\\n        ctrlx = cx + coords[coords.length-4];\\n        ctrly = cy + coords[coords.length-3];\\n        cx += coords[coords.length-2];\\n        cy += coords[coords.length-1];\\n        return 'v'+coords.join(',');\\n      case 'C':\\n        ctrlx = coords[coords.length-4];\\n        ctrly = coords[coords.length-3];\\n        cx = coords[coords.length-2];\\n        cy = coords[coords.length-1];\\n        return 'c'+coords.join(',');\\n      case 's':\\n        coords.unshift(cy-ctrly);\\n        coords.unshift(cx-ctrlx);\\n        ctrlx = cx + coords[coords.length-4];\\n        ctrly = cy + coords[coords.length-3];\\n        cx += coords[coords.length-2];\\n        cy += coords[coords.length-1];\\n        return 'v'+coords.join(',');\\n      case 'S':\\n        coords.unshift(cy+cy-ctrly);\\n        coords.unshift(cx+cx-ctrlx);\\n        ctrlx = coords[coords.length-4];\\n        ctrly = coords[coords.length-3];\\n        cx = coords[coords.length-2];\\n        cy = coords[coords.length-1];\\n        return 'c'+coords.join(',');\\n    }\\n    return '';\\n  }).replace(/z/g, 'e');\\n};jvm.VMLCircleElement = function(config, style){\\n  jvm.VMLCircleElement.parentClass.call(this, 'oval', config, style);\\n};\\n\\njvm.inherits(jvm.VMLCircleElement, jvm.VMLShapeElement);\\n\\njvm.VMLCircleElement.prototype.applyAttr = function(attr, value){\\n  switch (attr) {\\n    case 'r':\\n      this.node.style.width = value*2+'px';\\n      this.node.style.height = value*2+'px';\\n      this.applyAttr('cx', this.get('cx') || 0);\\n      this.applyAttr('cy', this.get('cy') || 0);\\n      break;\\n    case 'cx':\\n      if (!value) return;\\n      this.node.style.left = value - (this.get('r') || 0) + 'px';\\n      break;\\n    case 'cy':\\n      if (!value) return;\\n      this.node.style.top = value - (this.get('r') || 0) + 'px';\\n      break;\\n    default:\\n      jvm.VMLCircleElement.parentClass.prototype.applyAttr.call(this, attr, value);\\n  }\\n};/**\\n * Class for vector images manipulations.\\n * @constructor\\n * @param {DOMElement} container to place canvas to\\n * @param {Number} width\\n * @param {Number} height\\n */\\njvm.VectorCanvas = function(container, width, height) {\\n  this.mode = window.SVGAngle ? 'svg' : 'vml';\\n\\n  if (this.mode == 'svg') {\\n    this.impl = new jvm.SVGCanvasElement(container, width, height);\\n  } else {\\n    this.impl = new jvm.VMLCanvasElement(container, width, height);\\n  }\\n  this.impl.mode = this.mode;\\n  return this.impl;\\n};jvm.SimpleScale = function(scale){\\n  this.scale = scale;\\n};\\n\\njvm.SimpleScale.prototype.getValue = function(value){\\n  return value;\\n};jvm.OrdinalScale = function(scale){\\n  this.scale = scale;\\n};\\n\\njvm.OrdinalScale.prototype.getValue = function(value){\\n  return this.scale[value];\\n};\\n\\njvm.OrdinalScale.prototype.getTicks = function(){\\n  var ticks = [],\\n      key;\\n\\n  for (key in this.scale) {\\n    ticks.push({\\n      label: key,\\n      value: this.scale[key]\\n    });\\n  }\\n\\n  return ticks;\\n};jvm.NumericScale = function(scale, normalizeFunction, minValue, maxValue) {\\n  this.scale = [];\\n\\n  normalizeFunction = normalizeFunction || 'linear';\\n\\n  if (scale) this.setScale(scale);\\n  if (normalizeFunction) this.setNormalizeFunction(normalizeFunction);\\n  if (typeof minValue !== 'undefined' ) this.setMin(minValue);\\n  if (typeof maxValue !== 'undefined' ) this.setMax(maxValue);\\n};\\n\\njvm.NumericScale.prototype = {\\n  setMin: function(min) {\\n    this.clearMinValue = min;\\n    if (typeof this.normalize === 'function') {\\n      this.minValue = this.normalize(min);\\n    } else {\\n      this.minValue = min;\\n    }\\n  },\\n\\n  setMax: function(max) {\\n    this.clearMaxValue = max;\\n    if (typeof this.normalize === 'function') {\\n      this.maxValue = this.normalize(max);\\n    } else {\\n      this.maxValue = max;\\n    }\\n  },\\n\\n  setScale: function(scale) {\\n    var i;\\n\\n    this.scale = [];\\n    for (i = 0; i < scale.length; i++) {\\n      this.scale[i] = [scale[i]];\\n    }\\n  },\\n\\n  setNormalizeFunction: function(f) {\\n    if (f === 'polynomial') {\\n      this.normalize = function(value) {\\n        return Math.pow(value, 0.2);\\n      }\\n    } else if (f === 'linear') {\\n      delete this.normalize;\\n    } else {\\n      this.normalize = f;\\n    }\\n    this.setMin(this.clearMinValue);\\n    this.setMax(this.clearMaxValue);\\n  },\\n\\n  getValue: function(value) {\\n    var lengthes = [],\\n        fullLength = 0,\\n        l,\\n        i = 0,\\n        c;\\n\\n    if (typeof this.normalize === 'function') {\\n      value = this.normalize(value);\\n    }\\n    for (i = 0; i < this.scale.length-1; i++) {\\n      l = this.vectorLength(this.vectorSubtract(this.scale[i+1], this.scale[i]));\\n      lengthes.push(l);\\n      fullLength += l;\\n    }\\n\\n    c = (this.maxValue - this.minValue) / fullLength;\\n    for (i=0; i<lengthes.length; i++) {\\n      lengthes[i] *= c;\\n    }\\n\\n    i = 0;\\n    value -= this.minValue;\\n    while (value - lengthes[i] >= 0) {\\n      value -= lengthes[i];\\n      i++;\\n    }\\n\\n    if (i == this.scale.length - 1) {\\n      value = this.vectorToNum(this.scale[i])\\n    } else {\\n      value = (\\n        this.vectorToNum(\\n          this.vectorAdd(this.scale[i],\\n            this.vectorMult(\\n              this.vectorSubtract(this.scale[i+1], this.scale[i]),\\n              (value) / (lengthes[i])\\n            )\\n          )\\n        )\\n      );\\n    }\\n\\n    return value;\\n  },\\n\\n  vectorToNum: function(vector) {\\n    var num = 0,\\n        i;\\n\\n    for (i = 0; i < vector.length; i++) {\\n      num += Math.round(vector[i])*Math.pow(256, vector.length-i-1);\\n    }\\n    return num;\\n  },\\n\\n  vectorSubtract: function(vector1, vector2) {\\n    var vector = [],\\n        i;\\n\\n    for (i = 0; i < vector1.length; i++) {\\n      vector[i] = vector1[i] - vector2[i];\\n    }\\n    return vector;\\n  },\\n\\n  vectorAdd: function(vector1, vector2) {\\n    var vector = [],\\n        i;\\n\\n    for (i = 0; i < vector1.length; i++) {\\n      vector[i] = vector1[i] + vector2[i];\\n    }\\n    return vector;\\n  },\\n\\n  vectorMult: function(vector, num) {\\n    var result = [],\\n        i;\\n\\n    for (i = 0; i < vector.length; i++) {\\n      result[i] = vector[i] * num;\\n    }\\n    return result;\\n  },\\n\\n  vectorLength: function(vector) {\\n    var result = 0,\\n        i;\\n    for (i = 0; i < vector.length; i++) {\\n      result += vector[i] * vector[i];\\n    }\\n    return Math.sqrt(result);\\n  },\\n\\n  /* Derived from d3 implementation https://github.com/mbostock/d3/blob/master/src/scale/linear.js#L94 */\\n  getTicks: function(){\\n    var m = 5,\\n        extent = [this.clearMinValue, this.clearMaxValue],\\n        span = extent[1] - extent[0],\\n        step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),\\n        err = m / span * step,\\n        ticks = [],\\n        tick,\\n        v;\\n\\n    if (err <= .15) step *= 10;\\n    else if (err <= .35) step *= 5;\\n    else if (err <= .75) step *= 2;\\n\\n    extent[0] = Math.floor(extent[0] / step) * step;\\n    extent[1] = Math.ceil(extent[1] / step) * step;\\n\\n    tick = extent[0];\\n    while (tick <= extent[1]) {\\n      if (tick == extent[0]) {\\n        v = this.clearMinValue;\\n      } else if (tick == extent[1]) {\\n        v = this.clearMaxValue;\\n      } else {\\n        v = tick;\\n      }\\n      ticks.push({\\n        label: tick,\\n        value: this.getValue(v)\\n      });\\n      tick += step;\\n    }\\n\\n    return ticks;\\n  }\\n};\\njvm.ColorScale = function(colors, normalizeFunction, minValue, maxValue) {\\n  jvm.ColorScale.parentClass.apply(this, arguments);\\n}\\n\\njvm.inherits(jvm.ColorScale, jvm.NumericScale);\\n\\njvm.ColorScale.prototype.setScale = function(scale) {\\n  var i;\\n\\n  for (i = 0; i < scale.length; i++) {\\n    this.scale[i] = jvm.ColorScale.rgbToArray(scale[i]);\\n  }\\n};\\n\\njvm.ColorScale.prototype.getValue = function(value) {\\n  return jvm.ColorScale.numToRgb(jvm.ColorScale.parentClass.prototype.getValue.call(this, value));\\n};\\n\\njvm.ColorScale.arrayToRgb = function(ar) {\\n  var rgb = '#',\\n      d,\\n      i;\\n\\n  for (i = 0; i < ar.length; i++) {\\n    d = ar[i].toString(16);\\n    rgb += d.length == 1 ? '0'+d : d;\\n  }\\n  return rgb;\\n};\\n\\njvm.ColorScale.numToRgb = function(num) {\\n  num = num.toString(16);\\n\\n  while (num.length < 6) {\\n    num = '0' + num;\\n  }\\n\\n  return '#'+num;\\n};\\n\\njvm.ColorScale.rgbToArray = function(rgb) {\\n  rgb = rgb.substr(1);\\n  return [parseInt(rgb.substr(0, 2), 16), parseInt(rgb.substr(2, 2), 16), parseInt(rgb.substr(4, 2), 16)];\\n};/**\\n * Represents map legend.\\n * @constructor\\n * @param {Object} params Configuration parameters.\\n * @param {String} params.cssClass Additional CSS class to apply to legend element.\\n * @param {Boolean} params.vertical If <code>true</code> legend will be rendered as vertical.\\n * @param {String} params.title Legend title.\\n * @param {Function} params.labelRender Method to convert series values to legend labels.\\n */\\njvm.Legend = function(params) {\\n  this.params = params || {};\\n  this.map = this.params.map;\\n  this.series = this.params.series;\\n  this.body = jvm.$('<div/>');\\n  this.body.addClass('jvectormap-legend');\\n  if (this.params.cssClass) {\\n    this.body.addClass(this.params.cssClass);\\n  }\\n\\n  if (params.vertical) {\\n    this.map.legendCntVertical.append( this.body );\\n  } else {\\n    this.map.legendCntHorizontal.append( this.body );\\n  }\\n\\n  this.render();\\n}\\n\\njvm.Legend.prototype.render = function(){\\n  var ticks = this.series.scale.getTicks(),\\n      i,\\n      inner = jvm.$('<div/>').addClass('jvectormap-legend-inner'),\\n      tick,\\n      sample,\\n      label;\\n\\n  this.body.html('');\\n  if (this.params.title) {\\n    this.body.append(\\n      jvm.$('<div/>').addClass('jvectormap-legend-title').html(this.params.title)\\n    );\\n  }\\n  this.body.append(inner);\\n\\n  for (i = 0; i < ticks.length; i++) {\\n    tick = jvm.$('<div/>').addClass('jvectormap-legend-tick');\\n    sample = jvm.$('<div/>').addClass('jvectormap-legend-tick-sample');\\n\\n    switch (this.series.params.attribute) {\\n      case 'fill':\\n        if (jvm.isImageUrl(ticks[i].value)) {\\n          sample.css('background', 'url('+ticks[i].value+')');\\n        } else {\\n          sample.css('background', ticks[i].value);\\n        }\\n        break;\\n      case 'stroke':\\n        sample.css('background', ticks[i].value);\\n        break;\\n      case 'image':\\n        sample.css('background', 'url('+(typeof ticks[i].value === 'object' ? ticks[i].value.url : ticks[i].value)+') no-repeat center center');\\n        break;\\n      case 'r':\\n        jvm.$('<div/>').css({\\n          'border-radius': ticks[i].value,\\n          border: this.map.params.markerStyle.initial['stroke-width']+'px '+\\n                  this.map.params.markerStyle.initial['stroke']+' solid',\\n          width: ticks[i].value * 2 + 'px',\\n          height: ticks[i].value * 2 + 'px',\\n          background: this.map.params.markerStyle.initial['fill']\\n        }).appendTo(sample);\\n        break;\\n    }\\n    tick.append( sample );\\n    label = ticks[i].label;\\n    if (this.params.labelRender) {\\n      label = this.params.labelRender(label);\\n    }\\n    tick.append( jvm.$('<div>'+label+' </div>').addClass('jvectormap-legend-tick-text') );\\n    inner.append(tick);\\n  }\\n  inner.append( jvm.$('<div/>').css('clear', 'both') );\\n}/**\\n * Creates data series.\\n * @constructor\\n * @param {Object} params Parameters to initialize series with.\\n * @param {Array} params.values The data set to visualize.\\n * @param {String} params.attribute Numeric, color or image attribute to use for data visualization. This could be: <code>fill</code>, <code>stroke</code>, <code>fill-opacity</code>, <code>stroke-opacity</code> for markers and regions and <code>r</code> (radius) or <code>image</code> for markers only.\\n * @param {Array} params.scale Values used to map a dimension of data to a visual representation. The first value sets visualization for minimum value from the data set and the last value sets visualization for the maximum value. There also could be intermidiate values. Default value is <code>['#C8EEFF', '#0071A4']</code>.\\n * @param {Function|String} params.normalizeFunction The function used to map input values to the provided scale. This parameter could be provided as function or one of the strings: <code>'linear'</code> or <code>'polynomial'</code>, while <code>'linear'</code> is used by default. The function provided takes value from the data set as an input and returns corresponding value from the scale.\\n * @param {Number} params.min Minimum value of the data set. Could be calculated automatically if not provided.\\n * @param {Number} params.max Maximum value of the data set. Could be calculated automatically if not provided.\\n */\\njvm.DataSeries = function (params, elements, map) {\\n  var scaleConstructor;\\n\\n  params = params || {};\\n  params.attribute = params.attribute || \\\"fill\\\";\\n\\n  this.elements = elements;\\n  this.params = params;\\n  this.map = map;\\n\\n  if (params.attributes) {\\n    this.setAttributes(params.attributes);\\n  }\\n\\n  if (jvm.$.isArray(params.scale)) {\\n    scaleConstructor =\\n      params.attribute === \\\"fill\\\" || params.attribute === \\\"stroke\\\"\\n        ? jvm.ColorScale\\n        : jvm.NumericScale;\\n    this.scale = new scaleConstructor(\\n      params.scale,\\n      params.normalizeFunction,\\n      params.min,\\n      params.max,\\n    );\\n  } else if (params.scale) {\\n    this.scale = new jvm.OrdinalScale(params.scale);\\n  } else {\\n    this.scale = new jvm.SimpleScale(params.scale);\\n  }\\n\\n  this.values = params.values || {};\\n  this.setValues(this.values);\\n\\n  if (this.params.legend) {\\n    this.legend = new jvm.Legend(\\n      jvm.$.extend(\\n        {\\n          map: this.map,\\n          series: this,\\n        },\\n        this.params.legend,\\n      ),\\n    );\\n  }\\n};\\n\\njvm.DataSeries.prototype = {\\n  setAttributes: function (key, attr) {\\n    var attrs = key,\\n      code;\\n\\n    if (typeof key == \\\"string\\\") {\\n      if (this.elements[key]) {\\n        this.elements[key].setStyle(this.params.attribute, attr);\\n      }\\n    } else {\\n      for (code in attrs) {\\n        if (this.elements[code]) {\\n          this.elements[code].element.setStyle(\\n            this.params.attribute,\\n            attrs[code],\\n          );\\n        }\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Set values for the data set.\\n   * @param {Object} values Object which maps codes of regions or markers to values.\\n   */\\n  setValues: function (values) {\\n    var max = -Number.MAX_VALUE,\\n      min = Number.MAX_VALUE,\\n      val,\\n      cc,\\n      attrs = {};\\n\\n    if (\\n      !(this.scale instanceof jvm.OrdinalScale) &&\\n      !(this.scale instanceof jvm.SimpleScale)\\n    ) {\\n      // we have a color scale as an array\\n      if (\\n        typeof this.params.min === \\\"undefined\\\" ||\\n        typeof this.params.max === \\\"undefined\\\"\\n      ) {\\n        // min and/or max are not defined, so calculate them\\n        for (cc in values) {\\n          val = parseFloat(values[cc]);\\n          if (val > max) max = val;\\n          if (val < min) min = val;\\n        }\\n      }\\n\\n      if (typeof this.params.min === \\\"undefined\\\") {\\n        this.scale.setMin(min);\\n        this.params.min = min;\\n      } else {\\n        this.scale.setMin(this.params.min);\\n      }\\n\\n      if (typeof this.params.max === \\\"undefined\\\") {\\n        this.scale.setMax(max);\\n        this.params.max = max;\\n      } else {\\n        this.scale.setMax(this.params.max);\\n      }\\n\\n      for (cc in values) {\\n        if (cc != \\\"indexOf\\\") {\\n          val = parseFloat(values[cc]);\\n          if (!isNaN(val)) {\\n            attrs[cc] = this.scale.getValue(val);\\n          } else {\\n            attrs[cc] =\\n              this.elements[cc].element.style.initial[this.params.attribute];\\n          }\\n        }\\n      }\\n    } else {\\n      for (cc in values) {\\n        if (values[cc]) {\\n          attrs[cc] = this.scale.getValue(values[cc]);\\n        } else {\\n          attrs[cc] =\\n            this.elements[cc].element.style.initial[this.params.attribute];\\n        }\\n      }\\n    }\\n\\n    this.setAttributes(attrs);\\n    jvm.$.extend(this.values, values);\\n  },\\n\\n  clear: function () {\\n    var key,\\n      attrs = {};\\n\\n    for (key in this.values) {\\n      if (this.elements[key]) {\\n        attrs[key] =\\n          this.elements[key].element.shape.style.initial[this.params.attribute];\\n      }\\n    }\\n    this.setAttributes(attrs);\\n    this.values = {};\\n  },\\n\\n  clearAndSet: function (values) {\\n    this.clear();\\n    this.setValues(values);\\n  },\\n\\n  /**\\n   * Set scale of the data series.\\n   * @param {Array} scale Values representing scale.\\n   */\\n  setScale: function (scale) {\\n    this.scale.setScale(scale);\\n    if (this.values) {\\n      this.setValues(this.values);\\n    }\\n  },\\n\\n  /**\\n   * Set normalize function of the data series.\\n   * @param {Function|String} f Normalize function.\\n   */\\n  setNormalizeFunction: function (f) {\\n    this.scale.setNormalizeFunction(f);\\n    if (this.values) {\\n      this.setValues(this.values);\\n    }\\n  },\\n};\\n/**\\n * Contains methods for transforming point on sphere to\\n * Cartesian coordinates using various projections.\\n * @class\\n */\\njvm.Proj = {\\n  degRad: 180 / Math.PI,\\n  radDeg: Math.PI / 180,\\n  radius: 6381372,\\n\\n  sgn: function(n){\\n    if (n > 0) {\\n      return 1;\\n    } else if (n < 0) {\\n      return -1;\\n    } else {\\n      return n;\\n    }\\n  },\\n\\n  /**\\n   * Converts point on sphere to the Cartesian coordinates using Miller projection\\n   * @param {Number} lat Latitude in degrees\\n   * @param {Number} lng Longitude in degrees\\n   * @param {Number} c Central meridian in degrees\\n   */\\n  mill: function(lat, lng, c){\\n    return {\\n      x: this.radius * (lng - c) * this.radDeg,\\n      y: - this.radius * Math.log(Math.tan((45 + 0.4 * lat) * this.radDeg)) / 0.8\\n    };\\n  },\\n\\n  /**\\n   * Inverse function of mill()\\n   * Converts Cartesian coordinates to point on sphere using Miller projection\\n   * @param {Number} x X of point in Cartesian system as integer\\n   * @param {Number} y Y of point in Cartesian system as integer\\n   * @param {Number} c Central meridian in degrees\\n   */\\n  mill_inv: function(x, y, c){\\n    return {\\n      lat: (2.5 * Math.atan(Math.exp(0.8 * y / this.radius)) - 5 * Math.PI / 8) * this.degRad,\\n      lng: (c * this.radDeg + x / this.radius) * this.degRad\\n    };\\n  },\\n\\n  /**\\n   * Converts point on sphere to the Cartesian coordinates using Mercator projection\\n   * @param {Number} lat Latitude in degrees\\n   * @param {Number} lng Longitude in degrees\\n   * @param {Number} c Central meridian in degrees\\n   */\\n  merc: function(lat, lng, c){\\n    return {\\n      x: this.radius * (lng - c) * this.radDeg,\\n      y: - this.radius * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))\\n    };\\n  },\\n\\n  /**\\n   * Inverse function of merc()\\n   * Converts Cartesian coordinates to point on sphere using Mercator projection\\n   * @param {Number} x X of point in Cartesian system as integer\\n   * @param {Number} y Y of point in Cartesian system as integer\\n   * @param {Number} c Central meridian in degrees\\n   */\\n  merc_inv: function(x, y, c){\\n    return {\\n      lat: (2 * Math.atan(Math.exp(y / this.radius)) - Math.PI / 2) * this.degRad,\\n      lng: (c * this.radDeg + x / this.radius) * this.degRad\\n    };\\n  },\\n\\n  /**\\n   * Converts point on sphere to the Cartesian coordinates using Albers Equal-Area Conic\\n   * projection\\n   * @see <a href=\\\"http://mathworld.wolfram.com/AlbersEqual-AreaConicProjection.html\\\">Albers Equal-Area Conic projection</a>\\n   * @param {Number} lat Latitude in degrees\\n   * @param {Number} lng Longitude in degrees\\n   * @param {Number} c Central meridian in degrees\\n   */\\n  aea: function(lat, lng, c){\\n    var fi0 = 0,\\n        lambda0 = c * this.radDeg,\\n        fi1 = 29.5 * this.radDeg,\\n        fi2 = 45.5 * this.radDeg,\\n        fi = lat * this.radDeg,\\n        lambda = lng * this.radDeg,\\n        n = (Math.sin(fi1)+Math.sin(fi2)) / 2,\\n        C = Math.cos(fi1)*Math.cos(fi1)+2*n*Math.sin(fi1),\\n        theta = n*(lambda-lambda0),\\n        ro = Math.sqrt(C-2*n*Math.sin(fi))/n,\\n        ro0 = Math.sqrt(C-2*n*Math.sin(fi0))/n;\\n\\n    return {\\n      x: ro * Math.sin(theta) * this.radius,\\n      y: - (ro0 - ro * Math.cos(theta)) * this.radius\\n    };\\n  },\\n\\n  /**\\n   * Converts Cartesian coordinates to the point on sphere using Albers Equal-Area Conic\\n   * projection\\n   * @see <a href=\\\"http://mathworld.wolfram.com/AlbersEqual-AreaConicProjection.html\\\">Albers Equal-Area Conic projection</a>\\n   * @param {Number} x X of point in Cartesian system as integer\\n   * @param {Number} y Y of point in Cartesian system as integer\\n   * @param {Number} c Central meridian in degrees\\n   */\\n  aea_inv: function(xCoord, yCoord, c){\\n    var x = xCoord / this.radius,\\n        y = yCoord / this.radius,\\n        fi0 = 0,\\n        lambda0 = c * this.radDeg,\\n        fi1 = 29.5 * this.radDeg,\\n        fi2 = 45.5 * this.radDeg,\\n        n = (Math.sin(fi1)+Math.sin(fi2)) / 2,\\n        C = Math.cos(fi1)*Math.cos(fi1)+2*n*Math.sin(fi1),\\n        ro0 = Math.sqrt(C-2*n*Math.sin(fi0))/n,\\n        ro = Math.sqrt(x*x+(ro0-y)*(ro0-y)),\\n        theta = Math.atan( x / (ro0 - y) );\\n\\n    return {\\n      lat: (Math.asin((C - ro * ro * n * n) / (2 * n))) * this.degRad,\\n      lng: (lambda0 + theta / n) * this.degRad\\n    };\\n  },\\n\\n  /**\\n   * Converts point on sphere to the Cartesian coordinates using Lambert conformal\\n   * conic projection\\n   * @see <a href=\\\"http://mathworld.wolfram.com/LambertConformalConicProjection.html\\\">Lambert Conformal Conic Projection</a>\\n   * @param {Number} lat Latitude in degrees\\n   * @param {Number} lng Longitude in degrees\\n   * @param {Number} c Central meridian in degrees\\n   */\\n  lcc: function(lat, lng, c){\\n    var fi0 = 0,\\n        lambda0 = c * this.radDeg,\\n        lambda = lng * this.radDeg,\\n        fi1 = 33 * this.radDeg,\\n        fi2 = 45 * this.radDeg,\\n        fi = lat * this.radDeg,\\n        n = Math.log( Math.cos(fi1) * (1 / Math.cos(fi2)) ) / Math.log( Math.tan( Math.PI / 4 + fi2 / 2) * (1 / Math.tan( Math.PI / 4 + fi1 / 2) ) ),\\n        F = ( Math.cos(fi1) * Math.pow( Math.tan( Math.PI / 4 + fi1 / 2 ), n ) ) / n,\\n        ro = F * Math.pow( 1 / Math.tan( Math.PI / 4 + fi / 2 ), n ),\\n        ro0 = F * Math.pow( 1 / Math.tan( Math.PI / 4 + fi0 / 2 ), n );\\n\\n    return {\\n      x: ro * Math.sin( n * (lambda - lambda0) ) * this.radius,\\n      y: - (ro0 - ro * Math.cos( n * (lambda - lambda0) ) ) * this.radius\\n    };\\n  },\\n\\n  /**\\n   * Converts Cartesian coordinates to the point on sphere using Lambert conformal conic\\n   * projection\\n   * @see <a href=\\\"http://mathworld.wolfram.com/LambertConformalConicProjection.html\\\">Lambert Conformal Conic Projection</a>\\n   * @param {Number} x X of point in Cartesian system as integer\\n   * @param {Number} y Y of point in Cartesian system as integer\\n   * @param {Number} c Central meridian in degrees\\n   */\\n  lcc_inv: function(xCoord, yCoord, c){\\n    var x = xCoord / this.radius,\\n        y = yCoord / this.radius,\\n        fi0 = 0,\\n        lambda0 = c * this.radDeg,\\n        fi1 = 33 * this.radDeg,\\n        fi2 = 45 * this.radDeg,\\n        n = Math.log( Math.cos(fi1) * (1 / Math.cos(fi2)) ) / Math.log( Math.tan( Math.PI / 4 + fi2 / 2) * (1 / Math.tan( Math.PI / 4 + fi1 / 2) ) ),\\n        F = ( Math.cos(fi1) * Math.pow( Math.tan( Math.PI / 4 + fi1 / 2 ), n ) ) / n,\\n        ro0 = F * Math.pow( 1 / Math.tan( Math.PI / 4 + fi0 / 2 ), n ),\\n        ro = this.sgn(n) * Math.sqrt(x*x+(ro0-y)*(ro0-y)),\\n        theta = Math.atan( x / (ro0 - y) );\\n\\n    return {\\n      lat: (2 * Math.atan(Math.pow(F/ro, 1/n)) - Math.PI / 2) * this.degRad,\\n      lng: (lambda0 + theta / n) * this.degRad\\n    };\\n  }\\n};jvm.MapObject = function(config){};\\n\\njvm.MapObject.prototype.getLabelText = function(key){\\n  var text;\\n\\n  if (this.config.label) {\\n    if (typeof this.config.label.render === 'function') {\\n      text = this.config.label.render(key);\\n    } else {\\n      text = key;\\n    }\\n  } else {\\n    text = null;\\n  }\\n  return text;\\n}\\n\\njvm.MapObject.prototype.getLabelOffsets = function(key){\\n  var offsets;\\n\\n  if (this.config.label) {\\n    if (typeof this.config.label.offsets === 'function') {\\n      offsets = this.config.label.offsets(key);\\n    } else if (typeof this.config.label.offsets === 'object') {\\n      offsets = this.config.label.offsets[key];\\n    }\\n  }\\n  return offsets || [0, 0];\\n}\\n\\n/**\\n * Set hovered state to the element. Hovered state means mouse cursor is over element. Styles will be updates respectively.\\n * @param {Boolean} isHovered <code>true</code> to make element hovered, <code>false</code> otherwise.\\n */\\njvm.MapObject.prototype.setHovered = function(isHovered){\\n  if (this.isHovered !== isHovered) {\\n    this.isHovered = isHovered;\\n    this.shape.isHovered = isHovered;\\n    this.shape.updateStyle();\\n    if (this.label) {\\n      this.label.isHovered = isHovered;\\n      this.label.updateStyle();\\n    }\\n  }\\n};\\n\\n/**\\n * Set selected state to the element. Styles will be updates respectively.\\n * @param {Boolean} isSelected <code>true</code> to make element selected, <code>false</code> otherwise.\\n */\\njvm.MapObject.prototype.setSelected = function(isSelected){\\n  if (this.isSelected !== isSelected) {\\n    this.isSelected = isSelected;\\n    this.shape.isSelected = isSelected;\\n    this.shape.updateStyle();\\n    if (this.label) {\\n      this.label.isSelected = isSelected;\\n      this.label.updateStyle();\\n    }\\n    jvm.$(this.shape).trigger('selected', [isSelected]);\\n  }\\n};\\n\\njvm.MapObject.prototype.setStyle = function(){\\n\tthis.shape.setStyle.apply(this.shape, arguments);\\n};\\n\\njvm.MapObject.prototype.remove = function(){\\n  this.shape.remove();\\n  if (this.label) {\\n    this.label.remove();\\n  }\\n};jvm.Region = function(config){\\n  var bbox,\\n      text,\\n      offsets,\\n      labelDx,\\n      labelDy;\\n\\n  this.config = config;\\n  this.map = this.config.map;\\n\\n  this.shape = config.canvas.addPath({\\n    d: config.path,\\n    'data-code': config.code\\n  }, config.style, config.canvas.rootElement);\\n  this.shape.addClass('jvectormap-region jvectormap-element');\\n\\n  bbox = this.shape.getBBox();\\n\\n  text = this.getLabelText(config.code);\\n  if (this.config.label && text) {\\n    offsets = this.getLabelOffsets(config.code);\\n    this.labelX = bbox.x + bbox.width / 2 + offsets[0];\\n    this.labelY = bbox.y + bbox.height / 2 + offsets[1];\\n    this.label = config.canvas.addText({\\n      text: text,\\n      'text-anchor': 'middle',\\n      'alignment-baseline': 'central',\\n      x: this.labelX,\\n      y: this.labelY,\\n      'data-code': config.code\\n    }, config.labelStyle, config.labelsGroup);\\n    this.label.addClass('jvectormap-region jvectormap-element');\\n  }\\n};\\n\\njvm.inherits(jvm.Region, jvm.MapObject);\\n\\njvm.Region.prototype.updateLabelPosition = function(){\\n  if (this.label) {\\n    this.label.set({\\n      x: this.labelX * this.map.scale + this.map.transX * this.map.scale,\\n      y: this.labelY * this.map.scale + this.map.transY * this.map.scale\\n    });\\n  }\\n};jvm.Marker = function(config){\\n  var text,\\n      offsets;\\n\\n  this.config = config;\\n  this.map = this.config.map;\\n\\n  this.isImage = !!this.config.style.initial.image;\\n  this.createShape();\\n\\n  text = this.getLabelText(config.index);\\n  if (this.config.label && text) {\\n    this.offsets = this.getLabelOffsets(config.index);\\n    this.labelX = config.cx / this.map.scale - this.map.transX;\\n    this.labelY = config.cy / this.map.scale - this.map.transY;\\n    this.label = config.canvas.addText({\\n      text: text,\\n      'data-index': config.index,\\n      dy: \\\"0.6ex\\\",\\n      x: this.labelX,\\n      y: this.labelY\\n    }, config.labelStyle, config.labelsGroup);\\n\\n    this.label.addClass('jvectormap-marker jvectormap-element');\\n  }\\n};\\n\\njvm.inherits(jvm.Marker, jvm.MapObject);\\n\\njvm.Marker.prototype.createShape = function(){\\n  var that = this;\\n\\n  if (this.shape) {\\n    this.shape.remove();\\n  }\\n  this.shape = this.config.canvas[this.isImage ? 'addImage' : 'addCircle']({\\n    \\\"data-index\\\": this.config.index,\\n    cx: this.config.cx,\\n    cy: this.config.cy\\n  }, this.config.style, this.config.group);\\n\\n  this.shape.addClass('jvectormap-marker jvectormap-element');\\n\\n  if (this.isImage) {\\n    jvm.$(this.shape.node).on('imageloaded', function(){\\n      that.updateLabelPosition();\\n    });\\n  }\\n};\\n\\njvm.Marker.prototype.updateLabelPosition = function(){\\n  if (this.label) {\\n    this.label.set({\\n      x: this.labelX * this.map.scale + this.offsets[0] +\\n         this.map.transX * this.map.scale + 5 + (this.isImage ? (this.shape.width || 0) / 2 : this.shape.properties.r),\\n      y: this.labelY * this.map.scale + this.map.transY * this.map.scale + this.offsets[1]\\n    });\\n  }\\n};\\n\\njvm.Marker.prototype.setStyle = function(property, value){\\n  var isImage;\\n\\n  jvm.Marker.parentClass.prototype.setStyle.apply(this, arguments);\\n\\n  if (property === 'r') {\\n    this.updateLabelPosition();\\n  }\\n\\n  isImage = !!this.shape.get('image');\\n  if (isImage != this.isImage) {\\n    this.isImage = isImage;\\n    this.config.style = jvm.$.extend(true, {}, this.shape.style);\\n    this.createShape();\\n  }\\n};/**\\n * Creates map, draws paths, binds events.\\n * @constructor\\n * @param {Object} params Parameters to initialize map with.\\n * @param {String} params.map Name of the map in the format <code>territory_proj_lang</code> where <code>territory</code> is a unique code or name of the territory which the map represents (ISO 3166 standard is used where possible), <code>proj</code> is a name of projection used to generate representation of the map on the plane (projections are named according to the conventions of proj4 utility) and <code>lang</code> is a code of the language, used for the names of regions.\\n * @param {String} params.backgroundColor Background color of the map in CSS format.\\n * @param {Boolean} params.zoomOnScroll When set to true map could be zoomed using mouse scroll. Default value is <code>true</code>.\\n * @param {Number} params.zoomOnScrollSpeed Mouse scroll speed. Number from 1 to 10. Default value is <code>3</code>.\\n * @param {Boolean} params.panOnDrag When set to true, the map pans when being dragged. Default value is <code>true</code>.\\n * @param {Number} params.zoomMax Indicates the maximum zoom ratio which could be reached zooming the map. Default value is <code>8</code>.\\n * @param {Number} params.zoomMin Indicates the minimum zoom ratio which could be reached zooming the map. Default value is <code>1</code>.\\n * @param {Number} params.zoomStep Indicates the multiplier used to zoom map with +/- buttons. Default value is <code>1.6</code>.\\n * @param {Boolean} params.zoomAnimate Indicates whether or not to animate changing of map zoom with zoom buttons.\\n * @param {Boolean} params.regionsSelectable When set to true regions of the map could be selected. Default value is <code>false</code>.\\n * @param {Boolean} params.regionsSelectableOne Allow only one region to be selected at the moment. Default value is <code>false</code>.\\n * @param {Boolean} params.markersSelectable When set to true markers on the map could be selected. Default value is <code>false</code>.\\n * @param {Boolean} params.markersSelectableOne Allow only one marker to be selected at the moment. Default value is <code>false</code>.\\n * @param {Object} params.regionStyle Set the styles for the map's regions. Each region or marker has four states: <code>initial</code> (default state), <code>hover</code> (when the mouse cursor is over the region or marker), <code>selected</code> (when region or marker is selected), <code>selectedHover</code> (when the mouse cursor is over the region or marker and it's selected simultaneously). Styles could be set for each of this states. Default value for that parameter is:\\n<pre>{\\n  initial: {\\n    fill: 'white',\\n    \\\"fill-opacity\\\": 1,\\n    stroke: 'none',\\n    \\\"stroke-width\\\": 0,\\n    \\\"stroke-opacity\\\": 1\\n  },\\n  hover: {\\n    \\\"fill-opacity\\\": 0.8,\\n    cursor: 'pointer'\\n  },\\n  selected: {\\n    fill: 'yellow'\\n  },\\n  selectedHover: {\\n  }\\n}</pre>\\n* @param {Object} params.regionLabelStyle Set the styles for the regions' labels. Each region or marker has four states: <code>initial</code> (default state), <code>hover</code> (when the mouse cursor is over the region or marker), <code>selected</code> (when region or marker is selected), <code>selectedHover</code> (when the mouse cursor is over the region or marker and it's selected simultaneously). Styles could be set for each of this states. Default value for that parameter is:\\n<pre>{\\n  initial: {\\n    'font-family': 'Verdana',\\n    'font-size': '12',\\n    'font-weight': 'bold',\\n    cursor: 'default',\\n    fill: 'black'\\n  },\\n  hover: {\\n    cursor: 'pointer'\\n  }\\n}</pre>\\n * @param {Object} params.markerStyle Set the styles for the map's markers. Any parameter suitable for <code>regionStyle</code> could be used as well as numeric parameter <code>r</code> to set the marker's radius. Default value for that parameter is:\\n<pre>{\\n  initial: {\\n    fill: 'grey',\\n    stroke: '#505050',\\n    \\\"fill-opacity\\\": 1,\\n    \\\"stroke-width\\\": 1,\\n    \\\"stroke-opacity\\\": 1,\\n    r: 5\\n  },\\n  hover: {\\n    stroke: 'black',\\n    \\\"stroke-width\\\": 2,\\n    cursor: 'pointer'\\n  },\\n  selected: {\\n    fill: 'blue'\\n  },\\n  selectedHover: {\\n  }\\n}</pre>\\nYou can also use <code>image</code> style attribute for markers. By default marker images are centered with the target point on map. To supply a custom offset please use the following format:\\n<pre>{\\n  url: 'image/url',\\n  offset: [-10, 5]\\n}</pre>\\n * @param {Object} params.markerLabelStyle Set the styles for the markers' labels. Default value for that parameter is:\\n<pre>{\\n  initial: {\\n    'font-family': 'Verdana',\\n    'font-size': '12',\\n    'font-weight': 'bold',\\n    cursor: 'default',\\n    fill: 'black'\\n  },\\n  hover: {\\n    cursor: 'pointer'\\n  }\\n}</pre>\\n * @param {Object|Array} params.markers Set of markers to add to the map during initialization. In case of array is provided, codes of markers will be set as string representations of array indexes. Each marker is represented by <code>latLng</code> (array of two numeric values), <code>name</code> (string which will be show on marker's tip) and any marker styles.\\n * @param {Object} params.series Object with two keys: <code>markers</code> and <code>regions</code>. Each of which is an array of series configs to be applied to the respective map elements. See <a href=\\\"jvm.DataSeries.html\\\">DataSeries</a> description for a list of parameters available.\\n * @param {Object|String} params.focusOn This parameter sets the initial position and scale of the map viewport. See <code>setFocus</code> docuemntation for possible parameters.\\n * @param {Object} params.labels Defines parameters for rendering static labels. Object could contain two keys: <code>regions</code> and <code>markers</code>. Each key value defines configuration object with the following possible options:\\n<ul>\\n  <li><code>render {Function}</code> - defines method for converting region code or marker index to actual label value.</li>\\n  <li><code>offsets {Object|Function}</code> - provides method or object which could be used to define label offset by region code or marker index.</li>\\n</ul>\\n<b>Plase note: static labels feature is not supported in Internet Explorer 8 and below.</b>\\n * @param {Array|Object|String} params.selectedRegions Set initially selected regions.\\n * @param {Array|Object|String} params.selectedMarkers Set initially selected markers.\\n * @param {Function} params.onRegionTipShow <code>(Event e, Object tip, String code)</code> Will be called right before the region tip is going to be shown.\\n * @param {Function} params.onRegionOver <code>(Event e, String code)</code> Will be called on region mouse over event.\\n * @param {Function} params.onRegionOut <code>(Event e, String code)</code> Will be called on region mouse out event.\\n * @param {Function} params.onRegionClick <code>(Event e, String code)</code> Will be called on region click event.\\n * @param {Function} params.onRegionSelected <code>(Event e, String code, Boolean isSelected, Array selectedRegions)</code> Will be called when region is (de)selected. <code>isSelected</code> parameter of the callback indicates whether region is selected or not. <code>selectedRegions</code> contains codes of all currently selected regions.\\n * @param {Function} params.onMarkerTipShow <code>(Event e, Object tip, String code)</code> Will be called right before the marker tip is going to be shown.\\n * @param {Function} params.onMarkerOver <code>(Event e, String code)</code> Will be called on marker mouse over event.\\n * @param {Function} params.onMarkerOut <code>(Event e, String code)</code> Will be called on marker mouse out event.\\n * @param {Function} params.onMarkerClick <code>(Event e, String code)</code> Will be called on marker click event.\\n * @param {Function} params.onMarkerSelected <code>(Event e, String code, Boolean isSelected, Array selectedMarkers)</code> Will be called when marker is (de)selected. <code>isSelected</code> parameter of the callback indicates whether marker is selected or not. <code>selectedMarkers</code> contains codes of all currently selected markers.\\n * @param {Function} params.onViewportChange <code>(Event e, Number scale)</code> Triggered when the map's viewport is changed (map was panned or zoomed).\\n */\\njvm.Map = function (params) {\\n  var map = this,\\n    e;\\n\\n  this.params = jvm.$.extend(true, {}, jvm.Map.defaultParams, params);\\n\\n  if (!jvm.Map.maps[this.params.map]) {\\n    throw new Error(\\n      \\\"Attempt to use map which was not loaded: \\\" + this.params.map,\\n    );\\n  }\\n\\n  this.mapData = jvm.Map.maps[this.params.map];\\n  this.markers = {};\\n  this.regions = {};\\n  this.regionsColors = {};\\n  this.regionsData = {};\\n\\n  this.container = jvm.$(\\\"<div>\\\").addClass(\\\"jvectormap-container\\\");\\n  if (this.params.container) {\\n    this.params.container.append(this.container);\\n  }\\n  this.container.data(\\\"mapObject\\\", this);\\n\\n  this.defaultWidth = this.mapData.width;\\n  this.defaultHeight = this.mapData.height;\\n\\n  this.setBackgroundColor(this.params.backgroundColor);\\n\\n  this.onResize = function () {\\n    map.updateSize();\\n  };\\n  jvm.$(window).resize(this.onResize);\\n\\n  for (e in jvm.Map.apiEvents) {\\n    if (this.params[e]) {\\n      this.container.bind(jvm.Map.apiEvents[e] + \\\".jvectormap\\\", this.params[e]);\\n    }\\n  }\\n\\n  this.canvas = new jvm.VectorCanvas(\\n    this.container[0],\\n    this.width,\\n    this.height,\\n  );\\n\\n  if (this.params.bindTouchEvents) {\\n    if (\\n      \\\"ontouchstart\\\" in window ||\\n      (window.DocumentTouch && document instanceof DocumentTouch)\\n    ) {\\n      this.bindContainerTouchEvents();\\n    } else if (window.MSGesture) {\\n      this.bindContainerPointerEvents();\\n    }\\n  }\\n  this.bindContainerEvents();\\n  this.bindElementEvents();\\n  this.createTip();\\n  if (this.params.zoomButtons) {\\n    this.bindZoomButtons();\\n  }\\n\\n  this.createRegions();\\n  this.createMarkers(this.params.markers || {});\\n\\n  this.updateSize();\\n\\n  if (this.params.focusOn) {\\n    if (typeof this.params.focusOn === \\\"string\\\") {\\n      this.params.focusOn = { region: this.params.focusOn };\\n    } else if (jvm.$.isArray(this.params.focusOn)) {\\n      this.params.focusOn = { regions: this.params.focusOn };\\n    }\\n    this.setFocus(this.params.focusOn);\\n  }\\n\\n  if (this.params.selectedRegions) {\\n    this.setSelectedRegions(this.params.selectedRegions);\\n  }\\n  if (this.params.selectedMarkers) {\\n    this.setSelectedMarkers(this.params.selectedMarkers);\\n  }\\n\\n  this.legendCntHorizontal = jvm\\n    .$(\\\"<div/>\\\")\\n    .addClass(\\\"jvectormap-legend-cnt jvectormap-legend-cnt-h\\\");\\n  this.legendCntVertical = jvm\\n    .$(\\\"<div/>\\\")\\n    .addClass(\\\"jvectormap-legend-cnt jvectormap-legend-cnt-v\\\");\\n  this.container.append(this.legendCntHorizontal);\\n  this.container.append(this.legendCntVertical);\\n\\n  if (this.params.series) {\\n    this.createSeries();\\n  }\\n};\\n\\njvm.Map.prototype = {\\n  transX: 0,\\n  transY: 0,\\n  scale: 1,\\n  baseTransX: 0,\\n  baseTransY: 0,\\n  baseScale: 1,\\n\\n  width: 0,\\n  height: 0,\\n\\n  /**\\n   * Set background color of the map.\\n   * @param {String} backgroundColor Background color in CSS format.\\n   */\\n  setBackgroundColor: function (backgroundColor) {\\n    this.container.css(\\\"background-color\\\", backgroundColor);\\n  },\\n\\n  resize: function () {\\n    var curBaseScale = this.baseScale;\\n    if (this.width / this.height > this.defaultWidth / this.defaultHeight) {\\n      this.baseScale = this.height / this.defaultHeight;\\n      this.baseTransX =\\n        Math.abs(this.width - this.defaultWidth * this.baseScale) /\\n        (2 * this.baseScale);\\n    } else {\\n      this.baseScale = this.width / this.defaultWidth;\\n      this.baseTransY =\\n        Math.abs(this.height - this.defaultHeight * this.baseScale) /\\n        (2 * this.baseScale);\\n    }\\n    this.scale *= this.baseScale / curBaseScale;\\n    this.transX *= this.baseScale / curBaseScale;\\n    this.transY *= this.baseScale / curBaseScale;\\n  },\\n\\n  /**\\n   * Synchronize the size of the map with the size of the container. Suitable in situations where the size of the container is changed programmatically or container is shown after it became visible.\\n   */\\n  updateSize: function () {\\n    this.width = this.container.width();\\n    this.height = this.container.height();\\n    this.resize();\\n    this.canvas.setSize(this.width, this.height);\\n    this.applyTransform();\\n  },\\n\\n  /**\\n   * Reset all the series and show the map with the initial zoom.\\n   */\\n  reset: function () {\\n    var key, i;\\n\\n    for (key in this.series) {\\n      for (i = 0; i < this.series[key].length; i++) {\\n        this.series[key][i].clear();\\n      }\\n    }\\n    this.scale = this.baseScale;\\n    this.transX = this.baseTransX;\\n    this.transY = this.baseTransY;\\n    this.applyTransform();\\n  },\\n\\n  applyTransform: function () {\\n    var maxTransX, maxTransY, minTransX, minTransY;\\n\\n    if (this.defaultWidth * this.scale <= this.width) {\\n      maxTransX =\\n        (this.width - this.defaultWidth * this.scale) / (2 * this.scale);\\n      minTransX =\\n        (this.width - this.defaultWidth * this.scale) / (2 * this.scale);\\n    } else {\\n      maxTransX = 0;\\n      minTransX = (this.width - this.defaultWidth * this.scale) / this.scale;\\n    }\\n\\n    if (this.defaultHeight * this.scale <= this.height) {\\n      maxTransY =\\n        (this.height - this.defaultHeight * this.scale) / (2 * this.scale);\\n      minTransY =\\n        (this.height - this.defaultHeight * this.scale) / (2 * this.scale);\\n    } else {\\n      maxTransY = 0;\\n      minTransY = (this.height - this.defaultHeight * this.scale) / this.scale;\\n    }\\n\\n    if (this.transY > maxTransY) {\\n      this.transY = maxTransY;\\n    } else if (this.transY < minTransY) {\\n      this.transY = minTransY;\\n    }\\n    if (this.transX > maxTransX) {\\n      this.transX = maxTransX;\\n    } else if (this.transX < minTransX) {\\n      this.transX = minTransX;\\n    }\\n\\n    this.canvas.applyTransformParams(this.scale, this.transX, this.transY);\\n\\n    if (this.markers) {\\n      this.repositionMarkers();\\n    }\\n\\n    this.repositionLabels();\\n\\n    this.container.trigger(\\\"viewportChange\\\", [\\n      this.scale / this.baseScale,\\n      this.transX,\\n      this.transY,\\n    ]);\\n  },\\n\\n  bindContainerEvents: function () {\\n    var mouseDown = false,\\n      oldPageX,\\n      oldPageY,\\n      map = this;\\n\\n    if (this.params.panOnDrag) {\\n      this.container\\n        .mousemove(function (e) {\\n          if (mouseDown) {\\n            map.transX -= (oldPageX - e.pageX) / map.scale;\\n            map.transY -= (oldPageY - e.pageY) / map.scale;\\n\\n            map.applyTransform();\\n\\n            oldPageX = e.pageX;\\n            oldPageY = e.pageY;\\n          }\\n          return false;\\n        })\\n        .mousedown(function (e) {\\n          mouseDown = true;\\n          oldPageX = e.pageX;\\n          oldPageY = e.pageY;\\n          return false;\\n        });\\n\\n      this.onContainerMouseUp = function () {\\n        mouseDown = false;\\n      };\\n      jvm.$(\\\"body\\\").mouseup(this.onContainerMouseUp);\\n    }\\n\\n    if (this.params.zoomOnScroll) {\\n      this.container.mousewheel(function (event, delta, deltaX, deltaY) {\\n        var offset = jvm.$(map.container).offset(),\\n          centerX = event.pageX - offset.left,\\n          centerY = event.pageY - offset.top,\\n          zoomStep = Math.pow(\\n            1 + map.params.zoomOnScrollSpeed / 1000,\\n            event.deltaFactor * event.deltaY,\\n          );\\n\\n        map.tip.hide();\\n\\n        map.setScale(map.scale * zoomStep, centerX, centerY);\\n        event.preventDefault();\\n      });\\n    }\\n  },\\n\\n  bindContainerTouchEvents: function () {\\n    var touchStartScale,\\n      touchStartDistance,\\n      map = this,\\n      touchX,\\n      touchY,\\n      centerTouchX,\\n      centerTouchY,\\n      lastTouchesLength,\\n      handleTouchEvent = function (e) {\\n        var touches = e.originalEvent.touches,\\n          offset,\\n          scale,\\n          transXOld,\\n          transYOld;\\n\\n        if (e.type == \\\"touchstart\\\") {\\n          lastTouchesLength = 0;\\n        }\\n\\n        if (touches.length == 1) {\\n          if (lastTouchesLength == 1) {\\n            transXOld = map.transX;\\n            transYOld = map.transY;\\n            map.transX -= (touchX - touches[0].pageX) / map.scale;\\n            map.transY -= (touchY - touches[0].pageY) / map.scale;\\n            map.applyTransform();\\n            map.tip.hide();\\n            if (transXOld != map.transX || transYOld != map.transY) {\\n              e.preventDefault();\\n            }\\n          }\\n          touchX = touches[0].pageX;\\n          touchY = touches[0].pageY;\\n        } else if (touches.length == 2) {\\n          if (lastTouchesLength == 2) {\\n            scale =\\n              Math.sqrt(\\n                Math.pow(touches[0].pageX - touches[1].pageX, 2) +\\n                  Math.pow(touches[0].pageY - touches[1].pageY, 2),\\n              ) / touchStartDistance;\\n            map.setScale(touchStartScale * scale, centerTouchX, centerTouchY);\\n            map.tip.hide();\\n            e.preventDefault();\\n          } else {\\n            offset = jvm.$(map.container).offset();\\n            if (touches[0].pageX > touches[1].pageX) {\\n              centerTouchX =\\n                touches[1].pageX + (touches[0].pageX - touches[1].pageX) / 2;\\n            } else {\\n              centerTouchX =\\n                touches[0].pageX + (touches[1].pageX - touches[0].pageX) / 2;\\n            }\\n            if (touches[0].pageY > touches[1].pageY) {\\n              centerTouchY =\\n                touches[1].pageY + (touches[0].pageY - touches[1].pageY) / 2;\\n            } else {\\n              centerTouchY =\\n                touches[0].pageY + (touches[1].pageY - touches[0].pageY) / 2;\\n            }\\n            centerTouchX -= offset.left;\\n            centerTouchY -= offset.top;\\n            touchStartScale = map.scale;\\n            touchStartDistance = Math.sqrt(\\n              Math.pow(touches[0].pageX - touches[1].pageX, 2) +\\n                Math.pow(touches[0].pageY - touches[1].pageY, 2),\\n            );\\n          }\\n        }\\n\\n        lastTouchesLength = touches.length;\\n      };\\n\\n    jvm.$(this.container).bind(\\\"touchstart\\\", handleTouchEvent);\\n    jvm.$(this.container).bind(\\\"touchmove\\\", handleTouchEvent);\\n  },\\n\\n  bindContainerPointerEvents: function () {\\n    var map = this,\\n      gesture = new MSGesture(),\\n      element = this.container[0],\\n      handlePointerDownEvent = function (e) {\\n        gesture.addPointer(e.pointerId);\\n      },\\n      handleGestureEvent = function (e) {\\n        var offset, scale, transXOld, transYOld;\\n\\n        if (e.translationX != 0 || e.translationY != 0) {\\n          transXOld = map.transX;\\n          transYOld = map.transY;\\n          map.transX += e.translationX / map.scale;\\n          map.transY += e.translationY / map.scale;\\n          map.applyTransform();\\n          map.tip.hide();\\n          if (transXOld != map.transX || transYOld != map.transY) {\\n            e.preventDefault();\\n          }\\n        }\\n        if (e.scale != 1) {\\n          map.setScale(map.scale * e.scale, e.offsetX, e.offsetY);\\n          map.tip.hide();\\n          e.preventDefault();\\n        }\\n      };\\n\\n    gesture.target = element;\\n    element.addEventListener(\\\"MSGestureChange\\\", handleGestureEvent, false);\\n    element.addEventListener(\\\"pointerdown\\\", handlePointerDownEvent, false);\\n  },\\n\\n  bindElementEvents: function () {\\n    var map = this,\\n      pageX,\\n      pageY,\\n      mouseMoved;\\n\\n    this.container.mousemove(function (e) {\\n      if (Math.abs(pageX - e.pageX) + Math.abs(pageY - e.pageY) > 2) {\\n        mouseMoved = true;\\n      }\\n    });\\n\\n    /* Can not use common class selectors here because of the bug in jQuery\\n       SVG handling, use with caution. */\\n    this.container.delegate(\\n      \\\"[class~='jvectormap-element']\\\",\\n      \\\"mouseover mouseout\\\",\\n      function (e) {\\n        var baseVal =\\n            jvm.$(this).attr(\\\"class\\\").baseVal || jvm.$(this).attr(\\\"class\\\"),\\n          type =\\n            baseVal.indexOf(\\\"jvectormap-region\\\") === -1 ? \\\"marker\\\" : \\\"region\\\",\\n          code =\\n            type == \\\"region\\\"\\n              ? jvm.$(this).attr(\\\"data-code\\\")\\n              : jvm.$(this).attr(\\\"data-index\\\"),\\n          element =\\n            type == \\\"region\\\"\\n              ? map.regions[code].element\\n              : map.markers[code].element,\\n          tipText =\\n            type == \\\"region\\\"\\n              ? map.mapData.paths[code].name\\n              : map.markers[code].config.name || \\\"\\\",\\n          tipShowEvent = jvm.$.Event(type + \\\"TipShow.jvectormap\\\"),\\n          overEvent = jvm.$.Event(type + \\\"Over.jvectormap\\\");\\n\\n        if (e.type == \\\"mouseover\\\") {\\n          map.container.trigger(overEvent, [code]);\\n          if (!overEvent.isDefaultPrevented()) {\\n            element.setHovered(true);\\n          }\\n\\n          map.tip.text(tipText);\\n          map.container.trigger(tipShowEvent, [map.tip, code]);\\n          if (!tipShowEvent.isDefaultPrevented()) {\\n            map.tip.show();\\n            map.tipWidth = map.tip.width();\\n            map.tipHeight = map.tip.height();\\n          }\\n        } else {\\n          element.setHovered(false);\\n          map.tip.hide();\\n          map.container.trigger(type + \\\"Out.jvectormap\\\", [code]);\\n        }\\n      },\\n    );\\n\\n    /* Can not use common class selectors here because of the bug in jQuery\\n       SVG handling, use with caution. */\\n    this.container.delegate(\\n      \\\"[class~='jvectormap-element']\\\",\\n      \\\"mousedown\\\",\\n      function (e) {\\n        pageX = e.pageX;\\n        pageY = e.pageY;\\n        mouseMoved = false;\\n      },\\n    );\\n\\n    /* Can not use common class selectors here because of the bug in jQuery\\n       SVG handling, use with caution. */\\n    this.container.delegate(\\n      \\\"[class~='jvectormap-element']\\\",\\n      \\\"mouseup\\\",\\n      function () {\\n        var baseVal = jvm.$(this).attr(\\\"class\\\").baseVal\\n            ? jvm.$(this).attr(\\\"class\\\").baseVal\\n            : jvm.$(this).attr(\\\"class\\\"),\\n          type =\\n            baseVal.indexOf(\\\"jvectormap-region\\\") === -1 ? \\\"marker\\\" : \\\"region\\\",\\n          code =\\n            type == \\\"region\\\"\\n              ? jvm.$(this).attr(\\\"data-code\\\")\\n              : jvm.$(this).attr(\\\"data-index\\\"),\\n          clickEvent = jvm.$.Event(type + \\\"Click.jvectormap\\\"),\\n          element =\\n            type == \\\"region\\\"\\n              ? map.regions[code].element\\n              : map.markers[code].element;\\n\\n        if (!mouseMoved) {\\n          map.container.trigger(clickEvent, [code]);\\n          if (\\n            (type === \\\"region\\\" && map.params.regionsSelectable) ||\\n            (type === \\\"marker\\\" && map.params.markersSelectable)\\n          ) {\\n            if (!clickEvent.isDefaultPrevented()) {\\n              if (map.params[type + \\\"sSelectableOne\\\"]) {\\n                map.clearSelected(type + \\\"s\\\");\\n              }\\n              element.setSelected(!element.isSelected);\\n            }\\n          }\\n        }\\n      },\\n    );\\n  },\\n\\n  bindZoomButtons: function () {\\n    var map = this;\\n\\n    jvm\\n      .$(\\\"<div/>\\\")\\n      .addClass(\\\"jvectormap-zoomin\\\")\\n      .text(\\\"+\\\")\\n      .appendTo(this.container);\\n    jvm\\n      .$(\\\"<div/>\\\")\\n      .addClass(\\\"jvectormap-zoomout\\\")\\n      .html(\\\"&#x2212;\\\")\\n      .appendTo(this.container);\\n\\n    this.container.find(\\\".jvectormap-zoomin\\\").click(function () {\\n      map.setScale(\\n        map.scale * map.params.zoomStep,\\n        map.width / 2,\\n        map.height / 2,\\n        false,\\n        map.params.zoomAnimate,\\n      );\\n    });\\n    this.container.find(\\\".jvectormap-zoomout\\\").click(function () {\\n      map.setScale(\\n        map.scale / map.params.zoomStep,\\n        map.width / 2,\\n        map.height / 2,\\n        false,\\n        map.params.zoomAnimate,\\n      );\\n    });\\n  },\\n\\n  createTip: function () {\\n    var map = this;\\n\\n    this.tip = jvm\\n      .$(\\\"<div/>\\\")\\n      .addClass(\\\"jvectormap-tip\\\")\\n      .appendTo(jvm.$(\\\"body\\\"));\\n\\n    this.container.mousemove(function (e) {\\n      var left = e.pageX - 15 - map.tipWidth,\\n        top = e.pageY - 15 - map.tipHeight;\\n\\n      if (left < 5) {\\n        left = e.pageX + 15;\\n      }\\n      if (top < 5) {\\n        top = e.pageY + 15;\\n      }\\n\\n      map.tip.css({\\n        left: left,\\n        top: top,\\n      });\\n    });\\n  },\\n\\n  setScale: function (scale, anchorX, anchorY, isCentered, animate) {\\n    var viewportChangeEvent = jvm.$.Event(\\\"zoom.jvectormap\\\"),\\n      interval,\\n      that = this,\\n      i = 0,\\n      count = Math.abs(\\n        Math.round(((scale - this.scale) * 60) / Math.max(scale, this.scale)),\\n      ),\\n      scaleStart,\\n      scaleDiff,\\n      transXStart,\\n      transXDiff,\\n      transYStart,\\n      transYDiff,\\n      transX,\\n      transY,\\n      deferred = new jvm.$.Deferred();\\n\\n    if (scale > this.params.zoomMax * this.baseScale) {\\n      scale = this.params.zoomMax * this.baseScale;\\n    } else if (scale < this.params.zoomMin * this.baseScale) {\\n      scale = this.params.zoomMin * this.baseScale;\\n    }\\n\\n    if (typeof anchorX != \\\"undefined\\\" && typeof anchorY != \\\"undefined\\\") {\\n      const zoomStep = scale / this.scale;\\n      if (isCentered) {\\n        transX =\\n          anchorX +\\n          (this.defaultWidth * (this.width / (this.defaultWidth * scale))) / 2;\\n        transY =\\n          anchorY +\\n          (this.defaultHeight * (this.height / (this.defaultHeight * scale))) /\\n            2;\\n      } else {\\n        transX = this.transX - ((zoomStep - 1) / scale) * anchorX;\\n        transY = this.transY - ((zoomStep - 1) / scale) * anchorY;\\n      }\\n    }\\n\\n    if (animate && count > 0) {\\n      scaleStart = this.scale;\\n      scaleDiff = (scale - scaleStart) / count;\\n      transXStart = this.transX * this.scale;\\n      transYStart = this.transY * this.scale;\\n      transXDiff = (transX * scale - transXStart) / count;\\n      transYDiff = (transY * scale - transYStart) / count;\\n      interval = setInterval(function () {\\n        i += 1;\\n        that.scale = scaleStart + scaleDiff * i;\\n        that.transX = (transXStart + transXDiff * i) / that.scale;\\n        that.transY = (transYStart + transYDiff * i) / that.scale;\\n        that.applyTransform();\\n        if (i == count) {\\n          clearInterval(interval);\\n          that.container.trigger(viewportChangeEvent, [scale / that.baseScale]);\\n          deferred.resolve();\\n        }\\n      }, 10);\\n    } else {\\n      this.transX = transX;\\n      this.transY = transY;\\n      this.scale = scale;\\n      this.applyTransform();\\n      this.container.trigger(viewportChangeEvent, [scale / this.baseScale]);\\n      deferred.resolve();\\n    }\\n\\n    return deferred;\\n  },\\n\\n  /**\\n   * Set the map's viewport to the specific point and set zoom of the map to the specific level. Point and zoom level could be defined in two ways: using the code of some region to focus on or a central point and zoom level as numbers.\\n   * @param This method takes a configuration object as the single argument. The options passed to it are the following:\\n   * @param {Array} params.regions Array of region codes to zoom to.\\n   * @param {String} params.region Region code to zoom to.\\n   * @param {Number} params.scale Map scale to set.\\n   * @param {Number} params.lat Latitude to set viewport to.\\n   * @param {Number} params.lng Longitude to set viewport to.\\n   * @param {Number} params.x Number from 0 to 1 specifying the horizontal coordinate of the central point of the viewport.\\n   * @param {Number} params.y Number from 0 to 1 specifying the vertical coordinate of the central point of the viewport.\\n   * @param {Boolean} params.animate Indicates whether or not to animate the scale change and transition.\\n   */\\n  setFocus: function (config) {\\n    var bbox, itemBbox, newBbox, codes, i, point;\\n\\n    config = config || {};\\n\\n    if (config.region) {\\n      codes = [config.region];\\n    } else if (config.regions) {\\n      codes = config.regions;\\n    }\\n\\n    if (codes) {\\n      for (i = 0; i < codes.length; i++) {\\n        if (this.regions[codes[i]]) {\\n          itemBbox = this.regions[codes[i]].element.shape.getBBox();\\n          if (itemBbox) {\\n            if (typeof bbox == \\\"undefined\\\") {\\n              bbox = itemBbox;\\n            } else {\\n              newBbox = {\\n                x: Math.min(bbox.x, itemBbox.x),\\n                y: Math.min(bbox.y, itemBbox.y),\\n                width:\\n                  Math.max(bbox.x + bbox.width, itemBbox.x + itemBbox.width) -\\n                  Math.min(bbox.x, itemBbox.x),\\n                height:\\n                  Math.max(bbox.y + bbox.height, itemBbox.y + itemBbox.height) -\\n                  Math.min(bbox.y, itemBbox.y),\\n              };\\n              bbox = newBbox;\\n            }\\n          }\\n        }\\n      }\\n      return this.setScale(\\n        Math.min(this.width / bbox.width, this.height / bbox.height),\\n        -(bbox.x + bbox.width / 2),\\n        -(bbox.y + bbox.height / 2),\\n        true,\\n        config.animate,\\n      );\\n    } else {\\n      if (config.lat !== undefined && config.lng !== undefined) {\\n        point = this.latLngToPoint(config.lat, config.lng);\\n        config.x = this.transX - point.x / this.scale;\\n        config.y = this.transY - point.y / this.scale;\\n      } else if (config.x && config.y) {\\n        config.x *= -this.defaultWidth;\\n        config.y *= -this.defaultHeight;\\n      }\\n      return this.setScale(\\n        config.scale * this.baseScale,\\n        config.x,\\n        config.y,\\n        true,\\n        config.animate,\\n      );\\n    }\\n  },\\n\\n  getSelected: function (type) {\\n    var key,\\n      selected = [];\\n\\n    for (key in this[type]) {\\n      if (this[type][key].element.isSelected) {\\n        selected.push(key);\\n      }\\n    }\\n    return selected;\\n  },\\n\\n  /**\\n   * Return the codes of currently selected regions.\\n   * @returns {Array}\\n   */\\n  getSelectedRegions: function () {\\n    return this.getSelected(\\\"regions\\\");\\n  },\\n\\n  /**\\n   * Return the codes of currently selected markers.\\n   * @returns {Array}\\n   */\\n  getSelectedMarkers: function () {\\n    return this.getSelected(\\\"markers\\\");\\n  },\\n\\n  setSelected: function (type, keys) {\\n    var i;\\n\\n    if (typeof keys != \\\"object\\\") {\\n      keys = [keys];\\n    }\\n\\n    if (jvm.$.isArray(keys)) {\\n      for (i = 0; i < keys.length; i++) {\\n        this[type][keys[i]].element.setSelected(true);\\n      }\\n    } else {\\n      for (i in keys) {\\n        this[type][i].element.setSelected(!!keys[i]);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Set or remove selected state for the regions.\\n   * @param {String|Array|Object} keys If <code>String</code> or <code>Array</code> the region(s) with the corresponding code(s) will be selected. If <code>Object</code> was provided its keys are  codes of regions, state of which should be changed. Selected state will be set if value is true, removed otherwise.\\n   */\\n  setSelectedRegions: function (keys) {\\n    this.setSelected(\\\"regions\\\", keys);\\n  },\\n\\n  /**\\n   * Set or remove selected state for the markers.\\n   * @param {String|Array|Object} keys If <code>String</code> or <code>Array</code> the marker(s) with the corresponding code(s) will be selected. If <code>Object</code> was provided its keys are  codes of markers, state of which should be changed. Selected state will be set if value is true, removed otherwise.\\n   */\\n  setSelectedMarkers: function (keys) {\\n    this.setSelected(\\\"markers\\\", keys);\\n  },\\n\\n  clearSelected: function (type) {\\n    var select = {},\\n      selected = this.getSelected(type),\\n      i;\\n\\n    for (i = 0; i < selected.length; i++) {\\n      select[selected[i]] = false;\\n    }\\n\\n    this.setSelected(type, select);\\n  },\\n\\n  /**\\n   * Remove the selected state from all the currently selected regions.\\n   */\\n  clearSelectedRegions: function () {\\n    this.clearSelected(\\\"regions\\\");\\n  },\\n\\n  /**\\n   * Remove the selected state from all the currently selected markers.\\n   */\\n  clearSelectedMarkers: function () {\\n    this.clearSelected(\\\"markers\\\");\\n  },\\n\\n  /**\\n   * Return the instance of Map. Useful when instantiated as a jQuery plug-in.\\n   * @returns {Map}\\n   */\\n  getMapObject: function () {\\n    return this;\\n  },\\n\\n  /**\\n   * Return the name of the region by region code.\\n   * @returns {String}\\n   */\\n  getRegionName: function (code) {\\n    return this.mapData.paths[code].name;\\n  },\\n\\n  createRegions: function () {\\n    var key,\\n      region,\\n      map = this;\\n\\n    this.regionLabelsGroup = this.regionLabelsGroup || this.canvas.addGroup();\\n\\n    for (key in this.mapData.paths) {\\n      const regionStyle =\\n        typeof this.params.regionStyle === \\\"function\\\"\\n          ? {\\n              ...jvm.Map.defaultParams.regionStyle,\\n              ...this.params.regionStyle(key),\\n            }\\n          : this.params.regionStyle;\\n      region = new jvm.Region({\\n        map: this,\\n        path: this.mapData.paths[key].path,\\n        code: key,\\n        style: jvm.$.extend(true, {}, regionStyle),\\n        labelStyle: jvm.$.extend(true, {}, this.params.regionLabelStyle),\\n        canvas: this.canvas,\\n        labelsGroup: this.regionLabelsGroup,\\n        label:\\n          this.canvas.mode != \\\"vml\\\"\\n            ? this.params.labels && this.params.labels.regions\\n            : null,\\n      });\\n\\n      jvm.$(region.shape).bind(\\\"selected\\\", function (e, isSelected) {\\n        map.container.trigger(\\\"regionSelected.jvectormap\\\", [\\n          jvm.$(this.node).attr(\\\"data-code\\\"),\\n          isSelected,\\n          map.getSelectedRegions(),\\n        ]);\\n      });\\n      this.regions[key] = {\\n        element: region,\\n        config: this.mapData.paths[key],\\n      };\\n    }\\n  },\\n\\n  createMarkers: function (markers) {\\n    var i,\\n      marker,\\n      point,\\n      markerConfig,\\n      markersArray,\\n      map = this;\\n\\n    this.markersGroup = this.markersGroup || this.canvas.addGroup();\\n    this.markerLabelsGroup = this.markerLabelsGroup || this.canvas.addGroup();\\n\\n    if (jvm.$.isArray(markers)) {\\n      markersArray = markers.slice();\\n      markers = {};\\n      for (i = 0; i < markersArray.length; i++) {\\n        markers[i] = markersArray[i];\\n      }\\n    }\\n\\n    for (i in markers) {\\n      markerConfig =\\n        markers[i] instanceof Array ? { latLng: markers[i] } : markers[i];\\n      point = this.getMarkerPosition(markerConfig);\\n\\n      if (point !== false) {\\n        marker = new jvm.Marker({\\n          map: this,\\n          style: jvm.$.extend(true, {}, this.params.markerStyle, {\\n            initial: markerConfig.style || {},\\n          }),\\n          labelStyle: jvm.$.extend(true, {}, this.params.markerLabelStyle),\\n          index: i,\\n          cx: point.x,\\n          cy: point.y,\\n          group: this.markersGroup,\\n          canvas: this.canvas,\\n          labelsGroup: this.markerLabelsGroup,\\n          label:\\n            this.canvas.mode != \\\"vml\\\"\\n              ? this.params.labels && this.params.labels.markers\\n              : null,\\n        });\\n\\n        jvm.$(marker.shape).bind(\\\"selected\\\", function (e, isSelected) {\\n          map.container.trigger(\\\"markerSelected.jvectormap\\\", [\\n            jvm.$(this.node).attr(\\\"data-index\\\"),\\n            isSelected,\\n            map.getSelectedMarkers(),\\n          ]);\\n        });\\n        if (this.markers[i]) {\\n          this.removeMarkers([i]);\\n        }\\n        this.markers[i] = { element: marker, config: markerConfig };\\n      }\\n    }\\n  },\\n\\n  repositionMarkers: function () {\\n    var i, point;\\n\\n    for (i in this.markers) {\\n      point = this.getMarkerPosition(this.markers[i].config);\\n      if (point !== false) {\\n        this.markers[i].element.setStyle({ cx: point.x, cy: point.y });\\n      }\\n    }\\n  },\\n\\n  repositionLabels: function () {\\n    var key;\\n\\n    for (key in this.regions) {\\n      this.regions[key].element.updateLabelPosition();\\n    }\\n\\n    for (key in this.markers) {\\n      this.markers[key].element.updateLabelPosition();\\n    }\\n  },\\n\\n  getMarkerPosition: function (markerConfig) {\\n    if (jvm.Map.maps[this.params.map].projection) {\\n      return this.latLngToPoint.apply(this, markerConfig.latLng || [0, 0]);\\n    } else {\\n      return {\\n        x: markerConfig.coords[0] * this.scale + this.transX * this.scale,\\n        y: markerConfig.coords[1] * this.scale + this.transY * this.scale,\\n      };\\n    }\\n  },\\n\\n  /**\\n   * Add one marker to the map.\\n   * @param {String} key Marker unique code.\\n   * @param {Object} marker Marker configuration parameters.\\n   * @param {Array} seriesData Values to add to the data series.\\n   */\\n  addMarker: function (key, marker, seriesData) {\\n    var markers = {},\\n      data = [],\\n      values,\\n      i,\\n      seriesData = seriesData || [];\\n\\n    markers[key] = marker;\\n\\n    for (i = 0; i < seriesData.length; i++) {\\n      values = {};\\n      if (typeof seriesData[i] !== \\\"undefined\\\") {\\n        values[key] = seriesData[i];\\n      }\\n      data.push(values);\\n    }\\n    this.addMarkers(markers, data);\\n  },\\n\\n  /**\\n   * Add set of marker to the map.\\n   * @param {Object|Array} markers Markers to add to the map. In case of array is provided, codes of markers will be set as string representations of array indexes.\\n   * @param {Array} seriesData Values to add to the data series.\\n   */\\n  addMarkers: function (markers, seriesData) {\\n    var i;\\n\\n    seriesData = seriesData || [];\\n\\n    this.createMarkers(markers);\\n    for (i = 0; i < seriesData.length; i++) {\\n      this.series.markers[i].setValues(seriesData[i] || {});\\n    }\\n  },\\n\\n  /**\\n   * Remove some markers from the map.\\n   * @param {Array} markers Array of marker codes to be removed.\\n   */\\n  removeMarkers: function (markers) {\\n    var i;\\n\\n    for (i = 0; i < markers.length; i++) {\\n      this.markers[markers[i]].element.remove();\\n      delete this.markers[markers[i]];\\n    }\\n  },\\n\\n  /**\\n   * Remove all markers from the map.\\n   */\\n  removeAllMarkers: function () {\\n    var i,\\n      markers = [];\\n\\n    for (i in this.markers) {\\n      markers.push(i);\\n    }\\n    this.removeMarkers(markers);\\n  },\\n\\n  /**\\n   * Converts coordinates expressed as latitude and longitude to the coordinates in pixels on the map.\\n   * @param {Number} lat Latitide of point in degrees.\\n   * @param {Number} lng Longitude of point in degrees.\\n   */\\n  latLngToPoint: function (lat, lng) {\\n    var point,\\n      proj = jvm.Map.maps[this.params.map].projection,\\n      centralMeridian = proj.centralMeridian,\\n      inset,\\n      bbox;\\n\\n    if (lng < -180 + centralMeridian) {\\n      lng += 360;\\n    }\\n\\n    point = jvm.Proj[proj.type](lat, lng, centralMeridian);\\n\\n    inset = this.getInsetForPoint(point.x, point.y);\\n    if (inset) {\\n      bbox = inset.bbox;\\n\\n      point.x =\\n        ((point.x - bbox[0].x) / (bbox[1].x - bbox[0].x)) *\\n        inset.width *\\n        this.scale;\\n      point.y =\\n        ((point.y - bbox[0].y) / (bbox[1].y - bbox[0].y)) *\\n        inset.height *\\n        this.scale;\\n\\n      return {\\n        x: point.x + this.transX * this.scale + inset.left * this.scale,\\n        y: point.y + this.transY * this.scale + inset.top * this.scale,\\n      };\\n    } else {\\n      return false;\\n    }\\n  },\\n\\n  /**\\n   * Converts cartesian coordinates into coordinates expressed as latitude and longitude.\\n   * @param {Number} x X-axis of point on map in pixels.\\n   * @param {Number} y Y-axis of point on map in pixels.\\n   */\\n  pointToLatLng: function (x, y) {\\n    var proj = jvm.Map.maps[this.params.map].projection,\\n      centralMeridian = proj.centralMeridian,\\n      insets = jvm.Map.maps[this.params.map].insets,\\n      i,\\n      inset,\\n      bbox,\\n      nx,\\n      ny;\\n\\n    for (i = 0; i < insets.length; i++) {\\n      inset = insets[i];\\n      bbox = inset.bbox;\\n\\n      nx = x - (this.transX * this.scale + inset.left * this.scale);\\n      ny = y - (this.transY * this.scale + inset.top * this.scale);\\n\\n      nx =\\n        (nx / (inset.width * this.scale)) * (bbox[1].x - bbox[0].x) + bbox[0].x;\\n      ny =\\n        (ny / (inset.height * this.scale)) * (bbox[1].y - bbox[0].y) +\\n        bbox[0].y;\\n\\n      if (\\n        nx > bbox[0].x &&\\n        nx < bbox[1].x &&\\n        ny > bbox[0].y &&\\n        ny < bbox[1].y\\n      ) {\\n        return jvm.Proj[proj.type + \\\"_inv\\\"](nx, -ny, centralMeridian);\\n      }\\n    }\\n\\n    return false;\\n  },\\n\\n  getInsetForPoint: function (x, y) {\\n    var insets = jvm.Map.maps[this.params.map].insets,\\n      i,\\n      bbox;\\n\\n    for (i = 0; i < insets.length; i++) {\\n      bbox = insets[i].bbox;\\n      if (x > bbox[0].x && x < bbox[1].x && y > bbox[0].y && y < bbox[1].y) {\\n        return insets[i];\\n      }\\n    }\\n  },\\n\\n  createSeries: function () {\\n    var i, key;\\n\\n    this.series = {\\n      markers: [],\\n      regions: [],\\n    };\\n\\n    for (key in this.params.series) {\\n      for (i = 0; i < this.params.series[key].length; i++) {\\n        this.series[key][i] = new jvm.DataSeries(\\n          this.params.series[key][i],\\n          this[key],\\n          this,\\n        );\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Gracefully remove the map and and all its accessories, unbind event handlers.\\n   */\\n  remove: function () {\\n    this.tip.remove();\\n    this.container.remove();\\n    jvm.$(window).unbind(\\\"resize\\\", this.onResize);\\n    jvm.$(\\\"body\\\").unbind(\\\"mouseup\\\", this.onContainerMouseUp);\\n  },\\n};\\n\\njvm.Map.maps = {};\\njvm.Map.defaultParams = {\\n  map: \\\"world_mill_en\\\",\\n  backgroundColor: \\\"#505050\\\",\\n  zoomButtons: true,\\n  zoomOnScroll: true,\\n  zoomOnScrollSpeed: 3,\\n  panOnDrag: true,\\n  zoomMax: 8,\\n  zoomMin: 1,\\n  zoomStep: 1.6,\\n  zoomAnimate: true,\\n  regionsSelectable: false,\\n  markersSelectable: false,\\n  bindTouchEvents: true,\\n  regionStyle: {\\n    initial: {\\n      fill: \\\"white\\\",\\n      \\\"fill-opacity\\\": 1,\\n      stroke: \\\"none\\\",\\n      \\\"stroke-width\\\": 0,\\n      \\\"stroke-opacity\\\": 1,\\n    },\\n    hover: {\\n      \\\"fill-opacity\\\": 0.8,\\n      cursor: \\\"pointer\\\",\\n    },\\n    selected: {\\n      fill: \\\"yellow\\\",\\n    },\\n    selectedHover: {},\\n  },\\n  regionLabelStyle: {\\n    initial: {\\n      \\\"font-family\\\": \\\"Verdana\\\",\\n      \\\"font-size\\\": \\\"12\\\",\\n      \\\"font-weight\\\": \\\"bold\\\",\\n      cursor: \\\"default\\\",\\n      fill: \\\"black\\\",\\n    },\\n    hover: {\\n      cursor: \\\"pointer\\\",\\n    },\\n  },\\n  markerStyle: {\\n    initial: {\\n      fill: \\\"grey\\\",\\n      stroke: \\\"#505050\\\",\\n      \\\"fill-opacity\\\": 1,\\n      \\\"stroke-width\\\": 1,\\n      \\\"stroke-opacity\\\": 1,\\n      r: 5,\\n    },\\n    hover: {\\n      stroke: \\\"black\\\",\\n      \\\"stroke-width\\\": 2,\\n      cursor: \\\"pointer\\\",\\n    },\\n    selected: {\\n      fill: \\\"blue\\\",\\n    },\\n    selectedHover: {},\\n  },\\n  markerLabelStyle: {\\n    initial: {\\n      \\\"font-family\\\": \\\"Verdana\\\",\\n      \\\"font-size\\\": \\\"12\\\",\\n      \\\"font-weight\\\": \\\"bold\\\",\\n      cursor: \\\"default\\\",\\n      fill: \\\"black\\\",\\n    },\\n    hover: {\\n      cursor: \\\"pointer\\\",\\n    },\\n  },\\n};\\njvm.Map.apiEvents = {\\n  onRegionTipShow: \\\"regionTipShow\\\",\\n  onRegionOver: \\\"regionOver\\\",\\n  onRegionOut: \\\"regionOut\\\",\\n  onRegionClick: \\\"regionClick\\\",\\n  onRegionSelected: \\\"regionSelected\\\",\\n  onMarkerTipShow: \\\"markerTipShow\\\",\\n  onMarkerOver: \\\"markerOver\\\",\\n  onMarkerOut: \\\"markerOut\\\",\\n  onMarkerClick: \\\"markerClick\\\",\\n  onMarkerSelected: \\\"markerSelected\\\",\\n  onViewportChange: \\\"viewportChange\\\",\\n};\\n/**\\n * Creates map with drill-down functionality.\\n * @constructor\\n * @param {Object} params Parameters to initialize map with.\\n * @param {Number} params.maxLevel Maximum number of levels user can go through\\n * @param {Object} params.main Config of the main map. See <a href=\\\"./jvm-map/\\\">jvm.Map</a> for more information.\\n * @param {Function} params.mapNameByCode Function to generate map name by region code. Default value is:\\n<pre>\\nfunction(code, multiMap) {\\n  return code.toLowerCase()+'_'+\\n         multiMap.defaultProjection+'_en';\\n}\\n</pre>\\n * @param {Function} params.mapUrlByCode Function to generate map url by region code. Default value is:\\n<pre>\\nfunction(code, multiMap){\\n  return 'jquery-jvectormap-data-'+\\n         code.toLowerCase()+'-'+\\n         multiMap.defaultProjection+'-en.js';\\n}\\n</pre>\\n */\\njvm.MultiMap = function (params) {\\n  var that = this;\\n\\n  this.maps = {};\\n  this.params = jvm.$.extend(true, {}, jvm.MultiMap.defaultParams, params);\\n  this.params.maxLevel = this.params.maxLevel || Number.MAX_VALUE;\\n  this.params.main = this.params.main || {};\\n  this.params.main.multiMapLevel = 0;\\n  this.history = [this.addMap(this.params.main.map, this.params.main)];\\n  this.defaultProjection = this.history[0].mapData.projection.type;\\n  this.mapsLoaded = {};\\n  this.mapsLoadedData = {};\\n\\n  this.params.container.css({ position: \\\"relative\\\" });\\n  this.backButton = jvm\\n    .$(\\\"<div/>\\\")\\n    .addClass(\\\"jvectormap-goback\\\")\\n    .text(\\\"Back\\\")\\n    .appendTo(this.params.container);\\n  this.backButton.hide();\\n  this.backButton.click(function () {\\n    that.goBack();\\n  });\\n\\n  this.spinner = jvm\\n    .$(\\\"<div/>\\\")\\n    .addClass(\\\"jvectormap-spinner\\\")\\n    .appendTo(this.params.container);\\n  this.spinner.hide();\\n};\\n\\njvm.MultiMap.prototype = {\\n  addMap: function (name, config) {\\n    var cnt = jvm.$(\\\"<div/>\\\").css({\\n      width: \\\"100%\\\",\\n      height: \\\"100%\\\",\\n    });\\n\\n    this.params.container.append(cnt);\\n\\n    this.maps[name] = new jvm.Map(jvm.$.extend(config, { container: cnt }));\\n    if (this.params.maxLevel > config.multiMapLevel) {\\n      this.maps[name].container.on(\\n        \\\"regionClick.jvectormap\\\",\\n        { scope: this },\\n        function (e, code) {\\n          var multimap = e.data.scope,\\n            mapName = multimap.params.mapNameByCode(code, multimap);\\n\\n          if (\\n            !multimap.drillDownPromise ||\\n            multimap.drillDownPromise.state() !== \\\"pending\\\"\\n          ) {\\n            multimap.drillDown(mapName, code);\\n          }\\n        },\\n      );\\n    }\\n\\n    return this.maps[name];\\n  },\\n\\n  downloadMap: function (code) {\\n    var that = this,\\n      deferred = jvm.$.Deferred();\\n    const { getDrillDownMap } = this.params;\\n\\n    const handleMapData = function (data) {\\n      that.mapsLoaded[code] = true;\\n      that.mapsLoadedData[code] = data;\\n      deferred.resolve();\\n    };\\n\\n    if (!this.mapsLoaded[code]) {\\n      if (getDrillDownMap && typeof getDrillDownMap === \\\"function\\\") {\\n        const result = getDrillDownMap(code);\\n        if (result && typeof result.then === \\\"function\\\") {\\n          result\\n            .then((data) => {\\n              handleMapData(data);\\n            })\\n            .catch(() => {\\n              deferred.reject();\\n            });\\n        } else {\\n          handleMapData(result);\\n        }\\n        return deferred;\\n      }\\n      jvm.$.get(this.params.mapUrlByCode(code, this)).then(\\n        function (data) {\\n          handleMapData(data);\\n        },\\n        function () {\\n          deferred.reject();\\n        },\\n      );\\n    } else {\\n      deferred.resolve();\\n    }\\n    return deferred;\\n  },\\n\\n  drillDown: function (name, code) {\\n    var currentMap = this.history[this.history.length - 1],\\n      that = this,\\n      focusPromise = currentMap.setFocus({ region: code, animate: true }),\\n      downloadPromise = this.downloadMap(code);\\n\\n    focusPromise.then(function () {\\n      if (downloadPromise.state() === \\\"pending\\\") {\\n        that.spinner.show();\\n      }\\n    });\\n    downloadPromise.always(function () {\\n      that.spinner.hide();\\n    });\\n    this.drillDownPromise = jvm.$.when(downloadPromise, focusPromise);\\n    this.drillDownPromise.then(function () {\\n      const { content } = that.mapsLoadedData[code];\\n      currentMap.params.container.hide();\\n      if (!that.maps[name]) {\\n        jvm.$.fn.vectorMap(\\\"addMap\\\", name, content);\\n        that.addMap(name, {\\n          map: name,\\n          multiMapLevel: currentMap.params.multiMapLevel + 1,\\n        });\\n      } else {\\n        that.maps[name].params.container.show();\\n      }\\n      that.history.push(that.maps[name]);\\n      that.backButton.show();\\n    });\\n  },\\n\\n  goBack: function () {\\n    var currentMap = this.history.pop(),\\n      prevMap = this.history[this.history.length - 1],\\n      that = this;\\n\\n    currentMap\\n      .setFocus({ scale: 1, x: 0.5, y: 0.5, animate: true })\\n      .then(function () {\\n        currentMap.params.container.hide();\\n        prevMap.params.container.show();\\n        prevMap.updateSize();\\n        if (that.history.length === 1) {\\n          that.backButton.hide();\\n        }\\n        prevMap.setFocus({ scale: 1, x: 0.5, y: 0.5, animate: true });\\n      });\\n  },\\n};\\n\\njvm.MultiMap.defaultParams = {\\n  mapNameByCode: function (code, multiMap) {\\n    return code.toLowerCase() + \\\"_\\\" + multiMap.defaultProjection + \\\"_en\\\";\\n  },\\n  mapUrlByCode: function (code, multiMap) {\\n    return (\\n      \\\"jquery-jvectormap-data-\\\" +\\n      code.toLowerCase() +\\n      \\\"-\\\" +\\n      multiMap.defaultProjection +\\n      \\\"-en.js\\\"\\n    );\\n  },\\n};\\n\\n\\n//# sourceURL=webpack://@react-jvectormap/core/../jvectormap/jquery.jvectormap.min.js?\");\n            /***/ },\n            /***/ \"data:image/gif;base64,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\": /*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\\\n  !*** data:image/gif;base64,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 ***!\n  \\**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/ /***/ (module)=>{\n                \"use strict\";\n                eval('module.exports = \"data:image/gif;base64,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\";\\n\\n//# sourceURL=webpack://@react-jvectormap/core/data:image/gif;base64,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?');\n            /***/ },\n            /***/ \"jquery\": /*!*************************!*\\\n  !*** external \"jquery\" ***!\n  \\*************************/ /***/ (module1)=>{\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;\n            /***/ },\n            /***/ \"react\": /*!************************!*\\\n  !*** external \"react\" ***!\n  \\************************/ /***/ (module1)=>{\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_215432__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ id: moduleId,\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module1, module1.exports, __nested_webpack_require_215432__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_215432__.m = __webpack_modules__;\n        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ (()=>{\n            /******/ // getDefaultExport function for compatibility with non-harmony modules\n            /******/ __nested_webpack_require_215432__.n = (module1)=>{\n                /******/ var getter = module1 && module1.__esModule ? /******/ ()=>module1[\"default\"] : /******/ ()=>module1;\n                /******/ __nested_webpack_require_215432__.d(getter, {\n                    a: getter\n                });\n                /******/ return getter;\n            /******/ };\n        /******/ })();\n        /******/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n            /******/ // define getter functions for harmony exports\n            /******/ __nested_webpack_require_215432__.d = (exports1, definition)=>{\n                /******/ for(var key in definition){\n                    /******/ if (__nested_webpack_require_215432__.o(definition, key) && !__nested_webpack_require_215432__.o(exports1, key)) {\n                        /******/ Object.defineProperty(exports1, key, {\n                            enumerable: true,\n                            get: definition[key]\n                        });\n                    /******/ }\n                /******/ }\n            /******/ };\n        /******/ })();\n        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n            /******/ __nested_webpack_require_215432__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n        /******/ })();\n        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{\n            /******/ // define __esModule on exports\n            /******/ __nested_webpack_require_215432__.r = (exports1)=>{\n                /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                        value: \"Module\"\n                    });\n                /******/ }\n                /******/ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /******/ };\n        /******/ })();\n        /******/ /******/ /* webpack/runtime/jsonp chunk loading */ /******/ (()=>{\n            /******/ __nested_webpack_require_215432__.b = document.baseURI || self.location.href;\n            /******/ /******/ // object to store loaded and loading chunks\n            /******/ // undefined = chunk not loaded, null = chunk preloaded/prefetched\n            /******/ // [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\n            /******/ var installedChunks = {\n                /******/ \"main\": 0\n            };\n        /******/ /******/ // no chunk on demand loading\n        /******/ /******/ // no prefetching\n        /******/ /******/ // no preloaded\n        /******/ /******/ // no HMR\n        /******/ /******/ // no HMR manifest\n        /******/ /******/ // no on chunks loaded\n        /******/ /******/ // no jsonp function\n        /******/ })();\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module can't be inlined because the eval devtool is used.\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_215432__(\"./src/index.ts\");\n        /******/ /******/ return __nested_webpack_exports__;\n    /******/ })();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LWp2ZWN0b3JtYXArY29yZUAxLjAuNF9qcXVlcnlAMy43LjFfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjBfX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7OztDQU9DLEdBQ0EsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRCxRQUFRRyxtQkFBT0EsQ0FBQywwRkFBUSxHQUFHQSxtQkFBT0EsQ0FBQyxtTEFBTztTQUN2RCxhQUtKO0FBQ0YsR0FBR0ssTUFBTSxTQUFTQyxrQ0FBa0MsRUFBRUMsaUNBQWlDO0lBQ3ZGLE9BQWdCLE1BQUgsR0FBSTtRQUNqQixNQUFNLEdBQUksSUFBSUMsc0JBQXVCO1lBRXJDLEdBQUcsR0FBRyxrREFDTjs7d0RBRXdELEdBQ3hELEdBQUcsR0FBSSxDQUFDQyx5QkFBeUJDLHFCQUFxQkM7Z0JBRXREO2dCQUNBQyxLQUFLO1lBRUwsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLDBDQUNOOztnREFFZ0QsR0FDaEQsR0FBRyxHQUFJLENBQUNILHlCQUF5QkMscUJBQXFCQztnQkFFdEQ7Z0JBQ0FDLEtBQUs7WUFFTCxHQUFHLEdBQUc7WUFFTixHQUFHLEdBQUcsMENBQ047O2dEQUVnRCxHQUNoRCxHQUFHLEdBQUksQ0FBQ0gseUJBQXlCQyxxQkFBcUJDO2dCQUV0RDtnQkFDQUMsS0FBSztZQUVMLEdBQUcsR0FBRztZQUVOLEdBQUcsR0FBRyxzQ0FDTjs7NENBRTRDLEdBQzVDLEdBQUcsR0FBSSxDQUFDSCx5QkFBeUJDLHFCQUFxQkM7Z0JBRXREO2dCQUNBQyxLQUFLO1lBRUwsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLDRDQUNOOztrREFFa0QsR0FDbEQsR0FBRyxHQUFJLENBQUNILHlC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QVE7WUFDVDtRQUNYLE1BQU0sR0FDTixNQUFNLEdBQUssNkJBQTZCO1FBQ3hDLE1BQU0sR0FDTixNQUFNLEdBQUssaUJBQWlCO1FBQzVCLE1BQU0sR0FDTixNQUFNLEdBQUssZUFBZTtRQUMxQixNQUFNLEdBQ04sTUFBTSxHQUFLLFNBQVM7UUFDcEIsTUFBTSxHQUNOLE1BQU0sR0FBSyxrQkFBa0I7UUFDN0IsTUFBTSxHQUNOLE1BQU0sR0FBSyxzQkFBc0I7UUFDakMsTUFBTSxHQUNOLE1BQU0sR0FBSyxvQkFBb0I7UUFDL0IsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUNOLHdFQUF3RSxHQUN4RSxNQUFNLEdBQ04sTUFBTSxHQUFJLFVBQVU7UUFDcEIsTUFBTSxHQUFJLHVDQUF1QztRQUNqRCxNQUFNLEdBQUksdUVBQXVFO1FBQ2pGLE1BQU0sR0FBSSxJQUFJbkMsMEJBQW1CQSxHQUFHQyxpQ0FBbUJBLENBQUM7UUFDeEQsTUFBTSxHQUNOLE1BQU0sR0FBSSxPQUFPRCwwQkFBbUJBO0lBQ3BDLE1BQU0sR0FBRztBQUVUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0ZXJpYWwtdGFpbHdpbmQtZGFzaGJvYXJkLW5leHRqcy1wcm8vLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LWp2ZWN0b3JtYXArY29yZUAxLjAuNF9qcXVlcnlAMy43LjFfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjBfX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS9kaXN0L2luZGV4LmpzPzJhOWIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIiksIHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJqcXVlcnlcIiwgXCJyZWFjdFwiXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeShyZXF1aXJlKFwianF1ZXJ5XCIpLCByZXF1aXJlKFwicmVhY3RcIikpIDogZmFjdG9yeShyb290W1wianF1ZXJ5XCJdLCByb290W1wicmVhY3RcIl0pO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9qcXVlcnlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9NYXBDb250YWluZXIvTWFwQ29udGFpbmVyLnRzeFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvTWFwQ29udGFpbmVyL01hcENvbnRhaW5lci50c3ggKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiTWFwQ29udGFpbmVyXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFwQ29udGFpbmVyKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVhY3QgKi8gXFxcInJlYWN0XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNsYXNzbmFtZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNsYXNzbmFtZXMgKi8gXFxcIi4uLy4uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNsYXNzbmFtZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjbGFzc25hbWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bGVzX21vZHVsZV9zY3NzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0eWxlcy5tb2R1bGUuc2NzcyAqLyBcXFwiLi9zcmMvY29tcG9uZW50cy9NYXBDb250YWluZXIvc3R5bGVzLm1vZHVsZS5zY3NzXFxcIik7XFxuXFxuXFxuXFxuY29uc3QgTWFwQ29udGFpbmVyID0gKHtcXG4gIGNvbnRhaW5lclJlZixcXG4gIGNsYXNzTmFtZSxcXG4gIHN0eWxlXFxufSkgPT4gLyojX19QVVJFX18qL3JlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIsIHtcXG4gIHN0eWxlOiBzdHlsZSxcXG4gIGNsYXNzTmFtZTogY2xhc3NuYW1lc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKShfc3R5bGVzX21vZHVsZV9zY3NzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXS5yb290LCBjbGFzc05hbWUpLFxcbiAgcmVmOiBjb250YWluZXJSZWZcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AcmVhY3QtanZlY3Rvcm1hcC9jb3JlLy4vc3JjL2NvbXBvbmVudHMvTWFwQ29udGFpbmVyL01hcENvbnRhaW5lci50c3g/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL01hcENvbnRhaW5lci9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL01hcENvbnRhaW5lci9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiTWFwQ29udGFpbmVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX01hcENvbnRhaW5lcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLk1hcENvbnRhaW5lcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX01hcENvbnRhaW5lcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9NYXBDb250YWluZXIgKi8gXFxcIi4vc3JjL2NvbXBvbmVudHMvTWFwQ29udGFpbmVyL01hcENvbnRhaW5lci50c3hcXFwiKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AcmVhY3QtanZlY3Rvcm1hcC9jb3JlLy4vc3JjL2NvbXBvbmVudHMvTWFwQ29udGFpbmVyL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9NdWx0aU1hcC9NdWx0aU1hcC50c3hcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9NdWx0aU1hcC9NdWx0aU1hcC50c3ggKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIk11bHRpTWFwXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTXVsdGlNYXApXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWFjdCAqLyBcXFwicmVhY3RcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihyZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9NYXBDb250YWluZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL01hcENvbnRhaW5lciAqLyBcXFwiLi9zcmMvY29tcG9uZW50cy9NYXBDb250YWluZXIvaW5kZXgudHNcXFwiKTtcXG5cXG5cXG5cXG5jb25zdCBNdWx0aU1hcCA9ICh7XFxuICBtYXBSZWYsXFxuICBzdHlsZSxcXG4gIGNsYXNzTmFtZSxcXG4gIC4uLnByb3BzXFxufSkgPT4ge1xcbiAgY29uc3QgY29udGFpbmVyUmVmID0gKDAscmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy51c2VSZWYpKG51bGwpO1xcbiAgKDAscmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy51c2VMYXlvdXRFZmZlY3QpKCgpID0+IHtcXG4gICAgY29uc3QgbWFwQ29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XFxuICAgIGNvbnN0IHtcXG4gICAgICBtYWluLFxcbiAgICAgIC4uLnJlc3RcXG4gICAgfSA9IHByb3BzO1xcbiAgICBjb25zdCB7XFxuICAgICAgbWFwOiB7XFxuICAgICAgICBuYW1lLFxcbiAgICAgICAgY29udGVudFxcbiAgICAgIH0sXFxuICAgICAgLi4ucmVzdE1haW5cXG4gICAgfSA9IG1haW47XFxuICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKS5mbi52ZWN0b3JNYXAoXFxcImFkZE1hcFxcXCIsIG5hbWUsIGNvbnRlbnQpO1xcblxcbiAgICBpZiAobWFwQ29udGFpbmVyKSB7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKG1hcENvbnRhaW5lcikubXVsdGlNYXAoe1xcbiAgICAgICAgbWFpbjogeyAuLi5yZXN0TWFpbixcXG4gICAgICAgICAgbWFwOiBuYW1lXFxuICAgICAgICB9LFxcbiAgICAgICAgLi4ucmVzdFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9LCBbbWFwUmVmLCBwcm9wc10pO1xcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9yZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKS5jcmVhdGVFbGVtZW50KF9NYXBDb250YWluZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5NYXBDb250YWluZXIsIHtcXG4gICAgc3R5bGU6IHN0eWxlLFxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcXG4gICAgY29udGFpbmVyUmVmOiBjb250YWluZXJSZWZcXG4gIH0pO1xcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uL3NyYy9jb21wb25lbnRzL011bHRpTWFwL011bHRpTWFwLnRzeD9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvTXVsdGlNYXAvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL011bHRpTWFwL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIk11bHRpTWFwXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX011bHRpTWFwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uTXVsdGlNYXApXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9NdWx0aU1hcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9NdWx0aU1hcCAqLyBcXFwiLi9zcmMvY29tcG9uZW50cy9NdWx0aU1hcC9NdWx0aU1hcC50c3hcXFwiKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AcmVhY3QtanZlY3Rvcm1hcC9jb3JlLy4vc3JjL2NvbXBvbmVudHMvTXVsdGlNYXAvaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZlY3Rvck1hcC9WZWN0b3JNYXAudHN4XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WZWN0b3JNYXAvVmVjdG9yTWFwLnRzeCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJWZWN0b3JNYXBcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBWZWN0b3JNYXApXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWFjdCAqLyBcXFwicmVhY3RcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihyZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9NYXBDb250YWluZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL01hcENvbnRhaW5lciAqLyBcXFwiLi9zcmMvY29tcG9uZW50cy9NYXBDb250YWluZXIvaW5kZXgudHNcXFwiKTtcXG5cXG5cXG5cXG5jb25zdCBWZWN0b3JNYXAgPSAoe1xcbiAgbWFwLFxcbiAgbWFwUmVmLFxcbiAgc3R5bGUsXFxuICBjbGFzc05hbWUsXFxuICBzZXJpZXMsXFxuICAuLi5wcm9wc1xcbn0pID0+IHtcXG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9ICgwLHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18udXNlUmVmKShudWxsKTtcXG4gICgwLHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18udXNlTGF5b3V0RWZmZWN0KSgoKSA9PiB7XFxuICAgIGNvbnN0IG1hcENvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xcblxcbiAgICBpZiAoIW1hcCkge1xcbiAgICAgIGNvbnNvbGUuZXJyb3IoXFxcIltyZWFjdC1qdmVjdG9ybWFwXTogbm8gbWFwIHdhcyBsb2FkZWQhXFxcIik7XFxuICAgIH1cXG5cXG4gICAgY29uc3Qge1xcbiAgICAgIG5hbWUsXFxuICAgICAgY29udGVudFxcbiAgICB9ID0gbWFwO1xcbiAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0KCkuZm4udmVjdG9yTWFwKFxcXCJhZGRNYXBcXFwiLCBuYW1lLCBjb250ZW50KTtcXG5cXG4gICAgaWYgKG1hcENvbnRhaW5lcikge1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKShtYXBDb250YWluZXIpLnZlY3Rvck1hcCh7XFxuICAgICAgICBtYXA6IG5hbWUsXFxuICAgICAgICBzZXJpZXMsXFxuICAgICAgICAuLi5wcm9wc1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChtYXAgJiYgKG1hcFJlZiA9PT0gbnVsbCB8fCBtYXBSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcFJlZi5jdXJyZW50KSA9PT0gbnVsbCkge1xcbiAgICAgICAgbWFwUmVmLmN1cnJlbnQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0KCkobWFwQ29udGFpbmVyKS52ZWN0b3JNYXAoXFxcImdldFxcXCIsIFxcXCJtYXBPYmplY3RcXFwiKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIFttYXAsIG1hcFJlZiwgcHJvcHMsIHNlcmllc10pO1xcbiAgKDAscmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy51c2VFZmZlY3QpKCgpID0+IHtcXG4gICAgY29uc3QgbWFwQ29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XFxuXFxuICAgIGlmIChzZXJpZXMgJiYgbWFwQ29udGFpbmVyKSB7XFxuICAgICAgY29uc3QgbWFwID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKG1hcENvbnRhaW5lcikudmVjdG9yTWFwKFxcXCJnZXRcXFwiLCBcXFwibWFwT2JqZWN0XFxcIik7XFxuICAgICAgY29uc3Qge1xcbiAgICAgICAgbWFya2VycyA9IFtdLFxcbiAgICAgICAgcmVnaW9ucyA9IFtdXFxuICAgICAgfSA9IHNlcmllcztcXG4gICAgICByZWdpb25zLmZvckVhY2goKHtcXG4gICAgICAgIHZhbHVlc1xcbiAgICAgIH0sIGluZGV4KSA9PiB7XFxuICAgICAgICB2YXIgX21hcCRzZXJpZXM7XFxuXFxuICAgICAgICBpZiAodmFsdWVzICYmIChfbWFwJHNlcmllcyA9IG1hcC5zZXJpZXMpICE9PSBudWxsICYmIF9tYXAkc2VyaWVzICE9PSB2b2lkIDAgJiYgX21hcCRzZXJpZXMucmVnaW9ucykge1xcbiAgICAgICAgICB2YXIgX21hcCRzZXJpZXMyLCBfbWFwJHNlcmllczIkcmVnaW9ucyQ7XFxuXFxuICAgICAgICAgIChfbWFwJHNlcmllczIgPSBtYXAuc2VyaWVzKSA9PT0gbnVsbCB8fCBfbWFwJHNlcmllczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbWFwJHNlcmllczIkcmVnaW9ucyQgPSBfbWFwJHNlcmllczIucmVnaW9uc1tpbmRleF0pID09PSBudWxsIHx8IF9tYXAkc2VyaWVzMiRyZWdpb25zJCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hcCRzZXJpZXMyJHJlZ2lvbnMkLmNsZWFyQW5kU2V0KHZhbHVlcyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgbWFya2Vycy5mb3JFYWNoKCh7XFxuICAgICAgICB2YWx1ZXNcXG4gICAgICB9LCBpbmRleCkgPT4ge1xcbiAgICAgICAgdmFyIF9tYXAkc2VyaWVzMztcXG5cXG4gICAgICAgIGlmICh2YWx1ZXMgJiYgKF9tYXAkc2VyaWVzMyA9IG1hcC5zZXJpZXMpICE9PSBudWxsICYmIF9tYXAkc2VyaWVzMyAhPT0gdm9pZCAwICYmIF9tYXAkc2VyaWVzMy5tYXJrZXJzKSB7XFxuICAgICAgICAgIHZhciBfbWFwJHNlcmllczQsIF9tYXAkc2VyaWVzNCRtYXJrZXJzJDtcXG5cXG4gICAgICAgICAgKF9tYXAkc2VyaWVzNCA9IG1hcC5zZXJpZXMpID09PSBudWxsIHx8IF9tYXAkc2VyaWVzNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9tYXAkc2VyaWVzNCRtYXJrZXJzJCA9IF9tYXAkc2VyaWVzNC5tYXJrZXJzW2luZGV4XSkgPT09IG51bGwgfHwgX21hcCRzZXJpZXM0JG1hcmtlcnMkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWFwJHNlcmllczQkbWFya2VycyQuY2xlYXJBbmRTZXQodmFsdWVzKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSwgW3Nlcmllc10pO1xcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9yZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKS5jcmVhdGVFbGVtZW50KF9NYXBDb250YWluZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5NYXBDb250YWluZXIsIHtcXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXFxuICAgIHN0eWxlOiBzdHlsZSxcXG4gICAgY29udGFpbmVyUmVmOiBjb250YWluZXJSZWZcXG4gIH0pO1xcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uL3NyYy9jb21wb25lbnRzL1ZlY3Rvck1hcC9WZWN0b3JNYXAudHN4P1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WZWN0b3JNYXAvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WZWN0b3JNYXAvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIlZlY3Rvck1hcFxcXCI6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9WZWN0b3JNYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5WZWN0b3JNYXApXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WZWN0b3JNYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVmVjdG9yTWFwICovIFxcXCIuL3NyYy9jb21wb25lbnRzL1ZlY3Rvck1hcC9WZWN0b3JNYXAudHN4XFxcIik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uL3NyYy9jb21wb25lbnRzL1ZlY3Rvck1hcC9pbmRleC50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIlZlY3Rvck1hcFxcXCI6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9WZWN0b3JNYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5WZWN0b3JNYXApLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIk11bHRpTWFwXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX011bHRpTWFwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uTXVsdGlNYXApXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WZWN0b3JNYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVmVjdG9yTWFwICovIFxcXCIuL3NyYy9jb21wb25lbnRzL1ZlY3Rvck1hcC9pbmRleC50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfTXVsdGlNYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vTXVsdGlNYXAgKi8gXFxcIi4vc3JjL2NvbXBvbmVudHMvTXVsdGlNYXAvaW5kZXgudHNcXFwiKTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AcmVhY3QtanZlY3Rvcm1hcC9jb3JlLy4vc3JjL2NvbXBvbmVudHMvaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiTXVsdGlNYXBcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfY29tcG9uZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLk11bHRpTWFwKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJWZWN0b3JNYXBcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfY29tcG9uZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLlZlY3Rvck1hcCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiQXR0cmlidXRlU2VyaWVzQnVpbGRlclxcXCI6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkF0dHJpYnV0ZVNlcmllc0J1aWxkZXIpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkxhYmVsc0J1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5MYWJlbHNCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJMYWJlbHNQcm9wc0J1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5MYWJlbHNQcm9wc0J1aWxkZXIpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIk1hcmtlckJ1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5NYXJrZXJCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJNdWx0aU1hcEJ1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5NdWx0aU1hcEJ1aWxkZXIpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIlNlcmllc0J1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5TZXJpZXNCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJTdHlsZUJ1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5TdHlsZUJ1aWxkZXIpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIlZlY3Rvck1hcEJ1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5WZWN0b3JNYXBCdWlsZGVyKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVhY3RfanZlY3Rvcm1hcF9saWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEByZWFjdC1qdmVjdG9ybWFwL2xpYiAqLyBcXFwiLi4vanZlY3Rvcm1hcC9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbXBvbmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tcG9uZW50cyAqLyBcXFwiLi9zcmMvY29tcG9uZW50cy9pbmRleC50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMgKi8gXFxcIi4vc3JjL3V0aWxzL2luZGV4LnRzXFxcIik7XFxuXFxuXFxuXFxuXFxuKDAsX3JlYWN0X2p2ZWN0b3JtYXBfbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ubG9hZEpWZWN0b3JNYXApKChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0KCkpKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AcmVhY3QtanZlY3Rvcm1hcC9jb3JlLy4vc3JjL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvYnVpbGRlcnMvQXR0cmlidXRlU2VyaWVzQnVpbGRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2J1aWxkZXJzL0F0dHJpYnV0ZVNlcmllc0J1aWxkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiQXR0cmlidXRlU2VyaWVzQnVpbGRlclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEF0dHJpYnV0ZVNlcmllc0J1aWxkZXIpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuY2xhc3MgQXR0cmlidXRlU2VyaWVzQnVpbGRlciB7XFxuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGUpIHtcXG4gICAgdGhpcy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVcXG4gICAqL1xcblxcblxcbiAgc2V0QXR0cmlidXRlKHZhbHVlKSB7XFxuICAgIHRoaXMuYXR0cmlidXRlID0gdmFsdWU7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldFNjYWxlKHZhbHVlKSB7XFxuICAgIHRoaXMuc2NhbGUgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVcXG4gICAqL1xcblxcblxcbiAgc2V0VmFsdWVzKHZhbHVlKSB7XFxuICAgIHRoaXMudmFsdWVzID0gdmFsdWU7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldE5vcm1hbGl6ZUZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHRoaXMubm9ybWFsaXplRnVuY3Rpb24gPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICBidWlsZCgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBzY2FsZTogdGhpcy5zY2FsZSxcXG4gICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzLFxcbiAgICAgIGF0dHJpYnV0ZTogdGhpcy5hdHRyaWJ1dGUsXFxuICAgICAgbm9ybWFsaXplRnVuY3Rpb246IHRoaXMubm9ybWFsaXplRnVuY3Rpb25cXG4gICAgfTtcXG4gIH1cXG5cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uL3NyYy91dGlscy9idWlsZGVycy9BdHRyaWJ1dGVTZXJpZXNCdWlsZGVyLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvYnVpbGRlcnMvTGFiZWxzQnVpbGRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2J1aWxkZXJzL0xhYmVsc0J1aWxkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiTGFiZWxzQnVpbGRlclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIExhYmVsc0J1aWxkZXIpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscyAqLyBcXFwiLi9zcmMvdXRpbHMvYnVpbGRlcnMvdXRpbHMudHNcXFwiKTtcXG5cXG5jbGFzcyBMYWJlbHNCdWlsZGVyIHtcXG4gIC8qKlxcbiAgICpcXG4gICAqIEBwYXJhbSB2YWx1ZXNcXG4gICAqL1xcbiAgYWRkTWFya2Vyc0xhYmVsUHJvcHMoLi4udmFsdWVzKSB7XFxuICAgIGlmICghdGhpcy5tYXJrZXJzKSB7XFxuICAgICAgdGhpcy5tYXJrZXJzID0gW107XFxuICAgIH1cXG5cXG4gICAgdGhpcy5tYXJrZXJzLnB1c2goLi4udmFsdWVzKTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVzXFxuICAgKi9cXG5cXG5cXG4gIGFkZFJlZ2lvbnNMYWJlbFByb3BzKC4uLnZhbHVlcykge1xcbiAgICBpZiAoIXRoaXMucmVnaW9ucykge1xcbiAgICAgIHRoaXMucmVnaW9ucyA9IFtdO1xcbiAgICB9XFxuXFxuICAgIHRoaXMucmVnaW9ucy5wdXNoKC4uLnZhbHVlcyk7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgYnVpbGQoKSB7XFxuICAgIHJldHVybiAoMCxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zdHJpcFVuZGVmaW5lZFZhbHVlcykoe1xcbiAgICAgIG1hcmtlcnM6IHRoaXMubWFya2VycyxcXG4gICAgICByZWdpb25zOiB0aGlzLnJlZ2lvbnNcXG4gICAgfSk7XFxuICB9XFxuXFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0ByZWFjdC1qdmVjdG9ybWFwL2NvcmUvLi9zcmMvdXRpbHMvYnVpbGRlcnMvTGFiZWxzQnVpbGRlci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2J1aWxkZXJzL0xhYmVsc1Byb3BzQnVpbGRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvYnVpbGRlcnMvTGFiZWxzUHJvcHNCdWlsZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiTGFiZWxzUHJvcHNCdWlsZGVyXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTGFiZWxzUHJvcHNCdWlsZGVyKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmNsYXNzIExhYmVsc1Byb3BzQnVpbGRlciB7XFxuICBjb25zdHJ1Y3RvcihyZW5kZXIsIG9mZnNldHMpIHtcXG4gICAgdGhpcy5yZW5kZXIgPSByZW5kZXI7XFxuICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gcmVuZGVyXFxuICAgKi9cXG5cXG5cXG4gIHNldFJlbmRlcihyZW5kZXIpIHtcXG4gICAgdGhpcy5yZW5kZXIgPSByZW5kZXI7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIG9mZnNldHNcXG4gICAqL1xcblxcblxcbiAgc2V0T2Zmc2V0cyhvZmZzZXRzKSB7XFxuICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICovXFxuXFxuXFxuICBidWlsZCgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICByZW5kZXI6IHRoaXMucmVuZGVyLFxcbiAgICAgIG9mZnNldHM6IHRoaXMub2Zmc2V0c1xcbiAgICB9O1xcbiAgfVxcblxcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AcmVhY3QtanZlY3Rvcm1hcC9jb3JlLy4vc3JjL3V0aWxzL2J1aWxkZXJzL0xhYmVsc1Byb3BzQnVpbGRlci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2J1aWxkZXJzL01hcmtlckJ1aWxkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9idWlsZGVycy9NYXJrZXJCdWlsZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIk1hcmtlckJ1aWxkZXJcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBNYXJrZXJCdWlsZGVyKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmNsYXNzIE1hcmtlckJ1aWxkZXIge1xcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcXG4gICAgdGhpcy5uYW1lID0gdmFsdWU7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVcXG4gICAqL1xcblxcblxcbiAgc2V0TmFtZSh2YWx1ZSkge1xcbiAgICB0aGlzLm5hbWUgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVcXG4gICAqL1xcblxcblxcbiAgc2V0Q29vcmRzKHZhbHVlKSB7XFxuICAgIHRoaXMubGF0TG5nID0gdW5kZWZpbmVkO1xcbiAgICB0aGlzLmNvb3JkcyA9IHZhbHVlO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIC8qKlxcbiAgICpcXG4gICAqIEBwYXJhbSB2YWx1ZVxcbiAgICovXFxuXFxuXFxuICBzZXRMYXRMbmcodmFsdWUpIHtcXG4gICAgdGhpcy5jb29yZHMgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMubGF0TG5nID0gdmFsdWU7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldFN0eWxlKHZhbHVlKSB7XFxuICAgIHRoaXMuc3R5bGUgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKi9cXG5cXG5cXG4gIGJ1aWxkKCkge1xcbiAgICBjb25zdCBjb21tb25Qcm9wcyA9IHtcXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXFxuICAgICAgc3R5bGU6IHRoaXMuc3R5bGVcXG4gICAgfTtcXG5cXG4gICAgaWYgKHRoaXMuY29vcmRzKSB7XFxuICAgICAgcmV0dXJuIHsgLi4uY29tbW9uUHJvcHMsXFxuICAgICAgICBjb29yZHM6IHRoaXMuY29vcmRzXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICh0aGlzLmxhdExuZykge1xcbiAgICAgIHJldHVybiB7IC4uLmNvbW1vblByb3BzLFxcbiAgICAgICAgbGF0TG5nOiB0aGlzLmxhdExuZ1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHsgLi4uY29tbW9uUHJvcHMsXFxuICAgICAgbGF0TG5nOiBbMCwgMF1cXG4gICAgfTtcXG4gIH1cXG5cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uL3NyYy91dGlscy9idWlsZGVycy9NYXJrZXJCdWlsZGVyLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvYnVpbGRlcnMvTXVsdGlNYXBCdWlsZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9idWlsZGVycy9NdWx0aU1hcEJ1aWxkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJNdWx0aU1hcEJ1aWxkZXJcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBNdWx0aU1hcEJ1aWxkZXIpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscyAqLyBcXFwiLi9zcmMvdXRpbHMvYnVpbGRlcnMvdXRpbHMudHNcXFwiKTtcXG5cXG5jbGFzcyBNdWx0aU1hcEJ1aWxkZXIge1xcbiAgY29uc3RydWN0b3IobWFpbk1hcCwgbWF4TGV2ZWwgPSAxKSB7XFxuICAgIHRoaXMubWFpbiA9IHtcXG4gICAgICBtYXA6IG1haW5NYXBcXG4gICAgfTtcXG4gICAgdGhpcy5tYXhMZXZlbCA9IG1heExldmVsO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldE1haW5NYXAodmFsdWUpIHtcXG4gICAgdGhpcy5tYWluLm1hcCA9IHZhbHVlO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIC8qKlxcbiAgICpcXG4gICAqIEBwYXJhbSB2YWx1ZVxcbiAgICovXFxuXFxuXFxuICBzZXRNYXhMZXZlbCh2YWx1ZSkge1xcbiAgICB0aGlzLm1heExldmVsID0gdmFsdWU7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldE1hcE5hbWVCeUNvZGUodmFsdWUpIHtcXG4gICAgdGhpcy5tYXBOYW1lQnlDb2RlID0gdmFsdWU7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldFVybEJ5Q29kZSh2YWx1ZSkge1xcbiAgICB0aGlzLm1hcFVybEJ5Q29kZSA9IHZhbHVlO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIC8qKlxcbiAgICpcXG4gICAqIEBwYXJhbSB2YWx1ZVxcbiAgICovXFxuXFxuXFxuICBzZXRHZXREcmlsbERvd25NYXAodmFsdWUpIHtcXG4gICAgdGhpcy5nZXREcmlsbERvd25NYXAgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICBidWlsZCgpIHtcXG4gICAgY29uc3QgYmFzZVByb3BzID0ge1xcbiAgICAgIG1haW46IHRoaXMubWFpbixcXG4gICAgICBtYXhMZXZlbDogdGhpcy5tYXhMZXZlbFxcbiAgICB9O1xcbiAgICByZXR1cm4geyAuLi5iYXNlUHJvcHMsXFxuICAgICAgLi4uKDAsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uc3RyaXBVbmRlZmluZWRWYWx1ZXMpKHtcXG4gICAgICAgIG1hcE5hbWVCeUNvZGU6IHRoaXMubWFwTmFtZUJ5Q29kZSxcXG4gICAgICAgIG1hcFVybEJ5Q29kZTogdGhpcy5tYXBVcmxCeUNvZGUsXFxuICAgICAgICBnZXREcmlsbERvd25NYXA6IHRoaXMuZ2V0RHJpbGxEb3duTWFwXFxuICAgICAgfSlcXG4gICAgfTtcXG4gIH1cXG5cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uL3NyYy91dGlscy9idWlsZGVycy9NdWx0aU1hcEJ1aWxkZXIudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9idWlsZGVycy9TZXJpZXNCdWlsZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvYnVpbGRlcnMvU2VyaWVzQnVpbGRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJTZXJpZXNCdWlsZGVyXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VyaWVzQnVpbGRlcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzICovIFxcXCIuL3NyYy91dGlscy9idWlsZGVycy91dGlscy50c1xcXCIpO1xcblxcbmNsYXNzIFNlcmllc0J1aWxkZXIge1xcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlc1xcbiAgICovXFxuICBhZGRNYXJrZXJzU2VyaWVzKC4uLnZhbHVlcykge1xcbiAgICBpZiAoIXRoaXMubWFya2Vycykge1xcbiAgICAgIHRoaXMubWFya2VycyA9IFtdO1xcbiAgICB9XFxuXFxuICAgIHRoaXMubWFya2Vycy5wdXNoKC4uLnZhbHVlcyk7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlc1xcbiAgICovXFxuXFxuXFxuICBhZGRSZWdpb25zU2VyaWVzKC4uLnZhbHVlcykge1xcbiAgICBpZiAoIXRoaXMucmVnaW9ucykge1xcbiAgICAgIHRoaXMucmVnaW9ucyA9IFtdO1xcbiAgICB9XFxuXFxuICAgIHRoaXMucmVnaW9ucy5wdXNoKC4uLnZhbHVlcyk7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgYnVpbGQoKSB7XFxuICAgIHJldHVybiAoMCxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zdHJpcFVuZGVmaW5lZFZhbHVlcykoe1xcbiAgICAgIG1hcmtlcnM6IHRoaXMubWFya2VycyxcXG4gICAgICByZWdpb25zOiB0aGlzLnJlZ2lvbnNcXG4gICAgfSk7XFxuICB9XFxuXFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0ByZWFjdC1qdmVjdG9ybWFwL2NvcmUvLi9zcmMvdXRpbHMvYnVpbGRlcnMvU2VyaWVzQnVpbGRlci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2J1aWxkZXJzL1N0eWxlQnVpbGRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvYnVpbGRlcnMvU3R5bGVCdWlsZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiU3R5bGVCdWlsZGVyXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3R5bGVCdWlsZGVyKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMgKi8gXFxcIi4vc3JjL3V0aWxzL2J1aWxkZXJzL3V0aWxzLnRzXFxcIik7XFxuXFxuY2xhc3MgU3R5bGVCdWlsZGVyIHtcXG4gIC8qKlxcbiAgICpcXG4gICAqIEBwYXJhbSB2YWx1ZVxcbiAgICovXFxuICBzZXRJbml0aWFsKHZhbHVlKSB7XFxuICAgIHRoaXMuaW5pdGlhbCA9IHZhbHVlO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIC8qKlxcbiAgICpcXG4gICAqIEBwYXJhbSB2YWx1ZVxcbiAgICovXFxuXFxuXFxuICBzZXRTZWxlY3RlZCh2YWx1ZSkge1xcbiAgICB0aGlzLnNlbGVjdGVkID0gdmFsdWU7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldEhvdmVyKHZhbHVlKSB7XFxuICAgIHRoaXMuaG92ZXIgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVcXG4gICAqL1xcblxcblxcbiAgc2V0U2VsZWN0ZWRIb3Zlcih2YWx1ZSkge1xcbiAgICB0aGlzLnNlbGVjdGVkSG92ZXIgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICBidWlsZCgpIHtcXG4gICAgcmV0dXJuICgwLF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnN0cmlwVW5kZWZpbmVkVmFsdWVzKSh7XFxuICAgICAgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWQsXFxuICAgICAgc2VsZWN0ZWRIb3ZlcjogdGhpcy5zZWxlY3RlZEhvdmVyLFxcbiAgICAgIGhvdmVyOiB0aGlzLmhvdmVyLFxcbiAgICAgIGluaXRpYWw6IHRoaXMuaW5pdGlhbFxcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uL3NyYy91dGlscy9idWlsZGVycy9TdHlsZUJ1aWxkZXIudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9idWlsZGVycy9WZWN0b3JNYXBCdWlsZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvYnVpbGRlcnMvVmVjdG9yTWFwQnVpbGRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJWZWN0b3JNYXBCdWlsZGVyXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVmVjdG9yTWFwQnVpbGRlcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5jbGFzcyBWZWN0b3JNYXBCdWlsZGVyIHtcXG4gIHNlbGVjdGVkUmVnaW9ucyA9IFtdO1xcblxcbiAgY29uc3RydWN0b3IobWFwKSB7XFxuICAgIHRoaXMubWFwID0gbWFwO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldE1hcCh2YWx1ZSkge1xcbiAgICB0aGlzLm1hcCA9IHZhbHVlO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIC8qKlxcbiAgICpcXG4gICAqIEBwYXJhbSB2YWx1ZVxcbiAgICovXFxuXFxuXFxuICBzZXRCYWNrZ3JvdW5kQ29sb3IodmFsdWUpIHtcXG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVcXG4gICAqL1xcblxcblxcbiAgc2V0Wm9vbU1pbih2YWx1ZSkge1xcbiAgICB0aGlzLnpvb21NaW4gPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVcXG4gICAqL1xcblxcblxcbiAgc2V0Wm9vbU1heCh2YWx1ZSkge1xcbiAgICB0aGlzLnpvb21NYXggPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gbWFya2VyXFxuICAgKi9cXG5cXG5cXG4gIGFkZE1hcmtlcihtYXJrZXIpIHtcXG4gICAgaWYgKCF0aGlzLm1hcmtlcnMpIHtcXG4gICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcXG4gICAgfVxcblxcbiAgICB0aGlzLm1hcmtlcnMucHVzaChtYXJrZXIpO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIC8qKlxcbiAgICpcXG4gICAqIEBwYXJhbSB2YWx1ZVxcbiAgICovXFxuXFxuXFxuICBzZXRNYXJrZXJTdHlsZSh2YWx1ZSkge1xcbiAgICB0aGlzLm1hcmtlclN0eWxlID0gdmFsdWU7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldFJlZ2lvblN0eWxlKHZhbHVlKSB7XFxuICAgIHRoaXMucmVnaW9uU3R5bGUgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVcXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG5cXG5cXG4gIHNldE1hcmtlcnNTZWxlY3RhYmxlKHZhbHVlKSB7XFxuICAgIHRoaXMubWFya2Vyc1NlbGVjdGFibGUgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVcXG4gICAqL1xcblxcblxcbiAgc2V0TWFya2Vycyh2YWx1ZSkge1xcbiAgICB0aGlzLm1hcmtlcnMgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldFJlZ2lvbnNTZWxlY3RhYmxlKHZhbHVlKSB7XFxuICAgIHRoaXMucmVnaW9uc1NlbGVjdGFibGUgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldE9uUmVnaW9uVGlwU2hvdyh2YWx1ZSkge1xcbiAgICB0aGlzLm9uUmVnaW9uVGlwU2hvdyA9IHZhbHVlO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIC8qKlxcbiAgICpcXG4gICAqIEBwYXJhbSB2YWx1ZVxcbiAgICovXFxuXFxuXFxuICBzZXRTZXJpZXModmFsdWUpIHtcXG4gICAgdGhpcy5zZXJpZXMgPSB2YWx1ZTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICAvKipcXG4gICAqXFxuICAgKiBAcGFyYW0gdmFsdWVzXFxuICAgKi9cXG5cXG5cXG4gIHNldExhYmVscyh2YWx1ZXMpIHtcXG4gICAgdGhpcy5sYWJlbHMgPSB2YWx1ZXM7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgLyoqXFxuICAgKlxcbiAgICogQHBhcmFtIHZhbHVlXFxuICAgKi9cXG5cXG5cXG4gIHNldFNlbGVjdGVkUmVnaW9ucyh2YWx1ZSkge1xcbiAgICB0aGlzLnNlbGVjdGVkUmVnaW9ucyA9IHZhbHVlO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIC8qKlxcbiAgICpcXG4gICAqL1xcblxcblxcbiAgYnVpbGQoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgbWFwOiB0aGlzLm1hcCxcXG4gICAgICBzZXJpZXM6IHRoaXMuc2VyaWVzLFxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXFxuICAgICAgem9vbU1heDogdGhpcy56b29tTWF4LFxcbiAgICAgIHpvb21NaW46IHRoaXMuem9vbU1pbixcXG4gICAgICBtYXJrZXJTdHlsZTogdGhpcy5tYXJrZXJTdHlsZSxcXG4gICAgICByZWdpb25TdHlsZTogdGhpcy5yZWdpb25TdHlsZSxcXG4gICAgICBtYXJrZXJzU2VsZWN0YWJsZTogdGhpcy5tYXJrZXJzU2VsZWN0YWJsZSxcXG4gICAgICByZWdpb25zU2VsZWN0YWJsZTogdGhpcy5yZWdpb25zU2VsZWN0YWJsZSxcXG4gICAgICBtYXJrZXJzOiB0aGlzLm1hcmtlcnMsXFxuICAgICAgbGFiZWxzOiB0aGlzLmxhYmVscyxcXG4gICAgICBzZWxlY3RlZFJlZ2lvbnM6IHRoaXMuc2VsZWN0ZWRSZWdpb25zXFxuICAgIH07XFxuICB9XFxuXFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0ByZWFjdC1qdmVjdG9ybWFwL2NvcmUvLi9zcmMvdXRpbHMvYnVpbGRlcnMvVmVjdG9yTWFwQnVpbGRlci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2J1aWxkZXJzL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2J1aWxkZXJzL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJWZWN0b3JNYXBCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX1ZlY3Rvck1hcEJ1aWxkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5WZWN0b3JNYXBCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJNYXJrZXJCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX01hcmtlckJ1aWxkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5NYXJrZXJCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJTdHlsZUJ1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfU3R5bGVCdWlsZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uU3R5bGVCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJBdHRyaWJ1dGVTZXJpZXNCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX0F0dHJpYnV0ZVNlcmllc0J1aWxkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5BdHRyaWJ1dGVTZXJpZXNCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJTZXJpZXNCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX1Nlcmllc0J1aWxkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5TZXJpZXNCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJMYWJlbHNCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX0xhYmVsc0J1aWxkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5MYWJlbHNCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJMYWJlbHNQcm9wc0J1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfTGFiZWxzUHJvcHNCdWlsZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uTGFiZWxzUHJvcHNCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJNdWx0aU1hcEJ1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfTXVsdGlNYXBCdWlsZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uTXVsdGlNYXBCdWlsZGVyKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVmVjdG9yTWFwQnVpbGRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WZWN0b3JNYXBCdWlsZGVyICovIFxcXCIuL3NyYy91dGlscy9idWlsZGVycy9WZWN0b3JNYXBCdWlsZGVyLnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9NYXJrZXJCdWlsZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL01hcmtlckJ1aWxkZXIgKi8gXFxcIi4vc3JjL3V0aWxzL2J1aWxkZXJzL01hcmtlckJ1aWxkZXIudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1N0eWxlQnVpbGRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9TdHlsZUJ1aWxkZXIgKi8gXFxcIi4vc3JjL3V0aWxzL2J1aWxkZXJzL1N0eWxlQnVpbGRlci50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfQXR0cmlidXRlU2VyaWVzQnVpbGRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9BdHRyaWJ1dGVTZXJpZXNCdWlsZGVyICovIFxcXCIuL3NyYy91dGlscy9idWlsZGVycy9BdHRyaWJ1dGVTZXJpZXNCdWlsZGVyLnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9TZXJpZXNCdWlsZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1Nlcmllc0J1aWxkZXIgKi8gXFxcIi4vc3JjL3V0aWxzL2J1aWxkZXJzL1Nlcmllc0J1aWxkZXIudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX0xhYmVsc0J1aWxkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vTGFiZWxzQnVpbGRlciAqLyBcXFwiLi9zcmMvdXRpbHMvYnVpbGRlcnMvTGFiZWxzQnVpbGRlci50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfTGFiZWxzUHJvcHNCdWlsZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0xhYmVsc1Byb3BzQnVpbGRlciAqLyBcXFwiLi9zcmMvdXRpbHMvYnVpbGRlcnMvTGFiZWxzUHJvcHNCdWlsZGVyLnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9NdWx0aU1hcEJ1aWxkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vTXVsdGlNYXBCdWlsZGVyICovIFxcXCIuL3NyYy91dGlscy9idWlsZGVycy9NdWx0aU1hcEJ1aWxkZXIudHNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AcmVhY3QtanZlY3Rvcm1hcC9jb3JlLy4vc3JjL3V0aWxzL2J1aWxkZXJzL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvYnVpbGRlcnMvdXRpbHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvYnVpbGRlcnMvdXRpbHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcInN0cmlwVW5kZWZpbmVkVmFsdWVzXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc3RyaXBVbmRlZmluZWRWYWx1ZXMpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyoqXFxuICogcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSBvYmplY3RcXG4gKiBAcGFyYW0gb2JqZWN0XFxuICovXFxuY29uc3Qgc3RyaXBVbmRlZmluZWRWYWx1ZXMgPSBvYmplY3QgPT4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9iamVjdCkuZmlsdGVyKGVudHJ5ID0+IGVudHJ5WzFdICE9PSB1bmRlZmluZWQpKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AcmVhY3QtanZlY3Rvcm1hcC9jb3JlLy4vc3JjL3V0aWxzL2J1aWxkZXJzL3V0aWxzLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkF0dHJpYnV0ZVNlcmllc0J1aWxkZXJcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfYnVpbGRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5BdHRyaWJ1dGVTZXJpZXNCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJMYWJlbHNCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2J1aWxkZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uTGFiZWxzQnVpbGRlciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiTGFiZWxzUHJvcHNCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2J1aWxkZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uTGFiZWxzUHJvcHNCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJNYXJrZXJCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2J1aWxkZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uTWFya2VyQnVpbGRlciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiTXVsdGlNYXBCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2J1aWxkZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uTXVsdGlNYXBCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJTZXJpZXNCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2J1aWxkZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uU2VyaWVzQnVpbGRlciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiU3R5bGVCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2J1aWxkZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uU3R5bGVCdWlsZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJWZWN0b3JNYXBCdWlsZGVyXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2J1aWxkZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uVmVjdG9yTWFwQnVpbGRlcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2J1aWxkZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2J1aWxkZXJzICovIFxcXCIuL3NyYy91dGlscy9idWlsZGVycy9pbmRleC50c1xcXCIpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0ByZWFjdC1qdmVjdG9ybWFwL2NvcmUvLi9zcmMvdXRpbHMvaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi8uLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi8uLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohXFxuICBDb3B5cmlnaHQgKGMpIDIwMTggSmVkIFdhdHNvbi5cXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXFxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXFxuKi9cXG4vKiBnbG9iYWwgZGVmaW5lICovXFxuXFxuKGZ1bmN0aW9uICgpIHtcXG5cXHQndXNlIHN0cmljdCc7XFxuXFxuXFx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xcblxcblxcdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XFxuXFx0XFx0dmFyIGNsYXNzZXMgPSBbXTtcXG5cXG5cXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XFxuXFx0XFx0XFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcXG5cXG5cXHRcXHRcXHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcXG5cXHRcXHRcXHRcXHRjbGFzc2VzLnB1c2goYXJnKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xcblxcdFxcdFxcdFxcdGlmIChhcmcubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChpbm5lcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNsYXNzZXMucHVzaChpbm5lcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGFyZy50b1N0cmluZyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xcblxcdFxcdFxcdFxcdFxcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2xhc3Nlcy5wdXNoKGtleSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xcblxcdH1cXG5cXG5cXHRpZiAoIHRydWUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcXG5cXHRcXHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcXG5cXHR9IGVsc2UgaWYgKHRydWUpIHtcXG5cXHRcXHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXFxuXFx0XFx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gY2xhc3NOYW1lcztcXG5cXHRcXHR9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcXG5cXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XFxuXFx0fSBlbHNlIHt9XFxufSgpKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AcmVhY3QtanZlY3Rvcm1hcC9jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3JjL2NvbXBvbmVudHMvTWFwQ29udGFpbmVyL3N0eWxlcy5tb2R1bGUuc2Nzc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9jb21wb25lbnRzL01hcENvbnRhaW5lci9zdHlsZXMubW9kdWxlLnNjc3MgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfbm9Tb3VyY2VNYXBzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvbm9Tb3VyY2VNYXBzLmpzICovIFxcXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvbm9Tb3VyY2VNYXBzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfbm9Tb3VyY2VNYXBzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9ub1NvdXJjZU1hcHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzICovIFxcXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfZ2V0VXJsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzICovIFxcXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfZ2V0VXJsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9nZXRVcmxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XFxuLy8gSW1wb3J0c1xcblxcblxcblxcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyA9IG5ldyBVUkwoLyogYXNzZXQgaW1wb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18oLyohIGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaElBQWdBUE1BQVAvLy93QUFBTWJHeG9TRWhMYTJ0cHFhbWpZMk5sWldWdGpZMk9UazVMeTh2QjRlSGdRRUJBQUFBQUFBQUFBQUFDSC9DMDVGVkZORFFWQkZNaTR3QXdFQUFBQWgvaHBEY21WaGRHVmtJSGRwZEdnZ1lXcGhlR3h2WVdRdWFXNW1id0FoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNXhESVNXbGhwZXJONTJKTGhTU2RSZ3dWbzFJQ1FaUlVzaXdIcFRKVDRpb3dOUzh2eVcyaWNDRjZrOEhNTUJrQ0VEc2t4VEJEQVp3dUFra3FJZnhJUXloQlFCRnZBUVNESVRNNVZEVzZYTkU0S2FnTmg2Qmd3ZTYwc21RVUIzZDRSejFaQkFwbkZBU0RkMGhpaGgxMkJrRTlrakFKVmx5Y1hJZzdDUUlGQTZTbG5KODdwYXFiU0tpS29xdXNuYk1kbURDMnRYUWxrVWh6aVl0eVdUeElmeTZCRThXSnQ1WUp2cEppdnhOYUdtTEhUMFZuT2dTWWYwZFpYUzdBUGRwQjMwOVJuSE9HNWdEcVhHTERhQzQ1N0QxelovVi9ubU9NODJYaUhSTFlLaEtQMW9abUFEZEVBQUFoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNmhESVNXbFpwT3JOcDFsR05SU2RScERVb2xJR3c1UlVZaGhIdWtxRnU4RHNyRXlxbldUaEd2QW1oVmx0ZUJ2b2pwVEREQlVFSUZ3TUZCUkFtQmtTZ09yQkZab2dDQVN3QkRFWS9DWlNnN0dTRTBnU0NqUUJNVkcwMjN4V0Joa2xBbm9FZGhRRWZ5TnFNSWNLamhSc2pFZG5lekIrQTRrOGdUd0poRnVpVzRkb2tYaWxvVWVwQkFwNXFhS3BwNitIbzdhV1c1NHdsN29idkVlMGtSdW9wbENHZXB3U3gyakp2cUhFbUd0NndoSnBHcGZKQ0htT29OSEthSHg2MVdpU1I5MkU0bGJGb3ErQjZRRHR1ZXRjYUJQblc2K083d0RIcElpSzlTYVZLNUdnVjU0M3R6amdHY2doQWdBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTdoRElTU2t4cE9yTjV6RkhOV1JkaFNpVm9WTEhzcFJVTW95VWFreUVlOFBUUENBVFc5QTE0RTBVdnVBS01OQVpLWVVaQ2lCTXVCYWtTUUtHOEcyRnpVV294MkFVdEFRRmNCS2xWUW9MZ1FSZVpoUWxDSUplc1FYSTVCMENCblVNT3hNQ2Vub0NmVENFV0JzSkNvbFRNQU5sZHgxNUJHczhCNXdsQ1o5UG82T0prd21ScG5xa3FudVNyYXlxZkttcXBMYWpvaVc1SEpxN0ZMMUdyMm1NTWNLVU1JaUpnSWVteTd4WnRKc1Rtc000eEhpS3Y1S01DWHFmeVVDSkVvblhQTjJyQU9JQW1zZkIzdVBvQUsrK0crdzQ4ZWRaUEsrTTZoTEpwUWc0ODRlblhJZFFGU1MxdTZVaGtzRU5FUUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQk9jUXlFbXBHS0xxeldjWlJWVVFuWllnMWFCU2gyR1VWRUlRMmFRT0UrRytjRDRudHBXa1pRajFKSWlaSW9nREZGeUhJMFV4UXdGdWdNU09GSVBKZnRmVkFFb1pMQmJjTEVGaGxRaXFHcDFWZDE0MEFVa2xVTjNlQ0E1MUMxRVdNek1DZXpDQkJta3hWSVZIQldkM0hIbDlKUU9JSlNkU25KMFRES0NoQ3dVSmpvV01QYUdxREthbm5hc01vNlduTTU2MlI1WWx1WlJ3dXIwd3BncVpFN05LVW0rRk5SUEloakJKeEtadGVXdUlCTU40elJNSVZJaGZmY2dvandDRjExN2k0bmxMblk1enRSTHNuT2srYVYrb0pZN1Y3bTc2UGRrUzR0cktjZGcwWmMwdFRjS2tSQUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQk80UXlFa3BLcWpxelNjcFJhVmtYWldRRXhpbXcxQlNDVUVJbERvaHJmdDZjcEtDazV4aWQ1TU5KVGFBSWtla0tHUWtXeUtIa3ZoS3NSN0FSbWl0a0FZRFlSSWJVUVJRaldCd0pSekNoaTlDUmxCY1kxVU40ZzAvVk5CMEFsY3ZjQVlIUnlaUGRFUUZZVjhjY3dSNUhXeEVKMDJZbVJNTG5KMXhDWXAwWTVpZHBRdWhvcG1tQzJLZ29qS2FzVVFEazVCTkF3d01PaDJSdFJxNXVRdVBaS0dJSlFJR3dBd0dmNkkwSlhNcEM4QzdrWFdEQklORk14UzRES01BV1ZXQUdZc0FkTnFXNXVhUnhrU0tKT1pLYVUzdFBPQlo0RHVLMkxBVGdKaGtQSk1nVHdLQ2RGanlQSEVuS3hGQ0RoRUFBQ0g1QkFrS0FBQUFMQUFBQUFBZ0FDQUFBQVR6RU1oSmFWS3A2czJuSWtvbElKMldrQlNocGtWUldxcVFyaExTRXU5TVpKS0s5eTFacnFZSzlXaUNsbXZvVWFGOGdJUVNOZUYxRXI0TU5GbjRTUlNEQVJXcm9BSUVUZzFpVnd1SGpZQjFrWWMxbXdydXdYS0M5Z21zSlhsaUd4YytYaVVDYnk5eWRoMXNPU2RNa3BNVEJwYVhCenNmaG9jNWw1OEdtNXlUb0FhWmhhT1VxamtEZ0NXTkhBVUxDd09MYVRtenN3YWRFcWdnUXdnSHVRc0hJb1pDSFFNTVFnUUd1YlZFY3hPUEZBY01EQVlVQTg1ZVdBUm1mU1JRQ2RjTWUwemVQMUFBeWd3TGxKdFBOQUFMMTlEQVJkUHpCT1dTbTFickpCaTQ1c29SQVdRQUFrclFJeWtTaFE5d1ZoSEN3Q1FDQUNINUJBa0tBQUFBTEFBQUFBQWdBQ0FBQUFUckVNaEphVktwNnMybklrcUZaRjJWSUJXaFVzSmFUb2txVUNvQnErRTcxU1JRZXlxVVRvTEE3VnhGMEpEeUlRaC9NVlZQTXQxRUNabGZjalpKOW1JS29hVGwxTVJJbDVvNENVS1hPd215ckNJbkNLcWNXdHZhZEwyU1loeUFTeU5ESjB1SWlSTURqSTBGZDMwL2lJMlVBNUdTUzVVRGoybDZOb3FnT2dONGdrc0VCZ1lGZjBGRHFLZ0hueVo5T1g4SHJnWUhkSHBjSFFVTFhBUzJxS3BFTlJnN2VBTUxDN2tUQmFpeFVZRmtLQXpXQUFuTEM3RkxWeExXREJMS0N3YUtUVUxnRXdiTEE0aEp0T2tTQk5xSVRUM3hFZ2ZMcEJ0ekUvaml1TDA0UkdFQmd3V2hTaFJnUUV4SEJBQWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU3eERJU1dsU3Flck5weUpLaFdSZGxTQVZvVkxDV2s2SktsQXFBYXZoTzlVa1VIc3FsRTZDd08xY1JkQ1E4aUVJZnpGVlR6TGRSQW1aWDNJMlNmWmlDcUdrNWRURVNKZWFPQWxDbHpzSnNxd2lKd2lxbkZyYjJuUzlrbUljZ0VzalF5ZExpSWxIZWhocGVqYUlqemg5ZW9tU2paUitpcHNsV0lSTEFnTURPUjJET3FLb2dUQjlwQ1VKQmFnREJYUjZYQjBFQmtJSXNhUnNHR01NQXhvREJnWUhUS0ppVVlFR0RBekhDOUVBQ2NVR2tJZ0Z6Z3daMFFzU0JjWEhpUXZPd2dEZEV3ZkZzMHNEenQ0UzZCSzR4WWprRE96bjB1bkZlQnpPQmlqSW0xRGdtZzVZRlF3c0NNanAxb0o4THlJQUFDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHdFTWhKYVZLcDZzMm5Ja3FGWkYyVklCV2hVc0phVG9rcVVDb0JxK0U3MVNSUWV5cVVUb0xBN1Z4RjBKRHlJUWgvTVZWUE10MUVDWmxmY2paSjltSUtvYVRsMU1SSWw1bzRDVUtYT3dteXJDSW5DS3FjV3R2YWRMMlNZaHlBU3lOREowdUlpVWQ2R0dsNk5vaVBPSDE2aVpLTmxINktteVdGT2dnSGhFRXZBd3dNQTBOOUdCc0VDNmFtaG5WY0V3YXZEQWF6R3dJRGFIMWlwYVlMQlVUQ0dnUURBOE5kSHowRnBxZ1RCd3NMcUFiV0FBbklBNEZXS2RNTEdkWUdFZ3JhaWdiVDBPSVRCY2c1UXdQVDR4THJST1pMNkF1UUFQVVM3YnhMcG9XaWRZMEp0eExIS2h3d01KQlRIZ1BLZEVRQUFDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHJFTWhKYVZLcDZzMm5Ja3FGWkYyVklCV2hVc0phVG9rcVVDb0JxK0U3MVNSUWV5cVVUb0xBN1Z4RjBKRHlJUWgvTVZWUE10MUVDWmxmY2paSjltSUtvYVRsMU1SSWw1bzRDVUtYT3dteXJDSW5DS3FjV3R2YWRMMlNZaHlBU3lOREowdUlpVWQ2R0FVTERKQ1JpWG8xQ3BHWERKT1VqWStZaXA5RGhUb0pBNFJCTHdNTEN3VkRmUmdiQkFhcXFvWjFYQk1Ic3dzSHR4dEZhSDFpcWFvR05nQUl4UnBiRkFnZlBRU3FwYmdHQnFVRDF3QlhlQ1lwMUFZWjE5SkpPWWdIMUt3QTRVQnZRd1hVQnhQcVZEOUwzc2JwMkJOazJ4dnZGUEpkK01GQ042SEFBSUtnTmdnWTBLdEVCQUFoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNkJESVNXbFNxZXJOcHlKS2hXUmRsU0FWb1ZMQ1drNkpLbEFxQWF2aE85VWtVSHNxbEU2Q3dPMWNSZENROGlFSWZ6RlZUekxkUkFtWlgzSTJTZllJRE1hQUZkVEVTSmVhRURBSU14WUZxck9VYU5XNEU0T2JZY0NYYWlCVkVnVUxlME5KYXh4dFlrc2poMk5Ma1pJU2dEZ0poSHRoa3BVNG1XNmJsUmlZbVpPbGg0SldrRHFJTHdVR0JuRTZUWUViQ2dldnIwTjFnSDRBdDdnSGlScEZhTE5ycnE4SE5nQUpBNzBBV3hRSUgxK3ZzWU1EQXpaUVBDOVZDTmtEV1VoR2t1RTVQeEpOd2lVSzRVZkx6T2xENFd2ekFIYW9HOW54UGk1ZCtqWVVxZkFoaHlrT0Z3SldpQUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQlBBUXlFbHBVcW5xemFjaVNvVmtYVlVNRmFGU3dscE9DY01ZbEVyQWF2aE9Nbk5MTm84S3Nac01aSXRKRUlESUZTa0xHUW9RVE5oSXNGZWhSd3cyQ1FMS0YwdFlHS1lTZyt5Z3NaSXVOcUprc0tnYmZnSUdlcE5vMmNJVUIzVjFCM0l2TmlCWU5RYURTVHRmaGh4MEN3VlBJMFVKZTArYm00ZzVWZ2NHb3FPY25qbWpxRFNkbmhnRW9hbWNzWnVYTzFhV1F5OEtBd09BdVRZWUd3aTd3NWgrS3IwU0o4TUZpaHBOYngrNEVycTdCWUJ1enNkaUgxakNBem9TZmwwclZpck5iUlhsQkJsTFgrQlAwWEpMQVBHelRrQXVBT3FiMFdUNUFIN09jZENtNUI4VGdSd1NSS0lIUXRhTEN3ZzFSQUFBT3dBQUFBQUFBQUFBQUE9PSAqLyBcXFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoSUFBZ0FQTUFBUC8vL3dBQUFNYkd4b1NFaExhMnRwcWFtalkyTmxaV1Z0alkyT1RrNUx5OHZCNGVIZ1FFQkFBQUFBQUFBQUFBQUNIL0MwNUZWRk5EUVZCRk1pNHdBd0VBQUFBaC9ocERjbVZoZEdWa0lIZHBkR2dnWVdwaGVHeHZZV1F1YVc1bWJ3QWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU1eERJU1dsaHBlck41MkpMaFNTZFJnd1ZvMUlDUVpSVXNpd0hwVEpUNGlvd05TOHZ5VzJpY0NGNms4SE1NQmtDRURza3hUQkRBWnd1QWtrcUlmeElReWhCUUJGdkFRU0RJVE01VkRXNlhORTRLYWdOaDZCZ3dlNjBzbVFVQjNkNFJ6MVpCQXBuRkFTRGQwaGloaDEyQmtFOWtqQUpWbHljWElnN0NRSUZBNlNsbko4N3BhcWJTS2lLb3F1c25iTWRtREMydFhRbGtVaHppWXR5V1R4SWZ5NkJFOFdKdDVZSnZwSml2eE5hR21MSFQwVm5PZ1NZZjBkWlhTN0FQZHBCMzA5Um5IT0c1Z0RxWEdMRGFDNDU3RDF6Wi9WL25tT004MlhpSFJMWUtoS1Axb1ptQURkRUFBQWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU2aERJU1dsWnBPck5wMWxHTlJTZFJwRFVvbElHdzVSVVloaEh1a3FGdThEc3JFeXFuV1RoR3ZBbWhWbHRlQnZvanBURERCVUVJRndNRkJSQW1Ca1NnT3JCRlpvZ0NBU3dCREVZL0NaU2c3R1NFMGdTQ2pRQk1WRzAyM3hXQmhrbEFub0VkaFFFZnlOcU1JY0tqaFJzakVkbmV6QitBNGs4Z1R3SmhGdWlXNGRva1hpbG9VZXBCQXA1cWFLcHA2K0hvN2FXVzU0d2w3b2J2RWUwa1J1b3BsQ0dlcHdTeDJqSnZxSEVtR3Q2d2hKcEdwZkpDSG1Pb05IS2FIeDYxV2lTUjkyRTRsYkZvcStCNlFEdHVldGNhQlBuVzYrTzd3REhwSWlLOVNhVks1R2dWNTQzdHpqZ0djZ2hBZ0FoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFN2hESVNTa3hwT3JONXpGSE5XUmRoU2lWb1ZMSHNwUlVNb3lVYWt5RWU4UFRQQ0FUVzlBMTRFMFV2dUFLTU5BWktZVVpDaUJNdUJha1NRS0c4RzJGelVXb3gyQVV0QVFGY0JLbFZRb0xnUVJlWmhRbENJSmVzUVhJNUIwQ0JuVU1PeE1DZW5vQ2ZUQ0VXQnNKQ29sVE1BTmxkeDE1QkdzOEI1d2xDWjlQbzZPSmt3bVJwbnFrcW51U3JheXFmS21xcExham9pVzVISnE3RkwxR3IybU1NY0tVTUlpSmdJZW15N3hadEpzVG1zTTR4SGlLdjVLTUNYcWZ5VUNKRW9uWFBOMnJBT0lBbXNmQjN1UG9BSysrRyt3NDhlZFpQSytNNmhMSnBRZzQ4NGVuWElkUUZTUzF1NlVoa3NFTkVRQUFJZmtFQ1FvQUFBQXNBQUFBQUNBQUlBQUFCT2NReUVtcEdLTHF6V2NaUlZVUW5aWWcxYUJTaDJHVVZFSVEyYVFPRStHK2NENG50cFdrWlFqMUpJaVpJb2dERkZ5SEkwVXhRd0Z1Z01TT0ZJUEpmdGZWQUVvWkxCYmNMRUZobFFpcUdwMVZkMTQwQVVrbFVOM2VDQTUxQzFFV016TUNlekNCQm1reFZJVkhCV2QzSEhsOUpRT0lKU2RTbkowVERLQ2hDd1VKam9XTVBhR3FES2FubmFzTW82V25NNTYyUjVZbHVaUnd1cjB3cGdxWkU3TktVbStGTlJQSWhqQkp4S1p0ZVd1SUJNTjR6Uk1JVkloZmZjZ29qd0NGMTE3aTRubExuWTV6dFJMc25PaythVitvSlk3VjdtNzZQZGtTNHRyS2NkZzBaYzB0VGNLa1JBQUFJZmtFQ1FvQUFBQXNBQUFBQUNBQUlBQUFCTzRReUVrcEtxanF6U2NwUmFWa1haV1FFeGltdzFCU0NVRUlsRG9ocmZ0NmNwS0NrNXhpZDVNTkpUYUFJa2VrS0dRa1d5S0hrdmhLc1I3QVJtaXRrQVlEWVJJYlVRUlFqV0J3SlJ6Q2hpOUNSbEJjWTFVTjRnMC9WTkIwQWxjdmNBWUhSeVpQZEVRRllWOGNjd1I1SFd4RUowMlltUk1MbkoxeENZcDBZNWlkcFF1aG9wbW1DMktnb2pLYXNVUURrNUJOQXd3TU9oMlJ0UnE1dVF1UFpLR0lKUUlHd0F3R2Y2STBKWE1wQzhDN2tYV0RCSU5GTXhTNERLTUFXVldBR1lzQWROcVc1dWFSeGtTS0pPWkthVTN0UE9CWjREdUsyTEFUZ0poa1BKTWdUd0tDZEZqeVBIRW5LeEZDRGhFQUFDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHpFTWhKYVZLcDZzMm5Ja29sSUoyV2tCU2hwa1ZSV3FxUXJoTFNFdTlNWkpLSzl5MVpycVlLOVdpQ2xtdm9VYUY4Z0lRU05lRjFFcjRNTkZuNFNSU0RBUldyb0FJRVRnMWlWd3VIallCMWtZYzFtd3J1d1hLQzlnbXNKWGxpR3hjK1hpVUNieTl5ZGgxc09TZE1rcE1UQnBhWEJ6c2Zob2M1bDU4R201eVRvQWFaaGFPVXFqa0RnQ1dOSEFVTEN3T0xhVG16c3dhZEVxZ2dRd2dIdVFzSElvWkNIUU1NUWdRR3ViVkVjeE9QRkFjTURBWVVBODVlV0FSbWZTUlFDZGNNZTB6ZVAxQUF5Z3dMbEp0UE5BQUwxOURBUmRQekJPV1NtMWJySkJpNDVzb1JBV1FBQWtyUUl5a1NoUTl3VmhIQ3dDUUNBQ0g1QkFrS0FBQUFMQUFBQUFBZ0FDQUFBQVRyRU1oSmFWS3A2czJuSWtxRlpGMlZJQldoVXNKYVRva3FVQ29CcStFNzFTUlFleXFVVG9MQTdWeEYwSkR5SVFoL01WVlBNdDFFQ1psZmNqWko5bUlLb2FUbDFNUklsNW80Q1VLWE93bXlyQ0luQ0txY1d0dmFkTDJTWWh5QVN5TkRKMHVJaVJNRGpJMEZkMzAvaUkyVUE1R1NTNVVEajJsNk5vcWdPZ040Z2tzRUJnWUZmMEZEcUtnSG55WjlPWDhIcmdZSGRIcGNIUVVMWEFTMnFLcEVOUmc3ZUFNTEM3a1RCYWl4VVlGa0tBeldBQW5MQzdGTFZ4TFdEQkxLQ3dhS1RVTGdFd2JMQTRoSnRPa1NCTnFJVFQzeEVnZkxwQnR6RS9qaXVMMDRSR0VCZ3dXaFNoUmdRRXhIQkFBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTd4RElTV2xTcWVyTnB5SktoV1JkbFNBVm9WTENXazZKS2xBcUFhdmhPOVVrVUhzcWxFNkN3TzFjUmRDUThpRUlmekZWVHpMZFJBbVpYM0kyU2ZaaUNxR2s1ZFRFU0plYU9BbENsenNKc3F3aUp3aXFuRnJiMm5TOWttSWNnRXNqUXlkTGlJbEhlaGhwZWphSWp6aDllb21TalpSK2lwc2xXSVJMQWdNRE9SMkRPcUtvZ1RCOXBDVUpCYWdEQlhSNlhCMEVCa0lJc2FSc0dHTU1BeG9EQmdZSFRLSmlVWUVHREF6SEM5RUFDY1VHa0lnRnpnd1owUXNTQmNYSGlRdk93Z0RkRXdmRnMwc0R6dDRTNkJLNHhZamtET3puMHVuRmVCek9CaWpJbTFEZ21nNVlGUXdzQ01qcDFvSjhMeUlBQUNINUJBa0tBQUFBTEFBQUFBQWdBQ0FBQUFUd0VNaEphVktwNnMybklrcUZaRjJWSUJXaFVzSmFUb2txVUNvQnErRTcxU1JRZXlxVVRvTEE3VnhGMEpEeUlRaC9NVlZQTXQxRUNabGZjalpKOW1JS29hVGwxTVJJbDVvNENVS1hPd215ckNJbkNLcWNXdHZhZEwyU1loeUFTeU5ESjB1SWlVZDZHR2w2Tm9pUE9IMTZpWktObEg2S215V0ZPZ2dIaEVFdkF3d01BME45R0JzRUM2YW1oblZjRXdhdkRBYXpHd0lEYUgxaXBhWUxCVVRDR2dRREE4TmRIejBGcHFnVEJ3c0xxQWJXQUFuSUE0RldLZE1MR2RZR0VncmFpZ2JUME9JVEJjZzVRd1BUNHhMclJPWkw2QXVRQVBVUzdieExwb1dpZFkwSnR4TEhLaHd3TUpCVEhnUEtkRVFBQUNINUJBa0tBQUFBTEFBQUFBQWdBQ0FBQUFUckVNaEphVktwNnMybklrcUZaRjJWSUJXaFVzSmFUb2txVUNvQnErRTcxU1JRZXlxVVRvTEE3VnhGMEpEeUlRaC9NVlZQTXQxRUNabGZjalpKOW1JS29hVGwxTVJJbDVvNENVS1hPd215ckNJbkNLcWNXdHZhZEwyU1loeUFTeU5ESjB1SWlVZDZHQVVMREpDUmlYbzFDcEdYREpPVWpZK1lpcDlEaFRvSkE0UkJMd01MQ3dWRGZSZ2JCQWFxcW9aMVhCTUhzd3NIdHh0RmFIMWlxYW9HTmdBSXhScGJGQWdmUFFTcXBiZ0dCcVVEMXdCWGVDWXAxQVlaMTlKSk9ZZ0gxS3dBNFVCdlF3WFVCeFBxVkQ5TDNzYnAyQk5rMnh2dkZQSmQrTUZDTjZIQUFJS2dOZ2dZMEt0RUJBQWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU2QkRJU1dsU3Flck5weUpLaFdSZGxTQVZvVkxDV2s2SktsQXFBYXZoTzlVa1VIc3FsRTZDd08xY1JkQ1E4aUVJZnpGVlR6TGRSQW1aWDNJMlNmWUlETWFBRmRURVNKZWFFREFJTXhZRnFyT1VhTlc0RTRPYlljQ1hhaUJWRWdVTGUwTkpheHh0WWtzamgyTkxrWklTZ0RnSmhIdGhrcFU0bVc2YmxSaVltWk9saDRKV2tEcUlMd1VHQm5FNlRZRWJDZ2V2cjBOMWdINEF0N2dIaVJwRmFMTnJycThITmdBSkE3MEFXeFFJSDErdnNZTURBelpRUEM5VkNOa0RXVWhHa3VFNVB4Sk53aVVLNFVmTHpPbEQ0V3Z6QUhhb0c5bnhQaTVkK2pZVXFmQWhoeWtPRndKV2lBQUFJZmtFQ1FvQUFBQXNBQUFBQUNBQUlBQUFCUEFReUVscFVxbnF6YWNpU29Wa1hWVU1GYUZTd2xwT0NjTVlsRXJBYXZoT01uTkxObzhLc1pzTVpJdEpFSURJRlNrTEdRb1FUTmhJc0ZlaFJ3dzJDUUxLRjB0WUdLWVNnK3lnc1pJdU5xSmtzS2diZmdJR2VwTm8yY0lVQjNWMUIzSXZOaUJZTlFhRFNUdGZoaHgwQ3dWUEkwVUplMCtibTRnNVZnY0dvcU9jbmptanFEU2RuaGdFb2FtY3NadVhPMWFXUXk4S0F3T0F1VFlZR3dpN3c1aCtLcjBTSjhNRmlocE5ieCs0RXJxN0JZQnV6c2RpSDFqQ0F6b1NmbDByVmlyTmJSWGxCQmxMWCtCUDBYSkxBUEd6VGtBdUFPcWIwV1Q1QUg3T2NkQ201QjhUZ1J3U1JLSUhRdGFMQ3dnMVJBQUFPd0FBQUFBQUFBQUFBQT09XFxcIiksIF9fd2VicGFja19yZXF1aXJlX18uYik7XFxudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0KCkoKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfbm9Tb3VyY2VNYXBzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKSk7XFxudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2dldFVybF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQoKShfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyk7XFxuLy8gTW9kdWxlXFxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcXFwiLmp2ZWN0b3JtYXAtdGlwIHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxuICBib3JkZXI6IHNvbGlkIDFweCAjY2RjZGNkO1xcXFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxcXG4gIGJhY2tncm91bmQ6ICMyOTI5Mjk7XFxcXG4gIGNvbG9yOiB3aGl0ZTtcXFxcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWYsIFZlcmRhbmE7XFxcXG4gIGZvbnQtc2l6ZTogc21hbGxlcjtcXFxcbiAgcGFkZGluZzogM3B4O1xcXFxufVxcXFxuXFxcXG4uX3U1Y0lUdFpuR2s5RF82dW9FbHgge1xcXFxuICBoZWlnaHQ6IDEwMCU7XFxcXG4gIHdpZHRoOiAxMDAlO1xcXFxufVxcXFxuLl91NWNJVHRabkdrOURfNnVvRWx4IHN2ZyB7XFxcXG4gIHRvdWNoLWFjdGlvbjogbm9uZTtcXFxcbn1cXFxcbi5fdTVjSVR0Wm5HazlEXzZ1b0VseCAuanZlY3Rvcm1hcC1jb250YWluZXIge1xcXFxuICB3aWR0aDogMTAwJTtcXFxcbiAgaGVpZ2h0OiAxMDAlO1xcXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxcXG4gIHRvdWNoLWFjdGlvbjogbm9uZTtcXFxcbn1cXFxcbi5fdTVjSVR0Wm5HazlEXzZ1b0VseCAuanZlY3Rvcm1hcC16b29taW4ge1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIGxlZnQ6IDEwcHg7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXFxcbiAgYmFja2dyb3VuZDogIzI5MjkyOTtcXFxcbiAgcGFkZGluZzogM3B4O1xcXFxuICBjb2xvcjogd2hpdGU7XFxcXG4gIGN1cnNvcjogcG9pbnRlcjtcXFxcbiAgbGluZS1oZWlnaHQ6IDEwcHg7XFxcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXFxcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxcXG4gIHdpZHRoOiAxMHB4O1xcXFxuICBoZWlnaHQ6IDEwcHg7XFxcXG4gIHRvcDogMTBweDtcXFxcbn1cXFxcbi5fdTVjSVR0Wm5HazlEXzZ1b0VseCAuanZlY3Rvcm1hcC16b29tb3V0IHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBsZWZ0OiAxMHB4O1xcXFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxcXG4gIGJhY2tncm91bmQ6ICMyOTI5Mjk7XFxcXG4gIHBhZGRpbmc6IDNweDtcXFxcbiAgY29sb3I6IHdoaXRlO1xcXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxcXG4gIGxpbmUtaGVpZ2h0OiAxMHB4O1xcXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcXFxuICB3aWR0aDogMTBweDtcXFxcbiAgaGVpZ2h0OiAxMHB4O1xcXFxuICB0b3A6IDMwcHg7XFxcXG59XFxcXG4uX3U1Y0lUdFpuR2s5RF82dW9FbHggLmp2ZWN0b3JtYXAtZ29iYWNrIHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBsZWZ0OiAxMHB4O1xcXFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxcXG4gIGJhY2tncm91bmQ6ICMyOTI5Mjk7XFxcXG4gIGNvbG9yOiB3aGl0ZTtcXFxcbiAgY3Vyc29yOiBwb2ludGVyO1xcXFxuICBsaW5lLWhlaWdodDogMTBweDtcXFxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcXFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXFxcbiAgYm90dG9tOiAxMHB4O1xcXFxuICB6LWluZGV4OiAxMDAwO1xcXFxuICBwYWRkaW5nOiA2cHg7XFxcXG59XFxcXG4uX3U1Y0lUdFpuR2s5RF82dW9FbHggLmp2ZWN0b3JtYXAtc3Bpbm5lciB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgbGVmdDogMDtcXFxcbiAgdG9wOiAwO1xcXFxuICByaWdodDogMDtcXFxcbiAgYm90dG9tOiAwO1xcXFxuICBiYWNrZ3JvdW5kOiBjZW50ZXIgbm8tcmVwZWF0IHVybChcXFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyArIFxcXCIpO1xcXFxufVxcXFxuLl91NWNJVHRabkdrOURfNnVvRWx4IC5qdmVjdG9ybWFwLWxlZ2VuZC10aXRsZSB7XFxcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcXFxuICBmb250LXNpemU6IDE0cHg7XFxcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXFxcbn1cXFxcbi5fdTVjSVR0Wm5HazlEXzZ1b0VseCAuanZlY3Rvcm1hcC1sZWdlbmQtY250IHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxufVxcXFxuLl91NWNJVHRabkdrOURfNnVvRWx4IC5qdmVjdG9ybWFwLWxlZ2VuZC1jbnQtaCB7XFxcXG4gIGJvdHRvbTogMDtcXFxcbiAgcmlnaHQ6IDA7XFxcXG59XFxcXG4uX3U1Y0lUdFpuR2s5RF82dW9FbHggLmp2ZWN0b3JtYXAtbGVnZW5kLWNudC1oIC5qdmVjdG9ybWFwLWxlZ2VuZCB7XFxcXG4gIGZsb2F0OiBsZWZ0O1xcXFxuICBtYXJnaW46IDAgMTBweCAxMHB4IDA7XFxcXG4gIHBhZGRpbmc6IDNweCAzcHggMXB4IDNweDtcXFxcbn1cXFxcbi5fdTVjSVR0Wm5HazlEXzZ1b0VseCAuanZlY3Rvcm1hcC1sZWdlbmQtY250LWggLmp2ZWN0b3JtYXAtbGVnZW5kIC5qdmVjdG9ybWFwLWxlZ2VuZC10aWNrIHtcXFxcbiAgZmxvYXQ6IGxlZnQ7XFxcXG59XFxcXG4uX3U1Y0lUdFpuR2s5RF82dW9FbHggLmp2ZWN0b3JtYXAtbGVnZW5kLWNudC1oIC5qdmVjdG9ybWFwLWxlZ2VuZC10aWNrIHtcXFxcbiAgd2lkdGg6IDQwcHg7XFxcXG59XFxcXG4uX3U1Y0lUdFpuR2s5RF82dW9FbHggLmp2ZWN0b3JtYXAtbGVnZW5kLWNudC1oIC5qdmVjdG9ybWFwLWxlZ2VuZC10aWNrLXNhbXBsZSB7XFxcXG4gIGhlaWdodDogMTVweDtcXFxcbn1cXFxcbi5fdTVjSVR0Wm5HazlEXzZ1b0VseCAuanZlY3Rvcm1hcC1sZWdlbmQtY250LWggLmp2ZWN0b3JtYXAtbGVnZW5kLXRpY2stdGV4dCB7XFxcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXFxcbn1cXFxcbi5fdTVjSVR0Wm5HazlEXzZ1b0VseCAuanZlY3Rvcm1hcC1sZWdlbmQtY250LXYge1xcXFxuICB0b3A6IDA7XFxcXG4gIHJpZ2h0OiAwO1xcXFxufVxcXFxuLl91NWNJVHRabkdrOURfNnVvRWx4IC5qdmVjdG9ybWFwLWxlZ2VuZC1jbnQtdiAuanZlY3Rvcm1hcC1sZWdlbmQge1xcXFxuICBtYXJnaW46IDEwcHggMTBweCAwIDA7XFxcXG4gIHBhZGRpbmc6IDNweDtcXFxcbn1cXFxcbi5fdTVjSVR0Wm5HazlEXzZ1b0VseCAuanZlY3Rvcm1hcC1sZWdlbmQtY250LXYgLmp2ZWN0b3JtYXAtbGVnZW5kLXRpY2stc2FtcGxlIHtcXFxcbiAgaGVpZ2h0OiAyMHB4O1xcXFxuICB3aWR0aDogMjBweDtcXFxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcXFxufVxcXFxuLl91NWNJVHRabkdrOURfNnVvRWx4IC5qdmVjdG9ybWFwLWxlZ2VuZC1jbnQtdiAuanZlY3Rvcm1hcC1sZWdlbmQtdGljay10ZXh0IHtcXFxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcXFxuICBsaW5lLWhlaWdodDogMjBweDtcXFxcbiAgcGFkZGluZy1sZWZ0OiAzcHg7XFxcXG59XFxcXG4uX3U1Y0lUdFpuR2s5RF82dW9FbHggLmp2ZWN0b3JtYXAtbGVnZW5kIHtcXFxcbiAgYmFja2dyb3VuZDogYmxhY2s7XFxcXG4gIGNvbG9yOiB3aGl0ZTtcXFxcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcXFxufVxcXFxuLl91NWNJVHRabkdrOURfNnVvRWx4IC5qdmVjdG9ybWFwLWxlZ2VuZC10aWNrLXRleHQge1xcXFxuICBmb250LXNpemU6IDEycHg7XFxcXG59XFxcIiwgXFxcIlxcXCJdKTtcXG4vLyBFeHBvcnRzXFxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xcblxcdFxcXCJyb290XFxcIjogXFxcIl91NWNJVHRabkdrOURfNnVvRWx4XFxcIlxcbn07XFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChfX19DU1NfTE9BREVSX0VYUE9SVF9fXyk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uL3NyYy9jb21wb25lbnRzL01hcENvbnRhaW5lci9zdHlsZXMubW9kdWxlLnNjc3M/Li4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxuLypcXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXFxuKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XFxuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXFxuXFxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xcbiAgICAgIHZhciBjb250ZW50ID0gXFxcIlxcXCI7XFxuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcXFwidW5kZWZpbmVkXFxcIjtcXG5cXG4gICAgICBpZiAoaXRlbVs0XSkge1xcbiAgICAgICAgY29udGVudCArPSBcXFwiQHN1cHBvcnRzIChcXFwiLmNvbmNhdChpdGVtWzRdLCBcXFwiKSB7XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpdGVtWzJdKSB7XFxuICAgICAgICBjb250ZW50ICs9IFxcXCJAbWVkaWEgXFxcIi5jb25jYXQoaXRlbVsyXSwgXFxcIiB7XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcXG4gICAgICAgIGNvbnRlbnQgKz0gXFxcIkBsYXllclxcXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFxcXCIgXFxcIi5jb25jYXQoaXRlbVs1XSkgOiBcXFwiXFxcIiwgXFxcIiB7XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcXG5cXG4gICAgICBpZiAobmVlZExheWVyKSB7XFxuICAgICAgICBjb250ZW50ICs9IFxcXCJ9XFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGl0ZW1bMl0pIHtcXG4gICAgICAgIGNvbnRlbnQgKz0gXFxcIn1cXFwiO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXRlbVs0XSkge1xcbiAgICAgICAgY29udGVudCArPSBcXFwifVxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjb250ZW50O1xcbiAgICB9KS5qb2luKFxcXCJcXFwiKTtcXG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XFxuXFxuXFxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XFxuICAgIH1cXG5cXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcXG5cXG4gICAgaWYgKGRlZHVwZSkge1xcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgdmFyIGlkID0gdGhpc1tfaV1bMF07XFxuXFxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG1vZHVsZXMubGVuZ3RoOyBfaTIrKykge1xcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2kyXSk7XFxuXFxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaXRlbVsxXSA9IFxcXCJAbGF5ZXJcXFwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcXFwiIFxcXCIuY29uY2F0KGl0ZW1bNV0pIDogXFxcIlxcXCIsIFxcXCIge1xcXCIpLmNvbmNhdChpdGVtWzFdLCBcXFwifVxcXCIpO1xcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChtZWRpYSkge1xcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XFxuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGl0ZW1bMV0gPSBcXFwiQG1lZGlhIFxcXCIuY29uY2F0KGl0ZW1bMl0sIFxcXCIge1xcXCIpLmNvbmNhdChpdGVtWzFdLCBcXFwifVxcXCIpO1xcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzdXBwb3J0cykge1xcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XFxuICAgICAgICAgIGl0ZW1bNF0gPSBcXFwiXFxcIi5jb25jYXQoc3VwcG9ydHMpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaXRlbVsxXSA9IFxcXCJAc3VwcG9ydHMgKFxcXCIuY29uY2F0KGl0ZW1bNF0sIFxcXCIpIHtcXFwiKS5jb25jYXQoaXRlbVsxXSwgXFxcIn1cXFwiKTtcXG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICByZXR1cm4gbGlzdDtcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0ByZWFjdC1qdmVjdG9ybWFwL2NvcmUvLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcXG4gIGlmICghb3B0aW9ucykge1xcbiAgICBvcHRpb25zID0ge307XFxuICB9XFxuXFxuICBpZiAoIXVybCkge1xcbiAgICByZXR1cm4gdXJsO1xcbiAgfVxcblxcbiAgdXJsID0gU3RyaW5nKHVybC5fX2VzTW9kdWxlID8gdXJsLmRlZmF1bHQgOiB1cmwpOyAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cXG5cXG4gIGlmICgvXlsnXFxcIl0uKlsnXFxcIl0kLy50ZXN0KHVybCkpIHtcXG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcXG4gIH1cXG5cXG4gIGlmIChvcHRpb25zLmhhc2gpIHtcXG4gICAgdXJsICs9IG9wdGlvbnMuaGFzaDtcXG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xcbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcXG5cXG5cXG4gIGlmICgvW1xcXCInKCkgXFxcXHRcXFxcbl18KCUyMCkvLnRlc3QodXJsKSB8fCBvcHRpb25zLm5lZWRRdW90ZXMpIHtcXG4gICAgcmV0dXJuIFxcXCJcXFxcXFxcIlxcXCIuY29uY2F0KHVybC5yZXBsYWNlKC9cXFwiL2csICdcXFxcXFxcXFxcXCInKS5yZXBsYWNlKC9cXFxcbi9nLCBcXFwiXFxcXFxcXFxuXFxcIiksIFxcXCJcXFxcXFxcIlxcXCIpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHVybDtcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0ByZWFjdC1qdmVjdG9ybWFwL2NvcmUvLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9ub1NvdXJjZU1hcHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvbm9Tb3VyY2VNYXBzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpKSB7XFxuICByZXR1cm4gaVsxXTtcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0ByZWFjdC1qdmVjdG9ybWFwL2NvcmUvLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL25vU291cmNlTWFwcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvTWFwQ29udGFpbmVyL3N0eWxlcy5tb2R1bGUuc2Nzc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9NYXBDb250YWluZXIvc3R5bGVzLm1vZHVsZS5zY3NzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19zdHlsZV9sb2FkZXJfZGlzdF9ydW50aW1lX2luamVjdFN0eWxlc0ludG9TdHlsZVRhZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyAqLyBcXFwiLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfc3R5bGVfbG9hZGVyX2Rpc3RfcnVudGltZV9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfc3R5bGVEb21BUElfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohICEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyAqLyBcXFwiLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19zdHlsZV9sb2FkZXJfZGlzdF9ydW50aW1lX3N0eWxlRG9tQVBJX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19zdHlsZV9sb2FkZXJfZGlzdF9ydW50aW1lX3N0eWxlRG9tQVBJX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfaW5zZXJ0QnlTZWxlY3Rvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMgKi8gXFxcIi4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19zdHlsZV9sb2FkZXJfZGlzdF9ydW50aW1lX2luc2VydEJ5U2VsZWN0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfaW5zZXJ0QnlTZWxlY3Rvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19zdHlsZV9sb2FkZXJfZGlzdF9ydW50aW1lX3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcyAqLyBcXFwiLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfc3R5bGVfbG9hZGVyX2Rpc3RfcnVudGltZV9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfaW5zZXJ0U3R5bGVFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzICovIFxcXCIuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19zdHlsZV9sb2FkZXJfZGlzdF9ydW50aW1lX2luc2VydFN0eWxlRWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfc3R5bGVfbG9hZGVyX2Rpc3RfcnVudGltZV9pbnNlcnRTdHlsZUVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfc3R5bGVfbG9hZGVyX2Rpc3RfcnVudGltZV9zdHlsZVRhZ1RyYW5zZm9ybV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzICovIFxcXCIuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfc3R5bGVUYWdUcmFuc2Zvcm1fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfc3R5bGVUYWdUcmFuc2Zvcm1fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfc3R5bGVzX21vZHVsZV9zY3NzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlcy5tb2R1bGUuc2NzcyAqLyBcXFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3JjL2NvbXBvbmVudHMvTWFwQ29udGFpbmVyL3N0eWxlcy5tb2R1bGUuc2Nzc1xcXCIpO1xcblxcbiAgICAgIFxcbiAgICAgIFxcbiAgICAgIFxcbiAgICAgIFxcbiAgICAgIFxcbiAgICAgIFxcbiAgICAgIFxcbiAgICAgIFxcbiAgICAgIFxcblxcbnZhciBvcHRpb25zID0ge307XFxuXFxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IChfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfc3R5bGVUYWdUcmFuc2Zvcm1fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0KCkpO1xcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IChfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCgpKTtcXG5cXG4gICAgICBvcHRpb25zLmluc2VydCA9IF9ub2RlX21vZHVsZXNfc3R5bGVfbG9hZGVyX2Rpc3RfcnVudGltZV9pbnNlcnRCeVNlbGVjdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCgpLmJpbmQobnVsbCwgXFxcImhlYWRcXFwiKTtcXG4gICAgXFxub3B0aW9ucy5kb21BUEkgPSAoX25vZGVfbW9kdWxlc19zdHlsZV9sb2FkZXJfZGlzdF9ydW50aW1lX3N0eWxlRG9tQVBJX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKTtcXG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IChfbm9kZV9tb2R1bGVzX3N0eWxlX2xvYWRlcl9kaXN0X3J1bnRpbWVfaW5zZXJ0U3R5bGVFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCgpKTtcXG5cXG52YXIgdXBkYXRlID0gX25vZGVfbW9kdWxlc19zdHlsZV9sb2FkZXJfZGlzdF9ydW50aW1lX2luamVjdFN0eWxlc0ludG9TdHlsZVRhZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3N0eWxlc19tb2R1bGVfc2Nzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0sIG9wdGlvbnMpO1xcblxcblxcblxcblxcbiAgICAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfc3R5bGVzX21vZHVsZV9zY3NzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcImRlZmF1bHRcXFwiXSAmJiBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3N0eWxlc19tb2R1bGVfc2Nzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0ubG9jYWxzID8gX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19zdHlsZXNfbW9kdWxlX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiZGVmYXVsdFxcXCJdLmxvY2FscyA6IHVuZGVmaW5lZCk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uL3NyYy9jb21wb25lbnRzL01hcENvbnRhaW5lci9zdHlsZXMubW9kdWxlLnNjc3M/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcXG5cXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XFxuICB2YXIgcmVzdWx0ID0gLTE7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XFxuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XFxuICAgICAgcmVzdWx0ID0gaTtcXG4gICAgICBicmVhaztcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcXG4gIHZhciBpZENvdW50TWFwID0ge307XFxuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XFxuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xcbiAgICB2YXIgaWRlbnRpZmllciA9IFxcXCJcXFwiLmNvbmNhdChpZCwgXFxcIiBcXFwiKS5jb25jYXQoY291bnQpO1xcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcXG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XFxuICAgIHZhciBvYmogPSB7XFxuICAgICAgY3NzOiBpdGVtWzFdLFxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcXG4gICAgICBsYXllcjogaXRlbVs1XVxcbiAgICB9O1xcblxcbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XFxuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcXG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XFxuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcXG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXFxuICAgICAgICByZWZlcmVuY2VzOiAxXFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcXG4gIH1cXG5cXG4gIHJldHVybiBpZGVudGlmaWVycztcXG59XFxuXFxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xcbiAgYXBpLnVwZGF0ZShvYmopO1xcblxcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xcbiAgICBpZiAobmV3T2JqKSB7XFxuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgYXBpLnJlbW92ZSgpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIHVwZGF0ZXI7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgbGlzdCA9IGxpc3QgfHwgW107XFxuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XFxuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XFxuICAgIH1cXG5cXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcXG5cXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xcblxcbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XFxuXFxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XFxuXFxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xcbiAgfTtcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0ByZWFjdC1qdmVjdG9ybWFwL2NvcmUvLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbnZhciBtZW1vID0ge307XFxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXFxuXFxuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcXG5cXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XFxuICB9XFxuXFxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xcbn1cXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cXG5cXG5cXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcXG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcXG5cXG4gIGlmICghdGFyZ2V0KSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihcXFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlxcXCIpO1xcbiAgfVxcblxcbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0ByZWFjdC1qdmVjdG9ybWFwL2NvcmUvLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XFxuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInN0eWxlXFxcIik7XFxuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcXG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XFxuICByZXR1cm4gZWxlbWVudDtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xcbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcXG4gIHZhciBub25jZSA9ICB0cnVlID8gX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA6IDA7XFxuXFxuICBpZiAobm9uY2UpIHtcXG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcXFwibm9uY2VcXFwiLCBub25jZSk7XFxuICB9XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0ByZWFjdC1qdmVjdG9ybWFwL2NvcmUvLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xcbiAgdmFyIGNzcyA9IFxcXCJcXFwiO1xcblxcbiAgaWYgKG9iai5zdXBwb3J0cykge1xcbiAgICBjc3MgKz0gXFxcIkBzdXBwb3J0cyAoXFxcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcXFwiKSB7XFxcIik7XFxuICB9XFxuXFxuICBpZiAob2JqLm1lZGlhKSB7XFxuICAgIGNzcyArPSBcXFwiQG1lZGlhIFxcXCIuY29uY2F0KG9iai5tZWRpYSwgXFxcIiB7XFxcIik7XFxuICB9XFxuXFxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXFxcInVuZGVmaW5lZFxcXCI7XFxuXFxuICBpZiAobmVlZExheWVyKSB7XFxuICAgIGNzcyArPSBcXFwiQGxheWVyXFxcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcXFwiIFxcXCIuY29uY2F0KG9iai5sYXllcikgOiBcXFwiXFxcIiwgXFxcIiB7XFxcIik7XFxuICB9XFxuXFxuICBjc3MgKz0gb2JqLmNzcztcXG5cXG4gIGlmIChuZWVkTGF5ZXIpIHtcXG4gICAgY3NzICs9IFxcXCJ9XFxcIjtcXG4gIH1cXG5cXG4gIGlmIChvYmoubWVkaWEpIHtcXG4gICAgY3NzICs9IFxcXCJ9XFxcIjtcXG4gIH1cXG5cXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcXG4gICAgY3NzICs9IFxcXCJ9XFxcIjtcXG4gIH1cXG5cXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xcblxcbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgY3NzICs9IFxcXCJcXFxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXFxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXFxcIiAqL1xcXCIpO1xcbiAgfSAvLyBGb3Igb2xkIElFXFxuXFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXFxuXFxuXFxuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XFxuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xcbn1cXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cXG5cXG5cXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xcbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xcbiAgcmV0dXJuIHtcXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XFxuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xcbiAgICB9LFxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcXG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcXG4gICAgfVxcbiAgfTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXFxuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xcbiAgfSBlbHNlIHtcXG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XFxuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcXG4gICAgfVxcblxcbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XFxuICB9XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2pxdWVyeS1tb3VzZXdoZWVsL2pxdWVyeS5tb3VzZXdoZWVsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2pxdWVyeS1tb3VzZXdoZWVsL2pxdWVyeS5tb3VzZXdoZWVsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJsb2FkSlF1ZXJ5TW91c2VXaGVlbFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGxvYWRKUXVlcnlNb3VzZVdoZWVsKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIVxcbiAqIGpRdWVyeSBNb3VzZXdoZWVsIDMuMS4xM1xcbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICovXFxuXFxuY29uc3QgbG9hZEpRdWVyeU1vdXNlV2hlZWwgPSAoJCkgPT5cXG4gIChmdW5jdGlvbiAoZmFjdG9yeSkge1xcbiAgICBmYWN0b3J5KCQpO1xcbiAgfSkoZnVuY3Rpb24gKCQpIHtcXG4gICAgdmFyIHRvRml4ID0gW1xcbiAgICAgICAgXFxcIndoZWVsXFxcIixcXG4gICAgICAgIFxcXCJtb3VzZXdoZWVsXFxcIixcXG4gICAgICAgIFxcXCJET01Nb3VzZVNjcm9sbFxcXCIsXFxuICAgICAgICBcXFwiTW96TW91c2VQaXhlbFNjcm9sbFxcXCIsXFxuICAgICAgXSxcXG4gICAgICB0b0JpbmQgPVxcbiAgICAgICAgXFxcIm9ud2hlZWxcXFwiIGluIHdpbmRvdy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRNb2RlID49IDlcXG4gICAgICAgICAgPyBbXFxcIndoZWVsXFxcIl1cXG4gICAgICAgICAgOiBbXFxcIm1vdXNld2hlZWxcXFwiLCBcXFwiRG9tTW91c2VTY3JvbGxcXFwiLCBcXFwiTW96TW91c2VQaXhlbFNjcm9sbFxcXCJdLFxcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxcbiAgICAgIG51bGxMb3dlc3REZWx0YVRpbWVvdXQsXFxuICAgICAgbG93ZXN0RGVsdGE7XFxuXFxuICAgIGlmICgkLmV2ZW50LmZpeEhvb2tzKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRvRml4Lmxlbmd0aDsgaTsgKSB7XFxuICAgICAgICAkLmV2ZW50LmZpeEhvb2tzW3RvRml4Wy0taV1dID0gJC5ldmVudC5tb3VzZUhvb2tzO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgc3BlY2lhbCA9ICgkLmV2ZW50LnNwZWNpYWwubW91c2V3aGVlbCA9IHtcXG4gICAgICB2ZXJzaW9uOiBcXFwiMy4xLjEyXFxcIixcXG5cXG4gICAgICBzZXR1cDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKHRoaXMuYWRkRXZlbnRMaXN0ZW5lcikge1xcbiAgICAgICAgICBmb3IgKHZhciBpID0gdG9CaW5kLmxlbmd0aDsgaTsgKSB7XFxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRvQmluZFstLWldLCBoYW5kbGVyLCBmYWxzZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMub25tb3VzZXdoZWVsID0gaGFuZGxlcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIFN0b3JlIHRoZSBsaW5lIGhlaWdodCBhbmQgcGFnZSBoZWlnaHQgZm9yIHRoaXMgcGFydGljdWxhciBlbGVtZW50XFxuICAgICAgICAkLmRhdGEodGhpcywgXFxcIm1vdXNld2hlZWwtbGluZS1oZWlnaHRcXFwiLCBzcGVjaWFsLmdldExpbmVIZWlnaHQodGhpcykpO1xcbiAgICAgICAgJC5kYXRhKHRoaXMsIFxcXCJtb3VzZXdoZWVsLXBhZ2UtaGVpZ2h0XFxcIiwgc3BlY2lhbC5nZXRQYWdlSGVpZ2h0KHRoaXMpKTtcXG4gICAgICB9LFxcblxcbiAgICAgIHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XFxuICAgICAgICAgIGZvciAodmFyIGkgPSB0b0JpbmQubGVuZ3RoOyBpOyApIHtcXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodG9CaW5kWy0taV0sIGhhbmRsZXIsIGZhbHNlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5vbm1vdXNld2hlZWwgPSBudWxsO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGRhdGEgd2UgYWRkZWQgdG8gdGhlIGVsZW1lbnRcXG4gICAgICAgICQucmVtb3ZlRGF0YSh0aGlzLCBcXFwibW91c2V3aGVlbC1saW5lLWhlaWdodFxcXCIpO1xcbiAgICAgICAgJC5yZW1vdmVEYXRhKHRoaXMsIFxcXCJtb3VzZXdoZWVsLXBhZ2UtaGVpZ2h0XFxcIik7XFxuICAgICAgfSxcXG5cXG4gICAgICBnZXRMaW5lSGVpZ2h0OiBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgdmFyICRlbGVtID0gJChlbGVtKSxcXG4gICAgICAgICAgJHBhcmVudCA9ICRlbGVtW1xcXCJvZmZzZXRQYXJlbnRcXFwiIGluICQuZm4gPyBcXFwib2Zmc2V0UGFyZW50XFxcIiA6IFxcXCJwYXJlbnRcXFwiXSgpO1xcbiAgICAgICAgaWYgKCEkcGFyZW50Lmxlbmd0aCkge1xcbiAgICAgICAgICAkcGFyZW50ID0gJChcXFwiYm9keVxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIChcXG4gICAgICAgICAgcGFyc2VJbnQoJHBhcmVudC5jc3MoXFxcImZvbnRTaXplXFxcIiksIDEwKSB8fFxcbiAgICAgICAgICBwYXJzZUludCgkZWxlbS5jc3MoXFxcImZvbnRTaXplXFxcIiksIDEwKSB8fFxcbiAgICAgICAgICAxNlxcbiAgICAgICAgKTtcXG4gICAgICB9LFxcblxcbiAgICAgIGdldFBhZ2VIZWlnaHQ6IGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICByZXR1cm4gJChlbGVtKS5oZWlnaHQoKTtcXG4gICAgICB9LFxcblxcbiAgICAgIHNldHRpbmdzOiB7XFxuICAgICAgICBhZGp1c3RPbGREZWx0YXM6IHRydWUsIC8vIHNlZSBzaG91bGRBZGp1c3RPbGREZWx0YXMoKSBiZWxvd1xcbiAgICAgICAgbm9ybWFsaXplT2Zmc2V0OiB0cnVlLCAvLyBjYWxscyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZm9yIGVhY2ggZXZlbnRcXG4gICAgICB9LFxcbiAgICB9KTtcXG5cXG4gICAgJC5mbi5leHRlbmQoe1xcbiAgICAgIG1vdXNld2hlZWw6IGZ1bmN0aW9uIChmbikge1xcbiAgICAgICAgcmV0dXJuIGZuID8gdGhpcy5vbihcXFwibW91c2V3aGVlbFxcXCIsIGZuKSA6IHRoaXMudHJpZ2dlcihcXFwibW91c2V3aGVlbFxcXCIpO1xcbiAgICAgIH0sXFxuXFxuICAgICAgdW5tb3VzZXdoZWVsOiBmdW5jdGlvbiAoZm4pIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm9mZihcXFwibW91c2V3aGVlbFxcXCIsIGZuKTtcXG4gICAgICB9LFxcbiAgICB9KTtcXG5cXG4gICAgZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xcbiAgICAgIHZhciBvcmdFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudCxcXG4gICAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXFxuICAgICAgICBkZWx0YSA9IDAsXFxuICAgICAgICBkZWx0YVggPSAwLFxcbiAgICAgICAgZGVsdGFZID0gMCxcXG4gICAgICAgIGFic0RlbHRhID0gMDtcXG4gICAgICBldmVudCA9ICQuZXZlbnQuZml4KG9yZ0V2ZW50KTtcXG4gICAgICBldmVudC50eXBlID0gXFxcIm1vdXNld2hlZWxcXFwiO1xcblxcbiAgICAgIC8vIE9sZCBzY2hvb2wgc2Nyb2xsd2hlZWwgZGVsdGFcXG4gICAgICBpZiAoXFxcImRldGFpbFxcXCIgaW4gb3JnRXZlbnQpIHtcXG4gICAgICAgIGRlbHRhWSA9IG9yZ0V2ZW50LmRldGFpbCAqIC0xO1xcbiAgICAgIH1cXG4gICAgICBpZiAoXFxcIndoZWVsRGVsdGFcXFwiIGluIG9yZ0V2ZW50KSB7XFxuICAgICAgICBkZWx0YVkgPSBvcmdFdmVudC53aGVlbERlbHRhO1xcbiAgICAgIH1cXG4gICAgICBpZiAoXFxcIndoZWVsRGVsdGFZXFxcIiBpbiBvcmdFdmVudCkge1xcbiAgICAgICAgZGVsdGFZID0gb3JnRXZlbnQud2hlZWxEZWx0YVk7XFxuICAgICAgfVxcbiAgICAgIGlmIChcXFwid2hlZWxEZWx0YVhcXFwiIGluIG9yZ0V2ZW50KSB7XFxuICAgICAgICBkZWx0YVggPSBvcmdFdmVudC53aGVlbERlbHRhWCAqIC0xO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBGaXJlZm94IDwgMTcgaG9yaXpvbnRhbCBzY3JvbGxpbmcgcmVsYXRlZCB0byBET01Nb3VzZVNjcm9sbCBldmVudFxcbiAgICAgIGlmIChcXFwiYXhpc1xcXCIgaW4gb3JnRXZlbnQgJiYgb3JnRXZlbnQuYXhpcyA9PT0gb3JnRXZlbnQuSE9SSVpPTlRBTF9BWElTKSB7XFxuICAgICAgICBkZWx0YVggPSBkZWx0YVkgKiAtMTtcXG4gICAgICAgIGRlbHRhWSA9IDA7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFNldCBkZWx0YSB0byBiZSBkZWx0YVkgb3IgZGVsdGFYIGlmIGRlbHRhWSBpcyAwIGZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0aXlcXG4gICAgICBkZWx0YSA9IGRlbHRhWSA9PT0gMCA/IGRlbHRhWCA6IGRlbHRhWTtcXG5cXG4gICAgICAvLyBOZXcgc2Nob29sIHdoZWVsIGRlbHRhICh3aGVlbCBldmVudClcXG4gICAgICBpZiAoXFxcImRlbHRhWVxcXCIgaW4gb3JnRXZlbnQpIHtcXG4gICAgICAgIGRlbHRhWSA9IG9yZ0V2ZW50LmRlbHRhWSAqIC0xO1xcbiAgICAgICAgZGVsdGEgPSBkZWx0YVk7XFxuICAgICAgfVxcbiAgICAgIGlmIChcXFwiZGVsdGFYXFxcIiBpbiBvcmdFdmVudCkge1xcbiAgICAgICAgZGVsdGFYID0gb3JnRXZlbnQuZGVsdGFYO1xcbiAgICAgICAgaWYgKGRlbHRhWSA9PT0gMCkge1xcbiAgICAgICAgICBkZWx0YSA9IGRlbHRhWCAqIC0xO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBObyBjaGFuZ2UgYWN0dWFsbHkgaGFwcGVuZWQsIG5vIHJlYXNvbiB0byBnbyBhbnkgZnVydGhlclxcbiAgICAgIGlmIChkZWx0YVkgPT09IDAgJiYgZGVsdGFYID09PSAwKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIC8vIE5lZWQgdG8gY29udmVydCBsaW5lcyBhbmQgcGFnZXMgdG8gcGl4ZWxzIGlmIHdlIGFyZW4ndCBhbHJlYWR5IGluIHBpeGVsc1xcbiAgICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBkZWx0YSBtb2RlczpcXG4gICAgICAvLyAgICogZGVsdGFNb2RlIDAgaXMgYnkgcGl4ZWxzLCBub3RoaW5nIHRvIGRvXFxuICAgICAgLy8gICAqIGRlbHRhTW9kZSAxIGlzIGJ5IGxpbmVzXFxuICAgICAgLy8gICAqIGRlbHRhTW9kZSAyIGlzIGJ5IHBhZ2VzXFxuICAgICAgaWYgKG9yZ0V2ZW50LmRlbHRhTW9kZSA9PT0gMSkge1xcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSAkLmRhdGEodGhpcywgXFxcIm1vdXNld2hlZWwtbGluZS1oZWlnaHRcXFwiKTtcXG4gICAgICAgIGRlbHRhICo9IGxpbmVIZWlnaHQ7XFxuICAgICAgICBkZWx0YVkgKj0gbGluZUhlaWdodDtcXG4gICAgICAgIGRlbHRhWCAqPSBsaW5lSGVpZ2h0O1xcbiAgICAgIH0gZWxzZSBpZiAob3JnRXZlbnQuZGVsdGFNb2RlID09PSAyKSB7XFxuICAgICAgICB2YXIgcGFnZUhlaWdodCA9ICQuZGF0YSh0aGlzLCBcXFwibW91c2V3aGVlbC1wYWdlLWhlaWdodFxcXCIpO1xcbiAgICAgICAgZGVsdGEgKj0gcGFnZUhlaWdodDtcXG4gICAgICAgIGRlbHRhWSAqPSBwYWdlSGVpZ2h0O1xcbiAgICAgICAgZGVsdGFYICo9IHBhZ2VIZWlnaHQ7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFN0b3JlIGxvd2VzdCBhYnNvbHV0ZSBkZWx0YSB0byBub3JtYWxpemUgdGhlIGRlbHRhIHZhbHVlc1xcbiAgICAgIGFic0RlbHRhID0gTWF0aC5tYXgoTWF0aC5hYnMoZGVsdGFZKSwgTWF0aC5hYnMoZGVsdGFYKSk7XFxuXFxuICAgICAgaWYgKCFsb3dlc3REZWx0YSB8fCBhYnNEZWx0YSA8IGxvd2VzdERlbHRhKSB7XFxuICAgICAgICBsb3dlc3REZWx0YSA9IGFic0RlbHRhO1xcblxcbiAgICAgICAgLy8gQWRqdXN0IG9sZGVyIGRlbHRhcyBpZiBuZWNlc3NhcnlcXG4gICAgICAgIGlmIChzaG91bGRBZGp1c3RPbGREZWx0YXMob3JnRXZlbnQsIGFic0RlbHRhKSkge1xcbiAgICAgICAgICBsb3dlc3REZWx0YSAvPSA0MDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gQWRqdXN0IG9sZGVyIGRlbHRhcyBpZiBuZWNlc3NhcnlcXG4gICAgICBpZiAoc2hvdWxkQWRqdXN0T2xkRGVsdGFzKG9yZ0V2ZW50LCBhYnNEZWx0YSkpIHtcXG4gICAgICAgIC8vIERpdmlkZSBhbGwgdGhlIHRoaW5ncyBieSA0MCFcXG4gICAgICAgIGRlbHRhIC89IDQwO1xcbiAgICAgICAgZGVsdGFYIC89IDQwO1xcbiAgICAgICAgZGVsdGFZIC89IDQwO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBHZXQgYSB3aG9sZSwgbm9ybWFsaXplZCB2YWx1ZSBmb3IgdGhlIGRlbHRhc1xcbiAgICAgIGRlbHRhID0gTWF0aFtkZWx0YSA+PSAxID8gXFxcImZsb29yXFxcIiA6IFxcXCJjZWlsXFxcIl0oZGVsdGEgLyBsb3dlc3REZWx0YSk7XFxuICAgICAgZGVsdGFYID0gTWF0aFtkZWx0YVggPj0gMSA/IFxcXCJmbG9vclxcXCIgOiBcXFwiY2VpbFxcXCJdKGRlbHRhWCAvIGxvd2VzdERlbHRhKTtcXG4gICAgICBkZWx0YVkgPSBNYXRoW2RlbHRhWSA+PSAxID8gXFxcImZsb29yXFxcIiA6IFxcXCJjZWlsXFxcIl0oZGVsdGFZIC8gbG93ZXN0RGVsdGEpO1xcblxcbiAgICAgIC8vIE5vcm1hbGlzZSBvZmZzZXRYIGFuZCBvZmZzZXRZIHByb3BlcnRpZXNcXG4gICAgICBpZiAoc3BlY2lhbC5zZXR0aW5ncy5ub3JtYWxpemVPZmZzZXQgJiYgdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgICAgICAgZXZlbnQub2Zmc2V0WCA9IGV2ZW50LmNsaWVudFggLSBib3VuZGluZ1JlY3QubGVmdDtcXG4gICAgICAgIGV2ZW50Lm9mZnNldFkgPSBldmVudC5jbGllbnRZIC0gYm91bmRpbmdSZWN0LnRvcDtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gQWRkIGluZm9ybWF0aW9uIHRvIHRoZSBldmVudCBvYmplY3RcXG4gICAgICBldmVudC5kZWx0YVggPSBkZWx0YVg7XFxuICAgICAgZXZlbnQuZGVsdGFZID0gZGVsdGFZO1xcbiAgICAgIGV2ZW50LmRlbHRhRmFjdG9yID0gbG93ZXN0RGVsdGE7XFxuXFxuICAgICAgLy8gR28gYWhlYWQgYW5kIHNldCBkZWx0YU1vZGUgdG8gMCBzaW5jZSB3ZSBjb252ZXJ0ZWQgdG8gcGl4ZWxzXFxuICAgICAgLy8gQWx0aG91Z2ggdGhpcyBpcyBhIGxpdHRsZSBvZGQgc2luY2Ugd2Ugb3ZlcndyaXRlIHRoZSBkZWx0YVgvWVxcbiAgICAgIC8vIHByb3BlcnRpZXMgd2l0aCBub3JtYWxpemVkIGRlbHRhcy5cXG4gICAgICBldmVudC5kZWx0YU1vZGUgPSAwO1xcblxcbiAgICAgIC8vIEFkZCBldmVudCBhbmQgZGVsdGEgdG8gdGhlIGZyb250IG9mIHRoZSBhcmd1bWVudHNcXG4gICAgICBhcmdzLnVuc2hpZnQoZXZlbnQsIGRlbHRhLCBkZWx0YVgsIGRlbHRhWSk7XFxuXFxuICAgICAgLy8gQ2xlYXJvdXQgbG93ZXN0RGVsdGEgYWZ0ZXIgc29tZXRpbWUgdG8gYmV0dGVyXFxuICAgICAgLy8gaGFuZGxlIG11bHRpcGxlIGRldmljZSB0eXBlcyB0aGF0IGdpdmUgZGlmZmVyZW50XFxuICAgICAgLy8gYSBkaWZmZXJlbnQgbG93ZXN0RGVsdGFcXG4gICAgICAvLyBFeDogdHJhY2twYWQgPSAzIGFuZCBtb3VzZSB3aGVlbCA9IDEyMFxcbiAgICAgIGlmIChudWxsTG93ZXN0RGVsdGFUaW1lb3V0KSB7XFxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KG51bGxMb3dlc3REZWx0YVRpbWVvdXQpO1xcbiAgICAgIH1cXG4gICAgICBudWxsTG93ZXN0RGVsdGFUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQobnVsbExvd2VzdERlbHRhLCAyMDApO1xcblxcbiAgICAgIHJldHVybiAoJC5ldmVudC5kaXNwYXRjaCB8fCAkLmV2ZW50LmhhbmRsZSkuYXBwbHkodGhpcywgYXJncyk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbnVsbExvd2VzdERlbHRhKCkge1xcbiAgICAgIGxvd2VzdERlbHRhID0gbnVsbDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzaG91bGRBZGp1c3RPbGREZWx0YXMob3JnRXZlbnQsIGFic0RlbHRhKSB7XFxuICAgICAgLy8gSWYgdGhpcyBpcyBhbiBvbGRlciBldmVudCBhbmQgdGhlIGRlbHRhIGlzIGRpdmlzYWJsZSBieSAxMjAsXFxuICAgICAgLy8gdGhlbiB3ZSBhcmUgYXNzdW1pbmcgdGhhdCB0aGUgYnJvd3NlciBpcyB0cmVhdGluZyB0aGlzIGFzIGFuXFxuICAgICAgLy8gb2xkZXIgbW91c2Ugd2hlZWwgZXZlbnQgYW5kIHRoYXQgd2Ugc2hvdWxkIGRpdmlkZSB0aGUgZGVsdGFzXFxuICAgICAgLy8gYnkgNDAgdG8gdHJ5IGFuZCBnZXQgYSBtb3JlIHVzYWJsZSBkZWx0YUZhY3Rvci5cXG4gICAgICAvLyBTaWRlIG5vdGUsIHRoaXMgYWN0dWFsbHkgaW1wYWN0cyB0aGUgcmVwb3J0ZWQgc2Nyb2xsIGRpc3RhbmNlXFxuICAgICAgLy8gaW4gb2xkZXIgYnJvd3NlcnMgYW5kIGNhbiBjYXVzZSBzY3JvbGxpbmcgdG8gYmUgc2xvd2VyIHRoYW4gbmF0aXZlLlxcbiAgICAgIC8vIFR1cm4gdGhpcyBvZmYgYnkgc2V0dGluZyAkLmV2ZW50LnNwZWNpYWwubW91c2V3aGVlbC5zZXR0aW5ncy5hZGp1c3RPbGREZWx0YXMgdG8gZmFsc2UuXFxuICAgICAgcmV0dXJuIChcXG4gICAgICAgIHNwZWNpYWwuc2V0dGluZ3MuYWRqdXN0T2xkRGVsdGFzICYmXFxuICAgICAgICBvcmdFdmVudC50eXBlID09PSBcXFwibW91c2V3aGVlbFxcXCIgJiZcXG4gICAgICAgIGFic0RlbHRhICUgMTIwID09PSAwXFxuICAgICAgKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uLi9qcXVlcnktbW91c2V3aGVlbC9qcXVlcnkubW91c2V3aGVlbC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2p2ZWN0b3JtYXAvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9qdmVjdG9ybWFwL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImxvYWRKVmVjdG9yTWFwXFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2pxdWVyeV9qdmVjdG9ybWFwX21pbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmxvYWRKVmVjdG9yTWFwKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfanF1ZXJ5X2p2ZWN0b3JtYXBfbWluX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pxdWVyeS5qdmVjdG9ybWFwLm1pbiAqLyBcXFwiLi4vanZlY3Rvcm1hcC9qcXVlcnkuanZlY3Rvcm1hcC5taW4uanNcXFwiKTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AcmVhY3QtanZlY3Rvcm1hcC9jb3JlLy4uL2p2ZWN0b3JtYXAvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9qdmVjdG9ybWFwL2pxdWVyeS5qdmVjdG9ybWFwLm1pbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9qdmVjdG9ybWFwL2pxdWVyeS5qdmVjdG9ybWFwLm1pbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwibG9hZEpWZWN0b3JNYXBcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBsb2FkSlZlY3Rvck1hcClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JlYWN0X2p2ZWN0b3JtYXBfanF1ZXJ5X21vdXNld2hlZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEByZWFjdC1qdmVjdG9ybWFwL2pxdWVyeS1tb3VzZXdoZWVsICovIFxcXCIuLi9qcXVlcnktbW91c2V3aGVlbC9qcXVlcnkubW91c2V3aGVlbC5qc1xcXCIpO1xcblxcblxcbi8qKlxcbiAqIGpWZWN0b3JNYXAgdmVyc2lvbiAyLjAuNVxcbiAqXFxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCwgS2lyaWxsIExlYmVkZXZcXG4gKlxcbiAqIGluc3BpcmVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4LXBleC9qdmVjdG9ybWFwL2Jsb2IvbWFzdGVyL2p2ZWN0b3JtYXAtbmV4dC9zcmMvanF1ZXJ5LWp2ZWN0b3JtYXAuanNcXG4gKi9cXG5jb25zdCBsb2FkSlZlY3Rvck1hcCA9ICgkKSA9PlxcbiAgKGZ1bmN0aW9uIChmYWN0b3J5KSB7XFxuICAgIGZhY3RvcnkoJCk7XFxuICB9KShmdW5jdGlvbiAoJCkge1xcbiAgICAoMCxfcmVhY3RfanZlY3Rvcm1hcF9qcXVlcnlfbW91c2V3aGVlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmxvYWRKUXVlcnlNb3VzZVdoZWVsKSgkKTtcXG4gICAganZtLiQgPSAkO1xcbiAgICB3aW5kb3cuanZtID0ganZtO1xcblxcbiAgICBjb25zdCBhcGlQYXJhbXMgPSB7XFxuICAgICAgc2V0OiB7XFxuICAgICAgICBjb2xvcnM6IDEsXFxuICAgICAgICB2YWx1ZXM6IDEsXFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IDEsXFxuICAgICAgICBzY2FsZUNvbG9yczogMSxcXG4gICAgICAgIG5vcm1hbGl6ZUZ1bmN0aW9uOiAxLFxcbiAgICAgICAgZm9jdXM6IDEsXFxuICAgICAgfSxcXG4gICAgICBnZXQ6IHtcXG4gICAgICAgIHNlbGVjdGVkUmVnaW9uczogMSxcXG4gICAgICAgIHNlbGVjdGVkTWFya2VyczogMSxcXG4gICAgICAgIG1hcE9iamVjdDogMSxcXG4gICAgICAgIHJlZ2lvbk5hbWU6IDEsXFxuICAgICAgfSxcXG4gICAgfTtcXG5cXG4gICAgJC5mbi5tdWx0aU1hcCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuICAgICAgb3B0aW9ucy5jb250YWluZXIgPSB0aGlzO1xcbiAgICAgIG5ldyBqdm0uTXVsdGlNYXAob3B0aW9ucyk7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH07XFxuXFxuICAgICQuZm4udmVjdG9yTWFwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG4gICAgICBsZXQgbWFwLCBtZXRob2ROYW1lO1xcbiAgICAgIG1hcCA9IHRoaXMuY2hpbGRyZW4oXFxcIi5qdmVjdG9ybWFwLWNvbnRhaW5lclxcXCIpLmRhdGEoXFxcIm1hcE9iamVjdFxcXCIpO1xcbiAgICAgIGlmIChvcHRpb25zID09PSBcXFwicmVtb3ZlXFxcIikge1xcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IFxcXCJhZGRNYXBcXFwiKSB7XFxuICAgICAgICBqdm0uTWFwLm1hcHNbYXJndW1lbnRzWzFdXSA9IGFyZ3VtZW50c1syXTtcXG4gICAgICB9IGVsc2UgaWYgKFxcbiAgICAgICAgKG9wdGlvbnMgPT09IFxcXCJzZXRcXFwiIHx8IG9wdGlvbnMgPT09IFxcXCJnZXRcXFwiKSAmJlxcbiAgICAgICAgYXBpUGFyYW1zW29wdGlvbnNdW2FyZ3VtZW50c1sxXV1cXG4gICAgICApIHtcXG4gICAgICAgIG1ldGhvZE5hbWUgPVxcbiAgICAgICAgICBhcmd1bWVudHNbMV0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBhcmd1bWVudHNbMV0uc3Vic3RyKDEpO1xcbiAgICAgICAgcmV0dXJuIG1hcFtvcHRpb25zICsgbWV0aG9kTmFtZV0uYXBwbHkoXFxuICAgICAgICAgIG1hcCxcXG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcXG4gICAgICAgICk7XFxuICAgICAgfSBlbHNlIGlmICghbWFwKSB7XFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gICAgICAgIG9wdGlvbnMuY29udGFpbmVyID0gdGhpcztcXG4gICAgICAgIG1hcCA9IG5ldyBqdm0uTWFwKG9wdGlvbnMpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfTtcXG4gIH0pO1xcbi8qKlxcbiAqIEBuYW1lc3BhY2UganZtIEhvbGRzIGNvcmUgbWV0aG9kcyBhbmQgY2xhc3NlcyB1c2VkIGJ5IGpWZWN0b3JNYXAuXFxuICovXFxudmFyIGp2bSA9IHtcXG4gIC8qKlxcbiAgICogSW5oZXJpdHMgY2hpbGQncyBwcm90b3R5cGUgZnJvbSB0aGUgcGFyZW50J3Mgb25lLlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmVudFxcbiAgICovXFxuICBpbmhlcml0czogZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcXG4gICAgZnVuY3Rpb24gdGVtcCgpIHt9XFxuICAgIHRlbXAucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcXG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IHRlbXAoKTtcXG4gICAgY2hpbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGQ7XFxuICAgIGNoaWxkLnBhcmVudENsYXNzID0gcGFyZW50O1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogTWl4ZXMgaW4gbWV0aG9kcyBmcm9tIHRoZSBzb3VyY2UgY29uc3RydWN0b3IgdG8gdGhlIHRhcmdldCBvbmUuXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXJnZXRcXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNvdXJjZVxcbiAgICovXFxuICBtaXhpbjogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XFxuICAgIHZhciBwcm9wO1xcblxcbiAgICBmb3IgKHByb3AgaW4gc291cmNlLnByb3RvdHlwZSkge1xcbiAgICAgIGlmIChzb3VyY2UucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApKSB7XFxuICAgICAgICB0YXJnZXQucHJvdG90eXBlW3Byb3BdID0gc291cmNlLnByb3RvdHlwZVtwcm9wXTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuXFxuICBtaW46IGZ1bmN0aW9uICh2YWx1ZXMpIHtcXG4gICAgdmFyIG1pbiA9IE51bWJlci5NQVhfVkFMVUUsXFxuICAgICAgaTtcXG5cXG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSB7XFxuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKHZhbHVlc1tpXSA8IG1pbikge1xcbiAgICAgICAgICBtaW4gPSB2YWx1ZXNbaV07XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAoaSBpbiB2YWx1ZXMpIHtcXG4gICAgICAgIGlmICh2YWx1ZXNbaV0gPCBtaW4pIHtcXG4gICAgICAgICAgbWluID0gdmFsdWVzW2ldO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gbWluO1xcbiAgfSxcXG5cXG4gIG1heDogZnVuY3Rpb24gKHZhbHVlcykge1xcbiAgICB2YXIgbWF4ID0gTnVtYmVyLk1JTl9WQUxVRSxcXG4gICAgICBpO1xcblxcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgQXJyYXkpIHtcXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAodmFsdWVzW2ldID4gbWF4KSB7XFxuICAgICAgICAgIG1heCA9IHZhbHVlc1tpXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yIChpIGluIHZhbHVlcykge1xcbiAgICAgICAgaWYgKHZhbHVlc1tpXSA+IG1heCkge1xcbiAgICAgICAgICBtYXggPSB2YWx1ZXNbaV07XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBtYXg7XFxuICB9LFxcblxcbiAga2V5czogZnVuY3Rpb24gKG9iamVjdCkge1xcbiAgICB2YXIga2V5cyA9IFtdLFxcbiAgICAgIGtleTtcXG5cXG4gICAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XFxuICAgICAga2V5cy5wdXNoKGtleSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGtleXM7XFxuICB9LFxcblxcbiAgdmFsdWVzOiBmdW5jdGlvbiAob2JqZWN0KSB7XFxuICAgIHZhciB2YWx1ZXMgPSBbXSxcXG4gICAgICBrZXksXFxuICAgICAgaTtcXG5cXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIG9iamVjdCA9IGFyZ3VtZW50c1tpXTtcXG4gICAgICBmb3IgKGtleSBpbiBvYmplY3QpIHtcXG4gICAgICAgIHZhbHVlcy5wdXNoKG9iamVjdFtrZXldKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHZhbHVlcztcXG4gIH0sXFxuXFxuICB3aGVuSW1hZ2VMb2FkZWQ6IGZ1bmN0aW9uICh1cmwpIHtcXG4gICAgdmFyIGRlZmVycmVkID0gbmV3IGp2bS4kLkRlZmVycmVkKCksXFxuICAgICAgaW1nID0ganZtLiQoXFxcIjxpbWcvPlxcXCIpO1xcblxcbiAgICBpbWdcXG4gICAgICAub24oXFxcImVycm9yXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XFxuICAgICAgfSlcXG4gICAgICAub24oXFxcImxvYWRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGltZyk7XFxuICAgICAgfSk7XFxuICAgIGltZy5hdHRyKFxcXCJzcmNcXFwiLCB1cmwpO1xcblxcbiAgICByZXR1cm4gZGVmZXJyZWQ7XFxuICB9LFxcblxcbiAgaXNJbWFnZVVybDogZnVuY3Rpb24gKHMpIHtcXG4gICAgcmV0dXJuIC9cXFxcLlxcXFx3ezMsNH0kLy50ZXN0KHMpO1xcbiAgfSxcXG59O1xcblxcbi8qKlxcbiAqIGluZGV4T2YgcG9seWZpbGwgZm9yIElFIDwgOVxcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcXG4gKi9cXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XFxuICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcXG4gICAgdmFyIGs7XFxuXFxuICAgIC8vIDEuIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCBwYXNzaW5nXFxuICAgIC8vICAgIHRoZSB0aGlzIHZhbHVlIGFzIHRoZSBhcmd1bWVudC5cXG4gICAgaWYgKHRoaXMgPT0gbnVsbCkge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJ0aGlzXFxcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XFxuICAgIH1cXG5cXG4gICAgdmFyIE8gPSBPYmplY3QodGhpcyk7XFxuXFxuICAgIC8vIDIuIExldCBsZW5WYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldFxcbiAgICAvLyAgICBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIHRoZSBhcmd1bWVudCBcXFwibGVuZ3RoXFxcIi5cXG4gICAgLy8gMy4gTGV0IGxlbiBiZSBUb1VpbnQzMihsZW5WYWx1ZSkuXFxuICAgIHZhciBsZW4gPSBPLmxlbmd0aCA+Pj4gMDtcXG5cXG4gICAgLy8gNC4gSWYgbGVuIGlzIDAsIHJldHVybiAtMS5cXG4gICAgaWYgKGxlbiA9PT0gMCkge1xcbiAgICAgIHJldHVybiAtMTtcXG4gICAgfVxcblxcbiAgICAvLyA1LiBJZiBhcmd1bWVudCBmcm9tSW5kZXggd2FzIHBhc3NlZCBsZXQgbiBiZVxcbiAgICAvLyAgICBUb0ludGVnZXIoZnJvbUluZGV4KTsgZWxzZSBsZXQgbiBiZSAwLlxcbiAgICB2YXIgbiA9ICtmcm9tSW5kZXggfHwgMDtcXG5cXG4gICAgaWYgKE1hdGguYWJzKG4pID09PSBJbmZpbml0eSkge1xcbiAgICAgIG4gPSAwO1xcbiAgICB9XFxuXFxuICAgIC8vIDYuIElmIG4gPj0gbGVuLCByZXR1cm4gLTEuXFxuICAgIGlmIChuID49IGxlbikge1xcbiAgICAgIHJldHVybiAtMTtcXG4gICAgfVxcblxcbiAgICAvLyA3LiBJZiBuID49IDAsIHRoZW4gTGV0IGsgYmUgbi5cXG4gICAgLy8gOC4gRWxzZSwgbjwwLCBMZXQgayBiZSBsZW4gLSBhYnMobikuXFxuICAgIC8vICAgIElmIGsgaXMgbGVzcyB0aGFuIDAsIHRoZW4gbGV0IGsgYmUgMC5cXG4gICAgayA9IE1hdGgubWF4KG4gPj0gMCA/IG4gOiBsZW4gLSBNYXRoLmFicyhuKSwgMCk7XFxuXFxuICAgIC8vIDkuIFJlcGVhdCwgd2hpbGUgayA8IGxlblxcbiAgICB3aGlsZSAoayA8IGxlbikge1xcbiAgICAgIC8vIGEuIExldCBQayBiZSBUb1N0cmluZyhrKS5cXG4gICAgICAvLyAgIFRoaXMgaXMgaW1wbGljaXQgZm9yIExIUyBvcGVyYW5kcyBvZiB0aGUgaW4gb3BlcmF0b3JcXG4gICAgICAvLyBiLiBMZXQga1ByZXNlbnQgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZVxcbiAgICAgIC8vICAgIEhhc1Byb3BlcnR5IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXFxuICAgICAgLy8gICBUaGlzIHN0ZXAgY2FuIGJlIGNvbWJpbmVkIHdpdGggY1xcbiAgICAgIC8vIGMuIElmIGtQcmVzZW50IGlzIHRydWUsIHRoZW5cXG4gICAgICAvLyAgICBpLiAgTGV0IGVsZW1lbnRLIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0XFxuICAgICAgLy8gICAgICAgIGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggdGhlIGFyZ3VtZW50IFRvU3RyaW5nKGspLlxcbiAgICAgIC8vICAgaWkuICBMZXQgc2FtZSBiZSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZVxcbiAgICAgIC8vICAgICAgICBTdHJpY3QgRXF1YWxpdHkgQ29tcGFyaXNvbiBBbGdvcml0aG0gdG9cXG4gICAgICAvLyAgICAgICAgc2VhcmNoRWxlbWVudCBhbmQgZWxlbWVudEsuXFxuICAgICAgLy8gIGlpaS4gIElmIHNhbWUgaXMgdHJ1ZSwgcmV0dXJuIGsuXFxuICAgICAgaWYgKGsgaW4gTyAmJiBPW2tdID09PSBzZWFyY2hFbGVtZW50KSB7XFxuICAgICAgICByZXR1cm4gaztcXG4gICAgICB9XFxuICAgICAgaysrO1xcbiAgICB9XFxuICAgIHJldHVybiAtMTtcXG4gIH07XFxufVxcbi8qKlxcbiAqIEJhc2ljIHdyYXBwZXIgZm9yIERPTSBlbGVtZW50LlxcbiAqIEBjb25zdHJ1Y3RvclxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRhZyBuYW1lIG9mIHRoZSBlbGVtZW50XFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBTZXQgb2YgcGFyYW1ldGVycyB0byBpbml0aWFsaXplIGVsZW1lbnQgd2l0aFxcbiAqL1xcbmp2bS5BYnN0cmFjdEVsZW1lbnQgPSBmdW5jdGlvbihuYW1lLCBjb25maWcpe1xcbiAgLyoqXFxuICAgKiBVbmRlcmx5aW5nIERPTSBlbGVtZW50XFxuICAgKiBAdHlwZSB7RE9NRWxlbWVudH1cXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG4gIHRoaXMubm9kZSA9IHRoaXMuY3JlYXRlRWxlbWVudChuYW1lKTtcXG5cXG4gIC8qKlxcbiAgICogTmFtZSBvZiB1bmRlcmx5aW5nIGVsZW1lbnRcXG4gICAqIEB0eXBlIHtTdHJpbmd9XFxuICAgKiBAcHJpdmF0ZVxcbiAgICovXFxuICB0aGlzLm5hbWUgPSBuYW1lO1xcblxcbiAgLyoqXFxuICAgKiBJbnRlcm5hbCBzdG9yZSBvZiBhdHRyaWJ1dGVzXFxuICAgKiBAdHlwZSB7T2JqZWN0fVxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgdGhpcy5wcm9wZXJ0aWVzID0ge307XFxuXFxuICBpZiAoY29uZmlnKSB7XFxuICAgIHRoaXMuc2V0KGNvbmZpZyk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgYXR0cmlidXRlIG9mIHRoZSB1bmRlcmx5aW5nIERPTSBlbGVtZW50LlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlXFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjb25maWcgU2V0IG9mIHBhcmFtZXRlcnMgdG8gaW5pdGlhbGl6ZSBlbGVtZW50IHdpdGhcXG4gKi9cXG5qdm0uQWJzdHJhY3RFbGVtZW50LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpe1xcbiAgdmFyIGtleTtcXG5cXG4gIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdvYmplY3QnKSB7XFxuICAgIGZvciAoa2V5IGluIHByb3BlcnR5KSB7XFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzW2tleV0gPSBwcm9wZXJ0eVtrZXldO1xcbiAgICAgIHRoaXMuYXBwbHlBdHRyKGtleSwgcHJvcGVydHlba2V5XSk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMucHJvcGVydGllc1twcm9wZXJ0eV0gPSB2YWx1ZTtcXG4gICAgdGhpcy5hcHBseUF0dHIocHJvcGVydHksIHZhbHVlKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFJldHVybnMgdmFsdWUgb2YgYXR0cmlidXRlLlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlXFxuICovXFxuanZtLkFic3RyYWN0RWxlbWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocHJvcGVydHkpe1xcbiAgcmV0dXJuIHRoaXMucHJvcGVydGllc1twcm9wZXJ0eV07XFxufTtcXG5cXG4vKipcXG4gKiBBcHBsaWVzIGF0dHJpYnV0ZSB2YWx1ZSB0byB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZVxcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY29uZmlnIFZhbHVlIG9mIGF0dHJpYnV0ZSB0byBhcHBseVxcbiAqIEBwcml2YXRlXFxuICovXFxuanZtLkFic3RyYWN0RWxlbWVudC5wcm90b3R5cGUuYXBwbHlBdHRyID0gZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKXtcXG4gIGlmICghTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xcbiAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKHByb3BlcnR5LCB2YWx1ZSk7XFxuICB9XFxufTtcXG5cXG5qdm0uQWJzdHJhY3RFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpe1xcbiAganZtLiQodGhpcy5ub2RlKS5yZW1vdmUoKTtcXG59Oy8qKlxcbiAqIEltcGxlbWVudHMgYWJzdHJhY3QgdmVjdG9yIGNhbnZhcy5cXG4gKiBAY29uc3RydWN0b3JcXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgQ29udGFpbmVyIHRvIHB1dCBlbGVtZW50IHRvLlxcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBXaWR0aCBvZiBjYW52YXMuXFxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgY2FudmFzLlxcbiAqL1xcbmp2bS5BYnN0cmFjdENhbnZhc0VsZW1lbnQgPSBmdW5jdGlvbihjb250YWluZXIsIHdpZHRoLCBoZWlnaHQpe1xcbiAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XFxuICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XFxuICB0aGlzLnJvb3RFbGVtZW50ID0gbmV3IGp2bVt0aGlzLmNsYXNzUHJlZml4KydHcm91cEVsZW1lbnQnXSgpO1xcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKCB0aGlzLnJvb3RFbGVtZW50Lm5vZGUgKTtcXG4gIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XFxufVxcblxcbi8qKlxcbiAqIEFkZCBlbGVtZW50IHRvIHRoZSBjZXJ0YWluIGdyb3VwIGluc2lkZSBvZiB0aGUgY2FudmFzLlxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBhZGQgdG8gY2FudmFzLlxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGdyb3VwIEdyb3VwIHRvIGFkZCBlbGVtZW50IGludG8gb3IgaW50byByb290IGdyb3VwIGlmIG5vdCBwcm92aWRlZC5cXG4gKi9cXG5qdm0uQWJzdHJhY3RDYW52YXNFbGVtZW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbGVtZW50LCBncm91cCl7XFxuICBncm91cCA9IGdyb3VwIHx8IHRoaXMucm9vdEVsZW1lbnQ7XFxuICBncm91cC5hZGQoZWxlbWVudCk7XFxuICBlbGVtZW50LmNhbnZhcyA9IHRoaXM7XFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZSBwYXRoIGFuZCBhZGQgaXQgdG8gdGhlIGNhbnZhcy5cXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFBhcmFtZXRlcnMgb2YgcGF0aCB0byBjcmVhdGUuXFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIFN0eWxlcyBvZiB0aGUgcGF0aCB0byBjcmVhdGUuXFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZ3JvdXAgR3JvdXAgdG8gYWRkIHBhdGggaW50by5cXG4gKi9cXG5qdm0uQWJzdHJhY3RDYW52YXNFbGVtZW50LnByb3RvdHlwZS5hZGRQYXRoID0gZnVuY3Rpb24oY29uZmlnLCBzdHlsZSwgZ3JvdXApe1xcbiAgdmFyIGVsID0gbmV3IGp2bVt0aGlzLmNsYXNzUHJlZml4KydQYXRoRWxlbWVudCddKGNvbmZpZywgc3R5bGUpO1xcblxcbiAgdGhpcy5hZGQoZWwsIGdyb3VwKTtcXG4gIHJldHVybiBlbDtcXG59O1xcblxcbi8qKlxcbiAqIENyZWF0ZSBjaXJjbGUgYW5kIGFkZCBpdCB0byB0aGUgY2FudmFzLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgUGFyYW1ldGVycyBvZiBwYXRoIHRvIGNyZWF0ZS5cXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgU3R5bGVzIG9mIHRoZSBwYXRoIHRvIGNyZWF0ZS5cXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBncm91cCBHcm91cCB0byBhZGQgY2lyY2xlIGludG8uXFxuICovXFxuanZtLkFic3RyYWN0Q2FudmFzRWxlbWVudC5wcm90b3R5cGUuYWRkQ2lyY2xlID0gZnVuY3Rpb24oY29uZmlnLCBzdHlsZSwgZ3JvdXApe1xcbiAgdmFyIGVsID0gbmV3IGp2bVt0aGlzLmNsYXNzUHJlZml4KydDaXJjbGVFbGVtZW50J10oY29uZmlnLCBzdHlsZSk7XFxuXFxuICB0aGlzLmFkZChlbCwgZ3JvdXApO1xcbiAgcmV0dXJuIGVsO1xcbn07XFxuXFxuLyoqXFxuICogQ3JlYXRlIGNpcmNsZSBhbmQgYWRkIGl0IHRvIHRoZSBjYW52YXMuXFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBQYXJhbWV0ZXJzIG9mIHBhdGggdG8gY3JlYXRlLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSBTdHlsZXMgb2YgdGhlIHBhdGggdG8gY3JlYXRlLlxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGdyb3VwIEdyb3VwIHRvIGFkZCBjaXJjbGUgaW50by5cXG4gKi9cXG5qdm0uQWJzdHJhY3RDYW52YXNFbGVtZW50LnByb3RvdHlwZS5hZGRJbWFnZSA9IGZ1bmN0aW9uKGNvbmZpZywgc3R5bGUsIGdyb3VwKXtcXG4gIHZhciBlbCA9IG5ldyBqdm1bdGhpcy5jbGFzc1ByZWZpeCsnSW1hZ2VFbGVtZW50J10oY29uZmlnLCBzdHlsZSk7XFxuXFxuICB0aGlzLmFkZChlbCwgZ3JvdXApO1xcbiAgcmV0dXJuIGVsO1xcbn07XFxuXFxuLyoqXFxuICogQ3JlYXRlIHRleHQgYW5kIGFkZCBpdCB0byB0aGUgY2FudmFzLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgUGFyYW1ldGVycyBvZiBwYXRoIHRvIGNyZWF0ZS5cXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgU3R5bGVzIG9mIHRoZSBwYXRoIHRvIGNyZWF0ZS5cXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBncm91cCBHcm91cCB0byBhZGQgY2lyY2xlIGludG8uXFxuICovXFxuanZtLkFic3RyYWN0Q2FudmFzRWxlbWVudC5wcm90b3R5cGUuYWRkVGV4dCA9IGZ1bmN0aW9uKGNvbmZpZywgc3R5bGUsIGdyb3VwKXtcXG4gIHZhciBlbCA9IG5ldyBqdm1bdGhpcy5jbGFzc1ByZWZpeCsnVGV4dEVsZW1lbnQnXShjb25maWcsIHN0eWxlKTtcXG5cXG4gIHRoaXMuYWRkKGVsLCBncm91cCk7XFxuICByZXR1cm4gZWw7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgZ3JvdXAgdG8gdGhlIGFub3RoZXIgZ3JvdXAgaW5zaWRlIG9mIHRoZSBjYW52YXMuXFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZ3JvdXAgR3JvdXAgdG8gYWRkIGNpcmNsZSBpbnRvIG9yIHJvb3QgZ3JvdXAgaWYgbm90IHByb3ZpZGVkLlxcbiAqL1xcbmp2bS5BYnN0cmFjdENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmFkZEdyb3VwID0gZnVuY3Rpb24ocGFyZW50R3JvdXApe1xcbiAgdmFyIGVsID0gbmV3IGp2bVt0aGlzLmNsYXNzUHJlZml4KydHcm91cEVsZW1lbnQnXSgpO1xcblxcbiAgaWYgKHBhcmVudEdyb3VwKSB7XFxuICAgIHBhcmVudEdyb3VwLm5vZGUuYXBwZW5kQ2hpbGQoZWwubm9kZSk7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZWwubm9kZSk7XFxuICB9XFxuICBlbC5jYW52YXMgPSB0aGlzO1xcbiAgcmV0dXJuIGVsO1xcbn07LyoqXFxuICogQWJzdHJhY3Qgc2hhcGUgZWxlbWVudC4gU2hhcGUgZWxlbWVudCByZXByZXNlbnRzIHNvbWUgdmlzdWFsIHZlY3RvciBvciByYXN0ZXIgb2JqZWN0LlxcbiAqIEBjb25zdHJ1Y3RvclxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRhZyBuYW1lIG9mIHRoZSBlbGVtZW50LlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgU2V0IG9mIHBhcmFtZXRlcnMgdG8gaW5pdGlhbGl6ZSBlbGVtZW50IHdpdGguXFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIE9iamVjdCB3aXRoIHN0eWxlcyB0byBzZXQgb24gZWxlbWVudCBpbml0aWFsaXphdGlvbi5cXG4gKi9cXG5qdm0uQWJzdHJhY3RTaGFwZUVsZW1lbnQgPSBmdW5jdGlvbihuYW1lLCBjb25maWcsIHN0eWxlKXtcXG4gIHRoaXMuc3R5bGUgPSBzdHlsZSB8fCB7fTtcXG4gIHRoaXMuc3R5bGUuY3VycmVudCA9IHRoaXMuc3R5bGUuY3VycmVudCB8fCB7fTtcXG4gIHRoaXMuaXNIb3ZlcmVkID0gZmFsc2U7XFxuICB0aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcXG4gIHRoaXMudXBkYXRlU3R5bGUoKTtcXG59O1xcblxcbi8qKlxcbiAqIFNldCBlbGVtZW50J3Mgc3R5bGUuXFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wZXJ0eSBDb3VsZCBiZSBzdHJpbmcgdG8gc2V0IG9ubHkgb25lIHByb3BlcnR5IG9yIG9iamVjdCB0byBzZXQgc2V2ZXJhbCBzdHlsZSBwcm9wZXJ0aWVzIGF0IG9uY2UuXFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHNldCBpbiBjYXNlIG9ubHkgb25lIHByb3BlcnR5IHNob3VsZCBiZSBzZXQuXFxuICovXFxuanZtLkFic3RyYWN0U2hhcGVFbGVtZW50LnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSl7XFxuICB2YXIgc3R5bGVzID0ge307XFxuXFxuICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnb2JqZWN0Jykge1xcbiAgICBzdHlsZXMgPSBwcm9wZXJ0eTtcXG4gIH0gZWxzZSB7XFxuICAgIHN0eWxlc1twcm9wZXJ0eV0gPSB2YWx1ZTtcXG4gIH1cXG4gIGp2bS4kLmV4dGVuZCh0aGlzLnN0eWxlLmN1cnJlbnQsIHN0eWxlcyk7XFxuICB0aGlzLnVwZGF0ZVN0eWxlKCk7XFxufTtcXG5cXG5cXG5qdm0uQWJzdHJhY3RTaGFwZUVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24oKXtcXG4gIHZhciBhdHRycyA9IHt9O1xcblxcbiAganZtLkFic3RyYWN0U2hhcGVFbGVtZW50Lm1lcmdlU3R5bGVzKGF0dHJzLCB0aGlzLnN0eWxlLmluaXRpYWwpO1xcbiAganZtLkFic3RyYWN0U2hhcGVFbGVtZW50Lm1lcmdlU3R5bGVzKGF0dHJzLCB0aGlzLnN0eWxlLmN1cnJlbnQpO1xcbiAgaWYgKHRoaXMuaXNIb3ZlcmVkKSB7XFxuICAgIGp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudC5tZXJnZVN0eWxlcyhhdHRycywgdGhpcy5zdHlsZS5ob3Zlcik7XFxuICB9XFxuICBpZiAodGhpcy5pc1NlbGVjdGVkKSB7XFxuICAgIGp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudC5tZXJnZVN0eWxlcyhhdHRycywgdGhpcy5zdHlsZS5zZWxlY3RlZCk7XFxuICAgIGlmICh0aGlzLmlzSG92ZXJlZCkge1xcbiAgICAgIGp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudC5tZXJnZVN0eWxlcyhhdHRycywgdGhpcy5zdHlsZS5zZWxlY3RlZEhvdmVyKTtcXG4gICAgfVxcbiAgfVxcbiAgdGhpcy5zZXQoYXR0cnMpO1xcbn07XFxuXFxuanZtLkFic3RyYWN0U2hhcGVFbGVtZW50Lm1lcmdlU3R5bGVzID0gZnVuY3Rpb24oc3R5bGVzLCBuZXdTdHlsZXMpe1xcbiAgdmFyIGtleTtcXG5cXG4gIG5ld1N0eWxlcyA9IG5ld1N0eWxlcyB8fCB7fTtcXG4gIGZvciAoa2V5IGluIG5ld1N0eWxlcykge1xcbiAgICBpZiAobmV3U3R5bGVzW2tleV0gPT09IG51bGwpIHtcXG4gICAgICBkZWxldGUgc3R5bGVzW2tleV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3R5bGVzW2tleV0gPSBuZXdTdHlsZXNba2V5XTtcXG4gICAgfVxcbiAgfVxcbn0vKipcXG4gKiBXcmFwcGVyIGZvciBTVkcgZWxlbWVudC5cXG4gKiBAY29uc3RydWN0b3JcXG4gKiBAZXh0ZW5kcyBqdm0uQWJzdHJhY3RFbGVtZW50XFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGFnIG5hbWUgb2YgdGhlIGVsZW1lbnRcXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFNldCBvZiBwYXJhbWV0ZXJzIHRvIGluaXRpYWxpemUgZWxlbWVudCB3aXRoXFxuICovXFxuXFxuanZtLlNWR0VsZW1lbnQgPSBmdW5jdGlvbihuYW1lLCBjb25maWcpe1xcbiAganZtLlNWR0VsZW1lbnQucGFyZW50Q2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG59XFxuXFxuanZtLmluaGVyaXRzKGp2bS5TVkdFbGVtZW50LCBqdm0uQWJzdHJhY3RFbGVtZW50KTtcXG5cXG5qdm0uU1ZHRWxlbWVudC5zdmducyA9IFxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI7XFxuXFxuLyoqXFxuICogQ3JlYXRlcyBET00gZWxlbWVudC5cXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZSBOYW1lIG9mIGVsZW1lbnRcXG4gKiBAcHJpdmF0ZVxcbiAqIEByZXR1cm5zIERPTUVsZW1lbnRcXG4gKi9cXG5qdm0uU1ZHRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCB0YWdOYW1lICl7XFxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCBqdm0uU1ZHRWxlbWVudC5zdmducywgdGFnTmFtZSApO1xcbn07XFxuXFxuLyoqXFxuICogQWRkcyBDU1MgY2xhc3MgZm9yIHVuZGVybHlpbmcgRE9NIGVsZW1lbnQuXFxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBOYW1lIG9mIENTUyBjbGFzcyBuYW1lXFxuICovXFxuanZtLlNWR0VsZW1lbnQucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24oIGNsYXNzTmFtZSApe1xcbiAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc05hbWUpO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJucyBjb25zdHJ1Y3RvciBmb3IgZWxlbWVudCBieSBuYW1lIHByZWZpeGVkIHdpdGggJ1ZNTCcuXFxuICogQHBhcmFtIHtTdHJpbmd9IGN0ciBOYW1lIG9mIGJhc2ljIGNvbnN0cnVjdG9yIHRvIHJldHVyblxcbiAqIHByb3BlciBpbXBsZW1lbnRhdGlvbiBmb3IuXFxuICogQHJldHVybnMgRnVuY3Rpb25cXG4gKiBAcHJpdmF0ZVxcbiAqL1xcbmp2bS5TVkdFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50Q3RyID0gZnVuY3Rpb24oIGN0ciApe1xcbiAgcmV0dXJuIGp2bVsnU1ZHJytjdHJdO1xcbn07XFxuXFxuanZtLlNWR0VsZW1lbnQucHJvdG90eXBlLmdldEJCb3ggPSBmdW5jdGlvbigpe1xcbiAgcmV0dXJuIHRoaXMubm9kZS5nZXRCQm94KCk7XFxufTtqdm0uU1ZHR3JvdXBFbGVtZW50ID0gZnVuY3Rpb24oKXtcXG4gIGp2bS5TVkdHcm91cEVsZW1lbnQucGFyZW50Q2xhc3MuY2FsbCh0aGlzLCAnZycpO1xcbn1cXG5cXG5qdm0uaW5oZXJpdHMoanZtLlNWR0dyb3VwRWxlbWVudCwganZtLlNWR0VsZW1lbnQpO1xcblxcbmp2bS5TVkdHcm91cEVsZW1lbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKCBlbGVtZW50Lm5vZGUgKTtcXG59O2p2bS5TVkdDYW52YXNFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgd2lkdGgsIGhlaWdodCkge1xcbiAgdGhpcy5jbGFzc1ByZWZpeCA9IFxcXCJTVkdcXFwiO1xcbiAganZtLlNWR0NhbnZhc0VsZW1lbnQucGFyZW50Q2xhc3MuY2FsbCh0aGlzLCBcXFwic3ZnXFxcIik7XFxuXFxuICB0aGlzLmRlZnNFbGVtZW50ID0gbmV3IGp2bS5TVkdFbGVtZW50KFxcXCJkZWZzXFxcIik7XFxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5kZWZzRWxlbWVudC5ub2RlKTtcXG5cXG4gIGp2bS5BYnN0cmFjdENhbnZhc0VsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG59O1xcblxcbmp2bS5pbmhlcml0cyhqdm0uU1ZHQ2FudmFzRWxlbWVudCwganZtLlNWR0VsZW1lbnQpO1xcbmp2bS5taXhpbihqdm0uU1ZHQ2FudmFzRWxlbWVudCwganZtLkFic3RyYWN0Q2FudmFzRWxlbWVudCk7XFxuXFxuanZtLlNWR0NhbnZhc0VsZW1lbnQucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xcbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XFxuICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFxcXCJ3aWR0aFxcXCIsIHdpZHRoKTtcXG4gIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXFxcImhlaWdodFxcXCIsIGhlaWdodCk7XFxufTtcXG5cXG5qdm0uU1ZHQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1QYXJhbXMgPSBmdW5jdGlvbiAoXFxuICBzY2FsZSxcXG4gIHRyYW5zWCxcXG4gIHRyYW5zWSxcXG4pIHtcXG4gIHRoaXMuc2NhbGUgPSBzY2FsZTtcXG4gIHRoaXMudHJhbnNYID0gdHJhbnNYO1xcbiAgdGhpcy50cmFuc1kgPSB0cmFuc1k7XFxuICBpZiAoIWlzTmFOKHRyYW5zWCkgJiYgIWlzTmFOKHRyYW5zWSkgJiYgIWlzTmFOKHNjYWxlKSkge1xcbiAgICB0aGlzLnJvb3RFbGVtZW50Lm5vZGUuc2V0QXR0cmlidXRlKFxcbiAgICAgIFxcXCJ0cmFuc2Zvcm1cXFwiLFxcbiAgICAgIFxcXCJzY2FsZShcXFwiICsgc2NhbGUgKyBcXFwiKSB0cmFuc2xhdGUoXFxcIiArIHRyYW5zWCArIFxcXCIsIFxcXCIgKyB0cmFuc1kgKyBcXFwiKVxcXCIsXFxuICAgICk7XFxuICB9XFxufTtcXG5qdm0uU1ZHU2hhcGVFbGVtZW50ID0gZnVuY3Rpb24obmFtZSwgY29uZmlnLCBzdHlsZSl7XFxuICBqdm0uU1ZHU2hhcGVFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcywgbmFtZSwgY29uZmlnKTtcXG4gIGp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbn07XFxuXFxuanZtLmluaGVyaXRzKGp2bS5TVkdTaGFwZUVsZW1lbnQsIGp2bS5TVkdFbGVtZW50KTtcXG5qdm0ubWl4aW4oanZtLlNWR1NoYXBlRWxlbWVudCwganZtLkFic3RyYWN0U2hhcGVFbGVtZW50KTtcXG5cXG5qdm0uU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hcHBseUF0dHIgPSBmdW5jdGlvbihhdHRyLCB2YWx1ZSl7XFxuICB2YXIgcGF0dGVybkVsLFxcbiAgICAgIGltYWdlRWwsXFxuICAgICAgdGhhdCA9IHRoaXM7XFxuXFxuICBpZiAoYXR0ciA9PT0gJ2ZpbGwnICYmIGp2bS5pc0ltYWdlVXJsKHZhbHVlKSkge1xcbiAgICBpZiAoIWp2bS5TVkdTaGFwZUVsZW1lbnQuaW1hZ2VzW3ZhbHVlXSkge1xcbiAgICAgIGp2bS53aGVuSW1hZ2VMb2FkZWQodmFsdWUpLnRoZW4oZnVuY3Rpb24oaW1nKXtcXG4gICAgICAgIGltYWdlRWwgPSBuZXcganZtLlNWR0VsZW1lbnQoJ2ltYWdlJyk7XFxuICAgICAgICBpbWFnZUVsLm5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIHZhbHVlKTtcXG4gICAgICAgIGltYWdlRWwuYXBwbHlBdHRyKCd4JywgJzAnKTtcXG4gICAgICAgIGltYWdlRWwuYXBwbHlBdHRyKCd5JywgJzAnKTtcXG4gICAgICAgIGltYWdlRWwuYXBwbHlBdHRyKCd3aWR0aCcsIGltZ1swXS53aWR0aCk7XFxuICAgICAgICBpbWFnZUVsLmFwcGx5QXR0cignaGVpZ2h0JywgaW1nWzBdLmhlaWdodCk7XFxuXFxuICAgICAgICBwYXR0ZXJuRWwgPSBuZXcganZtLlNWR0VsZW1lbnQoJ3BhdHRlcm4nKTtcXG4gICAgICAgIHBhdHRlcm5FbC5hcHBseUF0dHIoJ2lkJywgJ2ltYWdlJytqdm0uU1ZHU2hhcGVFbGVtZW50LmltYWdlQ291bnRlcik7XFxuICAgICAgICBwYXR0ZXJuRWwuYXBwbHlBdHRyKCd4JywgMCk7XFxuICAgICAgICBwYXR0ZXJuRWwuYXBwbHlBdHRyKCd5JywgMCk7XFxuICAgICAgICBwYXR0ZXJuRWwuYXBwbHlBdHRyKCd3aWR0aCcsIGltZ1swXS53aWR0aCAvIDIpO1xcbiAgICAgICAgcGF0dGVybkVsLmFwcGx5QXR0cignaGVpZ2h0JywgaW1nWzBdLmhlaWdodCAvIDIpO1xcbiAgICAgICAgcGF0dGVybkVsLmFwcGx5QXR0cigndmlld0JveCcsICcwIDAgJytpbWdbMF0ud2lkdGgrJyAnK2ltZ1swXS5oZWlnaHQpO1xcbiAgICAgICAgcGF0dGVybkVsLmFwcGx5QXR0cigncGF0dGVyblVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XFxuICAgICAgICBwYXR0ZXJuRWwubm9kZS5hcHBlbmRDaGlsZCggaW1hZ2VFbC5ub2RlICk7XFxuXFxuICAgICAgICB0aGF0LmNhbnZhcy5kZWZzRWxlbWVudC5ub2RlLmFwcGVuZENoaWxkKCBwYXR0ZXJuRWwubm9kZSApO1xcblxcbiAgICAgICAganZtLlNWR1NoYXBlRWxlbWVudC5pbWFnZXNbdmFsdWVdID0ganZtLlNWR1NoYXBlRWxlbWVudC5pbWFnZUNvdW50ZXIrKztcXG5cXG4gICAgICAgIHRoYXQuYXBwbHlBdHRyKCdmaWxsJywgJ3VybCgjaW1hZ2UnK2p2bS5TVkdTaGFwZUVsZW1lbnQuaW1hZ2VzW3ZhbHVlXSsnKScpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXMuYXBwbHlBdHRyKCdmaWxsJywgJ3VybCgjaW1hZ2UnK2p2bS5TVkdTaGFwZUVsZW1lbnQuaW1hZ2VzW3ZhbHVlXSsnKScpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBqdm0uU1ZHU2hhcGVFbGVtZW50LnBhcmVudENsYXNzLnByb3RvdHlwZS5hcHBseUF0dHIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG59O1xcblxcbmp2bS5TVkdTaGFwZUVsZW1lbnQuaW1hZ2VDb3VudGVyID0gMTtcXG5qdm0uU1ZHU2hhcGVFbGVtZW50LmltYWdlcyA9IHt9O2p2bS5TVkdQYXRoRWxlbWVudCA9IGZ1bmN0aW9uKGNvbmZpZywgc3R5bGUpe1xcbiAganZtLlNWR1BhdGhFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcywgJ3BhdGgnLCBjb25maWcsIHN0eWxlKTtcXG4gIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsICdldmVub2RkJyk7XFxufVxcblxcbmp2bS5pbmhlcml0cyhqdm0uU1ZHUGF0aEVsZW1lbnQsIGp2bS5TVkdTaGFwZUVsZW1lbnQpO2p2bS5TVkdDaXJjbGVFbGVtZW50ID0gZnVuY3Rpb24oY29uZmlnLCBzdHlsZSl7XFxuICBqdm0uU1ZHQ2lyY2xlRWxlbWVudC5wYXJlbnRDbGFzcy5jYWxsKHRoaXMsICdjaXJjbGUnLCBjb25maWcsIHN0eWxlKTtcXG59O1xcblxcbmp2bS5pbmhlcml0cyhqdm0uU1ZHQ2lyY2xlRWxlbWVudCwganZtLlNWR1NoYXBlRWxlbWVudCk7anZtLlNWR0ltYWdlRWxlbWVudCA9IGZ1bmN0aW9uKGNvbmZpZywgc3R5bGUpe1xcbiAganZtLlNWR0ltYWdlRWxlbWVudC5wYXJlbnRDbGFzcy5jYWxsKHRoaXMsICdpbWFnZScsIGNvbmZpZywgc3R5bGUpO1xcbn07XFxuXFxuanZtLmluaGVyaXRzKGp2bS5TVkdJbWFnZUVsZW1lbnQsIGp2bS5TVkdTaGFwZUVsZW1lbnQpO1xcblxcbmp2bS5TVkdJbWFnZUVsZW1lbnQucHJvdG90eXBlLmFwcGx5QXR0ciA9IGZ1bmN0aW9uKGF0dHIsIHZhbHVlKXtcXG4gIHZhciB0aGF0ID0gdGhpcyxcXG4gICAgICBpbWFnZU9mZnNldCxcXG4gICAgICBpbWFnZVVybDtcXG5cXG4gIGlmIChhdHRyID09ICdpbWFnZScpIHtcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xcbiAgICAgIGltYWdlVXJsID0gdmFsdWUudXJsO1xcbiAgICAgIHRoaXMub2Zmc2V0ID0gdmFsdWUub2Zmc2V0O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGltYWdlVXJsID0gdmFsdWU7XFxuICAgICAgdGhpcy5vZmZzZXQgPSBbMCwgMF07XFxuICAgIH1cXG5cXG4gICAganZtLndoZW5JbWFnZUxvYWRlZChpbWFnZVVybCkudGhlbihmdW5jdGlvbihpbWcpe1xcbiAgICAgIHRoYXQubm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgaW1hZ2VVcmwpO1xcbiAgICAgIHRoYXQud2lkdGggPSBpbWdbMF0ud2lkdGg7XFxuICAgICAgdGhhdC5oZWlnaHQgPSBpbWdbMF0uaGVpZ2h0O1xcbiAgICAgIHRoYXQuYXBwbHlBdHRyKCd3aWR0aCcsIHRoYXQud2lkdGgpO1xcbiAgICAgIHRoYXQuYXBwbHlBdHRyKCdoZWlnaHQnLCB0aGF0LmhlaWdodCk7XFxuXFxuICAgICAgdGhhdC5hcHBseUF0dHIoJ3gnLCB0aGF0LmN4IC0gdGhhdC53aWR0aCAvIDIgKyB0aGF0Lm9mZnNldFswXSk7XFxuICAgICAgdGhhdC5hcHBseUF0dHIoJ3knLCB0aGF0LmN5IC0gdGhhdC5oZWlnaHQgLyAyICsgdGhhdC5vZmZzZXRbMV0pO1xcblxcbiAgICAgIGp2bS4kKHRoYXQubm9kZSkudHJpZ2dlcignaW1hZ2Vsb2FkZWQnLCBbaW1nXSk7XFxuICAgIH0pO1xcbiAgfSBlbHNlIGlmKGF0dHIgPT0gJ2N4Jykge1xcbiAgICB0aGlzLmN4ID0gdmFsdWU7XFxuICAgIGlmICh0aGlzLndpZHRoKSB7XFxuICAgICAgdGhpcy5hcHBseUF0dHIoJ3gnLCB2YWx1ZSAtIHRoaXMud2lkdGggLyAyICsgdGhpcy5vZmZzZXRbMF0pO1xcbiAgICB9XFxuICB9IGVsc2UgaWYoYXR0ciA9PSAnY3knKSB7XFxuICAgIHRoaXMuY3kgPSB2YWx1ZTtcXG4gICAgaWYgKHRoaXMuaGVpZ2h0KSB7XFxuICAgICAgdGhpcy5hcHBseUF0dHIoJ3knLCB2YWx1ZSAtIHRoaXMuaGVpZ2h0IC8gMiArIHRoaXMub2Zmc2V0WzFdKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAganZtLlNWR0ltYWdlRWxlbWVudC5wYXJlbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlBdHRyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICB9XFxufTtqdm0uU1ZHVGV4dEVsZW1lbnQgPSBmdW5jdGlvbihjb25maWcsIHN0eWxlKXtcXG4gIGp2bS5TVkdUZXh0RWxlbWVudC5wYXJlbnRDbGFzcy5jYWxsKHRoaXMsICd0ZXh0JywgY29uZmlnLCBzdHlsZSk7XFxufVxcblxcbmp2bS5pbmhlcml0cyhqdm0uU1ZHVGV4dEVsZW1lbnQsIGp2bS5TVkdTaGFwZUVsZW1lbnQpO1xcblxcbmp2bS5TVkdUZXh0RWxlbWVudC5wcm90b3R5cGUuYXBwbHlBdHRyID0gZnVuY3Rpb24oYXR0ciwgdmFsdWUpe1xcbiAgaWYgKGF0dHIgPT09ICd0ZXh0Jykge1xcbiAgICB0aGlzLm5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZTtcXG4gIH0gZWxzZSB7XFxuICAgIGp2bS5TVkdUZXh0RWxlbWVudC5wYXJlbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlBdHRyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICB9XFxufTsvKipcXG4gKiBXcmFwcGVyIGZvciBWTUwgZWxlbWVudC5cXG4gKiBAY29uc3RydWN0b3JcXG4gKiBAZXh0ZW5kcyBqdm0uQWJzdHJhY3RFbGVtZW50XFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGFnIG5hbWUgb2YgdGhlIGVsZW1lbnRcXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFNldCBvZiBwYXJhbWV0ZXJzIHRvIGluaXRpYWxpemUgZWxlbWVudCB3aXRoXFxuICovXFxuXFxuanZtLlZNTEVsZW1lbnQgPSBmdW5jdGlvbihuYW1lLCBjb25maWcpe1xcbiAgaWYgKCFqdm0uVk1MRWxlbWVudC5WTUxJbml0aWFsaXplZCkge1xcbiAgICBqdm0uVk1MRWxlbWVudC5pbml0aWFsaXplVk1MKCk7XFxuICB9XFxuXFxuICBqdm0uVk1MRWxlbWVudC5wYXJlbnRDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbn07XFxuXFxuanZtLmluaGVyaXRzKGp2bS5WTUxFbGVtZW50LCBqdm0uQWJzdHJhY3RFbGVtZW50KTtcXG5cXG4vKipcXG4gKiBTaG93cyBpZiBWTUwgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IG9yIG5vdC5cXG4gKiBAc3RhdGljXFxuICogQHByaXZhdGVcXG4gKiBAdHlwZSB7Qm9vbGVhbn1cXG4gKi9cXG5qdm0uVk1MRWxlbWVudC5WTUxJbml0aWFsaXplZCA9IGZhbHNlO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemVzIFZNTCBoYW5kbGluZyBiZWZvcmUgY3JlYXRpbmcgdGhlIGZpcnN0IGVsZW1lbnRcXG4gKiAoYWRkcyBDU1MgY2xhc3MgYW5kIGNyZWF0ZXMgbmFtZXNwYWNlKS4gQWRkcyBvbmUgb2YgdHdvIGZvcm1zXFxuICogb2YgY3JlYXRlRWxlbWVudCBtZXRob2QgZGVwZW5kaW5nIG9mIHN1cHBvcnQgYnkgYnJvd3Nlci5cXG4gKiBAc3RhdGljXFxuICogQHByaXZhdGVcXG4gKi9cXG5cXG4gLy8gVGhlIGZvbGxvd2luZyBtZXRob2Qgb2YgVk1MIGhhbmRsaW5nIGlzIGJvcnJvd2VkIGZyb20gdGhlXFxuIC8vIFJhcGhhZWwgbGlicmFyeSBieSBEbWl0cnkgQmFyYW5vdnNreS5cXG5cXG5qdm0uVk1MRWxlbWVudC5pbml0aWFsaXplVk1MID0gZnVuY3Rpb24oKXtcXG4gIHRyeSB7XFxuICAgIGlmICghZG9jdW1lbnQubmFtZXNwYWNlcy5ydm1sKSB7XFxuICAgICAgZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoXFxcInJ2bWxcXFwiLFxcXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbFxcXCIpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIERPTSBlbGVtZW50LlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZSBOYW1lIG9mIGVsZW1lbnRcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHJldHVybnMgRE9NRWxlbWVudFxcbiAgICAgKi9cXG4gICAganZtLlZNTEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8cnZtbDonICsgdGFnTmFtZSArICcgY2xhc3M9XFxcInJ2bWxcXFwiPicpO1xcbiAgICB9O1xcbiAgfSBjYXRjaCAoZSkge1xcbiAgICAvKipcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuICAgIGp2bS5WTUxFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcXG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyB0YWdOYW1lICsgJyB4bWxucz1cXFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcXFwiIGNsYXNzPVxcXCJydm1sXFxcIj4nKTtcXG4gICAgfTtcXG4gIH1cXG4gIGRvY3VtZW50LmNyZWF0ZVN0eWxlU2hlZXQoKS5hZGRSdWxlKFxcXCIucnZtbFxcXCIsIFxcXCJiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKVxcXCIpO1xcbiAganZtLlZNTEVsZW1lbnQuVk1MSW5pdGlhbGl6ZWQgPSB0cnVlO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJucyBjb25zdHJ1Y3RvciBmb3IgZWxlbWVudCBieSBuYW1lIHByZWZpeGVkIHdpdGggJ1ZNTCcuXFxuICogQHBhcmFtIHtTdHJpbmd9IGN0ciBOYW1lIG9mIGJhc2ljIGNvbnN0cnVjdG9yIHRvIHJldHVyblxcbiAqIHByb3BlciBpbXBsZW1lbnRhdGlvbiBmb3IuXFxuICogQHJldHVybnMgRnVuY3Rpb25cXG4gKiBAcHJpdmF0ZVxcbiAqL1xcbmp2bS5WTUxFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50Q3RyID0gZnVuY3Rpb24oIGN0ciApe1xcbiAgcmV0dXJuIGp2bVsnVk1MJytjdHJdO1xcbn07XFxuXFxuLyoqXFxuICogQWRkcyBDU1MgY2xhc3MgZm9yIHVuZGVybHlpbmcgRE9NIGVsZW1lbnQuXFxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBOYW1lIG9mIENTUyBjbGFzcyBuYW1lXFxuICovXFxuanZtLlZNTEVsZW1lbnQucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24oIGNsYXNzTmFtZSApe1xcbiAganZtLiQodGhpcy5ub2RlKS5hZGRDbGFzcyhjbGFzc05hbWUpO1xcbn07XFxuXFxuLyoqXFxuICogQXBwbGllcyBhdHRyaWJ1dGUgdmFsdWUgdG8gdGhlIHVuZGVybHlpbmcgRE9NIGVsZW1lbnQuXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGVcXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNvbmZpZyBWYWx1ZSBvZiBhdHRyaWJ1dGUgdG8gYXBwbHlcXG4gKiBAcHJpdmF0ZVxcbiAqL1xcbmp2bS5WTUxFbGVtZW50LnByb3RvdHlwZS5hcHBseUF0dHIgPSBmdW5jdGlvbiggYXR0ciwgdmFsdWUgKXtcXG4gIHRoaXMubm9kZVthdHRyXSA9IHZhbHVlO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJucyBib3VuZGFyeSBib3ggZm9yIHRoZSBlbGVtZW50LlxcbiAqIEByZXR1cm5zIHtPYmplY3R9IEJvdW5kYXJ5IGJveCB3aXRoIG51bWVyaWMgZmllbGRzOiB4LCB5LCB3aWR0aCwgaGVpZ2h0XFxuICogQG92ZXJyaWRlXFxuICovXFxuanZtLlZNTEVsZW1lbnQucHJvdG90eXBlLmdldEJCb3ggPSBmdW5jdGlvbigpe1xcbiAgdmFyIG5vZGUgPSBqdm0uJCh0aGlzLm5vZGUpO1xcblxcbiAgcmV0dXJuIHtcXG4gICAgeDogbm9kZS5wb3NpdGlvbigpLmxlZnQgLyB0aGlzLmNhbnZhcy5zY2FsZSxcXG4gICAgeTogbm9kZS5wb3NpdGlvbigpLnRvcCAvIHRoaXMuY2FudmFzLnNjYWxlLFxcbiAgICB3aWR0aDogbm9kZS53aWR0aCgpIC8gdGhpcy5jYW52YXMuc2NhbGUsXFxuICAgIGhlaWdodDogbm9kZS5oZWlnaHQoKSAvIHRoaXMuY2FudmFzLnNjYWxlXFxuICB9O1xcbn07anZtLlZNTEdyb3VwRWxlbWVudCA9IGZ1bmN0aW9uKCl7XFxuICBqdm0uVk1MR3JvdXBFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcywgJ2dyb3VwJyk7XFxuXFxuICB0aGlzLm5vZGUuc3R5bGUubGVmdCA9ICcwcHgnO1xcbiAgdGhpcy5ub2RlLnN0eWxlLnRvcCA9ICcwcHgnO1xcbiAgdGhpcy5ub2RlLmNvb3Jkb3JpZ2luID0gXFxcIjAgMFxcXCI7XFxufTtcXG5cXG5qdm0uaW5oZXJpdHMoanZtLlZNTEdyb3VwRWxlbWVudCwganZtLlZNTEVsZW1lbnQpO1xcblxcbmp2bS5WTUxHcm91cEVsZW1lbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKCBlbGVtZW50Lm5vZGUgKTtcXG59O2p2bS5WTUxDYW52YXNFbGVtZW50ID0gZnVuY3Rpb24oY29udGFpbmVyLCB3aWR0aCwgaGVpZ2h0KXtcXG4gIHRoaXMuY2xhc3NQcmVmaXggPSAnVk1MJztcXG4gIGp2bS5WTUxDYW52YXNFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcywgJ2dyb3VwJyk7XFxuICBqdm0uQWJzdHJhY3RDYW52YXNFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICB0aGlzLm5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xcbn07XFxuXFxuanZtLmluaGVyaXRzKGp2bS5WTUxDYW52YXNFbGVtZW50LCBqdm0uVk1MRWxlbWVudCk7XFxuanZtLm1peGluKGp2bS5WTUxDYW52YXNFbGVtZW50LCBqdm0uQWJzdHJhY3RDYW52YXNFbGVtZW50KTtcXG5cXG5qdm0uVk1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpe1xcbiAgdmFyIHBhdGhzLFxcbiAgICAgIGdyb3VwcyxcXG4gICAgICBpLFxcbiAgICAgIGw7XFxuXFxuICB0aGlzLndpZHRoID0gd2lkdGg7XFxuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcXG4gIHRoaXMubm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgXFxcInB4XFxcIjtcXG4gIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcXFwicHhcXFwiO1xcbiAgdGhpcy5ub2RlLmNvb3Jkc2l6ZSA9IHdpZHRoKycgJytoZWlnaHQ7XFxuICB0aGlzLm5vZGUuY29vcmRvcmlnaW4gPSBcXFwiMCAwXFxcIjtcXG4gIGlmICh0aGlzLnJvb3RFbGVtZW50KSB7XFxuICAgIHBhdGhzID0gdGhpcy5yb290RWxlbWVudC5ub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzaGFwZScpO1xcbiAgICBmb3IoaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICBwYXRoc1tpXS5jb29yZHNpemUgPSB3aWR0aCsnICcraGVpZ2h0O1xcbiAgICAgIHBhdGhzW2ldLnN0eWxlLndpZHRoID0gd2lkdGgrJ3B4JztcXG4gICAgICBwYXRoc1tpXS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQrJ3B4JztcXG4gICAgfVxcbiAgICBncm91cHMgPSB0aGlzLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2dyb3VwJyk7XFxuICAgIGZvcihpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICBncm91cHNbaV0uY29vcmRzaXplID0gd2lkdGgrJyAnK2hlaWdodDtcXG4gICAgICBncm91cHNbaV0uc3R5bGUud2lkdGggPSB3aWR0aCsncHgnO1xcbiAgICAgIGdyb3Vwc1tpXS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQrJ3B4JztcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuanZtLlZNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtUGFyYW1zID0gZnVuY3Rpb24oc2NhbGUsIHRyYW5zWCwgdHJhbnNZKSB7XFxuICB0aGlzLnNjYWxlID0gc2NhbGU7XFxuICB0aGlzLnRyYW5zWCA9IHRyYW5zWDtcXG4gIHRoaXMudHJhbnNZID0gdHJhbnNZO1xcbiAgdGhpcy5yb290RWxlbWVudC5ub2RlLmNvb3Jkb3JpZ2luID0gKHRoaXMud2lkdGgtdHJhbnNYLXRoaXMud2lkdGgvMTAwKSsnLCcrKHRoaXMuaGVpZ2h0LXRyYW5zWS10aGlzLmhlaWdodC8xMDApO1xcbiAgdGhpcy5yb290RWxlbWVudC5ub2RlLmNvb3Jkc2l6ZSA9IHRoaXMud2lkdGgvc2NhbGUrJywnK3RoaXMuaGVpZ2h0L3NjYWxlO1xcbn07anZtLlZNTFNoYXBlRWxlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIGNvbmZpZyl7XFxuICBqdm0uVk1MU2hhcGVFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcywgbmFtZSwgY29uZmlnKTtcXG5cXG4gIHRoaXMuZmlsbEVsZW1lbnQgPSBuZXcganZtLlZNTEVsZW1lbnQoJ2ZpbGwnKTtcXG4gIHRoaXMuc3Ryb2tlRWxlbWVudCA9IG5ldyBqdm0uVk1MRWxlbWVudCgnc3Ryb2tlJyk7XFxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5maWxsRWxlbWVudC5ub2RlKTtcXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLnN0cm9rZUVsZW1lbnQubm9kZSk7XFxuICB0aGlzLm5vZGUuc3Ryb2tlZCA9IGZhbHNlO1xcblxcbiAganZtLkFic3RyYWN0U2hhcGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxufTtcXG5cXG5qdm0uaW5oZXJpdHMoanZtLlZNTFNoYXBlRWxlbWVudCwganZtLlZNTEVsZW1lbnQpO1xcbmp2bS5taXhpbihqdm0uVk1MU2hhcGVFbGVtZW50LCBqdm0uQWJzdHJhY3RTaGFwZUVsZW1lbnQpO1xcblxcbmp2bS5WTUxTaGFwZUVsZW1lbnQucHJvdG90eXBlLmFwcGx5QXR0ciA9IGZ1bmN0aW9uKGF0dHIsIHZhbHVlKXtcXG4gIHN3aXRjaCAoYXR0cikge1xcbiAgICBjYXNlICdmaWxsJzpcXG4gICAgICB0aGlzLm5vZGUuZmlsbGNvbG9yID0gdmFsdWU7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2ZpbGwtb3BhY2l0eSc6XFxuICAgICAgdGhpcy5maWxsRWxlbWVudC5ub2RlLm9wYWNpdHkgPSBNYXRoLnJvdW5kKHZhbHVlKjEwMCkrJyUnO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdzdHJva2UnOlxcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ25vbmUnKSB7XFxuICAgICAgICB0aGlzLm5vZGUuc3Ryb2tlZCA9IGZhbHNlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLm5vZGUuc3Ryb2tlZCA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIHRoaXMubm9kZS5zdHJva2Vjb2xvciA9IHZhbHVlO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdzdHJva2Utb3BhY2l0eSc6XFxuICAgICAgdGhpcy5zdHJva2VFbGVtZW50Lm5vZGUub3BhY2l0eSA9IE1hdGgucm91bmQodmFsdWUqMTAwKSsnJSc7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ3N0cm9rZS13aWR0aCc6XFxuICAgICAgaWYgKHBhcnNlSW50KHZhbHVlLCAxMCkgPT09IDApIHtcXG4gICAgICAgIHRoaXMubm9kZS5zdHJva2VkID0gZmFsc2U7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMubm9kZS5zdHJva2VkID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgdGhpcy5ub2RlLnN0cm9rZXdlaWdodCA9IHZhbHVlO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdkJzpcXG4gICAgICB0aGlzLm5vZGUucGF0aCA9IGp2bS5WTUxQYXRoRWxlbWVudC5wYXRoU3ZnVG9WbWwodmFsdWUpO1xcbiAgICAgIGJyZWFrO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIGp2bS5WTUxTaGFwZUVsZW1lbnQucGFyZW50Q2xhc3MucHJvdG90eXBlLmFwcGx5QXR0ci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcbn07anZtLlZNTFBhdGhFbGVtZW50ID0gZnVuY3Rpb24oY29uZmlnLCBzdHlsZSl7XFxuICB2YXIgc2NhbGUgPSBuZXcganZtLlZNTEVsZW1lbnQoJ3NrZXcnKTtcXG5cXG4gIGp2bS5WTUxQYXRoRWxlbWVudC5wYXJlbnRDbGFzcy5jYWxsKHRoaXMsICdzaGFwZScsIGNvbmZpZywgc3R5bGUpO1xcblxcbiAgdGhpcy5ub2RlLmNvb3Jkb3JpZ2luID0gXFxcIjAgMFxcXCI7XFxuXFxuICBzY2FsZS5ub2RlLm9uID0gdHJ1ZTtcXG4gIHNjYWxlLm5vZGUubWF0cml4ID0gJzAuMDEsMCwwLDAuMDEsMCwwJztcXG4gIHNjYWxlLm5vZGUub2Zmc2V0ID0gJzAsMCc7XFxuXFxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoc2NhbGUubm9kZSk7XFxufTtcXG5cXG5qdm0uaW5oZXJpdHMoanZtLlZNTFBhdGhFbGVtZW50LCBqdm0uVk1MU2hhcGVFbGVtZW50KTtcXG5cXG5qdm0uVk1MUGF0aEVsZW1lbnQucHJvdG90eXBlLmFwcGx5QXR0ciA9IGZ1bmN0aW9uKGF0dHIsIHZhbHVlKXtcXG4gIGlmIChhdHRyID09PSAnZCcpIHtcXG4gICAgdGhpcy5ub2RlLnBhdGggPSBqdm0uVk1MUGF0aEVsZW1lbnQucGF0aFN2Z1RvVm1sKHZhbHVlKTtcXG4gIH0gZWxzZSB7XFxuICAgIGp2bS5WTUxTaGFwZUVsZW1lbnQucHJvdG90eXBlLmFwcGx5QXR0ci5jYWxsKHRoaXMsIGF0dHIsIHZhbHVlKTtcXG4gIH1cXG59O1xcblxcbmp2bS5WTUxQYXRoRWxlbWVudC5wYXRoU3ZnVG9WbWwgPSBmdW5jdGlvbihwYXRoKSB7XFxuICB2YXIgY3ggPSAwLCBjeSA9IDAsIGN0cmx4LCBjdHJseTtcXG5cXG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoLygtP1xcXFxkKyllKC0/XFxcXGQrKS9nLCAnMCcpO1xcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvKFtNbUxsSGhWdkNjU3NdKVxcXFxzKigoPzotP1xcXFxkKig/OlxcXFwuXFxcXGQrKT9cXFxccyosP1xcXFxzKikrKS9nLCBmdW5jdGlvbihzZWdtZW50LCBsZXR0ZXIsIGNvb3JkcywgaW5kZXgpe1xcbiAgICBjb29yZHMgPSBjb29yZHMucmVwbGFjZSgvKFxcXFxkKS0vZywgJyQxLC0nKVxcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxcXHMrL2csICcnKVxcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxccyskL2csICcnKVxcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxccysvZywgJywnKS5zcGxpdCgnLCcpO1xcbiAgICBpZiAoIWNvb3Jkc1swXSkgY29vcmRzLnNoaWZ0KCk7XFxuICAgIGZvciAodmFyIGk9MCwgbD1jb29yZHMubGVuZ3RoOyBpPGw7IGkrKykge1xcbiAgICAgIGNvb3Jkc1tpXSA9IE1hdGgucm91bmQoMTAwKmNvb3Jkc1tpXSk7XFxuICAgIH1cXG4gICAgc3dpdGNoIChsZXR0ZXIpIHtcXG4gICAgICBjYXNlICdtJzpcXG4gICAgICAgIGN4ICs9IGNvb3Jkc1swXTtcXG4gICAgICAgIGN5ICs9IGNvb3Jkc1sxXTtcXG4gICAgICAgIHJldHVybiAndCcrY29vcmRzLmpvaW4oJywnKTtcXG4gICAgICBjYXNlICdNJzpcXG4gICAgICAgIGN4ID0gY29vcmRzWzBdO1xcbiAgICAgICAgY3kgPSBjb29yZHNbMV07XFxuICAgICAgICByZXR1cm4gJ20nK2Nvb3Jkcy5qb2luKCcsJyk7XFxuICAgICAgY2FzZSAnbCc6XFxuICAgICAgICBjeCArPSBjb29yZHNbMF07XFxuICAgICAgICBjeSArPSBjb29yZHNbMV07XFxuICAgICAgICByZXR1cm4gJ3InK2Nvb3Jkcy5qb2luKCcsJyk7XFxuICAgICAgY2FzZSAnTCc6XFxuICAgICAgICBjeCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGN5ID0gY29vcmRzWzFdO1xcbiAgICAgICAgcmV0dXJuICdsJytjb29yZHMuam9pbignLCcpO1xcbiAgICAgIGNhc2UgJ2gnOlxcbiAgICAgICAgY3ggKz0gY29vcmRzWzBdO1xcbiAgICAgICAgcmV0dXJuICdyJytjb29yZHNbMF0rJywwJztcXG4gICAgICBjYXNlICdIJzpcXG4gICAgICAgIGN4ID0gY29vcmRzWzBdO1xcbiAgICAgICAgcmV0dXJuICdsJytjeCsnLCcrY3k7XFxuICAgICAgY2FzZSAndic6XFxuICAgICAgICBjeSArPSBjb29yZHNbMF07XFxuICAgICAgICByZXR1cm4gJ3IwLCcrY29vcmRzWzBdO1xcbiAgICAgIGNhc2UgJ1YnOlxcbiAgICAgICAgY3kgPSBjb29yZHNbMF07XFxuICAgICAgICByZXR1cm4gJ2wnK2N4KycsJytjeTtcXG4gICAgICBjYXNlICdjJzpcXG4gICAgICAgIGN0cmx4ID0gY3ggKyBjb29yZHNbY29vcmRzLmxlbmd0aC00XTtcXG4gICAgICAgIGN0cmx5ID0gY3kgKyBjb29yZHNbY29vcmRzLmxlbmd0aC0zXTtcXG4gICAgICAgIGN4ICs9IGNvb3Jkc1tjb29yZHMubGVuZ3RoLTJdO1xcbiAgICAgICAgY3kgKz0gY29vcmRzW2Nvb3Jkcy5sZW5ndGgtMV07XFxuICAgICAgICByZXR1cm4gJ3YnK2Nvb3Jkcy5qb2luKCcsJyk7XFxuICAgICAgY2FzZSAnQyc6XFxuICAgICAgICBjdHJseCA9IGNvb3Jkc1tjb29yZHMubGVuZ3RoLTRdO1xcbiAgICAgICAgY3RybHkgPSBjb29yZHNbY29vcmRzLmxlbmd0aC0zXTtcXG4gICAgICAgIGN4ID0gY29vcmRzW2Nvb3Jkcy5sZW5ndGgtMl07XFxuICAgICAgICBjeSA9IGNvb3Jkc1tjb29yZHMubGVuZ3RoLTFdO1xcbiAgICAgICAgcmV0dXJuICdjJytjb29yZHMuam9pbignLCcpO1xcbiAgICAgIGNhc2UgJ3MnOlxcbiAgICAgICAgY29vcmRzLnVuc2hpZnQoY3ktY3RybHkpO1xcbiAgICAgICAgY29vcmRzLnVuc2hpZnQoY3gtY3RybHgpO1xcbiAgICAgICAgY3RybHggPSBjeCArIGNvb3Jkc1tjb29yZHMubGVuZ3RoLTRdO1xcbiAgICAgICAgY3RybHkgPSBjeSArIGNvb3Jkc1tjb29yZHMubGVuZ3RoLTNdO1xcbiAgICAgICAgY3ggKz0gY29vcmRzW2Nvb3Jkcy5sZW5ndGgtMl07XFxuICAgICAgICBjeSArPSBjb29yZHNbY29vcmRzLmxlbmd0aC0xXTtcXG4gICAgICAgIHJldHVybiAndicrY29vcmRzLmpvaW4oJywnKTtcXG4gICAgICBjYXNlICdTJzpcXG4gICAgICAgIGNvb3Jkcy51bnNoaWZ0KGN5K2N5LWN0cmx5KTtcXG4gICAgICAgIGNvb3Jkcy51bnNoaWZ0KGN4K2N4LWN0cmx4KTtcXG4gICAgICAgIGN0cmx4ID0gY29vcmRzW2Nvb3Jkcy5sZW5ndGgtNF07XFxuICAgICAgICBjdHJseSA9IGNvb3Jkc1tjb29yZHMubGVuZ3RoLTNdO1xcbiAgICAgICAgY3ggPSBjb29yZHNbY29vcmRzLmxlbmd0aC0yXTtcXG4gICAgICAgIGN5ID0gY29vcmRzW2Nvb3Jkcy5sZW5ndGgtMV07XFxuICAgICAgICByZXR1cm4gJ2MnK2Nvb3Jkcy5qb2luKCcsJyk7XFxuICAgIH1cXG4gICAgcmV0dXJuICcnO1xcbiAgfSkucmVwbGFjZSgvei9nLCAnZScpO1xcbn07anZtLlZNTENpcmNsZUVsZW1lbnQgPSBmdW5jdGlvbihjb25maWcsIHN0eWxlKXtcXG4gIGp2bS5WTUxDaXJjbGVFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcywgJ292YWwnLCBjb25maWcsIHN0eWxlKTtcXG59O1xcblxcbmp2bS5pbmhlcml0cyhqdm0uVk1MQ2lyY2xlRWxlbWVudCwganZtLlZNTFNoYXBlRWxlbWVudCk7XFxuXFxuanZtLlZNTENpcmNsZUVsZW1lbnQucHJvdG90eXBlLmFwcGx5QXR0ciA9IGZ1bmN0aW9uKGF0dHIsIHZhbHVlKXtcXG4gIHN3aXRjaCAoYXR0cikge1xcbiAgICBjYXNlICdyJzpcXG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2lkdGggPSB2YWx1ZSoyKydweCc7XFxuICAgICAgdGhpcy5ub2RlLnN0eWxlLmhlaWdodCA9IHZhbHVlKjIrJ3B4JztcXG4gICAgICB0aGlzLmFwcGx5QXR0cignY3gnLCB0aGlzLmdldCgnY3gnKSB8fCAwKTtcXG4gICAgICB0aGlzLmFwcGx5QXR0cignY3knLCB0aGlzLmdldCgnY3knKSB8fCAwKTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnY3gnOlxcbiAgICAgIGlmICghdmFsdWUpIHJldHVybjtcXG4gICAgICB0aGlzLm5vZGUuc3R5bGUubGVmdCA9IHZhbHVlIC0gKHRoaXMuZ2V0KCdyJykgfHwgMCkgKyAncHgnO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdjeSc6XFxuICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xcbiAgICAgIHRoaXMubm9kZS5zdHlsZS50b3AgPSB2YWx1ZSAtICh0aGlzLmdldCgncicpIHx8IDApICsgJ3B4JztcXG4gICAgICBicmVhaztcXG4gICAgZGVmYXVsdDpcXG4gICAgICBqdm0uVk1MQ2lyY2xlRWxlbWVudC5wYXJlbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlBdHRyLmNhbGwodGhpcywgYXR0ciwgdmFsdWUpO1xcbiAgfVxcbn07LyoqXFxuICogQ2xhc3MgZm9yIHZlY3RvciBpbWFnZXMgbWFuaXB1bGF0aW9ucy5cXG4gKiBAY29uc3RydWN0b3JcXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciB0byBwbGFjZSBjYW52YXMgdG9cXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XFxuICovXFxuanZtLlZlY3RvckNhbnZhcyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgd2lkdGgsIGhlaWdodCkge1xcbiAgdGhpcy5tb2RlID0gd2luZG93LlNWR0FuZ2xlID8gJ3N2ZycgOiAndm1sJztcXG5cXG4gIGlmICh0aGlzLm1vZGUgPT0gJ3N2ZycpIHtcXG4gICAgdGhpcy5pbXBsID0gbmV3IGp2bS5TVkdDYW52YXNFbGVtZW50KGNvbnRhaW5lciwgd2lkdGgsIGhlaWdodCk7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLmltcGwgPSBuZXcganZtLlZNTENhbnZhc0VsZW1lbnQoY29udGFpbmVyLCB3aWR0aCwgaGVpZ2h0KTtcXG4gIH1cXG4gIHRoaXMuaW1wbC5tb2RlID0gdGhpcy5tb2RlO1xcbiAgcmV0dXJuIHRoaXMuaW1wbDtcXG59O2p2bS5TaW1wbGVTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKXtcXG4gIHRoaXMuc2NhbGUgPSBzY2FsZTtcXG59O1xcblxcbmp2bS5TaW1wbGVTY2FsZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSl7XFxuICByZXR1cm4gdmFsdWU7XFxufTtqdm0uT3JkaW5hbFNjYWxlID0gZnVuY3Rpb24oc2NhbGUpe1xcbiAgdGhpcy5zY2FsZSA9IHNjYWxlO1xcbn07XFxuXFxuanZtLk9yZGluYWxTY2FsZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSl7XFxuICByZXR1cm4gdGhpcy5zY2FsZVt2YWx1ZV07XFxufTtcXG5cXG5qdm0uT3JkaW5hbFNjYWxlLnByb3RvdHlwZS5nZXRUaWNrcyA9IGZ1bmN0aW9uKCl7XFxuICB2YXIgdGlja3MgPSBbXSxcXG4gICAgICBrZXk7XFxuXFxuICBmb3IgKGtleSBpbiB0aGlzLnNjYWxlKSB7XFxuICAgIHRpY2tzLnB1c2goe1xcbiAgICAgIGxhYmVsOiBrZXksXFxuICAgICAgdmFsdWU6IHRoaXMuc2NhbGVba2V5XVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aWNrcztcXG59O2p2bS5OdW1lcmljU2NhbGUgPSBmdW5jdGlvbihzY2FsZSwgbm9ybWFsaXplRnVuY3Rpb24sIG1pblZhbHVlLCBtYXhWYWx1ZSkge1xcbiAgdGhpcy5zY2FsZSA9IFtdO1xcblxcbiAgbm9ybWFsaXplRnVuY3Rpb24gPSBub3JtYWxpemVGdW5jdGlvbiB8fCAnbGluZWFyJztcXG5cXG4gIGlmIChzY2FsZSkgdGhpcy5zZXRTY2FsZShzY2FsZSk7XFxuICBpZiAobm9ybWFsaXplRnVuY3Rpb24pIHRoaXMuc2V0Tm9ybWFsaXplRnVuY3Rpb24obm9ybWFsaXplRnVuY3Rpb24pO1xcbiAgaWYgKHR5cGVvZiBtaW5WYWx1ZSAhPT0gJ3VuZGVmaW5lZCcgKSB0aGlzLnNldE1pbihtaW5WYWx1ZSk7XFxuICBpZiAodHlwZW9mIG1heFZhbHVlICE9PSAndW5kZWZpbmVkJyApIHRoaXMuc2V0TWF4KG1heFZhbHVlKTtcXG59O1xcblxcbmp2bS5OdW1lcmljU2NhbGUucHJvdG90eXBlID0ge1xcbiAgc2V0TWluOiBmdW5jdGlvbihtaW4pIHtcXG4gICAgdGhpcy5jbGVhck1pblZhbHVlID0gbWluO1xcbiAgICBpZiAodHlwZW9mIHRoaXMubm9ybWFsaXplID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgdGhpcy5taW5WYWx1ZSA9IHRoaXMubm9ybWFsaXplKG1pbik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5taW5WYWx1ZSA9IG1pbjtcXG4gICAgfVxcbiAgfSxcXG5cXG4gIHNldE1heDogZnVuY3Rpb24obWF4KSB7XFxuICAgIHRoaXMuY2xlYXJNYXhWYWx1ZSA9IG1heDtcXG4gICAgaWYgKHR5cGVvZiB0aGlzLm5vcm1hbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHRoaXMubWF4VmFsdWUgPSB0aGlzLm5vcm1hbGl6ZShtYXgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXMubWF4VmFsdWUgPSBtYXg7XFxuICAgIH1cXG4gIH0sXFxuXFxuICBzZXRTY2FsZTogZnVuY3Rpb24oc2NhbGUpIHtcXG4gICAgdmFyIGk7XFxuXFxuICAgIHRoaXMuc2NhbGUgPSBbXTtcXG4gICAgZm9yIChpID0gMDsgaSA8IHNjYWxlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdGhpcy5zY2FsZVtpXSA9IFtzY2FsZVtpXV07XFxuICAgIH1cXG4gIH0sXFxuXFxuICBzZXROb3JtYWxpemVGdW5jdGlvbjogZnVuY3Rpb24oZikge1xcbiAgICBpZiAoZiA9PT0gJ3BvbHlub21pYWwnKSB7XFxuICAgICAgdGhpcy5ub3JtYWxpemUgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHZhbHVlLCAwLjIpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChmID09PSAnbGluZWFyJykge1xcbiAgICAgIGRlbGV0ZSB0aGlzLm5vcm1hbGl6ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLm5vcm1hbGl6ZSA9IGY7XFxuICAgIH1cXG4gICAgdGhpcy5zZXRNaW4odGhpcy5jbGVhck1pblZhbHVlKTtcXG4gICAgdGhpcy5zZXRNYXgodGhpcy5jbGVhck1heFZhbHVlKTtcXG4gIH0sXFxuXFxuICBnZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgdmFyIGxlbmd0aGVzID0gW10sXFxuICAgICAgICBmdWxsTGVuZ3RoID0gMCxcXG4gICAgICAgIGwsXFxuICAgICAgICBpID0gMCxcXG4gICAgICAgIGM7XFxuXFxuICAgIGlmICh0eXBlb2YgdGhpcy5ub3JtYWxpemUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICB2YWx1ZSA9IHRoaXMubm9ybWFsaXplKHZhbHVlKTtcXG4gICAgfVxcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zY2FsZS5sZW5ndGgtMTsgaSsrKSB7XFxuICAgICAgbCA9IHRoaXMudmVjdG9yTGVuZ3RoKHRoaXMudmVjdG9yU3VidHJhY3QodGhpcy5zY2FsZVtpKzFdLCB0aGlzLnNjYWxlW2ldKSk7XFxuICAgICAgbGVuZ3RoZXMucHVzaChsKTtcXG4gICAgICBmdWxsTGVuZ3RoICs9IGw7XFxuICAgIH1cXG5cXG4gICAgYyA9ICh0aGlzLm1heFZhbHVlIC0gdGhpcy5taW5WYWx1ZSkgLyBmdWxsTGVuZ3RoO1xcbiAgICBmb3IgKGk9MDsgaTxsZW5ndGhlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxlbmd0aGVzW2ldICo9IGM7XFxuICAgIH1cXG5cXG4gICAgaSA9IDA7XFxuICAgIHZhbHVlIC09IHRoaXMubWluVmFsdWU7XFxuICAgIHdoaWxlICh2YWx1ZSAtIGxlbmd0aGVzW2ldID49IDApIHtcXG4gICAgICB2YWx1ZSAtPSBsZW5ndGhlc1tpXTtcXG4gICAgICBpKys7XFxuICAgIH1cXG5cXG4gICAgaWYgKGkgPT0gdGhpcy5zY2FsZS5sZW5ndGggLSAxKSB7XFxuICAgICAgdmFsdWUgPSB0aGlzLnZlY3RvclRvTnVtKHRoaXMuc2NhbGVbaV0pXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFsdWUgPSAoXFxuICAgICAgICB0aGlzLnZlY3RvclRvTnVtKFxcbiAgICAgICAgICB0aGlzLnZlY3RvckFkZCh0aGlzLnNjYWxlW2ldLFxcbiAgICAgICAgICAgIHRoaXMudmVjdG9yTXVsdChcXG4gICAgICAgICAgICAgIHRoaXMudmVjdG9yU3VidHJhY3QodGhpcy5zY2FsZVtpKzFdLCB0aGlzLnNjYWxlW2ldKSxcXG4gICAgICAgICAgICAgICh2YWx1ZSkgLyAobGVuZ3RoZXNbaV0pXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgICApXFxuICAgICAgICApXFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdmFsdWU7XFxuICB9LFxcblxcbiAgdmVjdG9yVG9OdW06IGZ1bmN0aW9uKHZlY3Rvcikge1xcbiAgICB2YXIgbnVtID0gMCxcXG4gICAgICAgIGk7XFxuXFxuICAgIGZvciAoaSA9IDA7IGkgPCB2ZWN0b3IubGVuZ3RoOyBpKyspIHtcXG4gICAgICBudW0gKz0gTWF0aC5yb3VuZCh2ZWN0b3JbaV0pKk1hdGgucG93KDI1NiwgdmVjdG9yLmxlbmd0aC1pLTEpO1xcbiAgICB9XFxuICAgIHJldHVybiBudW07XFxuICB9LFxcblxcbiAgdmVjdG9yU3VidHJhY3Q6IGZ1bmN0aW9uKHZlY3RvcjEsIHZlY3RvcjIpIHtcXG4gICAgdmFyIHZlY3RvciA9IFtdLFxcbiAgICAgICAgaTtcXG5cXG4gICAgZm9yIChpID0gMDsgaSA8IHZlY3RvcjEubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2ZWN0b3JbaV0gPSB2ZWN0b3IxW2ldIC0gdmVjdG9yMltpXTtcXG4gICAgfVxcbiAgICByZXR1cm4gdmVjdG9yO1xcbiAgfSxcXG5cXG4gIHZlY3RvckFkZDogZnVuY3Rpb24odmVjdG9yMSwgdmVjdG9yMikge1xcbiAgICB2YXIgdmVjdG9yID0gW10sXFxuICAgICAgICBpO1xcblxcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmVjdG9yMS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZlY3RvcltpXSA9IHZlY3RvcjFbaV0gKyB2ZWN0b3IyW2ldO1xcbiAgICB9XFxuICAgIHJldHVybiB2ZWN0b3I7XFxuICB9LFxcblxcbiAgdmVjdG9yTXVsdDogZnVuY3Rpb24odmVjdG9yLCBudW0pIHtcXG4gICAgdmFyIHJlc3VsdCA9IFtdLFxcbiAgICAgICAgaTtcXG5cXG4gICAgZm9yIChpID0gMDsgaSA8IHZlY3Rvci5sZW5ndGg7IGkrKykge1xcbiAgICAgIHJlc3VsdFtpXSA9IHZlY3RvcltpXSAqIG51bTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfSxcXG5cXG4gIHZlY3Rvckxlbmd0aDogZnVuY3Rpb24odmVjdG9yKSB7XFxuICAgIHZhciByZXN1bHQgPSAwLFxcbiAgICAgICAgaTtcXG4gICAgZm9yIChpID0gMDsgaSA8IHZlY3Rvci5sZW5ndGg7IGkrKykge1xcbiAgICAgIHJlc3VsdCArPSB2ZWN0b3JbaV0gKiB2ZWN0b3JbaV07XFxuICAgIH1cXG4gICAgcmV0dXJuIE1hdGguc3FydChyZXN1bHQpO1xcbiAgfSxcXG5cXG4gIC8qIERlcml2ZWQgZnJvbSBkMyBpbXBsZW1lbnRhdGlvbiBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvYmxvYi9tYXN0ZXIvc3JjL3NjYWxlL2xpbmVhci5qcyNMOTQgKi9cXG4gIGdldFRpY2tzOiBmdW5jdGlvbigpe1xcbiAgICB2YXIgbSA9IDUsXFxuICAgICAgICBleHRlbnQgPSBbdGhpcy5jbGVhck1pblZhbHVlLCB0aGlzLmNsZWFyTWF4VmFsdWVdLFxcbiAgICAgICAgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXSxcXG4gICAgICAgIHN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhzcGFuIC8gbSkgLyBNYXRoLkxOMTApKSxcXG4gICAgICAgIGVyciA9IG0gLyBzcGFuICogc3RlcCxcXG4gICAgICAgIHRpY2tzID0gW10sXFxuICAgICAgICB0aWNrLFxcbiAgICAgICAgdjtcXG5cXG4gICAgaWYgKGVyciA8PSAuMTUpIHN0ZXAgKj0gMTA7XFxuICAgIGVsc2UgaWYgKGVyciA8PSAuMzUpIHN0ZXAgKj0gNTtcXG4gICAgZWxzZSBpZiAoZXJyIDw9IC43NSkgc3RlcCAqPSAyO1xcblxcbiAgICBleHRlbnRbMF0gPSBNYXRoLmZsb29yKGV4dGVudFswXSAvIHN0ZXApICogc3RlcDtcXG4gICAgZXh0ZW50WzFdID0gTWF0aC5jZWlsKGV4dGVudFsxXSAvIHN0ZXApICogc3RlcDtcXG5cXG4gICAgdGljayA9IGV4dGVudFswXTtcXG4gICAgd2hpbGUgKHRpY2sgPD0gZXh0ZW50WzFdKSB7XFxuICAgICAgaWYgKHRpY2sgPT0gZXh0ZW50WzBdKSB7XFxuICAgICAgICB2ID0gdGhpcy5jbGVhck1pblZhbHVlO1xcbiAgICAgIH0gZWxzZSBpZiAodGljayA9PSBleHRlbnRbMV0pIHtcXG4gICAgICAgIHYgPSB0aGlzLmNsZWFyTWF4VmFsdWU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHYgPSB0aWNrO1xcbiAgICAgIH1cXG4gICAgICB0aWNrcy5wdXNoKHtcXG4gICAgICAgIGxhYmVsOiB0aWNrLFxcbiAgICAgICAgdmFsdWU6IHRoaXMuZ2V0VmFsdWUodilcXG4gICAgICB9KTtcXG4gICAgICB0aWNrICs9IHN0ZXA7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRpY2tzO1xcbiAgfVxcbn07XFxuanZtLkNvbG9yU2NhbGUgPSBmdW5jdGlvbihjb2xvcnMsIG5vcm1hbGl6ZUZ1bmN0aW9uLCBtaW5WYWx1ZSwgbWF4VmFsdWUpIHtcXG4gIGp2bS5Db2xvclNjYWxlLnBhcmVudENsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxufVxcblxcbmp2bS5pbmhlcml0cyhqdm0uQ29sb3JTY2FsZSwganZtLk51bWVyaWNTY2FsZSk7XFxuXFxuanZtLkNvbG9yU2NhbGUucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcXG4gIHZhciBpO1xcblxcbiAgZm9yIChpID0gMDsgaSA8IHNjYWxlLmxlbmd0aDsgaSsrKSB7XFxuICAgIHRoaXMuc2NhbGVbaV0gPSBqdm0uQ29sb3JTY2FsZS5yZ2JUb0FycmF5KHNjYWxlW2ldKTtcXG4gIH1cXG59O1xcblxcbmp2bS5Db2xvclNjYWxlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICByZXR1cm4ganZtLkNvbG9yU2NhbGUubnVtVG9SZ2IoanZtLkNvbG9yU2NhbGUucGFyZW50Q2xhc3MucHJvdG90eXBlLmdldFZhbHVlLmNhbGwodGhpcywgdmFsdWUpKTtcXG59O1xcblxcbmp2bS5Db2xvclNjYWxlLmFycmF5VG9SZ2IgPSBmdW5jdGlvbihhcikge1xcbiAgdmFyIHJnYiA9ICcjJyxcXG4gICAgICBkLFxcbiAgICAgIGk7XFxuXFxuICBmb3IgKGkgPSAwOyBpIDwgYXIubGVuZ3RoOyBpKyspIHtcXG4gICAgZCA9IGFyW2ldLnRvU3RyaW5nKDE2KTtcXG4gICAgcmdiICs9IGQubGVuZ3RoID09IDEgPyAnMCcrZCA6IGQ7XFxuICB9XFxuICByZXR1cm4gcmdiO1xcbn07XFxuXFxuanZtLkNvbG9yU2NhbGUubnVtVG9SZ2IgPSBmdW5jdGlvbihudW0pIHtcXG4gIG51bSA9IG51bS50b1N0cmluZygxNik7XFxuXFxuICB3aGlsZSAobnVtLmxlbmd0aCA8IDYpIHtcXG4gICAgbnVtID0gJzAnICsgbnVtO1xcbiAgfVxcblxcbiAgcmV0dXJuICcjJytudW07XFxufTtcXG5cXG5qdm0uQ29sb3JTY2FsZS5yZ2JUb0FycmF5ID0gZnVuY3Rpb24ocmdiKSB7XFxuICByZ2IgPSByZ2Iuc3Vic3RyKDEpO1xcbiAgcmV0dXJuIFtwYXJzZUludChyZ2Iuc3Vic3RyKDAsIDIpLCAxNiksIHBhcnNlSW50KHJnYi5zdWJzdHIoMiwgMiksIDE2KSwgcGFyc2VJbnQocmdiLnN1YnN0cig0LCAyKSwgMTYpXTtcXG59Oy8qKlxcbiAqIFJlcHJlc2VudHMgbWFwIGxlZ2VuZC5cXG4gKiBAY29uc3RydWN0b3JcXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbmZpZ3VyYXRpb24gcGFyYW1ldGVycy5cXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmNzc0NsYXNzIEFkZGl0aW9uYWwgQ1NTIGNsYXNzIHRvIGFwcGx5IHRvIGxlZ2VuZCBlbGVtZW50LlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLnZlcnRpY2FsIElmIDxjb2RlPnRydWU8L2NvZGU+IGxlZ2VuZCB3aWxsIGJlIHJlbmRlcmVkIGFzIHZlcnRpY2FsLlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudGl0bGUgTGVnZW5kIHRpdGxlLlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtcy5sYWJlbFJlbmRlciBNZXRob2QgdG8gY29udmVydCBzZXJpZXMgdmFsdWVzIHRvIGxlZ2VuZCBsYWJlbHMuXFxuICovXFxuanZtLkxlZ2VuZCA9IGZ1bmN0aW9uKHBhcmFtcykge1xcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXMgfHwge307XFxuICB0aGlzLm1hcCA9IHRoaXMucGFyYW1zLm1hcDtcXG4gIHRoaXMuc2VyaWVzID0gdGhpcy5wYXJhbXMuc2VyaWVzO1xcbiAgdGhpcy5ib2R5ID0ganZtLiQoJzxkaXYvPicpO1xcbiAgdGhpcy5ib2R5LmFkZENsYXNzKCdqdmVjdG9ybWFwLWxlZ2VuZCcpO1xcbiAgaWYgKHRoaXMucGFyYW1zLmNzc0NsYXNzKSB7XFxuICAgIHRoaXMuYm9keS5hZGRDbGFzcyh0aGlzLnBhcmFtcy5jc3NDbGFzcyk7XFxuICB9XFxuXFxuICBpZiAocGFyYW1zLnZlcnRpY2FsKSB7XFxuICAgIHRoaXMubWFwLmxlZ2VuZENudFZlcnRpY2FsLmFwcGVuZCggdGhpcy5ib2R5ICk7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLm1hcC5sZWdlbmRDbnRIb3Jpem9udGFsLmFwcGVuZCggdGhpcy5ib2R5ICk7XFxuICB9XFxuXFxuICB0aGlzLnJlbmRlcigpO1xcbn1cXG5cXG5qdm0uTGVnZW5kLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpe1xcbiAgdmFyIHRpY2tzID0gdGhpcy5zZXJpZXMuc2NhbGUuZ2V0VGlja3MoKSxcXG4gICAgICBpLFxcbiAgICAgIGlubmVyID0ganZtLiQoJzxkaXYvPicpLmFkZENsYXNzKCdqdmVjdG9ybWFwLWxlZ2VuZC1pbm5lcicpLFxcbiAgICAgIHRpY2ssXFxuICAgICAgc2FtcGxlLFxcbiAgICAgIGxhYmVsO1xcblxcbiAgdGhpcy5ib2R5Lmh0bWwoJycpO1xcbiAgaWYgKHRoaXMucGFyYW1zLnRpdGxlKSB7XFxuICAgIHRoaXMuYm9keS5hcHBlbmQoXFxuICAgICAganZtLiQoJzxkaXYvPicpLmFkZENsYXNzKCdqdmVjdG9ybWFwLWxlZ2VuZC10aXRsZScpLmh0bWwodGhpcy5wYXJhbXMudGl0bGUpXFxuICAgICk7XFxuICB9XFxuICB0aGlzLmJvZHkuYXBwZW5kKGlubmVyKTtcXG5cXG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xcbiAgICB0aWNrID0ganZtLiQoJzxkaXYvPicpLmFkZENsYXNzKCdqdmVjdG9ybWFwLWxlZ2VuZC10aWNrJyk7XFxuICAgIHNhbXBsZSA9IGp2bS4kKCc8ZGl2Lz4nKS5hZGRDbGFzcygnanZlY3Rvcm1hcC1sZWdlbmQtdGljay1zYW1wbGUnKTtcXG5cXG4gICAgc3dpdGNoICh0aGlzLnNlcmllcy5wYXJhbXMuYXR0cmlidXRlKSB7XFxuICAgICAgY2FzZSAnZmlsbCc6XFxuICAgICAgICBpZiAoanZtLmlzSW1hZ2VVcmwodGlja3NbaV0udmFsdWUpKSB7XFxuICAgICAgICAgIHNhbXBsZS5jc3MoJ2JhY2tncm91bmQnLCAndXJsKCcrdGlja3NbaV0udmFsdWUrJyknKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNhbXBsZS5jc3MoJ2JhY2tncm91bmQnLCB0aWNrc1tpXS52YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdzdHJva2UnOlxcbiAgICAgICAgc2FtcGxlLmNzcygnYmFja2dyb3VuZCcsIHRpY2tzW2ldLnZhbHVlKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2ltYWdlJzpcXG4gICAgICAgIHNhbXBsZS5jc3MoJ2JhY2tncm91bmQnLCAndXJsKCcrKHR5cGVvZiB0aWNrc1tpXS52YWx1ZSA9PT0gJ29iamVjdCcgPyB0aWNrc1tpXS52YWx1ZS51cmwgOiB0aWNrc1tpXS52YWx1ZSkrJykgbm8tcmVwZWF0IGNlbnRlciBjZW50ZXInKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ3InOlxcbiAgICAgICAganZtLiQoJzxkaXYvPicpLmNzcyh7XFxuICAgICAgICAgICdib3JkZXItcmFkaXVzJzogdGlja3NbaV0udmFsdWUsXFxuICAgICAgICAgIGJvcmRlcjogdGhpcy5tYXAucGFyYW1zLm1hcmtlclN0eWxlLmluaXRpYWxbJ3N0cm9rZS13aWR0aCddKydweCAnK1xcbiAgICAgICAgICAgICAgICAgIHRoaXMubWFwLnBhcmFtcy5tYXJrZXJTdHlsZS5pbml0aWFsWydzdHJva2UnXSsnIHNvbGlkJyxcXG4gICAgICAgICAgd2lkdGg6IHRpY2tzW2ldLnZhbHVlICogMiArICdweCcsXFxuICAgICAgICAgIGhlaWdodDogdGlja3NbaV0udmFsdWUgKiAyICsgJ3B4JyxcXG4gICAgICAgICAgYmFja2dyb3VuZDogdGhpcy5tYXAucGFyYW1zLm1hcmtlclN0eWxlLmluaXRpYWxbJ2ZpbGwnXVxcbiAgICAgICAgfSkuYXBwZW5kVG8oc2FtcGxlKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICB9XFxuICAgIHRpY2suYXBwZW5kKCBzYW1wbGUgKTtcXG4gICAgbGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcXG4gICAgaWYgKHRoaXMucGFyYW1zLmxhYmVsUmVuZGVyKSB7XFxuICAgICAgbGFiZWwgPSB0aGlzLnBhcmFtcy5sYWJlbFJlbmRlcihsYWJlbCk7XFxuICAgIH1cXG4gICAgdGljay5hcHBlbmQoIGp2bS4kKCc8ZGl2PicrbGFiZWwrJyA8L2Rpdj4nKS5hZGRDbGFzcygnanZlY3Rvcm1hcC1sZWdlbmQtdGljay10ZXh0JykgKTtcXG4gICAgaW5uZXIuYXBwZW5kKHRpY2spO1xcbiAgfVxcbiAgaW5uZXIuYXBwZW5kKCBqdm0uJCgnPGRpdi8+JykuY3NzKCdjbGVhcicsICdib3RoJykgKTtcXG59LyoqXFxuICogQ3JlYXRlcyBkYXRhIHNlcmllcy5cXG4gKiBAY29uc3RydWN0b3JcXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gaW5pdGlhbGl6ZSBzZXJpZXMgd2l0aC5cXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMudmFsdWVzIFRoZSBkYXRhIHNldCB0byB2aXN1YWxpemUuXFxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5hdHRyaWJ1dGUgTnVtZXJpYywgY29sb3Igb3IgaW1hZ2UgYXR0cmlidXRlIHRvIHVzZSBmb3IgZGF0YSB2aXN1YWxpemF0aW9uLiBUaGlzIGNvdWxkIGJlOiA8Y29kZT5maWxsPC9jb2RlPiwgPGNvZGU+c3Ryb2tlPC9jb2RlPiwgPGNvZGU+ZmlsbC1vcGFjaXR5PC9jb2RlPiwgPGNvZGU+c3Ryb2tlLW9wYWNpdHk8L2NvZGU+IGZvciBtYXJrZXJzIGFuZCByZWdpb25zIGFuZCA8Y29kZT5yPC9jb2RlPiAocmFkaXVzKSBvciA8Y29kZT5pbWFnZTwvY29kZT4gZm9yIG1hcmtlcnMgb25seS5cXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMuc2NhbGUgVmFsdWVzIHVzZWQgdG8gbWFwIGEgZGltZW5zaW9uIG9mIGRhdGEgdG8gYSB2aXN1YWwgcmVwcmVzZW50YXRpb24uIFRoZSBmaXJzdCB2YWx1ZSBzZXRzIHZpc3VhbGl6YXRpb24gZm9yIG1pbmltdW0gdmFsdWUgZnJvbSB0aGUgZGF0YSBzZXQgYW5kIHRoZSBsYXN0IHZhbHVlIHNldHMgdmlzdWFsaXphdGlvbiBmb3IgdGhlIG1heGltdW0gdmFsdWUuIFRoZXJlIGFsc28gY291bGQgYmUgaW50ZXJtaWRpYXRlIHZhbHVlcy4gRGVmYXVsdCB2YWx1ZSBpcyA8Y29kZT5bJyNDOEVFRkYnLCAnIzAwNzFBNCddPC9jb2RlPi5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gcGFyYW1zLm5vcm1hbGl6ZUZ1bmN0aW9uIFRoZSBmdW5jdGlvbiB1c2VkIHRvIG1hcCBpbnB1dCB2YWx1ZXMgdG8gdGhlIHByb3ZpZGVkIHNjYWxlLiBUaGlzIHBhcmFtZXRlciBjb3VsZCBiZSBwcm92aWRlZCBhcyBmdW5jdGlvbiBvciBvbmUgb2YgdGhlIHN0cmluZ3M6IDxjb2RlPidsaW5lYXInPC9jb2RlPiBvciA8Y29kZT4ncG9seW5vbWlhbCc8L2NvZGU+LCB3aGlsZSA8Y29kZT4nbGluZWFyJzwvY29kZT4gaXMgdXNlZCBieSBkZWZhdWx0LiBUaGUgZnVuY3Rpb24gcHJvdmlkZWQgdGFrZXMgdmFsdWUgZnJvbSB0aGUgZGF0YSBzZXQgYXMgYW4gaW5wdXQgYW5kIHJldHVybnMgY29ycmVzcG9uZGluZyB2YWx1ZSBmcm9tIHRoZSBzY2FsZS5cXG4gKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbiBNaW5pbXVtIHZhbHVlIG9mIHRoZSBkYXRhIHNldC4gQ291bGQgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBwcm92aWRlZC5cXG4gKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heCBNYXhpbXVtIHZhbHVlIG9mIHRoZSBkYXRhIHNldC4gQ291bGQgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBwcm92aWRlZC5cXG4gKi9cXG5qdm0uRGF0YVNlcmllcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGVsZW1lbnRzLCBtYXApIHtcXG4gIHZhciBzY2FsZUNvbnN0cnVjdG9yO1xcblxcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xcbiAgcGFyYW1zLmF0dHJpYnV0ZSA9IHBhcmFtcy5hdHRyaWJ1dGUgfHwgXFxcImZpbGxcXFwiO1xcblxcbiAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XFxuICB0aGlzLm1hcCA9IG1hcDtcXG5cXG4gIGlmIChwYXJhbXMuYXR0cmlidXRlcykge1xcbiAgICB0aGlzLnNldEF0dHJpYnV0ZXMocGFyYW1zLmF0dHJpYnV0ZXMpO1xcbiAgfVxcblxcbiAgaWYgKGp2bS4kLmlzQXJyYXkocGFyYW1zLnNjYWxlKSkge1xcbiAgICBzY2FsZUNvbnN0cnVjdG9yID1cXG4gICAgICBwYXJhbXMuYXR0cmlidXRlID09PSBcXFwiZmlsbFxcXCIgfHwgcGFyYW1zLmF0dHJpYnV0ZSA9PT0gXFxcInN0cm9rZVxcXCJcXG4gICAgICAgID8ganZtLkNvbG9yU2NhbGVcXG4gICAgICAgIDoganZtLk51bWVyaWNTY2FsZTtcXG4gICAgdGhpcy5zY2FsZSA9IG5ldyBzY2FsZUNvbnN0cnVjdG9yKFxcbiAgICAgIHBhcmFtcy5zY2FsZSxcXG4gICAgICBwYXJhbXMubm9ybWFsaXplRnVuY3Rpb24sXFxuICAgICAgcGFyYW1zLm1pbixcXG4gICAgICBwYXJhbXMubWF4LFxcbiAgICApO1xcbiAgfSBlbHNlIGlmIChwYXJhbXMuc2NhbGUpIHtcXG4gICAgdGhpcy5zY2FsZSA9IG5ldyBqdm0uT3JkaW5hbFNjYWxlKHBhcmFtcy5zY2FsZSk7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLnNjYWxlID0gbmV3IGp2bS5TaW1wbGVTY2FsZShwYXJhbXMuc2NhbGUpO1xcbiAgfVxcblxcbiAgdGhpcy52YWx1ZXMgPSBwYXJhbXMudmFsdWVzIHx8IHt9O1xcbiAgdGhpcy5zZXRWYWx1ZXModGhpcy52YWx1ZXMpO1xcblxcbiAgaWYgKHRoaXMucGFyYW1zLmxlZ2VuZCkge1xcbiAgICB0aGlzLmxlZ2VuZCA9IG5ldyBqdm0uTGVnZW5kKFxcbiAgICAgIGp2bS4kLmV4dGVuZChcXG4gICAgICAgIHtcXG4gICAgICAgICAgbWFwOiB0aGlzLm1hcCxcXG4gICAgICAgICAgc2VyaWVzOiB0aGlzLFxcbiAgICAgICAgfSxcXG4gICAgICAgIHRoaXMucGFyYW1zLmxlZ2VuZCxcXG4gICAgICApLFxcbiAgICApO1xcbiAgfVxcbn07XFxuXFxuanZtLkRhdGFTZXJpZXMucHJvdG90eXBlID0ge1xcbiAgc2V0QXR0cmlidXRlczogZnVuY3Rpb24gKGtleSwgYXR0cikge1xcbiAgICB2YXIgYXR0cnMgPSBrZXksXFxuICAgICAgY29kZTtcXG5cXG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICBpZiAodGhpcy5lbGVtZW50c1trZXldKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnRzW2tleV0uc2V0U3R5bGUodGhpcy5wYXJhbXMuYXR0cmlidXRlLCBhdHRyKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yIChjb2RlIGluIGF0dHJzKSB7XFxuICAgICAgICBpZiAodGhpcy5lbGVtZW50c1tjb2RlXSkge1xcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzW2NvZGVdLmVsZW1lbnQuc2V0U3R5bGUoXFxuICAgICAgICAgICAgdGhpcy5wYXJhbXMuYXR0cmlidXRlLFxcbiAgICAgICAgICAgIGF0dHJzW2NvZGVdLFxcbiAgICAgICAgICApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogU2V0IHZhbHVlcyBmb3IgdGhlIGRhdGEgc2V0LlxcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyBPYmplY3Qgd2hpY2ggbWFwcyBjb2RlcyBvZiByZWdpb25zIG9yIG1hcmtlcnMgdG8gdmFsdWVzLlxcbiAgICovXFxuICBzZXRWYWx1ZXM6IGZ1bmN0aW9uICh2YWx1ZXMpIHtcXG4gICAgdmFyIG1heCA9IC1OdW1iZXIuTUFYX1ZBTFVFLFxcbiAgICAgIG1pbiA9IE51bWJlci5NQVhfVkFMVUUsXFxuICAgICAgdmFsLFxcbiAgICAgIGNjLFxcbiAgICAgIGF0dHJzID0ge307XFxuXFxuICAgIGlmIChcXG4gICAgICAhKHRoaXMuc2NhbGUgaW5zdGFuY2VvZiBqdm0uT3JkaW5hbFNjYWxlKSAmJlxcbiAgICAgICEodGhpcy5zY2FsZSBpbnN0YW5jZW9mIGp2bS5TaW1wbGVTY2FsZSlcXG4gICAgKSB7XFxuICAgICAgLy8gd2UgaGF2ZSBhIGNvbG9yIHNjYWxlIGFzIGFuIGFycmF5XFxuICAgICAgaWYgKFxcbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zLm1pbiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHxcXG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtcy5tYXggPT09IFxcXCJ1bmRlZmluZWRcXFwiXFxuICAgICAgKSB7XFxuICAgICAgICAvLyBtaW4gYW5kL29yIG1heCBhcmUgbm90IGRlZmluZWQsIHNvIGNhbGN1bGF0ZSB0aGVtXFxuICAgICAgICBmb3IgKGNjIGluIHZhbHVlcykge1xcbiAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbHVlc1tjY10pO1xcbiAgICAgICAgICBpZiAodmFsID4gbWF4KSBtYXggPSB2YWw7XFxuICAgICAgICAgIGlmICh2YWwgPCBtaW4pIG1pbiA9IHZhbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhcmFtcy5taW4gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICB0aGlzLnNjYWxlLnNldE1pbihtaW4pO1xcbiAgICAgICAgdGhpcy5wYXJhbXMubWluID0gbWluO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNjYWxlLnNldE1pbih0aGlzLnBhcmFtcy5taW4pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIHRoaXMucGFyYW1zLm1heCA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgIHRoaXMuc2NhbGUuc2V0TWF4KG1heCk7XFxuICAgICAgICB0aGlzLnBhcmFtcy5tYXggPSBtYXg7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuc2NhbGUuc2V0TWF4KHRoaXMucGFyYW1zLm1heCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoY2MgaW4gdmFsdWVzKSB7XFxuICAgICAgICBpZiAoY2MgIT0gXFxcImluZGV4T2ZcXFwiKSB7XFxuICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsdWVzW2NjXSk7XFxuICAgICAgICAgIGlmICghaXNOYU4odmFsKSkge1xcbiAgICAgICAgICAgIGF0dHJzW2NjXSA9IHRoaXMuc2NhbGUuZ2V0VmFsdWUodmFsKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBhdHRyc1tjY10gPVxcbiAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tjY10uZWxlbWVudC5zdHlsZS5pbml0aWFsW3RoaXMucGFyYW1zLmF0dHJpYnV0ZV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yIChjYyBpbiB2YWx1ZXMpIHtcXG4gICAgICAgIGlmICh2YWx1ZXNbY2NdKSB7XFxuICAgICAgICAgIGF0dHJzW2NjXSA9IHRoaXMuc2NhbGUuZ2V0VmFsdWUodmFsdWVzW2NjXSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBhdHRyc1tjY10gPVxcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbY2NdLmVsZW1lbnQuc3R5bGUuaW5pdGlhbFt0aGlzLnBhcmFtcy5hdHRyaWJ1dGVdO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB0aGlzLnNldEF0dHJpYnV0ZXMoYXR0cnMpO1xcbiAgICBqdm0uJC5leHRlbmQodGhpcy52YWx1ZXMsIHZhbHVlcyk7XFxuICB9LFxcblxcbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGtleSxcXG4gICAgICBhdHRycyA9IHt9O1xcblxcbiAgICBmb3IgKGtleSBpbiB0aGlzLnZhbHVlcykge1xcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2tleV0pIHtcXG4gICAgICAgIGF0dHJzW2tleV0gPVxcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzW2tleV0uZWxlbWVudC5zaGFwZS5zdHlsZS5pbml0aWFsW3RoaXMucGFyYW1zLmF0dHJpYnV0ZV07XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHRoaXMuc2V0QXR0cmlidXRlcyhhdHRycyk7XFxuICAgIHRoaXMudmFsdWVzID0ge307XFxuICB9LFxcblxcbiAgY2xlYXJBbmRTZXQ6IGZ1bmN0aW9uICh2YWx1ZXMpIHtcXG4gICAgdGhpcy5jbGVhcigpO1xcbiAgICB0aGlzLnNldFZhbHVlcyh2YWx1ZXMpO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogU2V0IHNjYWxlIG9mIHRoZSBkYXRhIHNlcmllcy5cXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNjYWxlIFZhbHVlcyByZXByZXNlbnRpbmcgc2NhbGUuXFxuICAgKi9cXG4gIHNldFNjYWxlOiBmdW5jdGlvbiAoc2NhbGUpIHtcXG4gICAgdGhpcy5zY2FsZS5zZXRTY2FsZShzY2FsZSk7XFxuICAgIGlmICh0aGlzLnZhbHVlcykge1xcbiAgICAgIHRoaXMuc2V0VmFsdWVzKHRoaXMudmFsdWVzKTtcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogU2V0IG5vcm1hbGl6ZSBmdW5jdGlvbiBvZiB0aGUgZGF0YSBzZXJpZXMuXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZiBOb3JtYWxpemUgZnVuY3Rpb24uXFxuICAgKi9cXG4gIHNldE5vcm1hbGl6ZUZ1bmN0aW9uOiBmdW5jdGlvbiAoZikge1xcbiAgICB0aGlzLnNjYWxlLnNldE5vcm1hbGl6ZUZ1bmN0aW9uKGYpO1xcbiAgICBpZiAodGhpcy52YWx1ZXMpIHtcXG4gICAgICB0aGlzLnNldFZhbHVlcyh0aGlzLnZhbHVlcyk7XFxuICAgIH1cXG4gIH0sXFxufTtcXG4vKipcXG4gKiBDb250YWlucyBtZXRob2RzIGZvciB0cmFuc2Zvcm1pbmcgcG9pbnQgb24gc3BoZXJlIHRvXFxuICogQ2FydGVzaWFuIGNvb3JkaW5hdGVzIHVzaW5nIHZhcmlvdXMgcHJvamVjdGlvbnMuXFxuICogQGNsYXNzXFxuICovXFxuanZtLlByb2ogPSB7XFxuICBkZWdSYWQ6IDE4MCAvIE1hdGguUEksXFxuICByYWREZWc6IE1hdGguUEkgLyAxODAsXFxuICByYWRpdXM6IDYzODEzNzIsXFxuXFxuICBzZ246IGZ1bmN0aW9uKG4pe1xcbiAgICBpZiAobiA+IDApIHtcXG4gICAgICByZXR1cm4gMTtcXG4gICAgfSBlbHNlIGlmIChuIDwgMCkge1xcbiAgICAgIHJldHVybiAtMTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gbjtcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQ29udmVydHMgcG9pbnQgb24gc3BoZXJlIHRvIHRoZSBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgdXNpbmcgTWlsbGVyIHByb2plY3Rpb25cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsYXQgTGF0aXR1ZGUgaW4gZGVncmVlc1xcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxuZyBMb25naXR1ZGUgaW4gZGVncmVlc1xcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGMgQ2VudHJhbCBtZXJpZGlhbiBpbiBkZWdyZWVzXFxuICAgKi9cXG4gIG1pbGw6IGZ1bmN0aW9uKGxhdCwgbG5nLCBjKXtcXG4gICAgcmV0dXJuIHtcXG4gICAgICB4OiB0aGlzLnJhZGl1cyAqIChsbmcgLSBjKSAqIHRoaXMucmFkRGVnLFxcbiAgICAgIHk6IC0gdGhpcy5yYWRpdXMgKiBNYXRoLmxvZyhNYXRoLnRhbigoNDUgKyAwLjQgKiBsYXQpICogdGhpcy5yYWREZWcpKSAvIDAuOFxcbiAgICB9O1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogSW52ZXJzZSBmdW5jdGlvbiBvZiBtaWxsKClcXG4gICAqIENvbnZlcnRzIENhcnRlc2lhbiBjb29yZGluYXRlcyB0byBwb2ludCBvbiBzcGhlcmUgdXNpbmcgTWlsbGVyIHByb2plY3Rpb25cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IFggb2YgcG9pbnQgaW4gQ2FydGVzaWFuIHN5c3RlbSBhcyBpbnRlZ2VyXFxuICAgKiBAcGFyYW0ge051bWJlcn0geSBZIG9mIHBvaW50IGluIENhcnRlc2lhbiBzeXN0ZW0gYXMgaW50ZWdlclxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGMgQ2VudHJhbCBtZXJpZGlhbiBpbiBkZWdyZWVzXFxuICAgKi9cXG4gIG1pbGxfaW52OiBmdW5jdGlvbih4LCB5LCBjKXtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBsYXQ6ICgyLjUgKiBNYXRoLmF0YW4oTWF0aC5leHAoMC44ICogeSAvIHRoaXMucmFkaXVzKSkgLSA1ICogTWF0aC5QSSAvIDgpICogdGhpcy5kZWdSYWQsXFxuICAgICAgbG5nOiAoYyAqIHRoaXMucmFkRGVnICsgeCAvIHRoaXMucmFkaXVzKSAqIHRoaXMuZGVnUmFkXFxuICAgIH07XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBDb252ZXJ0cyBwb2ludCBvbiBzcGhlcmUgdG8gdGhlIENhcnRlc2lhbiBjb29yZGluYXRlcyB1c2luZyBNZXJjYXRvciBwcm9qZWN0aW9uXFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGF0IExhdGl0dWRlIGluIGRlZ3JlZXNcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsbmcgTG9uZ2l0dWRlIGluIGRlZ3JlZXNcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjIENlbnRyYWwgbWVyaWRpYW4gaW4gZGVncmVlc1xcbiAgICovXFxuICBtZXJjOiBmdW5jdGlvbihsYXQsIGxuZywgYyl7XFxuICAgIHJldHVybiB7XFxuICAgICAgeDogdGhpcy5yYWRpdXMgKiAobG5nIC0gYykgKiB0aGlzLnJhZERlZyxcXG4gICAgICB5OiAtIHRoaXMucmFkaXVzICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBsYXQgKiBNYXRoLlBJIC8gMzYwKSlcXG4gICAgfTtcXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIEludmVyc2UgZnVuY3Rpb24gb2YgbWVyYygpXFxuICAgKiBDb252ZXJ0cyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgdG8gcG9pbnQgb24gc3BoZXJlIHVzaW5nIE1lcmNhdG9yIHByb2plY3Rpb25cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IFggb2YgcG9pbnQgaW4gQ2FydGVzaWFuIHN5c3RlbSBhcyBpbnRlZ2VyXFxuICAgKiBAcGFyYW0ge051bWJlcn0geSBZIG9mIHBvaW50IGluIENhcnRlc2lhbiBzeXN0ZW0gYXMgaW50ZWdlclxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGMgQ2VudHJhbCBtZXJpZGlhbiBpbiBkZWdyZWVzXFxuICAgKi9cXG4gIG1lcmNfaW52OiBmdW5jdGlvbih4LCB5LCBjKXtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBsYXQ6ICgyICogTWF0aC5hdGFuKE1hdGguZXhwKHkgLyB0aGlzLnJhZGl1cykpIC0gTWF0aC5QSSAvIDIpICogdGhpcy5kZWdSYWQsXFxuICAgICAgbG5nOiAoYyAqIHRoaXMucmFkRGVnICsgeCAvIHRoaXMucmFkaXVzKSAqIHRoaXMuZGVnUmFkXFxuICAgIH07XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBDb252ZXJ0cyBwb2ludCBvbiBzcGhlcmUgdG8gdGhlIENhcnRlc2lhbiBjb29yZGluYXRlcyB1c2luZyBBbGJlcnMgRXF1YWwtQXJlYSBDb25pY1xcbiAgICogcHJvamVjdGlvblxcbiAgICogQHNlZSA8YSBocmVmPVxcXCJodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0FsYmVyc0VxdWFsLUFyZWFDb25pY1Byb2plY3Rpb24uaHRtbFxcXCI+QWxiZXJzIEVxdWFsLUFyZWEgQ29uaWMgcHJvamVjdGlvbjwvYT5cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsYXQgTGF0aXR1ZGUgaW4gZGVncmVlc1xcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxuZyBMb25naXR1ZGUgaW4gZGVncmVlc1xcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGMgQ2VudHJhbCBtZXJpZGlhbiBpbiBkZWdyZWVzXFxuICAgKi9cXG4gIGFlYTogZnVuY3Rpb24obGF0LCBsbmcsIGMpe1xcbiAgICB2YXIgZmkwID0gMCxcXG4gICAgICAgIGxhbWJkYTAgPSBjICogdGhpcy5yYWREZWcsXFxuICAgICAgICBmaTEgPSAyOS41ICogdGhpcy5yYWREZWcsXFxuICAgICAgICBmaTIgPSA0NS41ICogdGhpcy5yYWREZWcsXFxuICAgICAgICBmaSA9IGxhdCAqIHRoaXMucmFkRGVnLFxcbiAgICAgICAgbGFtYmRhID0gbG5nICogdGhpcy5yYWREZWcsXFxuICAgICAgICBuID0gKE1hdGguc2luKGZpMSkrTWF0aC5zaW4oZmkyKSkgLyAyLFxcbiAgICAgICAgQyA9IE1hdGguY29zKGZpMSkqTWF0aC5jb3MoZmkxKSsyKm4qTWF0aC5zaW4oZmkxKSxcXG4gICAgICAgIHRoZXRhID0gbioobGFtYmRhLWxhbWJkYTApLFxcbiAgICAgICAgcm8gPSBNYXRoLnNxcnQoQy0yKm4qTWF0aC5zaW4oZmkpKS9uLFxcbiAgICAgICAgcm8wID0gTWF0aC5zcXJ0KEMtMipuKk1hdGguc2luKGZpMCkpL247XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgeDogcm8gKiBNYXRoLnNpbih0aGV0YSkgKiB0aGlzLnJhZGl1cyxcXG4gICAgICB5OiAtIChybzAgLSBybyAqIE1hdGguY29zKHRoZXRhKSkgKiB0aGlzLnJhZGl1c1xcbiAgICB9O1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQ29udmVydHMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIHRvIHRoZSBwb2ludCBvbiBzcGhlcmUgdXNpbmcgQWxiZXJzIEVxdWFsLUFyZWEgQ29uaWNcXG4gICAqIHByb2plY3Rpb25cXG4gICAqIEBzZWUgPGEgaHJlZj1cXFwiaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9BbGJlcnNFcXVhbC1BcmVhQ29uaWNQcm9qZWN0aW9uLmh0bWxcXFwiPkFsYmVycyBFcXVhbC1BcmVhIENvbmljIHByb2plY3Rpb248L2E+XFxuICAgKiBAcGFyYW0ge051bWJlcn0geCBYIG9mIHBvaW50IGluIENhcnRlc2lhbiBzeXN0ZW0gYXMgaW50ZWdlclxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBvZiBwb2ludCBpbiBDYXJ0ZXNpYW4gc3lzdGVtIGFzIGludGVnZXJcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjIENlbnRyYWwgbWVyaWRpYW4gaW4gZGVncmVlc1xcbiAgICovXFxuICBhZWFfaW52OiBmdW5jdGlvbih4Q29vcmQsIHlDb29yZCwgYyl7XFxuICAgIHZhciB4ID0geENvb3JkIC8gdGhpcy5yYWRpdXMsXFxuICAgICAgICB5ID0geUNvb3JkIC8gdGhpcy5yYWRpdXMsXFxuICAgICAgICBmaTAgPSAwLFxcbiAgICAgICAgbGFtYmRhMCA9IGMgKiB0aGlzLnJhZERlZyxcXG4gICAgICAgIGZpMSA9IDI5LjUgKiB0aGlzLnJhZERlZyxcXG4gICAgICAgIGZpMiA9IDQ1LjUgKiB0aGlzLnJhZERlZyxcXG4gICAgICAgIG4gPSAoTWF0aC5zaW4oZmkxKStNYXRoLnNpbihmaTIpKSAvIDIsXFxuICAgICAgICBDID0gTWF0aC5jb3MoZmkxKSpNYXRoLmNvcyhmaTEpKzIqbipNYXRoLnNpbihmaTEpLFxcbiAgICAgICAgcm8wID0gTWF0aC5zcXJ0KEMtMipuKk1hdGguc2luKGZpMCkpL24sXFxuICAgICAgICBybyA9IE1hdGguc3FydCh4KngrKHJvMC15KSoocm8wLXkpKSxcXG4gICAgICAgIHRoZXRhID0gTWF0aC5hdGFuKCB4IC8gKHJvMCAtIHkpICk7XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgbGF0OiAoTWF0aC5hc2luKChDIC0gcm8gKiBybyAqIG4gKiBuKSAvICgyICogbikpKSAqIHRoaXMuZGVnUmFkLFxcbiAgICAgIGxuZzogKGxhbWJkYTAgKyB0aGV0YSAvIG4pICogdGhpcy5kZWdSYWRcXG4gICAgfTtcXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIENvbnZlcnRzIHBvaW50IG9uIHNwaGVyZSB0byB0aGUgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIHVzaW5nIExhbWJlcnQgY29uZm9ybWFsXFxuICAgKiBjb25pYyBwcm9qZWN0aW9uXFxuICAgKiBAc2VlIDxhIGhyZWY9XFxcImh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vTGFtYmVydENvbmZvcm1hbENvbmljUHJvamVjdGlvbi5odG1sXFxcIj5MYW1iZXJ0IENvbmZvcm1hbCBDb25pYyBQcm9qZWN0aW9uPC9hPlxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxhdCBMYXRpdHVkZSBpbiBkZWdyZWVzXFxuICAgKiBAcGFyYW0ge051bWJlcn0gbG5nIExvbmdpdHVkZSBpbiBkZWdyZWVzXFxuICAgKiBAcGFyYW0ge051bWJlcn0gYyBDZW50cmFsIG1lcmlkaWFuIGluIGRlZ3JlZXNcXG4gICAqL1xcbiAgbGNjOiBmdW5jdGlvbihsYXQsIGxuZywgYyl7XFxuICAgIHZhciBmaTAgPSAwLFxcbiAgICAgICAgbGFtYmRhMCA9IGMgKiB0aGlzLnJhZERlZyxcXG4gICAgICAgIGxhbWJkYSA9IGxuZyAqIHRoaXMucmFkRGVnLFxcbiAgICAgICAgZmkxID0gMzMgKiB0aGlzLnJhZERlZyxcXG4gICAgICAgIGZpMiA9IDQ1ICogdGhpcy5yYWREZWcsXFxuICAgICAgICBmaSA9IGxhdCAqIHRoaXMucmFkRGVnLFxcbiAgICAgICAgbiA9IE1hdGgubG9nKCBNYXRoLmNvcyhmaTEpICogKDEgLyBNYXRoLmNvcyhmaTIpKSApIC8gTWF0aC5sb2coIE1hdGgudGFuKCBNYXRoLlBJIC8gNCArIGZpMiAvIDIpICogKDEgLyBNYXRoLnRhbiggTWF0aC5QSSAvIDQgKyBmaTEgLyAyKSApICksXFxuICAgICAgICBGID0gKCBNYXRoLmNvcyhmaTEpICogTWF0aC5wb3coIE1hdGgudGFuKCBNYXRoLlBJIC8gNCArIGZpMSAvIDIgKSwgbiApICkgLyBuLFxcbiAgICAgICAgcm8gPSBGICogTWF0aC5wb3coIDEgLyBNYXRoLnRhbiggTWF0aC5QSSAvIDQgKyBmaSAvIDIgKSwgbiApLFxcbiAgICAgICAgcm8wID0gRiAqIE1hdGgucG93KCAxIC8gTWF0aC50YW4oIE1hdGguUEkgLyA0ICsgZmkwIC8gMiApLCBuICk7XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgeDogcm8gKiBNYXRoLnNpbiggbiAqIChsYW1iZGEgLSBsYW1iZGEwKSApICogdGhpcy5yYWRpdXMsXFxuICAgICAgeTogLSAocm8wIC0gcm8gKiBNYXRoLmNvcyggbiAqIChsYW1iZGEgLSBsYW1iZGEwKSApICkgKiB0aGlzLnJhZGl1c1xcbiAgICB9O1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQ29udmVydHMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIHRvIHRoZSBwb2ludCBvbiBzcGhlcmUgdXNpbmcgTGFtYmVydCBjb25mb3JtYWwgY29uaWNcXG4gICAqIHByb2plY3Rpb25cXG4gICAqIEBzZWUgPGEgaHJlZj1cXFwiaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9MYW1iZXJ0Q29uZm9ybWFsQ29uaWNQcm9qZWN0aW9uLmh0bWxcXFwiPkxhbWJlcnQgQ29uZm9ybWFsIENvbmljIFByb2plY3Rpb248L2E+XFxuICAgKiBAcGFyYW0ge051bWJlcn0geCBYIG9mIHBvaW50IGluIENhcnRlc2lhbiBzeXN0ZW0gYXMgaW50ZWdlclxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBvZiBwb2ludCBpbiBDYXJ0ZXNpYW4gc3lzdGVtIGFzIGludGVnZXJcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjIENlbnRyYWwgbWVyaWRpYW4gaW4gZGVncmVlc1xcbiAgICovXFxuICBsY2NfaW52OiBmdW5jdGlvbih4Q29vcmQsIHlDb29yZCwgYyl7XFxuICAgIHZhciB4ID0geENvb3JkIC8gdGhpcy5yYWRpdXMsXFxuICAgICAgICB5ID0geUNvb3JkIC8gdGhpcy5yYWRpdXMsXFxuICAgICAgICBmaTAgPSAwLFxcbiAgICAgICAgbGFtYmRhMCA9IGMgKiB0aGlzLnJhZERlZyxcXG4gICAgICAgIGZpMSA9IDMzICogdGhpcy5yYWREZWcsXFxuICAgICAgICBmaTIgPSA0NSAqIHRoaXMucmFkRGVnLFxcbiAgICAgICAgbiA9IE1hdGgubG9nKCBNYXRoLmNvcyhmaTEpICogKDEgLyBNYXRoLmNvcyhmaTIpKSApIC8gTWF0aC5sb2coIE1hdGgudGFuKCBNYXRoLlBJIC8gNCArIGZpMiAvIDIpICogKDEgLyBNYXRoLnRhbiggTWF0aC5QSSAvIDQgKyBmaTEgLyAyKSApICksXFxuICAgICAgICBGID0gKCBNYXRoLmNvcyhmaTEpICogTWF0aC5wb3coIE1hdGgudGFuKCBNYXRoLlBJIC8gNCArIGZpMSAvIDIgKSwgbiApICkgLyBuLFxcbiAgICAgICAgcm8wID0gRiAqIE1hdGgucG93KCAxIC8gTWF0aC50YW4oIE1hdGguUEkgLyA0ICsgZmkwIC8gMiApLCBuICksXFxuICAgICAgICBybyA9IHRoaXMuc2duKG4pICogTWF0aC5zcXJ0KHgqeCsocm8wLXkpKihybzAteSkpLFxcbiAgICAgICAgdGhldGEgPSBNYXRoLmF0YW4oIHggLyAocm8wIC0geSkgKTtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICBsYXQ6ICgyICogTWF0aC5hdGFuKE1hdGgucG93KEYvcm8sIDEvbikpIC0gTWF0aC5QSSAvIDIpICogdGhpcy5kZWdSYWQsXFxuICAgICAgbG5nOiAobGFtYmRhMCArIHRoZXRhIC8gbikgKiB0aGlzLmRlZ1JhZFxcbiAgICB9O1xcbiAgfVxcbn07anZtLk1hcE9iamVjdCA9IGZ1bmN0aW9uKGNvbmZpZyl7fTtcXG5cXG5qdm0uTWFwT2JqZWN0LnByb3RvdHlwZS5nZXRMYWJlbFRleHQgPSBmdW5jdGlvbihrZXkpe1xcbiAgdmFyIHRleHQ7XFxuXFxuICBpZiAodGhpcy5jb25maWcubGFiZWwpIHtcXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5sYWJlbC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICB0ZXh0ID0gdGhpcy5jb25maWcubGFiZWwucmVuZGVyKGtleSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGV4dCA9IGtleTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdGV4dCA9IG51bGw7XFxuICB9XFxuICByZXR1cm4gdGV4dDtcXG59XFxuXFxuanZtLk1hcE9iamVjdC5wcm90b3R5cGUuZ2V0TGFiZWxPZmZzZXRzID0gZnVuY3Rpb24oa2V5KXtcXG4gIHZhciBvZmZzZXRzO1xcblxcbiAgaWYgKHRoaXMuY29uZmlnLmxhYmVsKSB7XFxuICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWcubGFiZWwub2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIG9mZnNldHMgPSB0aGlzLmNvbmZpZy5sYWJlbC5vZmZzZXRzKGtleSk7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29uZmlnLmxhYmVsLm9mZnNldHMgPT09ICdvYmplY3QnKSB7XFxuICAgICAgb2Zmc2V0cyA9IHRoaXMuY29uZmlnLmxhYmVsLm9mZnNldHNba2V5XTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldHMgfHwgWzAsIDBdO1xcbn1cXG5cXG4vKipcXG4gKiBTZXQgaG92ZXJlZCBzdGF0ZSB0byB0aGUgZWxlbWVudC4gSG92ZXJlZCBzdGF0ZSBtZWFucyBtb3VzZSBjdXJzb3IgaXMgb3ZlciBlbGVtZW50LiBTdHlsZXMgd2lsbCBiZSB1cGRhdGVzIHJlc3BlY3RpdmVseS5cXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzSG92ZXJlZCA8Y29kZT50cnVlPC9jb2RlPiB0byBtYWtlIGVsZW1lbnQgaG92ZXJlZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cXG4gKi9cXG5qdm0uTWFwT2JqZWN0LnByb3RvdHlwZS5zZXRIb3ZlcmVkID0gZnVuY3Rpb24oaXNIb3ZlcmVkKXtcXG4gIGlmICh0aGlzLmlzSG92ZXJlZCAhPT0gaXNIb3ZlcmVkKSB7XFxuICAgIHRoaXMuaXNIb3ZlcmVkID0gaXNIb3ZlcmVkO1xcbiAgICB0aGlzLnNoYXBlLmlzSG92ZXJlZCA9IGlzSG92ZXJlZDtcXG4gICAgdGhpcy5zaGFwZS51cGRhdGVTdHlsZSgpO1xcbiAgICBpZiAodGhpcy5sYWJlbCkge1xcbiAgICAgIHRoaXMubGFiZWwuaXNIb3ZlcmVkID0gaXNIb3ZlcmVkO1xcbiAgICAgIHRoaXMubGFiZWwudXBkYXRlU3R5bGUoKTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogU2V0IHNlbGVjdGVkIHN0YXRlIHRvIHRoZSBlbGVtZW50LiBTdHlsZXMgd2lsbCBiZSB1cGRhdGVzIHJlc3BlY3RpdmVseS5cXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2VsZWN0ZWQgPGNvZGU+dHJ1ZTwvY29kZT4gdG8gbWFrZSBlbGVtZW50IHNlbGVjdGVkLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxcbiAqL1xcbmp2bS5NYXBPYmplY3QucHJvdG90eXBlLnNldFNlbGVjdGVkID0gZnVuY3Rpb24oaXNTZWxlY3RlZCl7XFxuICBpZiAodGhpcy5pc1NlbGVjdGVkICE9PSBpc1NlbGVjdGVkKSB7XFxuICAgIHRoaXMuaXNTZWxlY3RlZCA9IGlzU2VsZWN0ZWQ7XFxuICAgIHRoaXMuc2hhcGUuaXNTZWxlY3RlZCA9IGlzU2VsZWN0ZWQ7XFxuICAgIHRoaXMuc2hhcGUudXBkYXRlU3R5bGUoKTtcXG4gICAgaWYgKHRoaXMubGFiZWwpIHtcXG4gICAgICB0aGlzLmxhYmVsLmlzU2VsZWN0ZWQgPSBpc1NlbGVjdGVkO1xcbiAgICAgIHRoaXMubGFiZWwudXBkYXRlU3R5bGUoKTtcXG4gICAgfVxcbiAgICBqdm0uJCh0aGlzLnNoYXBlKS50cmlnZ2VyKCdzZWxlY3RlZCcsIFtpc1NlbGVjdGVkXSk7XFxuICB9XFxufTtcXG5cXG5qdm0uTWFwT2JqZWN0LnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uKCl7XFxuXFx0dGhpcy5zaGFwZS5zZXRTdHlsZS5hcHBseSh0aGlzLnNoYXBlLCBhcmd1bWVudHMpO1xcbn07XFxuXFxuanZtLk1hcE9iamVjdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKXtcXG4gIHRoaXMuc2hhcGUucmVtb3ZlKCk7XFxuICBpZiAodGhpcy5sYWJlbCkge1xcbiAgICB0aGlzLmxhYmVsLnJlbW92ZSgpO1xcbiAgfVxcbn07anZtLlJlZ2lvbiA9IGZ1bmN0aW9uKGNvbmZpZyl7XFxuICB2YXIgYmJveCxcXG4gICAgICB0ZXh0LFxcbiAgICAgIG9mZnNldHMsXFxuICAgICAgbGFiZWxEeCxcXG4gICAgICBsYWJlbER5O1xcblxcbiAgdGhpcy5jb25maWcgPSBjb25maWc7XFxuICB0aGlzLm1hcCA9IHRoaXMuY29uZmlnLm1hcDtcXG5cXG4gIHRoaXMuc2hhcGUgPSBjb25maWcuY2FudmFzLmFkZFBhdGgoe1xcbiAgICBkOiBjb25maWcucGF0aCxcXG4gICAgJ2RhdGEtY29kZSc6IGNvbmZpZy5jb2RlXFxuICB9LCBjb25maWcuc3R5bGUsIGNvbmZpZy5jYW52YXMucm9vdEVsZW1lbnQpO1xcbiAgdGhpcy5zaGFwZS5hZGRDbGFzcygnanZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50Jyk7XFxuXFxuICBiYm94ID0gdGhpcy5zaGFwZS5nZXRCQm94KCk7XFxuXFxuICB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoY29uZmlnLmNvZGUpO1xcbiAgaWYgKHRoaXMuY29uZmlnLmxhYmVsICYmIHRleHQpIHtcXG4gICAgb2Zmc2V0cyA9IHRoaXMuZ2V0TGFiZWxPZmZzZXRzKGNvbmZpZy5jb2RlKTtcXG4gICAgdGhpcy5sYWJlbFggPSBiYm94LnggKyBiYm94LndpZHRoIC8gMiArIG9mZnNldHNbMF07XFxuICAgIHRoaXMubGFiZWxZID0gYmJveC55ICsgYmJveC5oZWlnaHQgLyAyICsgb2Zmc2V0c1sxXTtcXG4gICAgdGhpcy5sYWJlbCA9IGNvbmZpZy5jYW52YXMuYWRkVGV4dCh7XFxuICAgICAgdGV4dDogdGV4dCxcXG4gICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcXG4gICAgICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2NlbnRyYWwnLFxcbiAgICAgIHg6IHRoaXMubGFiZWxYLFxcbiAgICAgIHk6IHRoaXMubGFiZWxZLFxcbiAgICAgICdkYXRhLWNvZGUnOiBjb25maWcuY29kZVxcbiAgICB9LCBjb25maWcubGFiZWxTdHlsZSwgY29uZmlnLmxhYmVsc0dyb3VwKTtcXG4gICAgdGhpcy5sYWJlbC5hZGRDbGFzcygnanZlY3Rvcm1hcC1yZWdpb24ganZlY3Rvcm1hcC1lbGVtZW50Jyk7XFxuICB9XFxufTtcXG5cXG5qdm0uaW5oZXJpdHMoanZtLlJlZ2lvbiwganZtLk1hcE9iamVjdCk7XFxuXFxuanZtLlJlZ2lvbi5wcm90b3R5cGUudXBkYXRlTGFiZWxQb3NpdGlvbiA9IGZ1bmN0aW9uKCl7XFxuICBpZiAodGhpcy5sYWJlbCkge1xcbiAgICB0aGlzLmxhYmVsLnNldCh7XFxuICAgICAgeDogdGhpcy5sYWJlbFggKiB0aGlzLm1hcC5zY2FsZSArIHRoaXMubWFwLnRyYW5zWCAqIHRoaXMubWFwLnNjYWxlLFxcbiAgICAgIHk6IHRoaXMubGFiZWxZICogdGhpcy5tYXAuc2NhbGUgKyB0aGlzLm1hcC50cmFuc1kgKiB0aGlzLm1hcC5zY2FsZVxcbiAgICB9KTtcXG4gIH1cXG59O2p2bS5NYXJrZXIgPSBmdW5jdGlvbihjb25maWcpe1xcbiAgdmFyIHRleHQsXFxuICAgICAgb2Zmc2V0cztcXG5cXG4gIHRoaXMuY29uZmlnID0gY29uZmlnO1xcbiAgdGhpcy5tYXAgPSB0aGlzLmNvbmZpZy5tYXA7XFxuXFxuICB0aGlzLmlzSW1hZ2UgPSAhIXRoaXMuY29uZmlnLnN0eWxlLmluaXRpYWwuaW1hZ2U7XFxuICB0aGlzLmNyZWF0ZVNoYXBlKCk7XFxuXFxuICB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoY29uZmlnLmluZGV4KTtcXG4gIGlmICh0aGlzLmNvbmZpZy5sYWJlbCAmJiB0ZXh0KSB7XFxuICAgIHRoaXMub2Zmc2V0cyA9IHRoaXMuZ2V0TGFiZWxPZmZzZXRzKGNvbmZpZy5pbmRleCk7XFxuICAgIHRoaXMubGFiZWxYID0gY29uZmlnLmN4IC8gdGhpcy5tYXAuc2NhbGUgLSB0aGlzLm1hcC50cmFuc1g7XFxuICAgIHRoaXMubGFiZWxZID0gY29uZmlnLmN5IC8gdGhpcy5tYXAuc2NhbGUgLSB0aGlzLm1hcC50cmFuc1k7XFxuICAgIHRoaXMubGFiZWwgPSBjb25maWcuY2FudmFzLmFkZFRleHQoe1xcbiAgICAgIHRleHQ6IHRleHQsXFxuICAgICAgJ2RhdGEtaW5kZXgnOiBjb25maWcuaW5kZXgsXFxuICAgICAgZHk6IFxcXCIwLjZleFxcXCIsXFxuICAgICAgeDogdGhpcy5sYWJlbFgsXFxuICAgICAgeTogdGhpcy5sYWJlbFlcXG4gICAgfSwgY29uZmlnLmxhYmVsU3R5bGUsIGNvbmZpZy5sYWJlbHNHcm91cCk7XFxuXFxuICAgIHRoaXMubGFiZWwuYWRkQ2xhc3MoJ2p2ZWN0b3JtYXAtbWFya2VyIGp2ZWN0b3JtYXAtZWxlbWVudCcpO1xcbiAgfVxcbn07XFxuXFxuanZtLmluaGVyaXRzKGp2bS5NYXJrZXIsIGp2bS5NYXBPYmplY3QpO1xcblxcbmp2bS5NYXJrZXIucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24oKXtcXG4gIHZhciB0aGF0ID0gdGhpcztcXG5cXG4gIGlmICh0aGlzLnNoYXBlKSB7XFxuICAgIHRoaXMuc2hhcGUucmVtb3ZlKCk7XFxuICB9XFxuICB0aGlzLnNoYXBlID0gdGhpcy5jb25maWcuY2FudmFzW3RoaXMuaXNJbWFnZSA/ICdhZGRJbWFnZScgOiAnYWRkQ2lyY2xlJ10oe1xcbiAgICBcXFwiZGF0YS1pbmRleFxcXCI6IHRoaXMuY29uZmlnLmluZGV4LFxcbiAgICBjeDogdGhpcy5jb25maWcuY3gsXFxuICAgIGN5OiB0aGlzLmNvbmZpZy5jeVxcbiAgfSwgdGhpcy5jb25maWcuc3R5bGUsIHRoaXMuY29uZmlnLmdyb3VwKTtcXG5cXG4gIHRoaXMuc2hhcGUuYWRkQ2xhc3MoJ2p2ZWN0b3JtYXAtbWFya2VyIGp2ZWN0b3JtYXAtZWxlbWVudCcpO1xcblxcbiAgaWYgKHRoaXMuaXNJbWFnZSkge1xcbiAgICBqdm0uJCh0aGlzLnNoYXBlLm5vZGUpLm9uKCdpbWFnZWxvYWRlZCcsIGZ1bmN0aW9uKCl7XFxuICAgICAgdGhhdC51cGRhdGVMYWJlbFBvc2l0aW9uKCk7XFxuICAgIH0pO1xcbiAgfVxcbn07XFxuXFxuanZtLk1hcmtlci5wcm90b3R5cGUudXBkYXRlTGFiZWxQb3NpdGlvbiA9IGZ1bmN0aW9uKCl7XFxuICBpZiAodGhpcy5sYWJlbCkge1xcbiAgICB0aGlzLmxhYmVsLnNldCh7XFxuICAgICAgeDogdGhpcy5sYWJlbFggKiB0aGlzLm1hcC5zY2FsZSArIHRoaXMub2Zmc2V0c1swXSArXFxuICAgICAgICAgdGhpcy5tYXAudHJhbnNYICogdGhpcy5tYXAuc2NhbGUgKyA1ICsgKHRoaXMuaXNJbWFnZSA/ICh0aGlzLnNoYXBlLndpZHRoIHx8IDApIC8gMiA6IHRoaXMuc2hhcGUucHJvcGVydGllcy5yKSxcXG4gICAgICB5OiB0aGlzLmxhYmVsWSAqIHRoaXMubWFwLnNjYWxlICsgdGhpcy5tYXAudHJhbnNZICogdGhpcy5tYXAuc2NhbGUgKyB0aGlzLm9mZnNldHNbMV1cXG4gICAgfSk7XFxuICB9XFxufTtcXG5cXG5qdm0uTWFya2VyLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSl7XFxuICB2YXIgaXNJbWFnZTtcXG5cXG4gIGp2bS5NYXJrZXIucGFyZW50Q2xhc3MucHJvdG90eXBlLnNldFN0eWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICBpZiAocHJvcGVydHkgPT09ICdyJykge1xcbiAgICB0aGlzLnVwZGF0ZUxhYmVsUG9zaXRpb24oKTtcXG4gIH1cXG5cXG4gIGlzSW1hZ2UgPSAhIXRoaXMuc2hhcGUuZ2V0KCdpbWFnZScpO1xcbiAgaWYgKGlzSW1hZ2UgIT0gdGhpcy5pc0ltYWdlKSB7XFxuICAgIHRoaXMuaXNJbWFnZSA9IGlzSW1hZ2U7XFxuICAgIHRoaXMuY29uZmlnLnN0eWxlID0ganZtLiQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLnNoYXBlLnN0eWxlKTtcXG4gICAgdGhpcy5jcmVhdGVTaGFwZSgpO1xcbiAgfVxcbn07LyoqXFxuICogQ3JlYXRlcyBtYXAsIGRyYXdzIHBhdGhzLCBiaW5kcyBldmVudHMuXFxuICogQGNvbnN0cnVjdG9yXFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzIHRvIGluaXRpYWxpemUgbWFwIHdpdGguXFxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5tYXAgTmFtZSBvZiB0aGUgbWFwIGluIHRoZSBmb3JtYXQgPGNvZGU+dGVycml0b3J5X3Byb2pfbGFuZzwvY29kZT4gd2hlcmUgPGNvZGU+dGVycml0b3J5PC9jb2RlPiBpcyBhIHVuaXF1ZSBjb2RlIG9yIG5hbWUgb2YgdGhlIHRlcnJpdG9yeSB3aGljaCB0aGUgbWFwIHJlcHJlc2VudHMgKElTTyAzMTY2IHN0YW5kYXJkIGlzIHVzZWQgd2hlcmUgcG9zc2libGUpLCA8Y29kZT5wcm9qPC9jb2RlPiBpcyBhIG5hbWUgb2YgcHJvamVjdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXAgb24gdGhlIHBsYW5lIChwcm9qZWN0aW9ucyBhcmUgbmFtZWQgYWNjb3JkaW5nIHRvIHRoZSBjb252ZW50aW9ucyBvZiBwcm9qNCB1dGlsaXR5KSBhbmQgPGNvZGU+bGFuZzwvY29kZT4gaXMgYSBjb2RlIG9mIHRoZSBsYW5ndWFnZSwgdXNlZCBmb3IgdGhlIG5hbWVzIG9mIHJlZ2lvbnMuXFxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5iYWNrZ3JvdW5kQ29sb3IgQmFja2dyb3VuZCBjb2xvciBvZiB0aGUgbWFwIGluIENTUyBmb3JtYXQuXFxuICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuem9vbU9uU2Nyb2xsIFdoZW4gc2V0IHRvIHRydWUgbWFwIGNvdWxkIGJlIHpvb21lZCB1c2luZyBtb3VzZSBzY3JvbGwuIERlZmF1bHQgdmFsdWUgaXMgPGNvZGU+dHJ1ZTwvY29kZT4uXFxuICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy56b29tT25TY3JvbGxTcGVlZCBNb3VzZSBzY3JvbGwgc3BlZWQuIE51bWJlciBmcm9tIDEgdG8gMTAuIERlZmF1bHQgdmFsdWUgaXMgPGNvZGU+MzwvY29kZT4uXFxuICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMucGFuT25EcmFnIFdoZW4gc2V0IHRvIHRydWUsIHRoZSBtYXAgcGFucyB3aGVuIGJlaW5nIGRyYWdnZWQuIERlZmF1bHQgdmFsdWUgaXMgPGNvZGU+dHJ1ZTwvY29kZT4uXFxuICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy56b29tTWF4IEluZGljYXRlcyB0aGUgbWF4aW11bSB6b29tIHJhdGlvIHdoaWNoIGNvdWxkIGJlIHJlYWNoZWQgem9vbWluZyB0aGUgbWFwLiBEZWZhdWx0IHZhbHVlIGlzIDxjb2RlPjg8L2NvZGU+LlxcbiAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuem9vbU1pbiBJbmRpY2F0ZXMgdGhlIG1pbmltdW0gem9vbSByYXRpbyB3aGljaCBjb3VsZCBiZSByZWFjaGVkIHpvb21pbmcgdGhlIG1hcC4gRGVmYXVsdCB2YWx1ZSBpcyA8Y29kZT4xPC9jb2RlPi5cXG4gKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnpvb21TdGVwIEluZGljYXRlcyB0aGUgbXVsdGlwbGllciB1c2VkIHRvIHpvb20gbWFwIHdpdGggKy8tIGJ1dHRvbnMuIERlZmF1bHQgdmFsdWUgaXMgPGNvZGU+MS42PC9jb2RlPi5cXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy56b29tQW5pbWF0ZSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gYW5pbWF0ZSBjaGFuZ2luZyBvZiBtYXAgem9vbSB3aXRoIHpvb20gYnV0dG9ucy5cXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5yZWdpb25zU2VsZWN0YWJsZSBXaGVuIHNldCB0byB0cnVlIHJlZ2lvbnMgb2YgdGhlIG1hcCBjb3VsZCBiZSBzZWxlY3RlZC4gRGVmYXVsdCB2YWx1ZSBpcyA8Y29kZT5mYWxzZTwvY29kZT4uXFxuICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMucmVnaW9uc1NlbGVjdGFibGVPbmUgQWxsb3cgb25seSBvbmUgcmVnaW9uIHRvIGJlIHNlbGVjdGVkIGF0IHRoZSBtb21lbnQuIERlZmF1bHQgdmFsdWUgaXMgPGNvZGU+ZmFsc2U8L2NvZGU+LlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLm1hcmtlcnNTZWxlY3RhYmxlIFdoZW4gc2V0IHRvIHRydWUgbWFya2VycyBvbiB0aGUgbWFwIGNvdWxkIGJlIHNlbGVjdGVkLiBEZWZhdWx0IHZhbHVlIGlzIDxjb2RlPmZhbHNlPC9jb2RlPi5cXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5tYXJrZXJzU2VsZWN0YWJsZU9uZSBBbGxvdyBvbmx5IG9uZSBtYXJrZXIgdG8gYmUgc2VsZWN0ZWQgYXQgdGhlIG1vbWVudC4gRGVmYXVsdCB2YWx1ZSBpcyA8Y29kZT5mYWxzZTwvY29kZT4uXFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5yZWdpb25TdHlsZSBTZXQgdGhlIHN0eWxlcyBmb3IgdGhlIG1hcCdzIHJlZ2lvbnMuIEVhY2ggcmVnaW9uIG9yIG1hcmtlciBoYXMgZm91ciBzdGF0ZXM6IDxjb2RlPmluaXRpYWw8L2NvZGU+IChkZWZhdWx0IHN0YXRlKSwgPGNvZGU+aG92ZXI8L2NvZGU+ICh3aGVuIHRoZSBtb3VzZSBjdXJzb3IgaXMgb3ZlciB0aGUgcmVnaW9uIG9yIG1hcmtlciksIDxjb2RlPnNlbGVjdGVkPC9jb2RlPiAod2hlbiByZWdpb24gb3IgbWFya2VyIGlzIHNlbGVjdGVkKSwgPGNvZGU+c2VsZWN0ZWRIb3ZlcjwvY29kZT4gKHdoZW4gdGhlIG1vdXNlIGN1cnNvciBpcyBvdmVyIHRoZSByZWdpb24gb3IgbWFya2VyIGFuZCBpdCdzIHNlbGVjdGVkIHNpbXVsdGFuZW91c2x5KS4gU3R5bGVzIGNvdWxkIGJlIHNldCBmb3IgZWFjaCBvZiB0aGlzIHN0YXRlcy4gRGVmYXVsdCB2YWx1ZSBmb3IgdGhhdCBwYXJhbWV0ZXIgaXM6XFxuPHByZT57XFxuICBpbml0aWFsOiB7XFxuICAgIGZpbGw6ICd3aGl0ZScsXFxuICAgIFxcXCJmaWxsLW9wYWNpdHlcXFwiOiAxLFxcbiAgICBzdHJva2U6ICdub25lJyxcXG4gICAgXFxcInN0cm9rZS13aWR0aFxcXCI6IDAsXFxuICAgIFxcXCJzdHJva2Utb3BhY2l0eVxcXCI6IDFcXG4gIH0sXFxuICBob3Zlcjoge1xcbiAgICBcXFwiZmlsbC1vcGFjaXR5XFxcIjogMC44LFxcbiAgICBjdXJzb3I6ICdwb2ludGVyJ1xcbiAgfSxcXG4gIHNlbGVjdGVkOiB7XFxuICAgIGZpbGw6ICd5ZWxsb3cnXFxuICB9LFxcbiAgc2VsZWN0ZWRIb3Zlcjoge1xcbiAgfVxcbn08L3ByZT5cXG4qIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucmVnaW9uTGFiZWxTdHlsZSBTZXQgdGhlIHN0eWxlcyBmb3IgdGhlIHJlZ2lvbnMnIGxhYmVscy4gRWFjaCByZWdpb24gb3IgbWFya2VyIGhhcyBmb3VyIHN0YXRlczogPGNvZGU+aW5pdGlhbDwvY29kZT4gKGRlZmF1bHQgc3RhdGUpLCA8Y29kZT5ob3ZlcjwvY29kZT4gKHdoZW4gdGhlIG1vdXNlIGN1cnNvciBpcyBvdmVyIHRoZSByZWdpb24gb3IgbWFya2VyKSwgPGNvZGU+c2VsZWN0ZWQ8L2NvZGU+ICh3aGVuIHJlZ2lvbiBvciBtYXJrZXIgaXMgc2VsZWN0ZWQpLCA8Y29kZT5zZWxlY3RlZEhvdmVyPC9jb2RlPiAod2hlbiB0aGUgbW91c2UgY3Vyc29yIGlzIG92ZXIgdGhlIHJlZ2lvbiBvciBtYXJrZXIgYW5kIGl0J3Mgc2VsZWN0ZWQgc2ltdWx0YW5lb3VzbHkpLiBTdHlsZXMgY291bGQgYmUgc2V0IGZvciBlYWNoIG9mIHRoaXMgc3RhdGVzLiBEZWZhdWx0IHZhbHVlIGZvciB0aGF0IHBhcmFtZXRlciBpczpcXG48cHJlPntcXG4gIGluaXRpYWw6IHtcXG4gICAgJ2ZvbnQtZmFtaWx5JzogJ1ZlcmRhbmEnLFxcbiAgICAnZm9udC1zaXplJzogJzEyJyxcXG4gICAgJ2ZvbnQtd2VpZ2h0JzogJ2JvbGQnLFxcbiAgICBjdXJzb3I6ICdkZWZhdWx0JyxcXG4gICAgZmlsbDogJ2JsYWNrJ1xcbiAgfSxcXG4gIGhvdmVyOiB7XFxuICAgIGN1cnNvcjogJ3BvaW50ZXInXFxuICB9XFxufTwvcHJlPlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMubWFya2VyU3R5bGUgU2V0IHRoZSBzdHlsZXMgZm9yIHRoZSBtYXAncyBtYXJrZXJzLiBBbnkgcGFyYW1ldGVyIHN1aXRhYmxlIGZvciA8Y29kZT5yZWdpb25TdHlsZTwvY29kZT4gY291bGQgYmUgdXNlZCBhcyB3ZWxsIGFzIG51bWVyaWMgcGFyYW1ldGVyIDxjb2RlPnI8L2NvZGU+IHRvIHNldCB0aGUgbWFya2VyJ3MgcmFkaXVzLiBEZWZhdWx0IHZhbHVlIGZvciB0aGF0IHBhcmFtZXRlciBpczpcXG48cHJlPntcXG4gIGluaXRpYWw6IHtcXG4gICAgZmlsbDogJ2dyZXknLFxcbiAgICBzdHJva2U6ICcjNTA1MDUwJyxcXG4gICAgXFxcImZpbGwtb3BhY2l0eVxcXCI6IDEsXFxuICAgIFxcXCJzdHJva2Utd2lkdGhcXFwiOiAxLFxcbiAgICBcXFwic3Ryb2tlLW9wYWNpdHlcXFwiOiAxLFxcbiAgICByOiA1XFxuICB9LFxcbiAgaG92ZXI6IHtcXG4gICAgc3Ryb2tlOiAnYmxhY2snLFxcbiAgICBcXFwic3Ryb2tlLXdpZHRoXFxcIjogMixcXG4gICAgY3Vyc29yOiAncG9pbnRlcidcXG4gIH0sXFxuICBzZWxlY3RlZDoge1xcbiAgICBmaWxsOiAnYmx1ZSdcXG4gIH0sXFxuICBzZWxlY3RlZEhvdmVyOiB7XFxuICB9XFxufTwvcHJlPlxcbllvdSBjYW4gYWxzbyB1c2UgPGNvZGU+aW1hZ2U8L2NvZGU+IHN0eWxlIGF0dHJpYnV0ZSBmb3IgbWFya2Vycy4gQnkgZGVmYXVsdCBtYXJrZXIgaW1hZ2VzIGFyZSBjZW50ZXJlZCB3aXRoIHRoZSB0YXJnZXQgcG9pbnQgb24gbWFwLiBUbyBzdXBwbHkgYSBjdXN0b20gb2Zmc2V0IHBsZWFzZSB1c2UgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XFxuPHByZT57XFxuICB1cmw6ICdpbWFnZS91cmwnLFxcbiAgb2Zmc2V0OiBbLTEwLCA1XVxcbn08L3ByZT5cXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLm1hcmtlckxhYmVsU3R5bGUgU2V0IHRoZSBzdHlsZXMgZm9yIHRoZSBtYXJrZXJzJyBsYWJlbHMuIERlZmF1bHQgdmFsdWUgZm9yIHRoYXQgcGFyYW1ldGVyIGlzOlxcbjxwcmU+e1xcbiAgaW5pdGlhbDoge1xcbiAgICAnZm9udC1mYW1pbHknOiAnVmVyZGFuYScsXFxuICAgICdmb250LXNpemUnOiAnMTInLFxcbiAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXFxuICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxcbiAgICBmaWxsOiAnYmxhY2snXFxuICB9LFxcbiAgaG92ZXI6IHtcXG4gICAgY3Vyc29yOiAncG9pbnRlcidcXG4gIH1cXG59PC9wcmU+XFxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHBhcmFtcy5tYXJrZXJzIFNldCBvZiBtYXJrZXJzIHRvIGFkZCB0byB0aGUgbWFwIGR1cmluZyBpbml0aWFsaXphdGlvbi4gSW4gY2FzZSBvZiBhcnJheSBpcyBwcm92aWRlZCwgY29kZXMgb2YgbWFya2VycyB3aWxsIGJlIHNldCBhcyBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIGFycmF5IGluZGV4ZXMuIEVhY2ggbWFya2VyIGlzIHJlcHJlc2VudGVkIGJ5IDxjb2RlPmxhdExuZzwvY29kZT4gKGFycmF5IG9mIHR3byBudW1lcmljIHZhbHVlcyksIDxjb2RlPm5hbWU8L2NvZGU+IChzdHJpbmcgd2hpY2ggd2lsbCBiZSBzaG93IG9uIG1hcmtlcidzIHRpcCkgYW5kIGFueSBtYXJrZXIgc3R5bGVzLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMuc2VyaWVzIE9iamVjdCB3aXRoIHR3byBrZXlzOiA8Y29kZT5tYXJrZXJzPC9jb2RlPiBhbmQgPGNvZGU+cmVnaW9uczwvY29kZT4uIEVhY2ggb2Ygd2hpY2ggaXMgYW4gYXJyYXkgb2Ygc2VyaWVzIGNvbmZpZ3MgdG8gYmUgYXBwbGllZCB0byB0aGUgcmVzcGVjdGl2ZSBtYXAgZWxlbWVudHMuIFNlZSA8YSBocmVmPVxcXCJqdm0uRGF0YVNlcmllcy5odG1sXFxcIj5EYXRhU2VyaWVzPC9hPiBkZXNjcmlwdGlvbiBmb3IgYSBsaXN0IG9mIHBhcmFtZXRlcnMgYXZhaWxhYmxlLlxcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcGFyYW1zLmZvY3VzT24gVGhpcyBwYXJhbWV0ZXIgc2V0cyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBhbmQgc2NhbGUgb2YgdGhlIG1hcCB2aWV3cG9ydC4gU2VlIDxjb2RlPnNldEZvY3VzPC9jb2RlPiBkb2N1ZW1udGF0aW9uIGZvciBwb3NzaWJsZSBwYXJhbWV0ZXJzLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMubGFiZWxzIERlZmluZXMgcGFyYW1ldGVycyBmb3IgcmVuZGVyaW5nIHN0YXRpYyBsYWJlbHMuIE9iamVjdCBjb3VsZCBjb250YWluIHR3byBrZXlzOiA8Y29kZT5yZWdpb25zPC9jb2RlPiBhbmQgPGNvZGU+bWFya2VyczwvY29kZT4uIEVhY2gga2V5IHZhbHVlIGRlZmluZXMgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBvc3NpYmxlIG9wdGlvbnM6XFxuPHVsPlxcbiAgPGxpPjxjb2RlPnJlbmRlciB7RnVuY3Rpb259PC9jb2RlPiAtIGRlZmluZXMgbWV0aG9kIGZvciBjb252ZXJ0aW5nIHJlZ2lvbiBjb2RlIG9yIG1hcmtlciBpbmRleCB0byBhY3R1YWwgbGFiZWwgdmFsdWUuPC9saT5cXG4gIDxsaT48Y29kZT5vZmZzZXRzIHtPYmplY3R8RnVuY3Rpb259PC9jb2RlPiAtIHByb3ZpZGVzIG1ldGhvZCBvciBvYmplY3Qgd2hpY2ggY291bGQgYmUgdXNlZCB0byBkZWZpbmUgbGFiZWwgb2Zmc2V0IGJ5IHJlZ2lvbiBjb2RlIG9yIG1hcmtlciBpbmRleC48L2xpPlxcbjwvdWw+XFxuPGI+UGxhc2Ugbm90ZTogc3RhdGljIGxhYmVscyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgOCBhbmQgYmVsb3cuPC9iPlxcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gcGFyYW1zLnNlbGVjdGVkUmVnaW9ucyBTZXQgaW5pdGlhbGx5IHNlbGVjdGVkIHJlZ2lvbnMuXFxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBwYXJhbXMuc2VsZWN0ZWRNYXJrZXJzIFNldCBpbml0aWFsbHkgc2VsZWN0ZWQgbWFya2Vycy5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJhbXMub25SZWdpb25UaXBTaG93IDxjb2RlPihFdmVudCBlLCBPYmplY3QgdGlwLCBTdHJpbmcgY29kZSk8L2NvZGU+IFdpbGwgYmUgY2FsbGVkIHJpZ2h0IGJlZm9yZSB0aGUgcmVnaW9uIHRpcCBpcyBnb2luZyB0byBiZSBzaG93bi5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJhbXMub25SZWdpb25PdmVyIDxjb2RlPihFdmVudCBlLCBTdHJpbmcgY29kZSk8L2NvZGU+IFdpbGwgYmUgY2FsbGVkIG9uIHJlZ2lvbiBtb3VzZSBvdmVyIGV2ZW50LlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtcy5vblJlZ2lvbk91dCA8Y29kZT4oRXZlbnQgZSwgU3RyaW5nIGNvZGUpPC9jb2RlPiBXaWxsIGJlIGNhbGxlZCBvbiByZWdpb24gbW91c2Ugb3V0IGV2ZW50LlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtcy5vblJlZ2lvbkNsaWNrIDxjb2RlPihFdmVudCBlLCBTdHJpbmcgY29kZSk8L2NvZGU+IFdpbGwgYmUgY2FsbGVkIG9uIHJlZ2lvbiBjbGljayBldmVudC5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJhbXMub25SZWdpb25TZWxlY3RlZCA8Y29kZT4oRXZlbnQgZSwgU3RyaW5nIGNvZGUsIEJvb2xlYW4gaXNTZWxlY3RlZCwgQXJyYXkgc2VsZWN0ZWRSZWdpb25zKTwvY29kZT4gV2lsbCBiZSBjYWxsZWQgd2hlbiByZWdpb24gaXMgKGRlKXNlbGVjdGVkLiA8Y29kZT5pc1NlbGVjdGVkPC9jb2RlPiBwYXJhbWV0ZXIgb2YgdGhlIGNhbGxiYWNrIGluZGljYXRlcyB3aGV0aGVyIHJlZ2lvbiBpcyBzZWxlY3RlZCBvciBub3QuIDxjb2RlPnNlbGVjdGVkUmVnaW9uczwvY29kZT4gY29udGFpbnMgY29kZXMgb2YgYWxsIGN1cnJlbnRseSBzZWxlY3RlZCByZWdpb25zLlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtcy5vbk1hcmtlclRpcFNob3cgPGNvZGU+KEV2ZW50IGUsIE9iamVjdCB0aXAsIFN0cmluZyBjb2RlKTwvY29kZT4gV2lsbCBiZSBjYWxsZWQgcmlnaHQgYmVmb3JlIHRoZSBtYXJrZXIgdGlwIGlzIGdvaW5nIHRvIGJlIHNob3duLlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtcy5vbk1hcmtlck92ZXIgPGNvZGU+KEV2ZW50IGUsIFN0cmluZyBjb2RlKTwvY29kZT4gV2lsbCBiZSBjYWxsZWQgb24gbWFya2VyIG1vdXNlIG92ZXIgZXZlbnQuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW1zLm9uTWFya2VyT3V0IDxjb2RlPihFdmVudCBlLCBTdHJpbmcgY29kZSk8L2NvZGU+IFdpbGwgYmUgY2FsbGVkIG9uIG1hcmtlciBtb3VzZSBvdXQgZXZlbnQuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW1zLm9uTWFya2VyQ2xpY2sgPGNvZGU+KEV2ZW50IGUsIFN0cmluZyBjb2RlKTwvY29kZT4gV2lsbCBiZSBjYWxsZWQgb24gbWFya2VyIGNsaWNrIGV2ZW50LlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtcy5vbk1hcmtlclNlbGVjdGVkIDxjb2RlPihFdmVudCBlLCBTdHJpbmcgY29kZSwgQm9vbGVhbiBpc1NlbGVjdGVkLCBBcnJheSBzZWxlY3RlZE1hcmtlcnMpPC9jb2RlPiBXaWxsIGJlIGNhbGxlZCB3aGVuIG1hcmtlciBpcyAoZGUpc2VsZWN0ZWQuIDxjb2RlPmlzU2VsZWN0ZWQ8L2NvZGU+IHBhcmFtZXRlciBvZiB0aGUgY2FsbGJhY2sgaW5kaWNhdGVzIHdoZXRoZXIgbWFya2VyIGlzIHNlbGVjdGVkIG9yIG5vdC4gPGNvZGU+c2VsZWN0ZWRNYXJrZXJzPC9jb2RlPiBjb250YWlucyBjb2RlcyBvZiBhbGwgY3VycmVudGx5IHNlbGVjdGVkIG1hcmtlcnMuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW1zLm9uVmlld3BvcnRDaGFuZ2UgPGNvZGU+KEV2ZW50IGUsIE51bWJlciBzY2FsZSk8L2NvZGU+IFRyaWdnZXJlZCB3aGVuIHRoZSBtYXAncyB2aWV3cG9ydCBpcyBjaGFuZ2VkIChtYXAgd2FzIHBhbm5lZCBvciB6b29tZWQpLlxcbiAqL1xcbmp2bS5NYXAgPSBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICB2YXIgbWFwID0gdGhpcyxcXG4gICAgZTtcXG5cXG4gIHRoaXMucGFyYW1zID0ganZtLiQuZXh0ZW5kKHRydWUsIHt9LCBqdm0uTWFwLmRlZmF1bHRQYXJhbXMsIHBhcmFtcyk7XFxuXFxuICBpZiAoIWp2bS5NYXAubWFwc1t0aGlzLnBhcmFtcy5tYXBdKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICBcXFwiQXR0ZW1wdCB0byB1c2UgbWFwIHdoaWNoIHdhcyBub3QgbG9hZGVkOiBcXFwiICsgdGhpcy5wYXJhbXMubWFwLFxcbiAgICApO1xcbiAgfVxcblxcbiAgdGhpcy5tYXBEYXRhID0ganZtLk1hcC5tYXBzW3RoaXMucGFyYW1zLm1hcF07XFxuICB0aGlzLm1hcmtlcnMgPSB7fTtcXG4gIHRoaXMucmVnaW9ucyA9IHt9O1xcbiAgdGhpcy5yZWdpb25zQ29sb3JzID0ge307XFxuICB0aGlzLnJlZ2lvbnNEYXRhID0ge307XFxuXFxuICB0aGlzLmNvbnRhaW5lciA9IGp2bS4kKFxcXCI8ZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJqdmVjdG9ybWFwLWNvbnRhaW5lclxcXCIpO1xcbiAgaWYgKHRoaXMucGFyYW1zLmNvbnRhaW5lcikge1xcbiAgICB0aGlzLnBhcmFtcy5jb250YWluZXIuYXBwZW5kKHRoaXMuY29udGFpbmVyKTtcXG4gIH1cXG4gIHRoaXMuY29udGFpbmVyLmRhdGEoXFxcIm1hcE9iamVjdFxcXCIsIHRoaXMpO1xcblxcbiAgdGhpcy5kZWZhdWx0V2lkdGggPSB0aGlzLm1hcERhdGEud2lkdGg7XFxuICB0aGlzLmRlZmF1bHRIZWlnaHQgPSB0aGlzLm1hcERhdGEuaGVpZ2h0O1xcblxcbiAgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5wYXJhbXMuYmFja2dyb3VuZENvbG9yKTtcXG5cXG4gIHRoaXMub25SZXNpemUgPSBmdW5jdGlvbiAoKSB7XFxuICAgIG1hcC51cGRhdGVTaXplKCk7XFxuICB9O1xcbiAganZtLiQod2luZG93KS5yZXNpemUodGhpcy5vblJlc2l6ZSk7XFxuXFxuICBmb3IgKGUgaW4ganZtLk1hcC5hcGlFdmVudHMpIHtcXG4gICAgaWYgKHRoaXMucGFyYW1zW2VdKSB7XFxuICAgICAgdGhpcy5jb250YWluZXIuYmluZChqdm0uTWFwLmFwaUV2ZW50c1tlXSArIFxcXCIuanZlY3Rvcm1hcFxcXCIsIHRoaXMucGFyYW1zW2VdKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdGhpcy5jYW52YXMgPSBuZXcganZtLlZlY3RvckNhbnZhcyhcXG4gICAgdGhpcy5jb250YWluZXJbMF0sXFxuICAgIHRoaXMud2lkdGgsXFxuICAgIHRoaXMuaGVpZ2h0LFxcbiAgKTtcXG5cXG4gIGlmICh0aGlzLnBhcmFtcy5iaW5kVG91Y2hFdmVudHMpIHtcXG4gICAgaWYgKFxcbiAgICAgIFxcXCJvbnRvdWNoc3RhcnRcXFwiIGluIHdpbmRvdyB8fFxcbiAgICAgICh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2gpXFxuICAgICkge1xcbiAgICAgIHRoaXMuYmluZENvbnRhaW5lclRvdWNoRXZlbnRzKCk7XFxuICAgIH0gZWxzZSBpZiAod2luZG93Lk1TR2VzdHVyZSkge1xcbiAgICAgIHRoaXMuYmluZENvbnRhaW5lclBvaW50ZXJFdmVudHMoKTtcXG4gICAgfVxcbiAgfVxcbiAgdGhpcy5iaW5kQ29udGFpbmVyRXZlbnRzKCk7XFxuICB0aGlzLmJpbmRFbGVtZW50RXZlbnRzKCk7XFxuICB0aGlzLmNyZWF0ZVRpcCgpO1xcbiAgaWYgKHRoaXMucGFyYW1zLnpvb21CdXR0b25zKSB7XFxuICAgIHRoaXMuYmluZFpvb21CdXR0b25zKCk7XFxuICB9XFxuXFxuICB0aGlzLmNyZWF0ZVJlZ2lvbnMoKTtcXG4gIHRoaXMuY3JlYXRlTWFya2Vycyh0aGlzLnBhcmFtcy5tYXJrZXJzIHx8IHt9KTtcXG5cXG4gIHRoaXMudXBkYXRlU2l6ZSgpO1xcblxcbiAgaWYgKHRoaXMucGFyYW1zLmZvY3VzT24pIHtcXG4gICAgaWYgKHR5cGVvZiB0aGlzLnBhcmFtcy5mb2N1c09uID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgIHRoaXMucGFyYW1zLmZvY3VzT24gPSB7IHJlZ2lvbjogdGhpcy5wYXJhbXMuZm9jdXNPbiB9O1xcbiAgICB9IGVsc2UgaWYgKGp2bS4kLmlzQXJyYXkodGhpcy5wYXJhbXMuZm9jdXNPbikpIHtcXG4gICAgICB0aGlzLnBhcmFtcy5mb2N1c09uID0geyByZWdpb25zOiB0aGlzLnBhcmFtcy5mb2N1c09uIH07XFxuICAgIH1cXG4gICAgdGhpcy5zZXRGb2N1cyh0aGlzLnBhcmFtcy5mb2N1c09uKTtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLnBhcmFtcy5zZWxlY3RlZFJlZ2lvbnMpIHtcXG4gICAgdGhpcy5zZXRTZWxlY3RlZFJlZ2lvbnModGhpcy5wYXJhbXMuc2VsZWN0ZWRSZWdpb25zKTtcXG4gIH1cXG4gIGlmICh0aGlzLnBhcmFtcy5zZWxlY3RlZE1hcmtlcnMpIHtcXG4gICAgdGhpcy5zZXRTZWxlY3RlZE1hcmtlcnModGhpcy5wYXJhbXMuc2VsZWN0ZWRNYXJrZXJzKTtcXG4gIH1cXG5cXG4gIHRoaXMubGVnZW5kQ250SG9yaXpvbnRhbCA9IGp2bVxcbiAgICAuJChcXFwiPGRpdi8+XFxcIilcXG4gICAgLmFkZENsYXNzKFxcXCJqdmVjdG9ybWFwLWxlZ2VuZC1jbnQganZlY3Rvcm1hcC1sZWdlbmQtY250LWhcXFwiKTtcXG4gIHRoaXMubGVnZW5kQ250VmVydGljYWwgPSBqdm1cXG4gICAgLiQoXFxcIjxkaXYvPlxcXCIpXFxuICAgIC5hZGRDbGFzcyhcXFwianZlY3Rvcm1hcC1sZWdlbmQtY250IGp2ZWN0b3JtYXAtbGVnZW5kLWNudC12XFxcIik7XFxuICB0aGlzLmNvbnRhaW5lci5hcHBlbmQodGhpcy5sZWdlbmRDbnRIb3Jpem9udGFsKTtcXG4gIHRoaXMuY29udGFpbmVyLmFwcGVuZCh0aGlzLmxlZ2VuZENudFZlcnRpY2FsKTtcXG5cXG4gIGlmICh0aGlzLnBhcmFtcy5zZXJpZXMpIHtcXG4gICAgdGhpcy5jcmVhdGVTZXJpZXMoKTtcXG4gIH1cXG59O1xcblxcbmp2bS5NYXAucHJvdG90eXBlID0ge1xcbiAgdHJhbnNYOiAwLFxcbiAgdHJhbnNZOiAwLFxcbiAgc2NhbGU6IDEsXFxuICBiYXNlVHJhbnNYOiAwLFxcbiAgYmFzZVRyYW5zWTogMCxcXG4gIGJhc2VTY2FsZTogMSxcXG5cXG4gIHdpZHRoOiAwLFxcbiAgaGVpZ2h0OiAwLFxcblxcbiAgLyoqXFxuICAgKiBTZXQgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgbWFwLlxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJhY2tncm91bmRDb2xvciBCYWNrZ3JvdW5kIGNvbG9yIGluIENTUyBmb3JtYXQuXFxuICAgKi9cXG4gIHNldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24gKGJhY2tncm91bmRDb2xvcikge1xcbiAgICB0aGlzLmNvbnRhaW5lci5jc3MoXFxcImJhY2tncm91bmQtY29sb3JcXFwiLCBiYWNrZ3JvdW5kQ29sb3IpO1xcbiAgfSxcXG5cXG4gIHJlc2l6ZTogZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgY3VyQmFzZVNjYWxlID0gdGhpcy5iYXNlU2NhbGU7XFxuICAgIGlmICh0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQgPiB0aGlzLmRlZmF1bHRXaWR0aCAvIHRoaXMuZGVmYXVsdEhlaWdodCkge1xcbiAgICAgIHRoaXMuYmFzZVNjYWxlID0gdGhpcy5oZWlnaHQgLyB0aGlzLmRlZmF1bHRIZWlnaHQ7XFxuICAgICAgdGhpcy5iYXNlVHJhbnNYID1cXG4gICAgICAgIE1hdGguYWJzKHRoaXMud2lkdGggLSB0aGlzLmRlZmF1bHRXaWR0aCAqIHRoaXMuYmFzZVNjYWxlKSAvXFxuICAgICAgICAoMiAqIHRoaXMuYmFzZVNjYWxlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLmJhc2VTY2FsZSA9IHRoaXMud2lkdGggLyB0aGlzLmRlZmF1bHRXaWR0aDtcXG4gICAgICB0aGlzLmJhc2VUcmFuc1kgPVxcbiAgICAgICAgTWF0aC5hYnModGhpcy5oZWlnaHQgLSB0aGlzLmRlZmF1bHRIZWlnaHQgKiB0aGlzLmJhc2VTY2FsZSkgL1xcbiAgICAgICAgKDIgKiB0aGlzLmJhc2VTY2FsZSk7XFxuICAgIH1cXG4gICAgdGhpcy5zY2FsZSAqPSB0aGlzLmJhc2VTY2FsZSAvIGN1ckJhc2VTY2FsZTtcXG4gICAgdGhpcy50cmFuc1ggKj0gdGhpcy5iYXNlU2NhbGUgLyBjdXJCYXNlU2NhbGU7XFxuICAgIHRoaXMudHJhbnNZICo9IHRoaXMuYmFzZVNjYWxlIC8gY3VyQmFzZVNjYWxlO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogU3luY2hyb25pemUgdGhlIHNpemUgb2YgdGhlIG1hcCB3aXRoIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIuIFN1aXRhYmxlIGluIHNpdHVhdGlvbnMgd2hlcmUgdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciBpcyBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHkgb3IgY29udGFpbmVyIGlzIHNob3duIGFmdGVyIGl0IGJlY2FtZSB2aXNpYmxlLlxcbiAgICovXFxuICB1cGRhdGVTaXplOiBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci53aWR0aCgpO1xcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLmhlaWdodCgpO1xcbiAgICB0aGlzLnJlc2l6ZSgpO1xcbiAgICB0aGlzLmNhbnZhcy5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcXG4gICAgdGhpcy5hcHBseVRyYW5zZm9ybSgpO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogUmVzZXQgYWxsIHRoZSBzZXJpZXMgYW5kIHNob3cgdGhlIG1hcCB3aXRoIHRoZSBpbml0aWFsIHpvb20uXFxuICAgKi9cXG4gIHJlc2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBrZXksIGk7XFxuXFxuICAgIGZvciAoa2V5IGluIHRoaXMuc2VyaWVzKSB7XFxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VyaWVzW2tleV0ubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHRoaXMuc2VyaWVzW2tleV1baV0uY2xlYXIoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgdGhpcy5zY2FsZSA9IHRoaXMuYmFzZVNjYWxlO1xcbiAgICB0aGlzLnRyYW5zWCA9IHRoaXMuYmFzZVRyYW5zWDtcXG4gICAgdGhpcy50cmFuc1kgPSB0aGlzLmJhc2VUcmFuc1k7XFxuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0oKTtcXG4gIH0sXFxuXFxuICBhcHBseVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgbWF4VHJhbnNYLCBtYXhUcmFuc1ksIG1pblRyYW5zWCwgbWluVHJhbnNZO1xcblxcbiAgICBpZiAodGhpcy5kZWZhdWx0V2lkdGggKiB0aGlzLnNjYWxlIDw9IHRoaXMud2lkdGgpIHtcXG4gICAgICBtYXhUcmFuc1ggPVxcbiAgICAgICAgKHRoaXMud2lkdGggLSB0aGlzLmRlZmF1bHRXaWR0aCAqIHRoaXMuc2NhbGUpIC8gKDIgKiB0aGlzLnNjYWxlKTtcXG4gICAgICBtaW5UcmFuc1ggPVxcbiAgICAgICAgKHRoaXMud2lkdGggLSB0aGlzLmRlZmF1bHRXaWR0aCAqIHRoaXMuc2NhbGUpIC8gKDIgKiB0aGlzLnNjYWxlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBtYXhUcmFuc1ggPSAwO1xcbiAgICAgIG1pblRyYW5zWCA9ICh0aGlzLndpZHRoIC0gdGhpcy5kZWZhdWx0V2lkdGggKiB0aGlzLnNjYWxlKSAvIHRoaXMuc2NhbGU7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuZGVmYXVsdEhlaWdodCAqIHRoaXMuc2NhbGUgPD0gdGhpcy5oZWlnaHQpIHtcXG4gICAgICBtYXhUcmFuc1kgPVxcbiAgICAgICAgKHRoaXMuaGVpZ2h0IC0gdGhpcy5kZWZhdWx0SGVpZ2h0ICogdGhpcy5zY2FsZSkgLyAoMiAqIHRoaXMuc2NhbGUpO1xcbiAgICAgIG1pblRyYW5zWSA9XFxuICAgICAgICAodGhpcy5oZWlnaHQgLSB0aGlzLmRlZmF1bHRIZWlnaHQgKiB0aGlzLnNjYWxlKSAvICgyICogdGhpcy5zY2FsZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbWF4VHJhbnNZID0gMDtcXG4gICAgICBtaW5UcmFuc1kgPSAodGhpcy5oZWlnaHQgLSB0aGlzLmRlZmF1bHRIZWlnaHQgKiB0aGlzLnNjYWxlKSAvIHRoaXMuc2NhbGU7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMudHJhbnNZID4gbWF4VHJhbnNZKSB7XFxuICAgICAgdGhpcy50cmFuc1kgPSBtYXhUcmFuc1k7XFxuICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc1kgPCBtaW5UcmFuc1kpIHtcXG4gICAgICB0aGlzLnRyYW5zWSA9IG1pblRyYW5zWTtcXG4gICAgfVxcbiAgICBpZiAodGhpcy50cmFuc1ggPiBtYXhUcmFuc1gpIHtcXG4gICAgICB0aGlzLnRyYW5zWCA9IG1heFRyYW5zWDtcXG4gICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zWCA8IG1pblRyYW5zWCkge1xcbiAgICAgIHRoaXMudHJhbnNYID0gbWluVHJhbnNYO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuY2FudmFzLmFwcGx5VHJhbnNmb3JtUGFyYW1zKHRoaXMuc2NhbGUsIHRoaXMudHJhbnNYLCB0aGlzLnRyYW5zWSk7XFxuXFxuICAgIGlmICh0aGlzLm1hcmtlcnMpIHtcXG4gICAgICB0aGlzLnJlcG9zaXRpb25NYXJrZXJzKCk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5yZXBvc2l0aW9uTGFiZWxzKCk7XFxuXFxuICAgIHRoaXMuY29udGFpbmVyLnRyaWdnZXIoXFxcInZpZXdwb3J0Q2hhbmdlXFxcIiwgW1xcbiAgICAgIHRoaXMuc2NhbGUgLyB0aGlzLmJhc2VTY2FsZSxcXG4gICAgICB0aGlzLnRyYW5zWCxcXG4gICAgICB0aGlzLnRyYW5zWSxcXG4gICAgXSk7XFxuICB9LFxcblxcbiAgYmluZENvbnRhaW5lckV2ZW50czogZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgbW91c2VEb3duID0gZmFsc2UsXFxuICAgICAgb2xkUGFnZVgsXFxuICAgICAgb2xkUGFnZVksXFxuICAgICAgbWFwID0gdGhpcztcXG5cXG4gICAgaWYgKHRoaXMucGFyYW1zLnBhbk9uRHJhZykge1xcbiAgICAgIHRoaXMuY29udGFpbmVyXFxuICAgICAgICAubW91c2Vtb3ZlKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIGlmIChtb3VzZURvd24pIHtcXG4gICAgICAgICAgICBtYXAudHJhbnNYIC09IChvbGRQYWdlWCAtIGUucGFnZVgpIC8gbWFwLnNjYWxlO1xcbiAgICAgICAgICAgIG1hcC50cmFuc1kgLT0gKG9sZFBhZ2VZIC0gZS5wYWdlWSkgLyBtYXAuc2NhbGU7XFxuXFxuICAgICAgICAgICAgbWFwLmFwcGx5VHJhbnNmb3JtKCk7XFxuXFxuICAgICAgICAgICAgb2xkUGFnZVggPSBlLnBhZ2VYO1xcbiAgICAgICAgICAgIG9sZFBhZ2VZID0gZS5wYWdlWTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9KVxcbiAgICAgICAgLm1vdXNlZG93bihmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xcbiAgICAgICAgICBvbGRQYWdlWCA9IGUucGFnZVg7XFxuICAgICAgICAgIG9sZFBhZ2VZID0gZS5wYWdlWTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgdGhpcy5vbkNvbnRhaW5lck1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcXG4gICAgICB9O1xcbiAgICAgIGp2bS4kKFxcXCJib2R5XFxcIikubW91c2V1cCh0aGlzLm9uQ29udGFpbmVyTW91c2VVcCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMucGFyYW1zLnpvb21PblNjcm9sbCkge1xcbiAgICAgIHRoaXMuY29udGFpbmVyLm1vdXNld2hlZWwoZnVuY3Rpb24gKGV2ZW50LCBkZWx0YSwgZGVsdGFYLCBkZWx0YVkpIHtcXG4gICAgICAgIHZhciBvZmZzZXQgPSBqdm0uJChtYXAuY29udGFpbmVyKS5vZmZzZXQoKSxcXG4gICAgICAgICAgY2VudGVyWCA9IGV2ZW50LnBhZ2VYIC0gb2Zmc2V0LmxlZnQsXFxuICAgICAgICAgIGNlbnRlclkgPSBldmVudC5wYWdlWSAtIG9mZnNldC50b3AsXFxuICAgICAgICAgIHpvb21TdGVwID0gTWF0aC5wb3coXFxuICAgICAgICAgICAgMSArIG1hcC5wYXJhbXMuem9vbU9uU2Nyb2xsU3BlZWQgLyAxMDAwLFxcbiAgICAgICAgICAgIGV2ZW50LmRlbHRhRmFjdG9yICogZXZlbnQuZGVsdGFZLFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgbWFwLnRpcC5oaWRlKCk7XFxuXFxuICAgICAgICBtYXAuc2V0U2NhbGUobWFwLnNjYWxlICogem9vbVN0ZXAsIGNlbnRlclgsIGNlbnRlclkpO1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSxcXG5cXG4gIGJpbmRDb250YWluZXJUb3VjaEV2ZW50czogZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdG91Y2hTdGFydFNjYWxlLFxcbiAgICAgIHRvdWNoU3RhcnREaXN0YW5jZSxcXG4gICAgICBtYXAgPSB0aGlzLFxcbiAgICAgIHRvdWNoWCxcXG4gICAgICB0b3VjaFksXFxuICAgICAgY2VudGVyVG91Y2hYLFxcbiAgICAgIGNlbnRlclRvdWNoWSxcXG4gICAgICBsYXN0VG91Y2hlc0xlbmd0aCxcXG4gICAgICBoYW5kbGVUb3VjaEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciB0b3VjaGVzID0gZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXMsXFxuICAgICAgICAgIG9mZnNldCxcXG4gICAgICAgICAgc2NhbGUsXFxuICAgICAgICAgIHRyYW5zWE9sZCxcXG4gICAgICAgICAgdHJhbnNZT2xkO1xcblxcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcXFwidG91Y2hzdGFydFxcXCIpIHtcXG4gICAgICAgICAgbGFzdFRvdWNoZXNMZW5ndGggPSAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRvdWNoZXMubGVuZ3RoID09IDEpIHtcXG4gICAgICAgICAgaWYgKGxhc3RUb3VjaGVzTGVuZ3RoID09IDEpIHtcXG4gICAgICAgICAgICB0cmFuc1hPbGQgPSBtYXAudHJhbnNYO1xcbiAgICAgICAgICAgIHRyYW5zWU9sZCA9IG1hcC50cmFuc1k7XFxuICAgICAgICAgICAgbWFwLnRyYW5zWCAtPSAodG91Y2hYIC0gdG91Y2hlc1swXS5wYWdlWCkgLyBtYXAuc2NhbGU7XFxuICAgICAgICAgICAgbWFwLnRyYW5zWSAtPSAodG91Y2hZIC0gdG91Y2hlc1swXS5wYWdlWSkgLyBtYXAuc2NhbGU7XFxuICAgICAgICAgICAgbWFwLmFwcGx5VHJhbnNmb3JtKCk7XFxuICAgICAgICAgICAgbWFwLnRpcC5oaWRlKCk7XFxuICAgICAgICAgICAgaWYgKHRyYW5zWE9sZCAhPSBtYXAudHJhbnNYIHx8IHRyYW5zWU9sZCAhPSBtYXAudHJhbnNZKSB7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHRvdWNoWCA9IHRvdWNoZXNbMF0ucGFnZVg7XFxuICAgICAgICAgIHRvdWNoWSA9IHRvdWNoZXNbMF0ucGFnZVk7XFxuICAgICAgICB9IGVsc2UgaWYgKHRvdWNoZXMubGVuZ3RoID09IDIpIHtcXG4gICAgICAgICAgaWYgKGxhc3RUb3VjaGVzTGVuZ3RoID09IDIpIHtcXG4gICAgICAgICAgICBzY2FsZSA9XFxuICAgICAgICAgICAgICBNYXRoLnNxcnQoXFxuICAgICAgICAgICAgICAgIE1hdGgucG93KHRvdWNoZXNbMF0ucGFnZVggLSB0b3VjaGVzWzFdLnBhZ2VYLCAyKSArXFxuICAgICAgICAgICAgICAgICAgTWF0aC5wb3codG91Y2hlc1swXS5wYWdlWSAtIHRvdWNoZXNbMV0ucGFnZVksIDIpLFxcbiAgICAgICAgICAgICAgKSAvIHRvdWNoU3RhcnREaXN0YW5jZTtcXG4gICAgICAgICAgICBtYXAuc2V0U2NhbGUodG91Y2hTdGFydFNjYWxlICogc2NhbGUsIGNlbnRlclRvdWNoWCwgY2VudGVyVG91Y2hZKTtcXG4gICAgICAgICAgICBtYXAudGlwLmhpZGUoKTtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgb2Zmc2V0ID0ganZtLiQobWFwLmNvbnRhaW5lcikub2Zmc2V0KCk7XFxuICAgICAgICAgICAgaWYgKHRvdWNoZXNbMF0ucGFnZVggPiB0b3VjaGVzWzFdLnBhZ2VYKSB7XFxuICAgICAgICAgICAgICBjZW50ZXJUb3VjaFggPVxcbiAgICAgICAgICAgICAgICB0b3VjaGVzWzFdLnBhZ2VYICsgKHRvdWNoZXNbMF0ucGFnZVggLSB0b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGNlbnRlclRvdWNoWCA9XFxuICAgICAgICAgICAgICAgIHRvdWNoZXNbMF0ucGFnZVggKyAodG91Y2hlc1sxXS5wYWdlWCAtIHRvdWNoZXNbMF0ucGFnZVgpIC8gMjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHRvdWNoZXNbMF0ucGFnZVkgPiB0b3VjaGVzWzFdLnBhZ2VZKSB7XFxuICAgICAgICAgICAgICBjZW50ZXJUb3VjaFkgPVxcbiAgICAgICAgICAgICAgICB0b3VjaGVzWzFdLnBhZ2VZICsgKHRvdWNoZXNbMF0ucGFnZVkgLSB0b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGNlbnRlclRvdWNoWSA9XFxuICAgICAgICAgICAgICAgIHRvdWNoZXNbMF0ucGFnZVkgKyAodG91Y2hlc1sxXS5wYWdlWSAtIHRvdWNoZXNbMF0ucGFnZVkpIC8gMjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY2VudGVyVG91Y2hYIC09IG9mZnNldC5sZWZ0O1xcbiAgICAgICAgICAgIGNlbnRlclRvdWNoWSAtPSBvZmZzZXQudG9wO1xcbiAgICAgICAgICAgIHRvdWNoU3RhcnRTY2FsZSA9IG1hcC5zY2FsZTtcXG4gICAgICAgICAgICB0b3VjaFN0YXJ0RGlzdGFuY2UgPSBNYXRoLnNxcnQoXFxuICAgICAgICAgICAgICBNYXRoLnBvdyh0b3VjaGVzWzBdLnBhZ2VYIC0gdG91Y2hlc1sxXS5wYWdlWCwgMikgK1xcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyh0b3VjaGVzWzBdLnBhZ2VZIC0gdG91Y2hlc1sxXS5wYWdlWSwgMiksXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgbGFzdFRvdWNoZXNMZW5ndGggPSB0b3VjaGVzLmxlbmd0aDtcXG4gICAgICB9O1xcblxcbiAgICBqdm0uJCh0aGlzLmNvbnRhaW5lcikuYmluZChcXFwidG91Y2hzdGFydFxcXCIsIGhhbmRsZVRvdWNoRXZlbnQpO1xcbiAgICBqdm0uJCh0aGlzLmNvbnRhaW5lcikuYmluZChcXFwidG91Y2htb3ZlXFxcIiwgaGFuZGxlVG91Y2hFdmVudCk7XFxuICB9LFxcblxcbiAgYmluZENvbnRhaW5lclBvaW50ZXJFdmVudHM6IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIG1hcCA9IHRoaXMsXFxuICAgICAgZ2VzdHVyZSA9IG5ldyBNU0dlc3R1cmUoKSxcXG4gICAgICBlbGVtZW50ID0gdGhpcy5jb250YWluZXJbMF0sXFxuICAgICAgaGFuZGxlUG9pbnRlckRvd25FdmVudCA9IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBnZXN0dXJlLmFkZFBvaW50ZXIoZS5wb2ludGVySWQpO1xcbiAgICAgIH0sXFxuICAgICAgaGFuZGxlR2VzdHVyZUV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciBvZmZzZXQsIHNjYWxlLCB0cmFuc1hPbGQsIHRyYW5zWU9sZDtcXG5cXG4gICAgICAgIGlmIChlLnRyYW5zbGF0aW9uWCAhPSAwIHx8IGUudHJhbnNsYXRpb25ZICE9IDApIHtcXG4gICAgICAgICAgdHJhbnNYT2xkID0gbWFwLnRyYW5zWDtcXG4gICAgICAgICAgdHJhbnNZT2xkID0gbWFwLnRyYW5zWTtcXG4gICAgICAgICAgbWFwLnRyYW5zWCArPSBlLnRyYW5zbGF0aW9uWCAvIG1hcC5zY2FsZTtcXG4gICAgICAgICAgbWFwLnRyYW5zWSArPSBlLnRyYW5zbGF0aW9uWSAvIG1hcC5zY2FsZTtcXG4gICAgICAgICAgbWFwLmFwcGx5VHJhbnNmb3JtKCk7XFxuICAgICAgICAgIG1hcC50aXAuaGlkZSgpO1xcbiAgICAgICAgICBpZiAodHJhbnNYT2xkICE9IG1hcC50cmFuc1ggfHwgdHJhbnNZT2xkICE9IG1hcC50cmFuc1kpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChlLnNjYWxlICE9IDEpIHtcXG4gICAgICAgICAgbWFwLnNldFNjYWxlKG1hcC5zY2FsZSAqIGUuc2NhbGUsIGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcXG4gICAgICAgICAgbWFwLnRpcC5oaWRlKCk7XFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICBnZXN0dXJlLnRhcmdldCA9IGVsZW1lbnQ7XFxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcXFwiTVNHZXN0dXJlQ2hhbmdlXFxcIiwgaGFuZGxlR2VzdHVyZUV2ZW50LCBmYWxzZSk7XFxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcXFwicG9pbnRlcmRvd25cXFwiLCBoYW5kbGVQb2ludGVyRG93bkV2ZW50LCBmYWxzZSk7XFxuICB9LFxcblxcbiAgYmluZEVsZW1lbnRFdmVudHM6IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIG1hcCA9IHRoaXMsXFxuICAgICAgcGFnZVgsXFxuICAgICAgcGFnZVksXFxuICAgICAgbW91c2VNb3ZlZDtcXG5cXG4gICAgdGhpcy5jb250YWluZXIubW91c2Vtb3ZlKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgaWYgKE1hdGguYWJzKHBhZ2VYIC0gZS5wYWdlWCkgKyBNYXRoLmFicyhwYWdlWSAtIGUucGFnZVkpID4gMikge1xcbiAgICAgICAgbW91c2VNb3ZlZCA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgLyogQ2FuIG5vdCB1c2UgY29tbW9uIGNsYXNzIHNlbGVjdG9ycyBoZXJlIGJlY2F1c2Ugb2YgdGhlIGJ1ZyBpbiBqUXVlcnlcXG4gICAgICAgU1ZHIGhhbmRsaW5nLCB1c2Ugd2l0aCBjYXV0aW9uLiAqL1xcbiAgICB0aGlzLmNvbnRhaW5lci5kZWxlZ2F0ZShcXG4gICAgICBcXFwiW2NsYXNzfj0nanZlY3Rvcm1hcC1lbGVtZW50J11cXFwiLFxcbiAgICAgIFxcXCJtb3VzZW92ZXIgbW91c2VvdXRcXFwiLFxcbiAgICAgIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICB2YXIgYmFzZVZhbCA9XFxuICAgICAgICAgICAganZtLiQodGhpcykuYXR0cihcXFwiY2xhc3NcXFwiKS5iYXNlVmFsIHx8IGp2bS4kKHRoaXMpLmF0dHIoXFxcImNsYXNzXFxcIiksXFxuICAgICAgICAgIHR5cGUgPVxcbiAgICAgICAgICAgIGJhc2VWYWwuaW5kZXhPZihcXFwianZlY3Rvcm1hcC1yZWdpb25cXFwiKSA9PT0gLTEgPyBcXFwibWFya2VyXFxcIiA6IFxcXCJyZWdpb25cXFwiLFxcbiAgICAgICAgICBjb2RlID1cXG4gICAgICAgICAgICB0eXBlID09IFxcXCJyZWdpb25cXFwiXFxuICAgICAgICAgICAgICA/IGp2bS4kKHRoaXMpLmF0dHIoXFxcImRhdGEtY29kZVxcXCIpXFxuICAgICAgICAgICAgICA6IGp2bS4kKHRoaXMpLmF0dHIoXFxcImRhdGEtaW5kZXhcXFwiKSxcXG4gICAgICAgICAgZWxlbWVudCA9XFxuICAgICAgICAgICAgdHlwZSA9PSBcXFwicmVnaW9uXFxcIlxcbiAgICAgICAgICAgICAgPyBtYXAucmVnaW9uc1tjb2RlXS5lbGVtZW50XFxuICAgICAgICAgICAgICA6IG1hcC5tYXJrZXJzW2NvZGVdLmVsZW1lbnQsXFxuICAgICAgICAgIHRpcFRleHQgPVxcbiAgICAgICAgICAgIHR5cGUgPT0gXFxcInJlZ2lvblxcXCJcXG4gICAgICAgICAgICAgID8gbWFwLm1hcERhdGEucGF0aHNbY29kZV0ubmFtZVxcbiAgICAgICAgICAgICAgOiBtYXAubWFya2Vyc1tjb2RlXS5jb25maWcubmFtZSB8fCBcXFwiXFxcIixcXG4gICAgICAgICAgdGlwU2hvd0V2ZW50ID0ganZtLiQuRXZlbnQodHlwZSArIFxcXCJUaXBTaG93Lmp2ZWN0b3JtYXBcXFwiKSxcXG4gICAgICAgICAgb3ZlckV2ZW50ID0ganZtLiQuRXZlbnQodHlwZSArIFxcXCJPdmVyLmp2ZWN0b3JtYXBcXFwiKTtcXG5cXG4gICAgICAgIGlmIChlLnR5cGUgPT0gXFxcIm1vdXNlb3ZlclxcXCIpIHtcXG4gICAgICAgICAgbWFwLmNvbnRhaW5lci50cmlnZ2VyKG92ZXJFdmVudCwgW2NvZGVdKTtcXG4gICAgICAgICAgaWYgKCFvdmVyRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG4gICAgICAgICAgICBlbGVtZW50LnNldEhvdmVyZWQodHJ1ZSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbWFwLnRpcC50ZXh0KHRpcFRleHQpO1xcbiAgICAgICAgICBtYXAuY29udGFpbmVyLnRyaWdnZXIodGlwU2hvd0V2ZW50LCBbbWFwLnRpcCwgY29kZV0pO1xcbiAgICAgICAgICBpZiAoIXRpcFNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xcbiAgICAgICAgICAgIG1hcC50aXAuc2hvdygpO1xcbiAgICAgICAgICAgIG1hcC50aXBXaWR0aCA9IG1hcC50aXAud2lkdGgoKTtcXG4gICAgICAgICAgICBtYXAudGlwSGVpZ2h0ID0gbWFwLnRpcC5oZWlnaHQoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZWxlbWVudC5zZXRIb3ZlcmVkKGZhbHNlKTtcXG4gICAgICAgICAgbWFwLnRpcC5oaWRlKCk7XFxuICAgICAgICAgIG1hcC5jb250YWluZXIudHJpZ2dlcih0eXBlICsgXFxcIk91dC5qdmVjdG9ybWFwXFxcIiwgW2NvZGVdKTtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICApO1xcblxcbiAgICAvKiBDYW4gbm90IHVzZSBjb21tb24gY2xhc3Mgc2VsZWN0b3JzIGhlcmUgYmVjYXVzZSBvZiB0aGUgYnVnIGluIGpRdWVyeVxcbiAgICAgICBTVkcgaGFuZGxpbmcsIHVzZSB3aXRoIGNhdXRpb24uICovXFxuICAgIHRoaXMuY29udGFpbmVyLmRlbGVnYXRlKFxcbiAgICAgIFxcXCJbY2xhc3N+PSdqdmVjdG9ybWFwLWVsZW1lbnQnXVxcXCIsXFxuICAgICAgXFxcIm1vdXNlZG93blxcXCIsXFxuICAgICAgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHBhZ2VYID0gZS5wYWdlWDtcXG4gICAgICAgIHBhZ2VZID0gZS5wYWdlWTtcXG4gICAgICAgIG1vdXNlTW92ZWQgPSBmYWxzZTtcXG4gICAgICB9LFxcbiAgICApO1xcblxcbiAgICAvKiBDYW4gbm90IHVzZSBjb21tb24gY2xhc3Mgc2VsZWN0b3JzIGhlcmUgYmVjYXVzZSBvZiB0aGUgYnVnIGluIGpRdWVyeVxcbiAgICAgICBTVkcgaGFuZGxpbmcsIHVzZSB3aXRoIGNhdXRpb24uICovXFxuICAgIHRoaXMuY29udGFpbmVyLmRlbGVnYXRlKFxcbiAgICAgIFxcXCJbY2xhc3N+PSdqdmVjdG9ybWFwLWVsZW1lbnQnXVxcXCIsXFxuICAgICAgXFxcIm1vdXNldXBcXFwiLFxcbiAgICAgIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiYXNlVmFsID0ganZtLiQodGhpcykuYXR0cihcXFwiY2xhc3NcXFwiKS5iYXNlVmFsXFxuICAgICAgICAgICAgPyBqdm0uJCh0aGlzKS5hdHRyKFxcXCJjbGFzc1xcXCIpLmJhc2VWYWxcXG4gICAgICAgICAgICA6IGp2bS4kKHRoaXMpLmF0dHIoXFxcImNsYXNzXFxcIiksXFxuICAgICAgICAgIHR5cGUgPVxcbiAgICAgICAgICAgIGJhc2VWYWwuaW5kZXhPZihcXFwianZlY3Rvcm1hcC1yZWdpb25cXFwiKSA9PT0gLTEgPyBcXFwibWFya2VyXFxcIiA6IFxcXCJyZWdpb25cXFwiLFxcbiAgICAgICAgICBjb2RlID1cXG4gICAgICAgICAgICB0eXBlID09IFxcXCJyZWdpb25cXFwiXFxuICAgICAgICAgICAgICA/IGp2bS4kKHRoaXMpLmF0dHIoXFxcImRhdGEtY29kZVxcXCIpXFxuICAgICAgICAgICAgICA6IGp2bS4kKHRoaXMpLmF0dHIoXFxcImRhdGEtaW5kZXhcXFwiKSxcXG4gICAgICAgICAgY2xpY2tFdmVudCA9IGp2bS4kLkV2ZW50KHR5cGUgKyBcXFwiQ2xpY2suanZlY3Rvcm1hcFxcXCIpLFxcbiAgICAgICAgICBlbGVtZW50ID1cXG4gICAgICAgICAgICB0eXBlID09IFxcXCJyZWdpb25cXFwiXFxuICAgICAgICAgICAgICA/IG1hcC5yZWdpb25zW2NvZGVdLmVsZW1lbnRcXG4gICAgICAgICAgICAgIDogbWFwLm1hcmtlcnNbY29kZV0uZWxlbWVudDtcXG5cXG4gICAgICAgIGlmICghbW91c2VNb3ZlZCkge1xcbiAgICAgICAgICBtYXAuY29udGFpbmVyLnRyaWdnZXIoY2xpY2tFdmVudCwgW2NvZGVdKTtcXG4gICAgICAgICAgaWYgKFxcbiAgICAgICAgICAgICh0eXBlID09PSBcXFwicmVnaW9uXFxcIiAmJiBtYXAucGFyYW1zLnJlZ2lvbnNTZWxlY3RhYmxlKSB8fFxcbiAgICAgICAgICAgICh0eXBlID09PSBcXFwibWFya2VyXFxcIiAmJiBtYXAucGFyYW1zLm1hcmtlcnNTZWxlY3RhYmxlKVxcbiAgICAgICAgICApIHtcXG4gICAgICAgICAgICBpZiAoIWNsaWNrRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG4gICAgICAgICAgICAgIGlmIChtYXAucGFyYW1zW3R5cGUgKyBcXFwic1NlbGVjdGFibGVPbmVcXFwiXSkge1xcbiAgICAgICAgICAgICAgICBtYXAuY2xlYXJTZWxlY3RlZCh0eXBlICsgXFxcInNcXFwiKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGVsZW1lbnQuc2V0U2VsZWN0ZWQoIWVsZW1lbnQuaXNTZWxlY3RlZCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgKTtcXG4gIH0sXFxuXFxuICBiaW5kWm9vbUJ1dHRvbnM6IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIG1hcCA9IHRoaXM7XFxuXFxuICAgIGp2bVxcbiAgICAgIC4kKFxcXCI8ZGl2Lz5cXFwiKVxcbiAgICAgIC5hZGRDbGFzcyhcXFwianZlY3Rvcm1hcC16b29taW5cXFwiKVxcbiAgICAgIC50ZXh0KFxcXCIrXFxcIilcXG4gICAgICAuYXBwZW5kVG8odGhpcy5jb250YWluZXIpO1xcbiAgICBqdm1cXG4gICAgICAuJChcXFwiPGRpdi8+XFxcIilcXG4gICAgICAuYWRkQ2xhc3MoXFxcImp2ZWN0b3JtYXAtem9vbW91dFxcXCIpXFxuICAgICAgLmh0bWwoXFxcIiYjeDIyMTI7XFxcIilcXG4gICAgICAuYXBwZW5kVG8odGhpcy5jb250YWluZXIpO1xcblxcbiAgICB0aGlzLmNvbnRhaW5lci5maW5kKFxcXCIuanZlY3Rvcm1hcC16b29taW5cXFwiKS5jbGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgbWFwLnNldFNjYWxlKFxcbiAgICAgICAgbWFwLnNjYWxlICogbWFwLnBhcmFtcy56b29tU3RlcCxcXG4gICAgICAgIG1hcC53aWR0aCAvIDIsXFxuICAgICAgICBtYXAuaGVpZ2h0IC8gMixcXG4gICAgICAgIGZhbHNlLFxcbiAgICAgICAgbWFwLnBhcmFtcy56b29tQW5pbWF0ZSxcXG4gICAgICApO1xcbiAgICB9KTtcXG4gICAgdGhpcy5jb250YWluZXIuZmluZChcXFwiLmp2ZWN0b3JtYXAtem9vbW91dFxcXCIpLmNsaWNrKGZ1bmN0aW9uICgpIHtcXG4gICAgICBtYXAuc2V0U2NhbGUoXFxuICAgICAgICBtYXAuc2NhbGUgLyBtYXAucGFyYW1zLnpvb21TdGVwLFxcbiAgICAgICAgbWFwLndpZHRoIC8gMixcXG4gICAgICAgIG1hcC5oZWlnaHQgLyAyLFxcbiAgICAgICAgZmFsc2UsXFxuICAgICAgICBtYXAucGFyYW1zLnpvb21BbmltYXRlLFxcbiAgICAgICk7XFxuICAgIH0pO1xcbiAgfSxcXG5cXG4gIGNyZWF0ZVRpcDogZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgbWFwID0gdGhpcztcXG5cXG4gICAgdGhpcy50aXAgPSBqdm1cXG4gICAgICAuJChcXFwiPGRpdi8+XFxcIilcXG4gICAgICAuYWRkQ2xhc3MoXFxcImp2ZWN0b3JtYXAtdGlwXFxcIilcXG4gICAgICAuYXBwZW5kVG8oanZtLiQoXFxcImJvZHlcXFwiKSk7XFxuXFxuICAgIHRoaXMuY29udGFpbmVyLm1vdXNlbW92ZShmdW5jdGlvbiAoZSkge1xcbiAgICAgIHZhciBsZWZ0ID0gZS5wYWdlWCAtIDE1IC0gbWFwLnRpcFdpZHRoLFxcbiAgICAgICAgdG9wID0gZS5wYWdlWSAtIDE1IC0gbWFwLnRpcEhlaWdodDtcXG5cXG4gICAgICBpZiAobGVmdCA8IDUpIHtcXG4gICAgICAgIGxlZnQgPSBlLnBhZ2VYICsgMTU7XFxuICAgICAgfVxcbiAgICAgIGlmICh0b3AgPCA1KSB7XFxuICAgICAgICB0b3AgPSBlLnBhZ2VZICsgMTU7XFxuICAgICAgfVxcblxcbiAgICAgIG1hcC50aXAuY3NzKHtcXG4gICAgICAgIGxlZnQ6IGxlZnQsXFxuICAgICAgICB0b3A6IHRvcCxcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuICB9LFxcblxcbiAgc2V0U2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgYW5jaG9yWCwgYW5jaG9yWSwgaXNDZW50ZXJlZCwgYW5pbWF0ZSkge1xcbiAgICB2YXIgdmlld3BvcnRDaGFuZ2VFdmVudCA9IGp2bS4kLkV2ZW50KFxcXCJ6b29tLmp2ZWN0b3JtYXBcXFwiKSxcXG4gICAgICBpbnRlcnZhbCxcXG4gICAgICB0aGF0ID0gdGhpcyxcXG4gICAgICBpID0gMCxcXG4gICAgICBjb3VudCA9IE1hdGguYWJzKFxcbiAgICAgICAgTWF0aC5yb3VuZCgoKHNjYWxlIC0gdGhpcy5zY2FsZSkgKiA2MCkgLyBNYXRoLm1heChzY2FsZSwgdGhpcy5zY2FsZSkpLFxcbiAgICAgICksXFxuICAgICAgc2NhbGVTdGFydCxcXG4gICAgICBzY2FsZURpZmYsXFxuICAgICAgdHJhbnNYU3RhcnQsXFxuICAgICAgdHJhbnNYRGlmZixcXG4gICAgICB0cmFuc1lTdGFydCxcXG4gICAgICB0cmFuc1lEaWZmLFxcbiAgICAgIHRyYW5zWCxcXG4gICAgICB0cmFuc1ksXFxuICAgICAgZGVmZXJyZWQgPSBuZXcganZtLiQuRGVmZXJyZWQoKTtcXG5cXG4gICAgaWYgKHNjYWxlID4gdGhpcy5wYXJhbXMuem9vbU1heCAqIHRoaXMuYmFzZVNjYWxlKSB7XFxuICAgICAgc2NhbGUgPSB0aGlzLnBhcmFtcy56b29tTWF4ICogdGhpcy5iYXNlU2NhbGU7XFxuICAgIH0gZWxzZSBpZiAoc2NhbGUgPCB0aGlzLnBhcmFtcy56b29tTWluICogdGhpcy5iYXNlU2NhbGUpIHtcXG4gICAgICBzY2FsZSA9IHRoaXMucGFyYW1zLnpvb21NaW4gKiB0aGlzLmJhc2VTY2FsZTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIGFuY2hvclggIT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgdHlwZW9mIGFuY2hvclkgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICBjb25zdCB6b29tU3RlcCA9IHNjYWxlIC8gdGhpcy5zY2FsZTtcXG4gICAgICBpZiAoaXNDZW50ZXJlZCkge1xcbiAgICAgICAgdHJhbnNYID1cXG4gICAgICAgICAgYW5jaG9yWCArXFxuICAgICAgICAgICh0aGlzLmRlZmF1bHRXaWR0aCAqICh0aGlzLndpZHRoIC8gKHRoaXMuZGVmYXVsdFdpZHRoICogc2NhbGUpKSkgLyAyO1xcbiAgICAgICAgdHJhbnNZID1cXG4gICAgICAgICAgYW5jaG9yWSArXFxuICAgICAgICAgICh0aGlzLmRlZmF1bHRIZWlnaHQgKiAodGhpcy5oZWlnaHQgLyAodGhpcy5kZWZhdWx0SGVpZ2h0ICogc2NhbGUpKSkgL1xcbiAgICAgICAgICAgIDI7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRyYW5zWCA9IHRoaXMudHJhbnNYIC0gKCh6b29tU3RlcCAtIDEpIC8gc2NhbGUpICogYW5jaG9yWDtcXG4gICAgICAgIHRyYW5zWSA9IHRoaXMudHJhbnNZIC0gKCh6b29tU3RlcCAtIDEpIC8gc2NhbGUpICogYW5jaG9yWTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGFuaW1hdGUgJiYgY291bnQgPiAwKSB7XFxuICAgICAgc2NhbGVTdGFydCA9IHRoaXMuc2NhbGU7XFxuICAgICAgc2NhbGVEaWZmID0gKHNjYWxlIC0gc2NhbGVTdGFydCkgLyBjb3VudDtcXG4gICAgICB0cmFuc1hTdGFydCA9IHRoaXMudHJhbnNYICogdGhpcy5zY2FsZTtcXG4gICAgICB0cmFuc1lTdGFydCA9IHRoaXMudHJhbnNZICogdGhpcy5zY2FsZTtcXG4gICAgICB0cmFuc1hEaWZmID0gKHRyYW5zWCAqIHNjYWxlIC0gdHJhbnNYU3RhcnQpIC8gY291bnQ7XFxuICAgICAgdHJhbnNZRGlmZiA9ICh0cmFuc1kgKiBzY2FsZSAtIHRyYW5zWVN0YXJ0KSAvIGNvdW50O1xcbiAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaSArPSAxO1xcbiAgICAgICAgdGhhdC5zY2FsZSA9IHNjYWxlU3RhcnQgKyBzY2FsZURpZmYgKiBpO1xcbiAgICAgICAgdGhhdC50cmFuc1ggPSAodHJhbnNYU3RhcnQgKyB0cmFuc1hEaWZmICogaSkgLyB0aGF0LnNjYWxlO1xcbiAgICAgICAgdGhhdC50cmFuc1kgPSAodHJhbnNZU3RhcnQgKyB0cmFuc1lEaWZmICogaSkgLyB0aGF0LnNjYWxlO1xcbiAgICAgICAgdGhhdC5hcHBseVRyYW5zZm9ybSgpO1xcbiAgICAgICAgaWYgKGkgPT0gY291bnQpIHtcXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XFxuICAgICAgICAgIHRoYXQuY29udGFpbmVyLnRyaWdnZXIodmlld3BvcnRDaGFuZ2VFdmVudCwgW3NjYWxlIC8gdGhhdC5iYXNlU2NhbGVdKTtcXG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIDEwKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLnRyYW5zWCA9IHRyYW5zWDtcXG4gICAgICB0aGlzLnRyYW5zWSA9IHRyYW5zWTtcXG4gICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XFxuICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybSgpO1xcbiAgICAgIHRoaXMuY29udGFpbmVyLnRyaWdnZXIodmlld3BvcnRDaGFuZ2VFdmVudCwgW3NjYWxlIC8gdGhpcy5iYXNlU2NhbGVdKTtcXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGRlZmVycmVkO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogU2V0IHRoZSBtYXAncyB2aWV3cG9ydCB0byB0aGUgc3BlY2lmaWMgcG9pbnQgYW5kIHNldCB6b29tIG9mIHRoZSBtYXAgdG8gdGhlIHNwZWNpZmljIGxldmVsLiBQb2ludCBhbmQgem9vbSBsZXZlbCBjb3VsZCBiZSBkZWZpbmVkIGluIHR3byB3YXlzOiB1c2luZyB0aGUgY29kZSBvZiBzb21lIHJlZ2lvbiB0byBmb2N1cyBvbiBvciBhIGNlbnRyYWwgcG9pbnQgYW5kIHpvb20gbGV2ZWwgYXMgbnVtYmVycy5cXG4gICAqIEBwYXJhbSBUaGlzIG1ldGhvZCB0YWtlcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGFzIHRoZSBzaW5nbGUgYXJndW1lbnQuIFRoZSBvcHRpb25zIHBhc3NlZCB0byBpdCBhcmUgdGhlIGZvbGxvd2luZzpcXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcy5yZWdpb25zIEFycmF5IG9mIHJlZ2lvbiBjb2RlcyB0byB6b29tIHRvLlxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5yZWdpb24gUmVnaW9uIGNvZGUgdG8gem9vbSB0by5cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuc2NhbGUgTWFwIHNjYWxlIHRvIHNldC5cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubGF0IExhdGl0dWRlIHRvIHNldCB2aWV3cG9ydCB0by5cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubG5nIExvbmdpdHVkZSB0byBzZXQgdmlld3BvcnQgdG8uXFxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnggTnVtYmVyIGZyb20gMCB0byAxIHNwZWNpZnlpbmcgdGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJhbCBwb2ludCBvZiB0aGUgdmlld3BvcnQuXFxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnkgTnVtYmVyIGZyb20gMCB0byAxIHNwZWNpZnlpbmcgdGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyYWwgcG9pbnQgb2YgdGhlIHZpZXdwb3J0LlxcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuYW5pbWF0ZSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gYW5pbWF0ZSB0aGUgc2NhbGUgY2hhbmdlIGFuZCB0cmFuc2l0aW9uLlxcbiAgICovXFxuICBzZXRGb2N1czogZnVuY3Rpb24gKGNvbmZpZykge1xcbiAgICB2YXIgYmJveCwgaXRlbUJib3gsIG5ld0Jib3gsIGNvZGVzLCBpLCBwb2ludDtcXG5cXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xcblxcbiAgICBpZiAoY29uZmlnLnJlZ2lvbikge1xcbiAgICAgIGNvZGVzID0gW2NvbmZpZy5yZWdpb25dO1xcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5yZWdpb25zKSB7XFxuICAgICAgY29kZXMgPSBjb25maWcucmVnaW9ucztcXG4gICAgfVxcblxcbiAgICBpZiAoY29kZXMpIHtcXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmICh0aGlzLnJlZ2lvbnNbY29kZXNbaV1dKSB7XFxuICAgICAgICAgIGl0ZW1CYm94ID0gdGhpcy5yZWdpb25zW2NvZGVzW2ldXS5lbGVtZW50LnNoYXBlLmdldEJCb3goKTtcXG4gICAgICAgICAgaWYgKGl0ZW1CYm94KSB7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiYm94ID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgICBiYm94ID0gaXRlbUJib3g7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIG5ld0Jib3ggPSB7XFxuICAgICAgICAgICAgICAgIHg6IE1hdGgubWluKGJib3gueCwgaXRlbUJib3gueCksXFxuICAgICAgICAgICAgICAgIHk6IE1hdGgubWluKGJib3gueSwgaXRlbUJib3gueSksXFxuICAgICAgICAgICAgICAgIHdpZHRoOlxcbiAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGJib3gueCArIGJib3gud2lkdGgsIGl0ZW1CYm94LnggKyBpdGVtQmJveC53aWR0aCkgLVxcbiAgICAgICAgICAgICAgICAgIE1hdGgubWluKGJib3gueCwgaXRlbUJib3gueCksXFxuICAgICAgICAgICAgICAgIGhlaWdodDpcXG4gICAgICAgICAgICAgICAgICBNYXRoLm1heChiYm94LnkgKyBiYm94LmhlaWdodCwgaXRlbUJib3gueSArIGl0ZW1CYm94LmhlaWdodCkgLVxcbiAgICAgICAgICAgICAgICAgIE1hdGgubWluKGJib3gueSwgaXRlbUJib3gueSksXFxuICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgYmJveCA9IG5ld0Jib3g7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzLnNldFNjYWxlKFxcbiAgICAgICAgTWF0aC5taW4odGhpcy53aWR0aCAvIGJib3gud2lkdGgsIHRoaXMuaGVpZ2h0IC8gYmJveC5oZWlnaHQpLFxcbiAgICAgICAgLShiYm94LnggKyBiYm94LndpZHRoIC8gMiksXFxuICAgICAgICAtKGJib3gueSArIGJib3guaGVpZ2h0IC8gMiksXFxuICAgICAgICB0cnVlLFxcbiAgICAgICAgY29uZmlnLmFuaW1hdGUsXFxuICAgICAgKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoY29uZmlnLmxhdCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy5sbmcgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgcG9pbnQgPSB0aGlzLmxhdExuZ1RvUG9pbnQoY29uZmlnLmxhdCwgY29uZmlnLmxuZyk7XFxuICAgICAgICBjb25maWcueCA9IHRoaXMudHJhbnNYIC0gcG9pbnQueCAvIHRoaXMuc2NhbGU7XFxuICAgICAgICBjb25maWcueSA9IHRoaXMudHJhbnNZIC0gcG9pbnQueSAvIHRoaXMuc2NhbGU7XFxuICAgICAgfSBlbHNlIGlmIChjb25maWcueCAmJiBjb25maWcueSkge1xcbiAgICAgICAgY29uZmlnLnggKj0gLXRoaXMuZGVmYXVsdFdpZHRoO1xcbiAgICAgICAgY29uZmlnLnkgKj0gLXRoaXMuZGVmYXVsdEhlaWdodDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRoaXMuc2V0U2NhbGUoXFxuICAgICAgICBjb25maWcuc2NhbGUgKiB0aGlzLmJhc2VTY2FsZSxcXG4gICAgICAgIGNvbmZpZy54LFxcbiAgICAgICAgY29uZmlnLnksXFxuICAgICAgICB0cnVlLFxcbiAgICAgICAgY29uZmlnLmFuaW1hdGUsXFxuICAgICAgKTtcXG4gICAgfVxcbiAgfSxcXG5cXG4gIGdldFNlbGVjdGVkOiBmdW5jdGlvbiAodHlwZSkge1xcbiAgICB2YXIga2V5LFxcbiAgICAgIHNlbGVjdGVkID0gW107XFxuXFxuICAgIGZvciAoa2V5IGluIHRoaXNbdHlwZV0pIHtcXG4gICAgICBpZiAodGhpc1t0eXBlXVtrZXldLmVsZW1lbnQuaXNTZWxlY3RlZCkge1xcbiAgICAgICAgc2VsZWN0ZWQucHVzaChrZXkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gc2VsZWN0ZWQ7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBSZXR1cm4gdGhlIGNvZGVzIG9mIGN1cnJlbnRseSBzZWxlY3RlZCByZWdpb25zLlxcbiAgICogQHJldHVybnMge0FycmF5fVxcbiAgICovXFxuICBnZXRTZWxlY3RlZFJlZ2lvbnM6IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0ZWQoXFxcInJlZ2lvbnNcXFwiKTtcXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIFJldHVybiB0aGUgY29kZXMgb2YgY3VycmVudGx5IHNlbGVjdGVkIG1hcmtlcnMuXFxuICAgKiBAcmV0dXJucyB7QXJyYXl9XFxuICAgKi9cXG4gIGdldFNlbGVjdGVkTWFya2VyczogZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3RlZChcXFwibWFya2Vyc1xcXCIpO1xcbiAgfSxcXG5cXG4gIHNldFNlbGVjdGVkOiBmdW5jdGlvbiAodHlwZSwga2V5cykge1xcbiAgICB2YXIgaTtcXG5cXG4gICAgaWYgKHR5cGVvZiBrZXlzICE9IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAga2V5cyA9IFtrZXlzXTtcXG4gICAgfVxcblxcbiAgICBpZiAoanZtLiQuaXNBcnJheShrZXlzKSkge1xcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB0aGlzW3R5cGVdW2tleXNbaV1dLmVsZW1lbnQuc2V0U2VsZWN0ZWQodHJ1ZSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAoaSBpbiBrZXlzKSB7XFxuICAgICAgICB0aGlzW3R5cGVdW2ldLmVsZW1lbnQuc2V0U2VsZWN0ZWQoISFrZXlzW2ldKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIFNldCBvciByZW1vdmUgc2VsZWN0ZWQgc3RhdGUgZm9yIHRoZSByZWdpb25zLlxcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8T2JqZWN0fSBrZXlzIElmIDxjb2RlPlN0cmluZzwvY29kZT4gb3IgPGNvZGU+QXJyYXk8L2NvZGU+IHRoZSByZWdpb24ocykgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBjb2RlKHMpIHdpbGwgYmUgc2VsZWN0ZWQuIElmIDxjb2RlPk9iamVjdDwvY29kZT4gd2FzIHByb3ZpZGVkIGl0cyBrZXlzIGFyZSAgY29kZXMgb2YgcmVnaW9ucywgc3RhdGUgb2Ygd2hpY2ggc2hvdWxkIGJlIGNoYW5nZWQuIFNlbGVjdGVkIHN0YXRlIHdpbGwgYmUgc2V0IGlmIHZhbHVlIGlzIHRydWUsIHJlbW92ZWQgb3RoZXJ3aXNlLlxcbiAgICovXFxuICBzZXRTZWxlY3RlZFJlZ2lvbnM6IGZ1bmN0aW9uIChrZXlzKSB7XFxuICAgIHRoaXMuc2V0U2VsZWN0ZWQoXFxcInJlZ2lvbnNcXFwiLCBrZXlzKTtcXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIFNldCBvciByZW1vdmUgc2VsZWN0ZWQgc3RhdGUgZm9yIHRoZSBtYXJrZXJzLlxcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8T2JqZWN0fSBrZXlzIElmIDxjb2RlPlN0cmluZzwvY29kZT4gb3IgPGNvZGU+QXJyYXk8L2NvZGU+IHRoZSBtYXJrZXIocykgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBjb2RlKHMpIHdpbGwgYmUgc2VsZWN0ZWQuIElmIDxjb2RlPk9iamVjdDwvY29kZT4gd2FzIHByb3ZpZGVkIGl0cyBrZXlzIGFyZSAgY29kZXMgb2YgbWFya2Vycywgc3RhdGUgb2Ygd2hpY2ggc2hvdWxkIGJlIGNoYW5nZWQuIFNlbGVjdGVkIHN0YXRlIHdpbGwgYmUgc2V0IGlmIHZhbHVlIGlzIHRydWUsIHJlbW92ZWQgb3RoZXJ3aXNlLlxcbiAgICovXFxuICBzZXRTZWxlY3RlZE1hcmtlcnM6IGZ1bmN0aW9uIChrZXlzKSB7XFxuICAgIHRoaXMuc2V0U2VsZWN0ZWQoXFxcIm1hcmtlcnNcXFwiLCBrZXlzKTtcXG4gIH0sXFxuXFxuICBjbGVhclNlbGVjdGVkOiBmdW5jdGlvbiAodHlwZSkge1xcbiAgICB2YXIgc2VsZWN0ID0ge30sXFxuICAgICAgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkKHR5cGUpLFxcbiAgICAgIGk7XFxuXFxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3RlZC5sZW5ndGg7IGkrKykge1xcbiAgICAgIHNlbGVjdFtzZWxlY3RlZFtpXV0gPSBmYWxzZTtcXG4gICAgfVxcblxcbiAgICB0aGlzLnNldFNlbGVjdGVkKHR5cGUsIHNlbGVjdCk7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBSZW1vdmUgdGhlIHNlbGVjdGVkIHN0YXRlIGZyb20gYWxsIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcmVnaW9ucy5cXG4gICAqL1xcbiAgY2xlYXJTZWxlY3RlZFJlZ2lvbnM6IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5jbGVhclNlbGVjdGVkKFxcXCJyZWdpb25zXFxcIik7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBSZW1vdmUgdGhlIHNlbGVjdGVkIHN0YXRlIGZyb20gYWxsIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbWFya2Vycy5cXG4gICAqL1xcbiAgY2xlYXJTZWxlY3RlZE1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5jbGVhclNlbGVjdGVkKFxcXCJtYXJrZXJzXFxcIik7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBSZXR1cm4gdGhlIGluc3RhbmNlIG9mIE1hcC4gVXNlZnVsIHdoZW4gaW5zdGFudGlhdGVkIGFzIGEgalF1ZXJ5IHBsdWctaW4uXFxuICAgKiBAcmV0dXJucyB7TWFwfVxcbiAgICovXFxuICBnZXRNYXBPYmplY3Q6IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIHJlZ2lvbiBieSByZWdpb24gY29kZS5cXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XFxuICAgKi9cXG4gIGdldFJlZ2lvbk5hbWU6IGZ1bmN0aW9uIChjb2RlKSB7XFxuICAgIHJldHVybiB0aGlzLm1hcERhdGEucGF0aHNbY29kZV0ubmFtZTtcXG4gIH0sXFxuXFxuICBjcmVhdGVSZWdpb25zOiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBrZXksXFxuICAgICAgcmVnaW9uLFxcbiAgICAgIG1hcCA9IHRoaXM7XFxuXFxuICAgIHRoaXMucmVnaW9uTGFiZWxzR3JvdXAgPSB0aGlzLnJlZ2lvbkxhYmVsc0dyb3VwIHx8IHRoaXMuY2FudmFzLmFkZEdyb3VwKCk7XFxuXFxuICAgIGZvciAoa2V5IGluIHRoaXMubWFwRGF0YS5wYXRocykge1xcbiAgICAgIGNvbnN0IHJlZ2lvblN0eWxlID1cXG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtcy5yZWdpb25TdHlsZSA9PT0gXFxcImZ1bmN0aW9uXFxcIlxcbiAgICAgICAgICA/IHtcXG4gICAgICAgICAgICAgIC4uLmp2bS5NYXAuZGVmYXVsdFBhcmFtcy5yZWdpb25TdHlsZSxcXG4gICAgICAgICAgICAgIC4uLnRoaXMucGFyYW1zLnJlZ2lvblN0eWxlKGtleSksXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICA6IHRoaXMucGFyYW1zLnJlZ2lvblN0eWxlO1xcbiAgICAgIHJlZ2lvbiA9IG5ldyBqdm0uUmVnaW9uKHtcXG4gICAgICAgIG1hcDogdGhpcyxcXG4gICAgICAgIHBhdGg6IHRoaXMubWFwRGF0YS5wYXRoc1trZXldLnBhdGgsXFxuICAgICAgICBjb2RlOiBrZXksXFxuICAgICAgICBzdHlsZToganZtLiQuZXh0ZW5kKHRydWUsIHt9LCByZWdpb25TdHlsZSksXFxuICAgICAgICBsYWJlbFN0eWxlOiBqdm0uJC5leHRlbmQodHJ1ZSwge30sIHRoaXMucGFyYW1zLnJlZ2lvbkxhYmVsU3R5bGUpLFxcbiAgICAgICAgY2FudmFzOiB0aGlzLmNhbnZhcyxcXG4gICAgICAgIGxhYmVsc0dyb3VwOiB0aGlzLnJlZ2lvbkxhYmVsc0dyb3VwLFxcbiAgICAgICAgbGFiZWw6XFxuICAgICAgICAgIHRoaXMuY2FudmFzLm1vZGUgIT0gXFxcInZtbFxcXCJcXG4gICAgICAgICAgICA/IHRoaXMucGFyYW1zLmxhYmVscyAmJiB0aGlzLnBhcmFtcy5sYWJlbHMucmVnaW9uc1xcbiAgICAgICAgICAgIDogbnVsbCxcXG4gICAgICB9KTtcXG5cXG4gICAgICBqdm0uJChyZWdpb24uc2hhcGUpLmJpbmQoXFxcInNlbGVjdGVkXFxcIiwgZnVuY3Rpb24gKGUsIGlzU2VsZWN0ZWQpIHtcXG4gICAgICAgIG1hcC5jb250YWluZXIudHJpZ2dlcihcXFwicmVnaW9uU2VsZWN0ZWQuanZlY3Rvcm1hcFxcXCIsIFtcXG4gICAgICAgICAganZtLiQodGhpcy5ub2RlKS5hdHRyKFxcXCJkYXRhLWNvZGVcXFwiKSxcXG4gICAgICAgICAgaXNTZWxlY3RlZCxcXG4gICAgICAgICAgbWFwLmdldFNlbGVjdGVkUmVnaW9ucygpLFxcbiAgICAgICAgXSk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5yZWdpb25zW2tleV0gPSB7XFxuICAgICAgICBlbGVtZW50OiByZWdpb24sXFxuICAgICAgICBjb25maWc6IHRoaXMubWFwRGF0YS5wYXRoc1trZXldLFxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0sXFxuXFxuICBjcmVhdGVNYXJrZXJzOiBmdW5jdGlvbiAobWFya2Vycykge1xcbiAgICB2YXIgaSxcXG4gICAgICBtYXJrZXIsXFxuICAgICAgcG9pbnQsXFxuICAgICAgbWFya2VyQ29uZmlnLFxcbiAgICAgIG1hcmtlcnNBcnJheSxcXG4gICAgICBtYXAgPSB0aGlzO1xcblxcbiAgICB0aGlzLm1hcmtlcnNHcm91cCA9IHRoaXMubWFya2Vyc0dyb3VwIHx8IHRoaXMuY2FudmFzLmFkZEdyb3VwKCk7XFxuICAgIHRoaXMubWFya2VyTGFiZWxzR3JvdXAgPSB0aGlzLm1hcmtlckxhYmVsc0dyb3VwIHx8IHRoaXMuY2FudmFzLmFkZEdyb3VwKCk7XFxuXFxuICAgIGlmIChqdm0uJC5pc0FycmF5KG1hcmtlcnMpKSB7XFxuICAgICAgbWFya2Vyc0FycmF5ID0gbWFya2Vycy5zbGljZSgpO1xcbiAgICAgIG1hcmtlcnMgPSB7fTtcXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWFya2Vyc0FycmF5Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBtYXJrZXJzW2ldID0gbWFya2Vyc0FycmF5W2ldO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmb3IgKGkgaW4gbWFya2Vycykge1xcbiAgICAgIG1hcmtlckNvbmZpZyA9XFxuICAgICAgICBtYXJrZXJzW2ldIGluc3RhbmNlb2YgQXJyYXkgPyB7IGxhdExuZzogbWFya2Vyc1tpXSB9IDogbWFya2Vyc1tpXTtcXG4gICAgICBwb2ludCA9IHRoaXMuZ2V0TWFya2VyUG9zaXRpb24obWFya2VyQ29uZmlnKTtcXG5cXG4gICAgICBpZiAocG9pbnQgIT09IGZhbHNlKSB7XFxuICAgICAgICBtYXJrZXIgPSBuZXcganZtLk1hcmtlcih7XFxuICAgICAgICAgIG1hcDogdGhpcyxcXG4gICAgICAgICAgc3R5bGU6IGp2bS4kLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5wYXJhbXMubWFya2VyU3R5bGUsIHtcXG4gICAgICAgICAgICBpbml0aWFsOiBtYXJrZXJDb25maWcuc3R5bGUgfHwge30sXFxuICAgICAgICAgIH0pLFxcbiAgICAgICAgICBsYWJlbFN0eWxlOiBqdm0uJC5leHRlbmQodHJ1ZSwge30sIHRoaXMucGFyYW1zLm1hcmtlckxhYmVsU3R5bGUpLFxcbiAgICAgICAgICBpbmRleDogaSxcXG4gICAgICAgICAgY3g6IHBvaW50LngsXFxuICAgICAgICAgIGN5OiBwb2ludC55LFxcbiAgICAgICAgICBncm91cDogdGhpcy5tYXJrZXJzR3JvdXAsXFxuICAgICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXFxuICAgICAgICAgIGxhYmVsc0dyb3VwOiB0aGlzLm1hcmtlckxhYmVsc0dyb3VwLFxcbiAgICAgICAgICBsYWJlbDpcXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5tb2RlICE9IFxcXCJ2bWxcXFwiXFxuICAgICAgICAgICAgICA/IHRoaXMucGFyYW1zLmxhYmVscyAmJiB0aGlzLnBhcmFtcy5sYWJlbHMubWFya2Vyc1xcbiAgICAgICAgICAgICAgOiBudWxsLFxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBqdm0uJChtYXJrZXIuc2hhcGUpLmJpbmQoXFxcInNlbGVjdGVkXFxcIiwgZnVuY3Rpb24gKGUsIGlzU2VsZWN0ZWQpIHtcXG4gICAgICAgICAgbWFwLmNvbnRhaW5lci50cmlnZ2VyKFxcXCJtYXJrZXJTZWxlY3RlZC5qdmVjdG9ybWFwXFxcIiwgW1xcbiAgICAgICAgICAgIGp2bS4kKHRoaXMubm9kZSkuYXR0cihcXFwiZGF0YS1pbmRleFxcXCIpLFxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQsXFxuICAgICAgICAgICAgbWFwLmdldFNlbGVjdGVkTWFya2VycygpLFxcbiAgICAgICAgICBdKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKHRoaXMubWFya2Vyc1tpXSkge1xcbiAgICAgICAgICB0aGlzLnJlbW92ZU1hcmtlcnMoW2ldKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMubWFya2Vyc1tpXSA9IHsgZWxlbWVudDogbWFya2VyLCBjb25maWc6IG1hcmtlckNvbmZpZyB9O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSxcXG5cXG4gIHJlcG9zaXRpb25NYXJrZXJzOiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBpLCBwb2ludDtcXG5cXG4gICAgZm9yIChpIGluIHRoaXMubWFya2Vycykge1xcbiAgICAgIHBvaW50ID0gdGhpcy5nZXRNYXJrZXJQb3NpdGlvbih0aGlzLm1hcmtlcnNbaV0uY29uZmlnKTtcXG4gICAgICBpZiAocG9pbnQgIT09IGZhbHNlKSB7XFxuICAgICAgICB0aGlzLm1hcmtlcnNbaV0uZWxlbWVudC5zZXRTdHlsZSh7IGN4OiBwb2ludC54LCBjeTogcG9pbnQueSB9KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuXFxuICByZXBvc2l0aW9uTGFiZWxzOiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBrZXk7XFxuXFxuICAgIGZvciAoa2V5IGluIHRoaXMucmVnaW9ucykge1xcbiAgICAgIHRoaXMucmVnaW9uc1trZXldLmVsZW1lbnQudXBkYXRlTGFiZWxQb3NpdGlvbigpO1xcbiAgICB9XFxuXFxuICAgIGZvciAoa2V5IGluIHRoaXMubWFya2Vycykge1xcbiAgICAgIHRoaXMubWFya2Vyc1trZXldLmVsZW1lbnQudXBkYXRlTGFiZWxQb3NpdGlvbigpO1xcbiAgICB9XFxuICB9LFxcblxcbiAgZ2V0TWFya2VyUG9zaXRpb246IGZ1bmN0aW9uIChtYXJrZXJDb25maWcpIHtcXG4gICAgaWYgKGp2bS5NYXAubWFwc1t0aGlzLnBhcmFtcy5tYXBdLnByb2plY3Rpb24pIHtcXG4gICAgICByZXR1cm4gdGhpcy5sYXRMbmdUb1BvaW50LmFwcGx5KHRoaXMsIG1hcmtlckNvbmZpZy5sYXRMbmcgfHwgWzAsIDBdKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgeDogbWFya2VyQ29uZmlnLmNvb3Jkc1swXSAqIHRoaXMuc2NhbGUgKyB0aGlzLnRyYW5zWCAqIHRoaXMuc2NhbGUsXFxuICAgICAgICB5OiBtYXJrZXJDb25maWcuY29vcmRzWzFdICogdGhpcy5zY2FsZSArIHRoaXMudHJhbnNZICogdGhpcy5zY2FsZSxcXG4gICAgICB9O1xcbiAgICB9XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBBZGQgb25lIG1hcmtlciB0byB0aGUgbWFwLlxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBNYXJrZXIgdW5pcXVlIGNvZGUuXFxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFya2VyIE1hcmtlciBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMuXFxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXJpZXNEYXRhIFZhbHVlcyB0byBhZGQgdG8gdGhlIGRhdGEgc2VyaWVzLlxcbiAgICovXFxuICBhZGRNYXJrZXI6IGZ1bmN0aW9uIChrZXksIG1hcmtlciwgc2VyaWVzRGF0YSkge1xcbiAgICB2YXIgbWFya2VycyA9IHt9LFxcbiAgICAgIGRhdGEgPSBbXSxcXG4gICAgICB2YWx1ZXMsXFxuICAgICAgaSxcXG4gICAgICBzZXJpZXNEYXRhID0gc2VyaWVzRGF0YSB8fCBbXTtcXG5cXG4gICAgbWFya2Vyc1trZXldID0gbWFya2VyO1xcblxcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VyaWVzRGF0YS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhbHVlcyA9IHt9O1xcbiAgICAgIGlmICh0eXBlb2Ygc2VyaWVzRGF0YVtpXSAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgIHZhbHVlc1trZXldID0gc2VyaWVzRGF0YVtpXTtcXG4gICAgICB9XFxuICAgICAgZGF0YS5wdXNoKHZhbHVlcyk7XFxuICAgIH1cXG4gICAgdGhpcy5hZGRNYXJrZXJzKG1hcmtlcnMsIGRhdGEpO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQWRkIHNldCBvZiBtYXJrZXIgdG8gdGhlIG1hcC5cXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBtYXJrZXJzIE1hcmtlcnMgdG8gYWRkIHRvIHRoZSBtYXAuIEluIGNhc2Ugb2YgYXJyYXkgaXMgcHJvdmlkZWQsIGNvZGVzIG9mIG1hcmtlcnMgd2lsbCBiZSBzZXQgYXMgc3RyaW5nIHJlcHJlc2VudGF0aW9ucyBvZiBhcnJheSBpbmRleGVzLlxcbiAgICogQHBhcmFtIHtBcnJheX0gc2VyaWVzRGF0YSBWYWx1ZXMgdG8gYWRkIHRvIHRoZSBkYXRhIHNlcmllcy5cXG4gICAqL1xcbiAgYWRkTWFya2VyczogZnVuY3Rpb24gKG1hcmtlcnMsIHNlcmllc0RhdGEpIHtcXG4gICAgdmFyIGk7XFxuXFxuICAgIHNlcmllc0RhdGEgPSBzZXJpZXNEYXRhIHx8IFtdO1xcblxcbiAgICB0aGlzLmNyZWF0ZU1hcmtlcnMobWFya2Vycyk7XFxuICAgIGZvciAoaSA9IDA7IGkgPCBzZXJpZXNEYXRhLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdGhpcy5zZXJpZXMubWFya2Vyc1tpXS5zZXRWYWx1ZXMoc2VyaWVzRGF0YVtpXSB8fCB7fSk7XFxuICAgIH1cXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIFJlbW92ZSBzb21lIG1hcmtlcnMgZnJvbSB0aGUgbWFwLlxcbiAgICogQHBhcmFtIHtBcnJheX0gbWFya2VycyBBcnJheSBvZiBtYXJrZXIgY29kZXMgdG8gYmUgcmVtb3ZlZC5cXG4gICAqL1xcbiAgcmVtb3ZlTWFya2VyczogZnVuY3Rpb24gKG1hcmtlcnMpIHtcXG4gICAgdmFyIGk7XFxuXFxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdGhpcy5tYXJrZXJzW21hcmtlcnNbaV1dLmVsZW1lbnQucmVtb3ZlKCk7XFxuICAgICAgZGVsZXRlIHRoaXMubWFya2Vyc1ttYXJrZXJzW2ldXTtcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogUmVtb3ZlIGFsbCBtYXJrZXJzIGZyb20gdGhlIG1hcC5cXG4gICAqL1xcbiAgcmVtb3ZlQWxsTWFya2VyczogZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgaSxcXG4gICAgICBtYXJrZXJzID0gW107XFxuXFxuICAgIGZvciAoaSBpbiB0aGlzLm1hcmtlcnMpIHtcXG4gICAgICBtYXJrZXJzLnB1c2goaSk7XFxuICAgIH1cXG4gICAgdGhpcy5yZW1vdmVNYXJrZXJzKG1hcmtlcnMpO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQ29udmVydHMgY29vcmRpbmF0ZXMgZXhwcmVzc2VkIGFzIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgdG8gdGhlIGNvb3JkaW5hdGVzIGluIHBpeGVscyBvbiB0aGUgbWFwLlxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxhdCBMYXRpdGlkZSBvZiBwb2ludCBpbiBkZWdyZWVzLlxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxuZyBMb25naXR1ZGUgb2YgcG9pbnQgaW4gZGVncmVlcy5cXG4gICAqL1xcbiAgbGF0TG5nVG9Qb2ludDogZnVuY3Rpb24gKGxhdCwgbG5nKSB7XFxuICAgIHZhciBwb2ludCxcXG4gICAgICBwcm9qID0ganZtLk1hcC5tYXBzW3RoaXMucGFyYW1zLm1hcF0ucHJvamVjdGlvbixcXG4gICAgICBjZW50cmFsTWVyaWRpYW4gPSBwcm9qLmNlbnRyYWxNZXJpZGlhbixcXG4gICAgICBpbnNldCxcXG4gICAgICBiYm94O1xcblxcbiAgICBpZiAobG5nIDwgLTE4MCArIGNlbnRyYWxNZXJpZGlhbikge1xcbiAgICAgIGxuZyArPSAzNjA7XFxuICAgIH1cXG5cXG4gICAgcG9pbnQgPSBqdm0uUHJvaltwcm9qLnR5cGVdKGxhdCwgbG5nLCBjZW50cmFsTWVyaWRpYW4pO1xcblxcbiAgICBpbnNldCA9IHRoaXMuZ2V0SW5zZXRGb3JQb2ludChwb2ludC54LCBwb2ludC55KTtcXG4gICAgaWYgKGluc2V0KSB7XFxuICAgICAgYmJveCA9IGluc2V0LmJib3g7XFxuXFxuICAgICAgcG9pbnQueCA9XFxuICAgICAgICAoKHBvaW50LnggLSBiYm94WzBdLngpIC8gKGJib3hbMV0ueCAtIGJib3hbMF0ueCkpICpcXG4gICAgICAgIGluc2V0LndpZHRoICpcXG4gICAgICAgIHRoaXMuc2NhbGU7XFxuICAgICAgcG9pbnQueSA9XFxuICAgICAgICAoKHBvaW50LnkgLSBiYm94WzBdLnkpIC8gKGJib3hbMV0ueSAtIGJib3hbMF0ueSkpICpcXG4gICAgICAgIGluc2V0LmhlaWdodCAqXFxuICAgICAgICB0aGlzLnNjYWxlO1xcblxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICB4OiBwb2ludC54ICsgdGhpcy50cmFuc1ggKiB0aGlzLnNjYWxlICsgaW5zZXQubGVmdCAqIHRoaXMuc2NhbGUsXFxuICAgICAgICB5OiBwb2ludC55ICsgdGhpcy50cmFuc1kgKiB0aGlzLnNjYWxlICsgaW5zZXQudG9wICogdGhpcy5zY2FsZSxcXG4gICAgICB9O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQ29udmVydHMgY2FydGVzaWFuIGNvb3JkaW5hdGVzIGludG8gY29vcmRpbmF0ZXMgZXhwcmVzc2VkIGFzIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXFxuICAgKiBAcGFyYW0ge051bWJlcn0geCBYLWF4aXMgb2YgcG9pbnQgb24gbWFwIGluIHBpeGVscy5cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IFktYXhpcyBvZiBwb2ludCBvbiBtYXAgaW4gcGl4ZWxzLlxcbiAgICovXFxuICBwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAoeCwgeSkge1xcbiAgICB2YXIgcHJvaiA9IGp2bS5NYXAubWFwc1t0aGlzLnBhcmFtcy5tYXBdLnByb2plY3Rpb24sXFxuICAgICAgY2VudHJhbE1lcmlkaWFuID0gcHJvai5jZW50cmFsTWVyaWRpYW4sXFxuICAgICAgaW5zZXRzID0ganZtLk1hcC5tYXBzW3RoaXMucGFyYW1zLm1hcF0uaW5zZXRzLFxcbiAgICAgIGksXFxuICAgICAgaW5zZXQsXFxuICAgICAgYmJveCxcXG4gICAgICBueCxcXG4gICAgICBueTtcXG5cXG4gICAgZm9yIChpID0gMDsgaSA8IGluc2V0cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGluc2V0ID0gaW5zZXRzW2ldO1xcbiAgICAgIGJib3ggPSBpbnNldC5iYm94O1xcblxcbiAgICAgIG54ID0geCAtICh0aGlzLnRyYW5zWCAqIHRoaXMuc2NhbGUgKyBpbnNldC5sZWZ0ICogdGhpcy5zY2FsZSk7XFxuICAgICAgbnkgPSB5IC0gKHRoaXMudHJhbnNZICogdGhpcy5zY2FsZSArIGluc2V0LnRvcCAqIHRoaXMuc2NhbGUpO1xcblxcbiAgICAgIG54ID1cXG4gICAgICAgIChueCAvIChpbnNldC53aWR0aCAqIHRoaXMuc2NhbGUpKSAqIChiYm94WzFdLnggLSBiYm94WzBdLngpICsgYmJveFswXS54O1xcbiAgICAgIG55ID1cXG4gICAgICAgIChueSAvIChpbnNldC5oZWlnaHQgKiB0aGlzLnNjYWxlKSkgKiAoYmJveFsxXS55IC0gYmJveFswXS55KSArXFxuICAgICAgICBiYm94WzBdLnk7XFxuXFxuICAgICAgaWYgKFxcbiAgICAgICAgbnggPiBiYm94WzBdLnggJiZcXG4gICAgICAgIG54IDwgYmJveFsxXS54ICYmXFxuICAgICAgICBueSA+IGJib3hbMF0ueSAmJlxcbiAgICAgICAgbnkgPCBiYm94WzFdLnlcXG4gICAgICApIHtcXG4gICAgICAgIHJldHVybiBqdm0uUHJvaltwcm9qLnR5cGUgKyBcXFwiX2ludlxcXCJdKG54LCAtbnksIGNlbnRyYWxNZXJpZGlhbik7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH0sXFxuXFxuICBnZXRJbnNldEZvclBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xcbiAgICB2YXIgaW5zZXRzID0ganZtLk1hcC5tYXBzW3RoaXMucGFyYW1zLm1hcF0uaW5zZXRzLFxcbiAgICAgIGksXFxuICAgICAgYmJveDtcXG5cXG4gICAgZm9yIChpID0gMDsgaSA8IGluc2V0cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGJib3ggPSBpbnNldHNbaV0uYmJveDtcXG4gICAgICBpZiAoeCA+IGJib3hbMF0ueCAmJiB4IDwgYmJveFsxXS54ICYmIHkgPiBiYm94WzBdLnkgJiYgeSA8IGJib3hbMV0ueSkge1xcbiAgICAgICAgcmV0dXJuIGluc2V0c1tpXTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuXFxuICBjcmVhdGVTZXJpZXM6IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGksIGtleTtcXG5cXG4gICAgdGhpcy5zZXJpZXMgPSB7XFxuICAgICAgbWFya2VyczogW10sXFxuICAgICAgcmVnaW9uczogW10sXFxuICAgIH07XFxuXFxuICAgIGZvciAoa2V5IGluIHRoaXMucGFyYW1zLnNlcmllcykge1xcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBhcmFtcy5zZXJpZXNba2V5XS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdGhpcy5zZXJpZXNba2V5XVtpXSA9IG5ldyBqdm0uRGF0YVNlcmllcyhcXG4gICAgICAgICAgdGhpcy5wYXJhbXMuc2VyaWVzW2tleV1baV0sXFxuICAgICAgICAgIHRoaXNba2V5XSxcXG4gICAgICAgICAgdGhpcyxcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBHcmFjZWZ1bGx5IHJlbW92ZSB0aGUgbWFwIGFuZCBhbmQgYWxsIGl0cyBhY2Nlc3NvcmllcywgdW5iaW5kIGV2ZW50IGhhbmRsZXJzLlxcbiAgICovXFxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy50aXAucmVtb3ZlKCk7XFxuICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xcbiAgICBqdm0uJCh3aW5kb3cpLnVuYmluZChcXFwicmVzaXplXFxcIiwgdGhpcy5vblJlc2l6ZSk7XFxuICAgIGp2bS4kKFxcXCJib2R5XFxcIikudW5iaW5kKFxcXCJtb3VzZXVwXFxcIiwgdGhpcy5vbkNvbnRhaW5lck1vdXNlVXApO1xcbiAgfSxcXG59O1xcblxcbmp2bS5NYXAubWFwcyA9IHt9O1xcbmp2bS5NYXAuZGVmYXVsdFBhcmFtcyA9IHtcXG4gIG1hcDogXFxcIndvcmxkX21pbGxfZW5cXFwiLFxcbiAgYmFja2dyb3VuZENvbG9yOiBcXFwiIzUwNTA1MFxcXCIsXFxuICB6b29tQnV0dG9uczogdHJ1ZSxcXG4gIHpvb21PblNjcm9sbDogdHJ1ZSxcXG4gIHpvb21PblNjcm9sbFNwZWVkOiAzLFxcbiAgcGFuT25EcmFnOiB0cnVlLFxcbiAgem9vbU1heDogOCxcXG4gIHpvb21NaW46IDEsXFxuICB6b29tU3RlcDogMS42LFxcbiAgem9vbUFuaW1hdGU6IHRydWUsXFxuICByZWdpb25zU2VsZWN0YWJsZTogZmFsc2UsXFxuICBtYXJrZXJzU2VsZWN0YWJsZTogZmFsc2UsXFxuICBiaW5kVG91Y2hFdmVudHM6IHRydWUsXFxuICByZWdpb25TdHlsZToge1xcbiAgICBpbml0aWFsOiB7XFxuICAgICAgZmlsbDogXFxcIndoaXRlXFxcIixcXG4gICAgICBcXFwiZmlsbC1vcGFjaXR5XFxcIjogMSxcXG4gICAgICBzdHJva2U6IFxcXCJub25lXFxcIixcXG4gICAgICBcXFwic3Ryb2tlLXdpZHRoXFxcIjogMCxcXG4gICAgICBcXFwic3Ryb2tlLW9wYWNpdHlcXFwiOiAxLFxcbiAgICB9LFxcbiAgICBob3Zlcjoge1xcbiAgICAgIFxcXCJmaWxsLW9wYWNpdHlcXFwiOiAwLjgsXFxuICAgICAgY3Vyc29yOiBcXFwicG9pbnRlclxcXCIsXFxuICAgIH0sXFxuICAgIHNlbGVjdGVkOiB7XFxuICAgICAgZmlsbDogXFxcInllbGxvd1xcXCIsXFxuICAgIH0sXFxuICAgIHNlbGVjdGVkSG92ZXI6IHt9LFxcbiAgfSxcXG4gIHJlZ2lvbkxhYmVsU3R5bGU6IHtcXG4gICAgaW5pdGlhbDoge1xcbiAgICAgIFxcXCJmb250LWZhbWlseVxcXCI6IFxcXCJWZXJkYW5hXFxcIixcXG4gICAgICBcXFwiZm9udC1zaXplXFxcIjogXFxcIjEyXFxcIixcXG4gICAgICBcXFwiZm9udC13ZWlnaHRcXFwiOiBcXFwiYm9sZFxcXCIsXFxuICAgICAgY3Vyc29yOiBcXFwiZGVmYXVsdFxcXCIsXFxuICAgICAgZmlsbDogXFxcImJsYWNrXFxcIixcXG4gICAgfSxcXG4gICAgaG92ZXI6IHtcXG4gICAgICBjdXJzb3I6IFxcXCJwb2ludGVyXFxcIixcXG4gICAgfSxcXG4gIH0sXFxuICBtYXJrZXJTdHlsZToge1xcbiAgICBpbml0aWFsOiB7XFxuICAgICAgZmlsbDogXFxcImdyZXlcXFwiLFxcbiAgICAgIHN0cm9rZTogXFxcIiM1MDUwNTBcXFwiLFxcbiAgICAgIFxcXCJmaWxsLW9wYWNpdHlcXFwiOiAxLFxcbiAgICAgIFxcXCJzdHJva2Utd2lkdGhcXFwiOiAxLFxcbiAgICAgIFxcXCJzdHJva2Utb3BhY2l0eVxcXCI6IDEsXFxuICAgICAgcjogNSxcXG4gICAgfSxcXG4gICAgaG92ZXI6IHtcXG4gICAgICBzdHJva2U6IFxcXCJibGFja1xcXCIsXFxuICAgICAgXFxcInN0cm9rZS13aWR0aFxcXCI6IDIsXFxuICAgICAgY3Vyc29yOiBcXFwicG9pbnRlclxcXCIsXFxuICAgIH0sXFxuICAgIHNlbGVjdGVkOiB7XFxuICAgICAgZmlsbDogXFxcImJsdWVcXFwiLFxcbiAgICB9LFxcbiAgICBzZWxlY3RlZEhvdmVyOiB7fSxcXG4gIH0sXFxuICBtYXJrZXJMYWJlbFN0eWxlOiB7XFxuICAgIGluaXRpYWw6IHtcXG4gICAgICBcXFwiZm9udC1mYW1pbHlcXFwiOiBcXFwiVmVyZGFuYVxcXCIsXFxuICAgICAgXFxcImZvbnQtc2l6ZVxcXCI6IFxcXCIxMlxcXCIsXFxuICAgICAgXFxcImZvbnQtd2VpZ2h0XFxcIjogXFxcImJvbGRcXFwiLFxcbiAgICAgIGN1cnNvcjogXFxcImRlZmF1bHRcXFwiLFxcbiAgICAgIGZpbGw6IFxcXCJibGFja1xcXCIsXFxuICAgIH0sXFxuICAgIGhvdmVyOiB7XFxuICAgICAgY3Vyc29yOiBcXFwicG9pbnRlclxcXCIsXFxuICAgIH0sXFxuICB9LFxcbn07XFxuanZtLk1hcC5hcGlFdmVudHMgPSB7XFxuICBvblJlZ2lvblRpcFNob3c6IFxcXCJyZWdpb25UaXBTaG93XFxcIixcXG4gIG9uUmVnaW9uT3ZlcjogXFxcInJlZ2lvbk92ZXJcXFwiLFxcbiAgb25SZWdpb25PdXQ6IFxcXCJyZWdpb25PdXRcXFwiLFxcbiAgb25SZWdpb25DbGljazogXFxcInJlZ2lvbkNsaWNrXFxcIixcXG4gIG9uUmVnaW9uU2VsZWN0ZWQ6IFxcXCJyZWdpb25TZWxlY3RlZFxcXCIsXFxuICBvbk1hcmtlclRpcFNob3c6IFxcXCJtYXJrZXJUaXBTaG93XFxcIixcXG4gIG9uTWFya2VyT3ZlcjogXFxcIm1hcmtlck92ZXJcXFwiLFxcbiAgb25NYXJrZXJPdXQ6IFxcXCJtYXJrZXJPdXRcXFwiLFxcbiAgb25NYXJrZXJDbGljazogXFxcIm1hcmtlckNsaWNrXFxcIixcXG4gIG9uTWFya2VyU2VsZWN0ZWQ6IFxcXCJtYXJrZXJTZWxlY3RlZFxcXCIsXFxuICBvblZpZXdwb3J0Q2hhbmdlOiBcXFwidmlld3BvcnRDaGFuZ2VcXFwiLFxcbn07XFxuLyoqXFxuICogQ3JlYXRlcyBtYXAgd2l0aCBkcmlsbC1kb3duIGZ1bmN0aW9uYWxpdHkuXFxuICogQGNvbnN0cnVjdG9yXFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzIHRvIGluaXRpYWxpemUgbWFwIHdpdGguXFxuICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhMZXZlbCBNYXhpbXVtIG51bWJlciBvZiBsZXZlbHMgdXNlciBjYW4gZ28gdGhyb3VnaFxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMubWFpbiBDb25maWcgb2YgdGhlIG1haW4gbWFwLiBTZWUgPGEgaHJlZj1cXFwiLi9qdm0tbWFwL1xcXCI+anZtLk1hcDwvYT4gZm9yIG1vcmUgaW5mb3JtYXRpb24uXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW1zLm1hcE5hbWVCeUNvZGUgRnVuY3Rpb24gdG8gZ2VuZXJhdGUgbWFwIG5hbWUgYnkgcmVnaW9uIGNvZGUuIERlZmF1bHQgdmFsdWUgaXM6XFxuPHByZT5cXG5mdW5jdGlvbihjb2RlLCBtdWx0aU1hcCkge1xcbiAgcmV0dXJuIGNvZGUudG9Mb3dlckNhc2UoKSsnXycrXFxuICAgICAgICAgbXVsdGlNYXAuZGVmYXVsdFByb2plY3Rpb24rJ19lbic7XFxufVxcbjwvcHJlPlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtcy5tYXBVcmxCeUNvZGUgRnVuY3Rpb24gdG8gZ2VuZXJhdGUgbWFwIHVybCBieSByZWdpb24gY29kZS4gRGVmYXVsdCB2YWx1ZSBpczpcXG48cHJlPlxcbmZ1bmN0aW9uKGNvZGUsIG11bHRpTWFwKXtcXG4gIHJldHVybiAnanF1ZXJ5LWp2ZWN0b3JtYXAtZGF0YS0nK1xcbiAgICAgICAgIGNvZGUudG9Mb3dlckNhc2UoKSsnLScrXFxuICAgICAgICAgbXVsdGlNYXAuZGVmYXVsdFByb2plY3Rpb24rJy1lbi5qcyc7XFxufVxcbjwvcHJlPlxcbiAqL1xcbmp2bS5NdWx0aU1hcCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gIHZhciB0aGF0ID0gdGhpcztcXG5cXG4gIHRoaXMubWFwcyA9IHt9O1xcbiAgdGhpcy5wYXJhbXMgPSBqdm0uJC5leHRlbmQodHJ1ZSwge30sIGp2bS5NdWx0aU1hcC5kZWZhdWx0UGFyYW1zLCBwYXJhbXMpO1xcbiAgdGhpcy5wYXJhbXMubWF4TGV2ZWwgPSB0aGlzLnBhcmFtcy5tYXhMZXZlbCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xcbiAgdGhpcy5wYXJhbXMubWFpbiA9IHRoaXMucGFyYW1zLm1haW4gfHwge307XFxuICB0aGlzLnBhcmFtcy5tYWluLm11bHRpTWFwTGV2ZWwgPSAwO1xcbiAgdGhpcy5oaXN0b3J5ID0gW3RoaXMuYWRkTWFwKHRoaXMucGFyYW1zLm1haW4ubWFwLCB0aGlzLnBhcmFtcy5tYWluKV07XFxuICB0aGlzLmRlZmF1bHRQcm9qZWN0aW9uID0gdGhpcy5oaXN0b3J5WzBdLm1hcERhdGEucHJvamVjdGlvbi50eXBlO1xcbiAgdGhpcy5tYXBzTG9hZGVkID0ge307XFxuICB0aGlzLm1hcHNMb2FkZWREYXRhID0ge307XFxuXFxuICB0aGlzLnBhcmFtcy5jb250YWluZXIuY3NzKHsgcG9zaXRpb246IFxcXCJyZWxhdGl2ZVxcXCIgfSk7XFxuICB0aGlzLmJhY2tCdXR0b24gPSBqdm1cXG4gICAgLiQoXFxcIjxkaXYvPlxcXCIpXFxuICAgIC5hZGRDbGFzcyhcXFwianZlY3Rvcm1hcC1nb2JhY2tcXFwiKVxcbiAgICAudGV4dChcXFwiQmFja1xcXCIpXFxuICAgIC5hcHBlbmRUbyh0aGlzLnBhcmFtcy5jb250YWluZXIpO1xcbiAgdGhpcy5iYWNrQnV0dG9uLmhpZGUoKTtcXG4gIHRoaXMuYmFja0J1dHRvbi5jbGljayhmdW5jdGlvbiAoKSB7XFxuICAgIHRoYXQuZ29CYWNrKCk7XFxuICB9KTtcXG5cXG4gIHRoaXMuc3Bpbm5lciA9IGp2bVxcbiAgICAuJChcXFwiPGRpdi8+XFxcIilcXG4gICAgLmFkZENsYXNzKFxcXCJqdmVjdG9ybWFwLXNwaW5uZXJcXFwiKVxcbiAgICAuYXBwZW5kVG8odGhpcy5wYXJhbXMuY29udGFpbmVyKTtcXG4gIHRoaXMuc3Bpbm5lci5oaWRlKCk7XFxufTtcXG5cXG5qdm0uTXVsdGlNYXAucHJvdG90eXBlID0ge1xcbiAgYWRkTWFwOiBmdW5jdGlvbiAobmFtZSwgY29uZmlnKSB7XFxuICAgIHZhciBjbnQgPSBqdm0uJChcXFwiPGRpdi8+XFxcIikuY3NzKHtcXG4gICAgICB3aWR0aDogXFxcIjEwMCVcXFwiLFxcbiAgICAgIGhlaWdodDogXFxcIjEwMCVcXFwiLFxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5wYXJhbXMuY29udGFpbmVyLmFwcGVuZChjbnQpO1xcblxcbiAgICB0aGlzLm1hcHNbbmFtZV0gPSBuZXcganZtLk1hcChqdm0uJC5leHRlbmQoY29uZmlnLCB7IGNvbnRhaW5lcjogY250IH0pKTtcXG4gICAgaWYgKHRoaXMucGFyYW1zLm1heExldmVsID4gY29uZmlnLm11bHRpTWFwTGV2ZWwpIHtcXG4gICAgICB0aGlzLm1hcHNbbmFtZV0uY29udGFpbmVyLm9uKFxcbiAgICAgICAgXFxcInJlZ2lvbkNsaWNrLmp2ZWN0b3JtYXBcXFwiLFxcbiAgICAgICAgeyBzY29wZTogdGhpcyB9LFxcbiAgICAgICAgZnVuY3Rpb24gKGUsIGNvZGUpIHtcXG4gICAgICAgICAgdmFyIG11bHRpbWFwID0gZS5kYXRhLnNjb3BlLFxcbiAgICAgICAgICAgIG1hcE5hbWUgPSBtdWx0aW1hcC5wYXJhbXMubWFwTmFtZUJ5Q29kZShjb2RlLCBtdWx0aW1hcCk7XFxuXFxuICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICAhbXVsdGltYXAuZHJpbGxEb3duUHJvbWlzZSB8fFxcbiAgICAgICAgICAgIG11bHRpbWFwLmRyaWxsRG93blByb21pc2Uuc3RhdGUoKSAhPT0gXFxcInBlbmRpbmdcXFwiXFxuICAgICAgICAgICkge1xcbiAgICAgICAgICAgIG11bHRpbWFwLmRyaWxsRG93bihtYXBOYW1lLCBjb2RlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzLm1hcHNbbmFtZV07XFxuICB9LFxcblxcbiAgZG93bmxvYWRNYXA6IGZ1bmN0aW9uIChjb2RlKSB7XFxuICAgIHZhciB0aGF0ID0gdGhpcyxcXG4gICAgICBkZWZlcnJlZCA9IGp2bS4kLkRlZmVycmVkKCk7XFxuICAgIGNvbnN0IHsgZ2V0RHJpbGxEb3duTWFwIH0gPSB0aGlzLnBhcmFtcztcXG5cXG4gICAgY29uc3QgaGFuZGxlTWFwRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgdGhhdC5tYXBzTG9hZGVkW2NvZGVdID0gdHJ1ZTtcXG4gICAgICB0aGF0Lm1hcHNMb2FkZWREYXRhW2NvZGVdID0gZGF0YTtcXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XFxuICAgIH07XFxuXFxuICAgIGlmICghdGhpcy5tYXBzTG9hZGVkW2NvZGVdKSB7XFxuICAgICAgaWYgKGdldERyaWxsRG93bk1hcCAmJiB0eXBlb2YgZ2V0RHJpbGxEb3duTWFwID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICBjb25zdCByZXN1bHQgPSBnZXREcmlsbERvd25NYXAoY29kZSk7XFxuICAgICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgICByZXN1bHRcXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xcbiAgICAgICAgICAgICAgaGFuZGxlTWFwRGF0YShkYXRhKTtcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XFxuICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGhhbmRsZU1hcERhdGEocmVzdWx0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBkZWZlcnJlZDtcXG4gICAgICB9XFxuICAgICAganZtLiQuZ2V0KHRoaXMucGFyYW1zLm1hcFVybEJ5Q29kZShjb2RlLCB0aGlzKSkudGhlbihcXG4gICAgICAgIGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgICAgIGhhbmRsZU1hcERhdGEoZGF0YSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcXG4gICAgICAgIH0sXFxuICAgICAgKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGRlZmVycmVkO1xcbiAgfSxcXG5cXG4gIGRyaWxsRG93bjogZnVuY3Rpb24gKG5hbWUsIGNvZGUpIHtcXG4gICAgdmFyIGN1cnJlbnRNYXAgPSB0aGlzLmhpc3RvcnlbdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFdLFxcbiAgICAgIHRoYXQgPSB0aGlzLFxcbiAgICAgIGZvY3VzUHJvbWlzZSA9IGN1cnJlbnRNYXAuc2V0Rm9jdXMoeyByZWdpb246IGNvZGUsIGFuaW1hdGU6IHRydWUgfSksXFxuICAgICAgZG93bmxvYWRQcm9taXNlID0gdGhpcy5kb3dubG9hZE1hcChjb2RlKTtcXG5cXG4gICAgZm9jdXNQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmIChkb3dubG9hZFByb21pc2Uuc3RhdGUoKSA9PT0gXFxcInBlbmRpbmdcXFwiKSB7XFxuICAgICAgICB0aGF0LnNwaW5uZXIuc2hvdygpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIGRvd25sb2FkUHJvbWlzZS5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIHRoYXQuc3Bpbm5lci5oaWRlKCk7XFxuICAgIH0pO1xcbiAgICB0aGlzLmRyaWxsRG93blByb21pc2UgPSBqdm0uJC53aGVuKGRvd25sb2FkUHJvbWlzZSwgZm9jdXNQcm9taXNlKTtcXG4gICAgdGhpcy5kcmlsbERvd25Qcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xcbiAgICAgIGNvbnN0IHsgY29udGVudCB9ID0gdGhhdC5tYXBzTG9hZGVkRGF0YVtjb2RlXTtcXG4gICAgICBjdXJyZW50TWFwLnBhcmFtcy5jb250YWluZXIuaGlkZSgpO1xcbiAgICAgIGlmICghdGhhdC5tYXBzW25hbWVdKSB7XFxuICAgICAgICBqdm0uJC5mbi52ZWN0b3JNYXAoXFxcImFkZE1hcFxcXCIsIG5hbWUsIGNvbnRlbnQpO1xcbiAgICAgICAgdGhhdC5hZGRNYXAobmFtZSwge1xcbiAgICAgICAgICBtYXA6IG5hbWUsXFxuICAgICAgICAgIG11bHRpTWFwTGV2ZWw6IGN1cnJlbnRNYXAucGFyYW1zLm11bHRpTWFwTGV2ZWwgKyAxLFxcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoYXQubWFwc1tuYW1lXS5wYXJhbXMuY29udGFpbmVyLnNob3coKTtcXG4gICAgICB9XFxuICAgICAgdGhhdC5oaXN0b3J5LnB1c2godGhhdC5tYXBzW25hbWVdKTtcXG4gICAgICB0aGF0LmJhY2tCdXR0b24uc2hvdygpO1xcbiAgICB9KTtcXG4gIH0sXFxuXFxuICBnb0JhY2s6IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGN1cnJlbnRNYXAgPSB0aGlzLmhpc3RvcnkucG9wKCksXFxuICAgICAgcHJldk1hcCA9IHRoaXMuaGlzdG9yeVt0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMV0sXFxuICAgICAgdGhhdCA9IHRoaXM7XFxuXFxuICAgIGN1cnJlbnRNYXBcXG4gICAgICAuc2V0Rm9jdXMoeyBzY2FsZTogMSwgeDogMC41LCB5OiAwLjUsIGFuaW1hdGU6IHRydWUgfSlcXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjdXJyZW50TWFwLnBhcmFtcy5jb250YWluZXIuaGlkZSgpO1xcbiAgICAgICAgcHJldk1hcC5wYXJhbXMuY29udGFpbmVyLnNob3coKTtcXG4gICAgICAgIHByZXZNYXAudXBkYXRlU2l6ZSgpO1xcbiAgICAgICAgaWYgKHRoYXQuaGlzdG9yeS5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICAgdGhhdC5iYWNrQnV0dG9uLmhpZGUoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHByZXZNYXAuc2V0Rm9jdXMoeyBzY2FsZTogMSwgeDogMC41LCB5OiAwLjUsIGFuaW1hdGU6IHRydWUgfSk7XFxuICAgICAgfSk7XFxuICB9LFxcbn07XFxuXFxuanZtLk11bHRpTWFwLmRlZmF1bHRQYXJhbXMgPSB7XFxuICBtYXBOYW1lQnlDb2RlOiBmdW5jdGlvbiAoY29kZSwgbXVsdGlNYXApIHtcXG4gICAgcmV0dXJuIGNvZGUudG9Mb3dlckNhc2UoKSArIFxcXCJfXFxcIiArIG11bHRpTWFwLmRlZmF1bHRQcm9qZWN0aW9uICsgXFxcIl9lblxcXCI7XFxuICB9LFxcbiAgbWFwVXJsQnlDb2RlOiBmdW5jdGlvbiAoY29kZSwgbXVsdGlNYXApIHtcXG4gICAgcmV0dXJuIChcXG4gICAgICBcXFwianF1ZXJ5LWp2ZWN0b3JtYXAtZGF0YS1cXFwiICtcXG4gICAgICBjb2RlLnRvTG93ZXJDYXNlKCkgK1xcbiAgICAgIFxcXCItXFxcIiArXFxuICAgICAgbXVsdGlNYXAuZGVmYXVsdFByb2plY3Rpb24gK1xcbiAgICAgIFxcXCItZW4uanNcXFwiXFxuICAgICk7XFxuICB9LFxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS8uLi9qdmVjdG9ybWFwL2pxdWVyeS5qdmVjdG9ybWFwLm1pbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaElBQWdBUE1BQVAvLy93QUFBTWJHeG9TRWhMYTJ0cHFhbWpZMk5sWldWdGpZMk9UazVMeTh2QjRlSGdRRUJBQUFBQUFBQUFBQUFDSC9DMDVGVkZORFFWQkZNaTR3QXdFQUFBQWgvaHBEY21WaGRHVmtJSGRwZEdnZ1lXcGhlR3h2WVdRdWFXNW1id0FoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNXhESVNXbGhwZXJONTJKTGhTU2RSZ3dWbzFJQ1FaUlVzaXdIcFRKVDRpb3dOUzh2eVcyaWNDRjZrOEhNTUJrQ0VEc2t4VEJEQVp3dUFra3FJZnhJUXloQlFCRnZBUVNESVRNNVZEVzZYTkU0S2FnTmg2Qmd3ZTYwc21RVUIzZDRSejFaQkFwbkZBU0RkMGhpaGgxMkJrRTlrakFKVmx5Y1hJZzdDUUlGQTZTbG5KODdwYXFiU0tpS29xdXNuYk1kbURDMnRYUWxrVWh6aVl0eVdUeElmeTZCRThXSnQ1WUp2cEppdnhOYUdtTEhUMFZuT2dTWWYwZFpYUzdBUGRwQjMwOVJuSE9HNWdEcVhHTERhQzQ1N0QxelovVi9ubU9NODJYaUhSTFlLaEtQMW9abUFEZEVBQUFoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNmhESVNXbFpwT3JOcDFsR05SU2RScERVb2xJR3c1UlVZaGhIdWtxRnU4RHNyRXlxbldUaEd2QW1oVmx0ZUJ2b2pwVEREQlVFSUZ3TUZCUkFtQmtTZ09yQkZab2dDQVN3QkRFWS9DWlNnN0dTRTBnU0NqUUJNVkcwMjN4V0Joa2xBbm9FZGhRRWZ5TnFNSWNLamhSc2pFZG5lekIrQTRrOGdUd0poRnVpVzRkb2tYaWxvVWVwQkFwNXFhS3BwNitIbzdhV1c1NHdsN29idkVlMGtSdW9wbENHZXB3U3gyakp2cUhFbUd0NndoSnBHcGZKQ0htT29OSEthSHg2MVdpU1I5MkU0bGJGb3ErQjZRRHR1ZXRjYUJQblc2K083d0RIcElpSzlTYVZLNUdnVjU0M3R6amdHY2doQWdBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTdoRElTU2t4cE9yTjV6RkhOV1JkaFNpVm9WTEhzcFJVTW95VWFreUVlOFBUUENBVFc5QTE0RTBVdnVBS01OQVpLWVVaQ2lCTXVCYWtTUUtHOEcyRnpVV294MkFVdEFRRmNCS2xWUW9MZ1FSZVpoUWxDSUplc1FYSTVCMENCblVNT3hNQ2Vub0NmVENFV0JzSkNvbFRNQU5sZHgxNUJHczhCNXdsQ1o5UG82T0prd21ScG5xa3FudVNyYXlxZkttcXBMYWpvaVc1SEpxN0ZMMUdyMm1NTWNLVU1JaUpnSWVteTd4WnRKc1Rtc000eEhpS3Y1S01DWHFmeVVDSkVvblhQTjJyQU9JQW1zZkIzdVBvQUsrK0crdzQ4ZWRaUEsrTTZoTEpwUWc0ODRlblhJZFFGU1MxdTZVaGtzRU5FUUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQk9jUXlFbXBHS0xxeldjWlJWVVFuWllnMWFCU2gyR1VWRUlRMmFRT0UrRytjRDRudHBXa1pRajFKSWlaSW9nREZGeUhJMFV4UXdGdWdNU09GSVBKZnRmVkFFb1pMQmJjTEVGaGxRaXFHcDFWZDE0MEFVa2xVTjNlQ0E1MUMxRVdNek1DZXpDQkJta3hWSVZIQldkM0hIbDlKUU9JSlNkU25KMFRES0NoQ3dVSmpvV01QYUdxREthbm5hc01vNlduTTU2MlI1WWx1WlJ3dXIwd3BncVpFN05LVW0rRk5SUEloakJKeEtadGVXdUlCTU40elJNSVZJaGZmY2dvandDRjExN2k0bmxMblk1enRSTHNuT2srYVYrb0pZN1Y3bTc2UGRrUzR0cktjZGcwWmMwdFRjS2tSQUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQk80UXlFa3BLcWpxelNjcFJhVmtYWldRRXhpbXcxQlNDVUVJbERvaHJmdDZjcEtDazV4aWQ1TU5KVGFBSWtla0tHUWtXeUtIa3ZoS3NSN0FSbWl0a0FZRFlSSWJVUVJRaldCd0pSekNoaTlDUmxCY1kxVU40ZzAvVk5CMEFsY3ZjQVlIUnlaUGRFUUZZVjhjY3dSNUhXeEVKMDJZbVJNTG5KMXhDWXAwWTVpZHBRdWhvcG1tQzJLZ29qS2FzVVFEazVCTkF3d01PaDJSdFJxNXVRdVBaS0dJSlFJR3dBd0dmNkkwSlhNcEM4QzdrWFdEQklORk14UzRES01BV1ZXQUdZc0FkTnFXNXVhUnhrU0tKT1pLYVUzdFBPQlo0RHVLMkxBVGdKaGtQSk1nVHdLQ2RGanlQSEVuS3hGQ0RoRUFBQ0g1QkFrS0FBQUFMQUFBQUFBZ0FDQUFBQVR6RU1oSmFWS3A2czJuSWtvbElKMldrQlNocGtWUldxcVFyaExTRXU5TVpKS0s5eTFacnFZSzlXaUNsbXZvVWFGOGdJUVNOZUYxRXI0TU5GbjRTUlNEQVJXcm9BSUVUZzFpVnd1SGpZQjFrWWMxbXdydXdYS0M5Z21zSlhsaUd4YytYaVVDYnk5eWRoMXNPU2RNa3BNVEJwYVhCenNmaG9jNWw1OEdtNXlUb0FhWmhhT1VxamtEZ0NXTkhBVUxDd09MYVRtenN3YWRFcWdnUXdnSHVRc0hJb1pDSFFNTVFnUUd1YlZFY3hPUEZBY01EQVlVQTg1ZVdBUm1mU1JRQ2RjTWUwemVQMUFBeWd3TGxKdFBOQUFMMTlEQVJkUHpCT1dTbTFickpCaTQ1c29SQVdRQUFrclFJeWtTaFE5d1ZoSEN3Q1FDQUNINUJBa0tBQUFBTEFBQUFBQWdBQ0FBQUFUckVNaEphVktwNnMybklrcUZaRjJWSUJXaFVzSmFUb2txVUNvQnErRTcxU1JRZXlxVVRvTEE3VnhGMEpEeUlRaC9NVlZQTXQxRUNabGZjalpKOW1JS29hVGwxTVJJbDVvNENVS1hPd215ckNJbkNLcWNXdHZhZEwyU1loeUFTeU5ESjB1SWlSTURqSTBGZDMwL2lJMlVBNUdTUzVVRGoybDZOb3FnT2dONGdrc0VCZ1lGZjBGRHFLZ0hueVo5T1g4SHJnWUhkSHBjSFFVTFhBUzJxS3BFTlJnN2VBTUxDN2tUQmFpeFVZRmtLQXpXQUFuTEM3RkxWeExXREJMS0N3YUtUVUxnRXdiTEE0aEp0T2tTQk5xSVRUM3hFZ2ZMcEJ0ekUvaml1TDA0UkdFQmd3V2hTaFJnUUV4SEJBQWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU3eERJU1dsU3Flck5weUpLaFdSZGxTQVZvVkxDV2s2SktsQXFBYXZoTzlVa1VIc3FsRTZDd08xY1JkQ1E4aUVJZnpGVlR6TGRSQW1aWDNJMlNmWmlDcUdrNWRURVNKZWFPQWxDbHpzSnNxd2lKd2lxbkZyYjJuUzlrbUljZ0VzalF5ZExpSWxIZWhocGVqYUlqemg5ZW9tU2paUitpcHNsV0lSTEFnTURPUjJET3FLb2dUQjlwQ1VKQmFnREJYUjZYQjBFQmtJSXNhUnNHR01NQXhvREJnWUhUS0ppVVlFR0RBekhDOUVBQ2NVR2tJZ0Z6Z3daMFFzU0JjWEhpUXZPd2dEZEV3ZkZzMHNEenQ0UzZCSzR4WWprRE96bjB1bkZlQnpPQmlqSW0xRGdtZzVZRlF3c0NNanAxb0o4THlJQUFDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHdFTWhKYVZLcDZzMm5Ja3FGWkYyVklCV2hVc0phVG9rcVVDb0JxK0U3MVNSUWV5cVVUb0xBN1Z4RjBKRHlJUWgvTVZWUE10MUVDWmxmY2paSjltSUtvYVRsMU1SSWw1bzRDVUtYT3dteXJDSW5DS3FjV3R2YWRMMlNZaHlBU3lOREowdUlpVWQ2R0dsNk5vaVBPSDE2aVpLTmxINktteVdGT2dnSGhFRXZBd3dNQTBOOUdCc0VDNmFtaG5WY0V3YXZEQWF6R3dJRGFIMWlwYVlMQlVUQ0dnUURBOE5kSHowRnBxZ1RCd3NMcUFiV0FBbklBNEZXS2RNTEdkWUdFZ3JhaWdiVDBPSVRCY2c1UXdQVDR4THJST1pMNkF1UUFQVVM3YnhMcG9XaWRZMEp0eExIS2h3d01KQlRIZ1BLZEVRQUFDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHJFTWhKYVZLcDZzMm5Ja3FGWkYyVklCV2hVc0phVG9rcVVDb0JxK0U3MVNSUWV5cVVUb0xBN1Z4RjBKRHlJUWgvTVZWUE10MUVDWmxmY2paSjltSUtvYVRsMU1SSWw1bzRDVUtYT3dteXJDSW5DS3FjV3R2YWRMMlNZaHlBU3lOREowdUlpVWQ2R0FVTERKQ1JpWG8xQ3BHWERKT1VqWStZaXA5RGhUb0pBNFJCTHdNTEN3VkRmUmdiQkFhcXFvWjFYQk1Ic3dzSHR4dEZhSDFpcWFvR05nQUl4UnBiRkFnZlBRU3FwYmdHQnFVRDF3QlhlQ1lwMUFZWjE5SkpPWWdIMUt3QTRVQnZRd1hVQnhQcVZEOUwzc2JwMkJOazJ4dnZGUEpkK01GQ042SEFBSUtnTmdnWTBLdEVCQUFoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNkJESVNXbFNxZXJOcHlKS2hXUmRsU0FWb1ZMQ1drNkpLbEFxQWF2aE85VWtVSHNxbEU2Q3dPMWNSZENROGlFSWZ6RlZUekxkUkFtWlgzSTJTZllJRE1hQUZkVEVTSmVhRURBSU14WUZxck9VYU5XNEU0T2JZY0NYYWlCVkVnVUxlME5KYXh4dFlrc2poMk5Ma1pJU2dEZ0poSHRoa3BVNG1XNmJsUmlZbVpPbGg0SldrRHFJTHdVR0JuRTZUWUViQ2dldnIwTjFnSDRBdDdnSGlScEZhTE5ycnE4SE5nQUpBNzBBV3hRSUgxK3ZzWU1EQXpaUVBDOVZDTmtEV1VoR2t1RTVQeEpOd2lVSzRVZkx6T2xENFd2ekFIYW9HOW54UGk1ZCtqWVVxZkFoaHlrT0Z3SldpQUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQlBBUXlFbHBVcW5xemFjaVNvVmtYVlVNRmFGU3dscE9DY01ZbEVyQWF2aE9Nbk5MTm84S3Nac01aSXRKRUlESUZTa0xHUW9RVE5oSXNGZWhSd3cyQ1FMS0YwdFlHS1lTZyt5Z3NaSXVOcUprc0tnYmZnSUdlcE5vMmNJVUIzVjFCM0l2TmlCWU5RYURTVHRmaGh4MEN3VlBJMFVKZTArYm00ZzVWZ2NHb3FPY25qbWpxRFNkbmhnRW9hbWNzWnVYTzFhV1F5OEtBd09BdVRZWUd3aTd3NWgrS3IwU0o4TUZpaHBOYngrNEVycTdCWUJ1enNkaUgxakNBem9TZmwwclZpck5iUlhsQkJsTFgrQlAwWEpMQVBHelRrQXVBT3FiMFdUNUFIN09jZENtNUI4VGdSd1NSS0lIUXRhTEN3ZzFSQUFBT3dBQUFBQUFBQUFBQUE9PVwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoSUFBZ0FQTUFBUC8vL3dBQUFNYkd4b1NFaExhMnRwcWFtalkyTmxaV1Z0alkyT1RrNUx5OHZCNGVIZ1FFQkFBQUFBQUFBQUFBQUNIL0MwNUZWRk5EUVZCRk1pNHdBd0VBQUFBaC9ocERjbVZoZEdWa0lIZHBkR2dnWVdwaGVHeHZZV1F1YVc1bWJ3QWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU1eERJU1dsaHBlck41MkpMaFNTZFJnd1ZvMUlDUVpSVXNpd0hwVEpUNGlvd05TOHZ5VzJpY0NGNms4SE1NQmtDRURza3hUQkRBWnd1QWtrcUlmeElReWhCUUJGdkFRU0RJVE01VkRXNlhORTRLYWdOaDZCZ3dlNjBzbVFVQjNkNFJ6MVpCQXBuRkFTRGQwaGloaDEyQmtFOWtqQUpWbHljWElnN0NRSUZBNlNsbko4N3BhcWJTS2lLb3F1c25iTWRtREMydFhRbGtVaHppWXR5V1R4SWZ5NkJFOFdKdDVZSnZwSml2eE5hR21MSFQwVm5PZ1NZZjBkWlhTN0FQZHBCMzA5Um5IT0c1Z0RxWEdMRGFDNDU3RDF6Wi9WL25tT004MlhpSFJMWUtoS1Axb1ptQURkRUFBQWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU2aERJU1dsWnBPck5wMWxHTlJTZFJwRFVvbElHdzVSVVloaEh1a3FGdThEc3JFeXFuV1RoR3ZBbWhWbHRlQnZvanBURERCVUVJRndNRkJSQW1Ca1NnT3JCRlpvZ0NBU3dCREVZL0NaU2c3R1NFMGdTQ2pRQk1WRzAyM3hXQmhrbEFub0VkaFFFZnlOcU1JY0tqaFJzakVkbmV6QitBNGs4Z1R3SmhGdWlXNGRva1hpbG9VZXBCQXA1cWFLcHA2K0hvN2FXVzU0d2w3b2J2RWUwa1J1b3BsQ0dlcHdTeDJqSnZxSEVtR3Q2d2hKcEdwZkpDSG1Pb05IS2FIeDYxV2lTUjkyRTRsYkZvcStCNlFEdHVldGNhQlBuVzYrTzd3REhwSWlLOVNhVks1R2dWNTQzdHpqZ0djZ2hBZ0FoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFN2hESVNTa3hwT3JONXpGSE5XUmRoU2lWb1ZMSHNwUlVNb3lVYWt5RWU4UFRQQ0FUVzlBMTRFMFV2dUFLTU5BWktZVVpDaUJNdUJha1NRS0c4RzJGelVXb3gyQVV0QVFGY0JLbFZRb0xnUVJlWmhRbENJSmVzUVhJNUIwQ0JuVU1PeE1DZW5vQ2ZUQ0VXQnNKQ29sVE1BTmxkeDE1QkdzOEI1d2xDWjlQbzZPSmt3bVJwbnFrcW51U3JheXFmS21xcExham9pVzVISnE3RkwxR3IybU1NY0tVTUlpSmdJZW15N3hadEpzVG1zTTR4SGlLdjVLTUNYcWZ5VUNKRW9uWFBOMnJBT0lBbXNmQjN1UG9BSysrRyt3NDhlZFpQSytNNmhMSnBRZzQ4NGVuWElkUUZTUzF1NlVoa3NFTkVRQUFJZmtFQ1FvQUFBQXNBQUFBQUNBQUlBQUFCT2NReUVtcEdLTHF6V2NaUlZVUW5aWWcxYUJTaDJHVVZFSVEyYVFPRStHK2NENG50cFdrWlFqMUpJaVpJb2dERkZ5SEkwVXhRd0Z1Z01TT0ZJUEpmdGZWQUVvWkxCYmNMRUZobFFpcUdwMVZkMTQwQVVrbFVOM2VDQTUxQzFFV016TUNlekNCQm1reFZJVkhCV2QzSEhsOUpRT0lKU2RTbkowVERLQ2hDd1VKam9XTVBhR3FES2FubmFzTW82V25NNTYyUjVZbHVaUnd1cjB3cGdxWkU3TktVbStGTlJQSWhqQkp4S1p0ZVd1SUJNTjR6Uk1JVkloZmZjZ29qd0NGMTE3aTRubExuWTV6dFJMc25PaythVitvSlk3VjdtNzZQZGtTNHRyS2NkZzBaYzB0VGNLa1JBQUFJZmtFQ1FvQUFBQXNBQUFBQUNBQUlBQUFCTzRReUVrcEtxanF6U2NwUmFWa1haV1FFeGltdzFCU0NVRUlsRG9ocmZ0NmNwS0NrNXhpZDVNTkpUYUFJa2VrS0dRa1d5S0hrdmhLc1I3QVJtaXRrQVlEWVJJYlVRUlFqV0J3SlJ6Q2hpOUNSbEJjWTFVTjRnMC9WTkIwQWxjdmNBWUhSeVpQZEVRRllWOGNjd1I1SFd4RUowMlltUk1MbkoxeENZcDBZNWlkcFF1aG9wbW1DMktnb2pLYXNVUURrNUJOQXd3TU9oMlJ0UnE1dVF1UFpLR0lKUUlHd0F3R2Y2STBKWE1wQzhDN2tYV0RCSU5GTXhTNERLTUFXVldBR1lzQWROcVc1dWFSeGtTS0pPWkthVTN0UE9CWjREdUsyTEFUZ0poa1BKTWdUd0tDZEZqeVBIRW5LeEZDRGhFQUFDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHpFTWhKYVZLcDZzMm5Ja29sSUoyV2tCU2hwa1ZSV3FxUXJoTFNFdTlNWkpLSzl5MVpycVlLOVdpQ2xtdm9VYUY4Z0lRU05lRjFFcjRNTkZuNFNSU0RBUldyb0FJRVRnMWlWd3VIallCMWtZYzFtd3J1d1hLQzlnbXNKWGxpR3hjK1hpVUNieTl5ZGgxc09TZE1rcE1UQnBhWEJ6c2Zob2M1bDU4R201eVRvQWFaaGFPVXFqa0RnQ1dOSEFVTEN3T0xhVG16c3dhZEVxZ2dRd2dIdVFzSElvWkNIUU1NUWdRR3ViVkVjeE9QRkFjTURBWVVBODVlV0FSbWZTUlFDZGNNZTB6ZVAxQUF5Z3dMbEp0UE5BQUwxOURBUmRQekJPV1NtMWJySkJpNDVzb1JBV1FBQWtyUUl5a1NoUTl3VmhIQ3dDUUNBQ0g1QkFrS0FBQUFMQUFBQUFBZ0FDQUFBQVRyRU1oSmFWS3A2czJuSWtxRlpGMlZJQldoVXNKYVRva3FVQ29CcStFNzFTUlFleXFVVG9MQTdWeEYwSkR5SVFoL01WVlBNdDFFQ1psZmNqWko5bUlLb2FUbDFNUklsNW80Q1VLWE93bXlyQ0luQ0txY1d0dmFkTDJTWWh5QVN5TkRKMHVJaVJNRGpJMEZkMzAvaUkyVUE1R1NTNVVEajJsNk5vcWdPZ040Z2tzRUJnWUZmMEZEcUtnSG55WjlPWDhIcmdZSGRIcGNIUVVMWEFTMnFLcEVOUmc3ZUFNTEM3a1RCYWl4VVlGa0tBeldBQW5MQzdGTFZ4TFdEQkxLQ3dhS1RVTGdFd2JMQTRoSnRPa1NCTnFJVFQzeEVnZkxwQnR6RS9qaXVMMDRSR0VCZ3dXaFNoUmdRRXhIQkFBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTd4RElTV2xTcWVyTnB5SktoV1JkbFNBVm9WTENXazZKS2xBcUFhdmhPOVVrVUhzcWxFNkN3TzFjUmRDUThpRUlmekZWVHpMZFJBbVpYM0kyU2ZaaUNxR2s1ZFRFU0plYU9BbENsenNKc3F3aUp3aXFuRnJiMm5TOWttSWNnRXNqUXlkTGlJbEhlaGhwZWphSWp6aDllb21TalpSK2lwc2xXSVJMQWdNRE9SMkRPcUtvZ1RCOXBDVUpCYWdEQlhSNlhCMEVCa0lJc2FSc0dHTU1BeG9EQmdZSFRLSmlVWUVHREF6SEM5RUFDY1VHa0lnRnpnd1owUXNTQmNYSGlRdk93Z0RkRXdmRnMwc0R6dDRTNkJLNHhZamtET3puMHVuRmVCek9CaWpJbTFEZ21nNVlGUXdzQ01qcDFvSjhMeUlBQUNINUJBa0tBQUFBTEFBQUFBQWdBQ0FBQUFUd0VNaEphVktwNnMybklrcUZaRjJWSUJXaFVzSmFUb2txVUNvQnErRTcxU1JRZXlxVVRvTEE3VnhGMEpEeUlRaC9NVlZQTXQxRUNabGZjalpKOW1JS29hVGwxTVJJbDVvNENVS1hPd215ckNJbkNLcWNXdHZhZEwyU1loeUFTeU5ESjB1SWlVZDZHR2w2Tm9pUE9IMTZpWktObEg2S215V0ZPZ2dIaEVFdkF3d01BME45R0JzRUM2YW1oblZjRXdhdkRBYXpHd0lEYUgxaXBhWUxCVVRDR2dRREE4TmRIejBGcHFnVEJ3c0xxQWJXQUFuSUE0RldLZE1MR2RZR0VncmFpZ2JUME9JVEJjZzVRd1BUNHhMclJPWkw2QXVRQVBVUzdieExwb1dpZFkwSnR4TEhLaHd3TUpCVEhnUEtkRVFBQUNINUJBa0tBQUFBTEFBQUFBQWdBQ0FBQUFUckVNaEphVktwNnMybklrcUZaRjJWSUJXaFVzSmFUb2txVUNvQnErRTcxU1JRZXlxVVRvTEE3VnhGMEpEeUlRaC9NVlZQTXQxRUNabGZjalpKOW1JS29hVGwxTVJJbDVvNENVS1hPd215ckNJbkNLcWNXdHZhZEwyU1loeUFTeU5ESjB1SWlVZDZHQVVMREpDUmlYbzFDcEdYREpPVWpZK1lpcDlEaFRvSkE0UkJMd01MQ3dWRGZSZ2JCQWFxcW9aMVhCTUhzd3NIdHh0RmFIMWlxYW9HTmdBSXhScGJGQWdmUFFTcXBiZ0dCcVVEMXdCWGVDWXAxQVlaMTlKSk9ZZ0gxS3dBNFVCdlF3WFVCeFBxVkQ5TDNzYnAyQk5rMnh2dkZQSmQrTUZDTjZIQUFJS2dOZ2dZMEt0RUJBQWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU2QkRJU1dsU3Flck5weUpLaFdSZGxTQVZvVkxDV2s2SktsQXFBYXZoTzlVa1VIc3FsRTZDd08xY1JkQ1E4aUVJZnpGVlR6TGRSQW1aWDNJMlNmWUlETWFBRmRURVNKZWFFREFJTXhZRnFyT1VhTlc0RTRPYlljQ1hhaUJWRWdVTGUwTkpheHh0WWtzamgyTkxrWklTZ0RnSmhIdGhrcFU0bVc2YmxSaVltWk9saDRKV2tEcUlMd1VHQm5FNlRZRWJDZ2V2cjBOMWdINEF0N2dIaVJwRmFMTnJycThITmdBSkE3MEFXeFFJSDErdnNZTURBelpRUEM5VkNOa0RXVWhHa3VFNVB4Sk53aVVLNFVmTHpPbEQ0V3Z6QUhhb0c5bnhQaTVkK2pZVXFmQWhoeWtPRndKV2lBQUFJZmtFQ1FvQUFBQXNBQUFBQUNBQUlBQUFCUEFReUVscFVxbnF6YWNpU29Wa1hWVU1GYUZTd2xwT0NjTVlsRXJBYXZoT01uTkxObzhLc1pzTVpJdEpFSURJRlNrTEdRb1FUTmhJc0ZlaFJ3dzJDUUxLRjB0WUdLWVNnK3lnc1pJdU5xSmtzS2diZmdJR2VwTm8yY0lVQjNWMUIzSXZOaUJZTlFhRFNUdGZoaHgwQ3dWUEkwVUplMCtibTRnNVZnY0dvcU9jbmptanFEU2RuaGdFb2FtY3NadVhPMWFXUXk4S0F3T0F1VFlZR3dpN3c1aCtLcjBTSjhNRmlocE5ieCs0RXJxN0JZQnV6c2RpSDFqQ0F6b1NmbDByVmlyTmJSWGxCQmxMWCtCUDBYSkxBUEd6VGtBdUFPcWIwV1Q1QUg3T2NkQ201QjhUZ1J3U1JLSUhRdGFMQ3dnMVJBQUFPd0FBQUFBQUFBQUFBQT09ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIm1vZHVsZS5leHBvcnRzID0gXFxcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaElBQWdBUE1BQVAvLy93QUFBTWJHeG9TRWhMYTJ0cHFhbWpZMk5sWldWdGpZMk9UazVMeTh2QjRlSGdRRUJBQUFBQUFBQUFBQUFDSC9DMDVGVkZORFFWQkZNaTR3QXdFQUFBQWgvaHBEY21WaGRHVmtJSGRwZEdnZ1lXcGhlR3h2WVdRdWFXNW1id0FoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNXhESVNXbGhwZXJONTJKTGhTU2RSZ3dWbzFJQ1FaUlVzaXdIcFRKVDRpb3dOUzh2eVcyaWNDRjZrOEhNTUJrQ0VEc2t4VEJEQVp3dUFra3FJZnhJUXloQlFCRnZBUVNESVRNNVZEVzZYTkU0S2FnTmg2Qmd3ZTYwc21RVUIzZDRSejFaQkFwbkZBU0RkMGhpaGgxMkJrRTlrakFKVmx5Y1hJZzdDUUlGQTZTbG5KODdwYXFiU0tpS29xdXNuYk1kbURDMnRYUWxrVWh6aVl0eVdUeElmeTZCRThXSnQ1WUp2cEppdnhOYUdtTEhUMFZuT2dTWWYwZFpYUzdBUGRwQjMwOVJuSE9HNWdEcVhHTERhQzQ1N0QxelovVi9ubU9NODJYaUhSTFlLaEtQMW9abUFEZEVBQUFoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNmhESVNXbFpwT3JOcDFsR05SU2RScERVb2xJR3c1UlVZaGhIdWtxRnU4RHNyRXlxbldUaEd2QW1oVmx0ZUJ2b2pwVEREQlVFSUZ3TUZCUkFtQmtTZ09yQkZab2dDQVN3QkRFWS9DWlNnN0dTRTBnU0NqUUJNVkcwMjN4V0Joa2xBbm9FZGhRRWZ5TnFNSWNLamhSc2pFZG5lekIrQTRrOGdUd0poRnVpVzRkb2tYaWxvVWVwQkFwNXFhS3BwNitIbzdhV1c1NHdsN29idkVlMGtSdW9wbENHZXB3U3gyakp2cUhFbUd0NndoSnBHcGZKQ0htT29OSEthSHg2MVdpU1I5MkU0bGJGb3ErQjZRRHR1ZXRjYUJQblc2K083d0RIcElpSzlTYVZLNUdnVjU0M3R6amdHY2doQWdBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTdoRElTU2t4cE9yTjV6RkhOV1JkaFNpVm9WTEhzcFJVTW95VWFreUVlOFBUUENBVFc5QTE0RTBVdnVBS01OQVpLWVVaQ2lCTXVCYWtTUUtHOEcyRnpVV294MkFVdEFRRmNCS2xWUW9MZ1FSZVpoUWxDSUplc1FYSTVCMENCblVNT3hNQ2Vub0NmVENFV0JzSkNvbFRNQU5sZHgxNUJHczhCNXdsQ1o5UG82T0prd21ScG5xa3FudVNyYXlxZkttcXBMYWpvaVc1SEpxN0ZMMUdyMm1NTWNLVU1JaUpnSWVteTd4WnRKc1Rtc000eEhpS3Y1S01DWHFmeVVDSkVvblhQTjJyQU9JQW1zZkIzdVBvQUsrK0crdzQ4ZWRaUEsrTTZoTEpwUWc0ODRlblhJZFFGU1MxdTZVaGtzRU5FUUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQk9jUXlFbXBHS0xxeldjWlJWVVFuWllnMWFCU2gyR1VWRUlRMmFRT0UrRytjRDRudHBXa1pRajFKSWlaSW9nREZGeUhJMFV4UXdGdWdNU09GSVBKZnRmVkFFb1pMQmJjTEVGaGxRaXFHcDFWZDE0MEFVa2xVTjNlQ0E1MUMxRVdNek1DZXpDQkJta3hWSVZIQldkM0hIbDlKUU9JSlNkU25KMFRES0NoQ3dVSmpvV01QYUdxREthbm5hc01vNlduTTU2MlI1WWx1WlJ3dXIwd3BncVpFN05LVW0rRk5SUEloakJKeEtadGVXdUlCTU40elJNSVZJaGZmY2dvandDRjExN2k0bmxMblk1enRSTHNuT2srYVYrb0pZN1Y3bTc2UGRrUzR0cktjZGcwWmMwdFRjS2tSQUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQk80UXlFa3BLcWpxelNjcFJhVmtYWldRRXhpbXcxQlNDVUVJbERvaHJmdDZjcEtDazV4aWQ1TU5KVGFBSWtla0tHUWtXeUtIa3ZoS3NSN0FSbWl0a0FZRFlSSWJVUVJRaldCd0pSekNoaTlDUmxCY1kxVU40ZzAvVk5CMEFsY3ZjQVlIUnlaUGRFUUZZVjhjY3dSNUhXeEVKMDJZbVJNTG5KMXhDWXAwWTVpZHBRdWhvcG1tQzJLZ29qS2FzVVFEazVCTkF3d01PaDJSdFJxNXVRdVBaS0dJSlFJR3dBd0dmNkkwSlhNcEM4QzdrWFdEQklORk14UzRES01BV1ZXQUdZc0FkTnFXNXVhUnhrU0tKT1pLYVUzdFBPQlo0RHVLMkxBVGdKaGtQSk1nVHdLQ2RGanlQSEVuS3hGQ0RoRUFBQ0g1QkFrS0FBQUFMQUFBQUFBZ0FDQUFBQVR6RU1oSmFWS3A2czJuSWtvbElKMldrQlNocGtWUldxcVFyaExTRXU5TVpKS0s5eTFacnFZSzlXaUNsbXZvVWFGOGdJUVNOZUYxRXI0TU5GbjRTUlNEQVJXcm9BSUVUZzFpVnd1SGpZQjFrWWMxbXdydXdYS0M5Z21zSlhsaUd4YytYaVVDYnk5eWRoMXNPU2RNa3BNVEJwYVhCenNmaG9jNWw1OEdtNXlUb0FhWmhhT1VxamtEZ0NXTkhBVUxDd09MYVRtenN3YWRFcWdnUXdnSHVRc0hJb1pDSFFNTVFnUUd1YlZFY3hPUEZBY01EQVlVQTg1ZVdBUm1mU1JRQ2RjTWUwemVQMUFBeWd3TGxKdFBOQUFMMTlEQVJkUHpCT1dTbTFickpCaTQ1c29SQVdRQUFrclFJeWtTaFE5d1ZoSEN3Q1FDQUNINUJBa0tBQUFBTEFBQUFBQWdBQ0FBQUFUckVNaEphVktwNnMybklrcUZaRjJWSUJXaFVzSmFUb2txVUNvQnErRTcxU1JRZXlxVVRvTEE3VnhGMEpEeUlRaC9NVlZQTXQxRUNabGZjalpKOW1JS29hVGwxTVJJbDVvNENVS1hPd215ckNJbkNLcWNXdHZhZEwyU1loeUFTeU5ESjB1SWlSTURqSTBGZDMwL2lJMlVBNUdTUzVVRGoybDZOb3FnT2dONGdrc0VCZ1lGZjBGRHFLZ0hueVo5T1g4SHJnWUhkSHBjSFFVTFhBUzJxS3BFTlJnN2VBTUxDN2tUQmFpeFVZRmtLQXpXQUFuTEM3RkxWeExXREJMS0N3YUtUVUxnRXdiTEE0aEp0T2tTQk5xSVRUM3hFZ2ZMcEJ0ekUvaml1TDA0UkdFQmd3V2hTaFJnUUV4SEJBQWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU3eERJU1dsU3Flck5weUpLaFdSZGxTQVZvVkxDV2s2SktsQXFBYXZoTzlVa1VIc3FsRTZDd08xY1JkQ1E4aUVJZnpGVlR6TGRSQW1aWDNJMlNmWmlDcUdrNWRURVNKZWFPQWxDbHpzSnNxd2lKd2lxbkZyYjJuUzlrbUljZ0VzalF5ZExpSWxIZWhocGVqYUlqemg5ZW9tU2paUitpcHNsV0lSTEFnTURPUjJET3FLb2dUQjlwQ1VKQmFnREJYUjZYQjBFQmtJSXNhUnNHR01NQXhvREJnWUhUS0ppVVlFR0RBekhDOUVBQ2NVR2tJZ0Z6Z3daMFFzU0JjWEhpUXZPd2dEZEV3ZkZzMHNEenQ0UzZCSzR4WWprRE96bjB1bkZlQnpPQmlqSW0xRGdtZzVZRlF3c0NNanAxb0o4THlJQUFDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHdFTWhKYVZLcDZzMm5Ja3FGWkYyVklCV2hVc0phVG9rcVVDb0JxK0U3MVNSUWV5cVVUb0xBN1Z4RjBKRHlJUWgvTVZWUE10MUVDWmxmY2paSjltSUtvYVRsMU1SSWw1bzRDVUtYT3dteXJDSW5DS3FjV3R2YWRMMlNZaHlBU3lOREowdUlpVWQ2R0dsNk5vaVBPSDE2aVpLTmxINktteVdGT2dnSGhFRXZBd3dNQTBOOUdCc0VDNmFtaG5WY0V3YXZEQWF6R3dJRGFIMWlwYVlMQlVUQ0dnUURBOE5kSHowRnBxZ1RCd3NMcUFiV0FBbklBNEZXS2RNTEdkWUdFZ3JhaWdiVDBPSVRCY2c1UXdQVDR4THJST1pMNkF1UUFQVVM3YnhMcG9XaWRZMEp0eExIS2h3d01KQlRIZ1BLZEVRQUFDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHJFTWhKYVZLcDZzMm5Ja3FGWkYyVklCV2hVc0phVG9rcVVDb0JxK0U3MVNSUWV5cVVUb0xBN1Z4RjBKRHlJUWgvTVZWUE10MUVDWmxmY2paSjltSUtvYVRsMU1SSWw1bzRDVUtYT3dteXJDSW5DS3FjV3R2YWRMMlNZaHlBU3lOREowdUlpVWQ2R0FVTERKQ1JpWG8xQ3BHWERKT1VqWStZaXA5RGhUb0pBNFJCTHdNTEN3VkRmUmdiQkFhcXFvWjFYQk1Ic3dzSHR4dEZhSDFpcWFvR05nQUl4UnBiRkFnZlBRU3FwYmdHQnFVRDF3QlhlQ1lwMUFZWjE5SkpPWWdIMUt3QTRVQnZRd1hVQnhQcVZEOUwzc2JwMkJOazJ4dnZGUEpkK01GQ042SEFBSUtnTmdnWTBLdEVCQUFoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFNkJESVNXbFNxZXJOcHlKS2hXUmRsU0FWb1ZMQ1drNkpLbEFxQWF2aE85VWtVSHNxbEU2Q3dPMWNSZENROGlFSWZ6RlZUekxkUkFtWlgzSTJTZllJRE1hQUZkVEVTSmVhRURBSU14WUZxck9VYU5XNEU0T2JZY0NYYWlCVkVnVUxlME5KYXh4dFlrc2poMk5Ma1pJU2dEZ0poSHRoa3BVNG1XNmJsUmlZbVpPbGg0SldrRHFJTHdVR0JuRTZUWUViQ2dldnIwTjFnSDRBdDdnSGlScEZhTE5ycnE4SE5nQUpBNzBBV3hRSUgxK3ZzWU1EQXpaUVBDOVZDTmtEV1VoR2t1RTVQeEpOd2lVSzRVZkx6T2xENFd2ekFIYW9HOW54UGk1ZCtqWVVxZkFoaHlrT0Z3SldpQUFBSWZrRUNRb0FBQUFzQUFBQUFDQUFJQUFBQlBBUXlFbHBVcW5xemFjaVNvVmtYVlVNRmFGU3dscE9DY01ZbEVyQWF2aE9Nbk5MTm84S3Nac01aSXRKRUlESUZTa0xHUW9RVE5oSXNGZWhSd3cyQ1FMS0YwdFlHS1lTZyt5Z3NaSXVOcUprc0tnYmZnSUdlcE5vMmNJVUIzVjFCM0l2TmlCWU5RYURTVHRmaGh4MEN3VlBJMFVKZTArYm00ZzVWZ2NHb3FPY25qbWpxRFNkbmhnRW9hbWNzWnVYTzFhV1F5OEtBd09BdVRZWUd3aTd3NWgrS3IwU0o4TUZpaHBOYngrNEVycTdCWUJ1enNkaUgxakNBem9TZmwwclZpck5iUlhsQkJsTFgrQlAwWEpMQVBHelRrQXVBT3FiMFdUNUFIN09jZENtNUI4VGdSd1NSS0lIUXRhTEN3ZzFSQUFBT3dBQUFBQUFBQUFBQUE9PVxcXCI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQHJlYWN0LWp2ZWN0b3JtYXAvY29yZS9kYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhJQUFnQVBNQUFQLy8vd0FBQU1iR3hvU0VoTGEydHBxYW1qWTJObFpXVnRqWTJPVGs1THk4dkI0ZUhnUUVCQUFBQUFBQUFBQUFBQ0gvQzA1RlZGTkRRVkJGTWk0d0F3RUFBQUFoL2hwRGNtVmhkR1ZrSUhkcGRHZ2dZV3BoZUd4dllXUXVhVzVtYndBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTV4RElTV2xocGVyTjUySkxoU1NkUmd3Vm8xSUNRWlJVc2l3SHBUSlQ0aW93TlM4dnlXMmljQ0Y2azhITU1Ca0NFRHNreFRCREFad3VBa2txSWZ4SVF5aEJRQkZ2QVFTRElUTTVWRFc2WE5FNEthZ05oNkJnd2U2MHNtUVVCM2Q0UnoxWkJBcG5GQVNEZDBoaWhoMTJCa0U5a2pBSlZseWNYSWc3Q1FJRkE2U2xuSjg3cGFxYlNLaUtvcXVzbmJNZG1EQzJ0WFFsa1VoemlZdHlXVHhJZnk2QkU4V0p0NVlKdnBKaXZ4TmFHbUxIVDBWbk9nU1lmMGRaWFM3QVBkcEIzMDlSbkhPRzVnRHFYR0xEYUM0NTdEMXpaL1Yvbm1PTTgyWGlIUkxZS2hLUDFvWm1BRGRFQUFBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTZoRElTV2xacE9yTnAxbEdOUlNkUnBEVW9sSUd3NVJVWWhoSHVrcUZ1OERzckV5cW5XVGhHdkFtaFZsdGVCdm9qcFREREJVRUlGd01GQlJBbUJrU2dPckJGWm9nQ0FTd0JERVkvQ1pTZzdHU0UwZ1NDalFCTVZHMDIzeFdCaGtsQW5vRWRoUUVmeU5xTUljS2poUnNqRWRuZXpCK0E0azhnVHdKaEZ1aVc0ZG9rWGlsb1VlcEJBcDVxYUtwcDYrSG83YVdXNTR3bDdvYnZFZTBrUnVvcGxDR2Vwd1N4MmpKdnFIRW1HdDZ3aEpwR3BmSkNIbU9vTkhLYUh4NjFXaVNSOTJFNGxiRm9xK0I2UUR0dWV0Y2FCUG5XNitPN3dESHBJaUs5U2FWSzVHZ1Y1NDN0empnR2NnaEFnQWgrUVFKQ2dBQUFDd0FBQUFBSUFBZ0FBQUU3aERJU1NreHBPck41ekZITldSZGhTaVZvVkxIc3BSVU1veVVha3lFZThQVFBDQVRXOUExNEUwVXZ1QUtNTkFaS1lVWkNpQk11QmFrU1FLRzhHMkZ6VVdveDJBVXRBUUZjQktsVlFvTGdRUmVaaFFsQ0lKZXNRWEk1QjBDQm5VTU94TUNlbm9DZlRDRVdCc0pDb2xUTUFObGR4MTVCR3M4QjV3bENaOVBvNk9Ka3dtUnBucWtxbnVTcmF5cWZLbXFwTGFqb2lXNUhKcTdGTDFHcjJtTU1jS1VNSWlKZ0llbXk3eFp0SnNUbXNNNHhIaUt2NUtNQ1hxZnlVQ0pFb25YUE4yckFPSUFtc2ZCM3VQb0FLKytHK3c0OGVkWlBLK002aExKcFFnNDg0ZW5YSWRRRlNTMXU2VWhrc0VORVFBQUlma0VDUW9BQUFBc0FBQUFBQ0FBSUFBQUJPY1F5RW1wR0tMcXpXY1pSVlVRblpZZzFhQlNoMkdVVkVJUTJhUU9FK0crY0Q0bnRwV2taUWoxSklpWklvZ0RGRnlISTBVeFF3RnVnTVNPRklQSmZ0ZlZBRW9aTEJiY0xFRmhsUWlxR3AxVmQxNDBBVWtsVU4zZUNBNTFDMUVXTXpNQ2V6Q0JCbWt4VklWSEJXZDNISGw5SlFPSUpTZFNuSjBUREtDaEN3VUpqb1dNUGFHcURLYW5uYXNNbzZXbk01NjJSNVlsdVpSd3VyMHdwZ3FaRTdOS1VtK0ZOUlBJaGpCSnhLWnRlV3VJQk1ONHpSTUlWSWhmZmNnb2p3Q0YxMTdpNG5sTG5ZNXp0Ukxzbk9rK2FWK29KWTdWN203NlBka1M0dHJLY2RnMFpjMHRUY0trUkFBQUlma0VDUW9BQUFBc0FBQUFBQ0FBSUFBQUJPNFF5RWtwS3FqcXpTY3BSYVZrWFpXUUV4aW13MUJTQ1VFSWxEb2hyZnQ2Y3BLQ2s1eGlkNU1OSlRhQUlrZWtLR1FrV3lLSGt2aEtzUjdBUm1pdGtBWURZUkliVVFSUWpXQndKUnpDaGk5Q1JsQmNZMVVONGcwL1ZOQjBBbGN2Y0FZSFJ5WlBkRVFGWVY4Y2N3UjVIV3hFSjAyWW1STUxuSjF4Q1lwMFk1aWRwUXVob3BtbUMyS2dvakthc1VRRGs1Qk5Bd3dNT2gyUnRScTV1UXVQWktHSUpRSUd3QXdHZjZJMEpYTXBDOEM3a1hXREJJTkZNeFM0REtNQVdWV0FHWXNBZE5xVzV1YVJ4a1NLSk9aS2FVM3RQT0JaNER1SzJMQVRnSmhrUEpNZ1R3S0NkRmp5UEhFbkt4RkNEaEVBQUNINUJBa0tBQUFBTEFBQUFBQWdBQ0FBQUFUekVNaEphVktwNnMybklrb2xJSjJXa0JTaHBrVlJXcXFRcmhMU0V1OU1aSktLOXkxWnJxWUs5V2lDbG12b1VhRjhnSVFTTmVGMUVyNE1ORm40U1JTREFSV3JvQUlFVGcxaVZ3dUhqWUIxa1ljMW13cnV3WEtDOWdtc0pYbGlHeGMrWGlVQ2J5OXlkaDFzT1NkTWtwTVRCcGFYQnpzZmhvYzVsNThHbTV5VG9BYVpoYU9VcWprRGdDV05IQVVMQ3dPTGFUbXpzd2FkRXFnZ1F3Z0h1UXNISW9aQ0hRTU1RZ1FHdWJWRWN4T1BGQWNNREFZVUE4NWVXQVJtZlNSUUNkY01lMHplUDFBQXlnd0xsSnRQTkFBTDE5REFSZFB6Qk9XU20xYnJKQmk0NXNvUkFXUUFBa3JRSXlrU2hROXdWaEhDd0NRQ0FDSDVCQWtLQUFBQUxBQUFBQUFnQUNBQUFBVHJFTWhKYVZLcDZzMm5Ja3FGWkYyVklCV2hVc0phVG9rcVVDb0JxK0U3MVNSUWV5cVVUb0xBN1Z4RjBKRHlJUWgvTVZWUE10MUVDWmxmY2paSjltSUtvYVRsMU1SSWw1bzRDVUtYT3dteXJDSW5DS3FjV3R2YWRMMlNZaHlBU3lOREowdUlpUk1EakkwRmQzMC9pSTJVQTVHU1M1VURqMmw2Tm9xZ09nTjRna3NFQmdZRmYwRkRxS2dIbnlaOU9YOEhyZ1lIZEhwY0hRVUxYQVMycUtwRU5SZzdlQU1MQzdrVEJhaXhVWUZrS0F6V0FBbkxDN0ZMVnhMV0RCTEtDd2FLVFVMZ0V3YkxBNGhKdE9rU0JOcUlUVDN4RWdmTHBCdHpFL2ppdUwwNFJHRUJnd1doU2hSZ1FFeEhCQUFoK1FRSkNnQUFBQ3dBQUFBQUlBQWdBQUFFN3hESVNXbFNxZXJOcHlKS2hXUmRsU0FWb1ZMQ1drNkpLbEFxQWF2aE85VWtVSHNxbEU2Q3dPMWNSZENROGlFSWZ6RlZUekxkUkFtWlgzSTJTZlppQ3FHazVkVEVTSmVhT0FsQ2x6c0pzcXdpSndpcW5GcmIyblM5a21JY2dFc2pReWRMaUlsSGVoaHBlamFJanpoOWVvbVNqWlIraXBzbFdJUkxBZ01ET1IyRE9xS29nVEI5cENVSkJhZ0RCWFI2WEIwRUJrSUlzYVJzR0dNTUF4b0RCZ1lIVEtKaVVZRUdEQXpIQzlFQUNjVUdrSWdGemd3WjBRc1NCY1hIaVF2T3dnRGRFd2ZGczBzRHp0NFM2Qks0eFlqa0RPem4wdW5GZUJ6T0JpakltMURnbWc1WUZRd3NDTWpwMW9KOEx5SUFBQ0g1QkFrS0FBQUFMQUFBQUFBZ0FDQUFBQVR3RU1oSmFWS3A2czJuSWtxRlpGMlZJQldoVXNKYVRva3FVQ29CcStFNzFTUlFleXFVVG9MQTdWeEYwSkR5SVFoL01WVlBNdDFFQ1psZmNqWko5bUlLb2FUbDFNUklsNW80Q1VLWE93bXlyQ0luQ0txY1d0dmFkTDJTWWh5QVN5TkRKMHVJaVVkNkdHbDZOb2lQT0gxNmlaS05sSDZLbXlXRk9nZ0hoRUV2QXd3TUEwTjlHQnNFQzZhbWhuVmNFd2F2REFhekd3SURhSDFpcGFZTEJVVENHZ1FEQThOZEh6MEZwcWdUQndzTHFBYldBQW5JQTRGV0tkTUxHZFlHRWdyYWlnYlQwT0lUQmNnNVF3UFQ0eExyUk9aTDZBdVFBUFVTN2J4THBvV2lkWTBKdHhMSEtod3dNSkJUSGdQS2RFUUFBQ0g1QkFrS0FBQUFMQUFBQUFBZ0FDQUFBQVRyRU1oSmFWS3A2czJuSWtxRlpGMlZJQldoVXNKYVRva3FVQ29CcStFNzFTUlFleXFVVG9MQTdWeEYwSkR5SVFoL01WVlBNdDFFQ1psZmNqWko5bUlLb2FUbDFNUklsNW80Q1VLWE93bXlyQ0luQ0txY1d0dmFkTDJTWWh5QVN5TkRKMHVJaVVkNkdBVUxESkNSaVhvMUNwR1hESk9ValkrWWlwOURoVG9KQTRSQkx3TUxDd1ZEZlJnYkJBYXFxb1oxWEJNSHN3c0h0eHRGYUgxaXFhb0dOZ0FJeFJwYkZBZ2ZQUVNxcGJnR0JxVUQxd0JYZUNZcDFBWVoxOUpKT1lnSDFLd0E0VUJ2UXdYVUJ4UHFWRDlMM3NicDJCTmsyeHZ2RlBKZCtNRkNONkhBQUlLZ05nZ1kwS3RFQkFBaCtRUUpDZ0FBQUN3QUFBQUFJQUFnQUFBRTZCRElTV2xTcWVyTnB5SktoV1JkbFNBVm9WTENXazZKS2xBcUFhdmhPOVVrVUhzcWxFNkN3TzFjUmRDUThpRUlmekZWVHpMZFJBbVpYM0kyU2ZZSURNYUFGZFRFU0plYUVEQUlNeFlGcXJPVWFOVzRFNE9iWWNDWGFpQlZFZ1VMZTBOSmF4eHRZa3NqaDJOTGtaSVNnRGdKaEh0aGtwVTRtVzZibFJpWW1aT2xoNEpXa0RxSUx3VUdCbkU2VFlFYkNnZXZyME4xZ0g0QXQ3Z0hpUnBGYUxOcnJxOEhOZ0FKQTcwQVd4UUlIMSt2c1lNREF6WlFQQzlWQ05rRFdVaEdrdUU1UHhKTndpVUs0VWZMek9sRDRXdnpBSGFvRzlueFBpNWQrallVcWZBaGh5a09Gd0pXaUFBQUlma0VDUW9BQUFBc0FBQUFBQ0FBSUFBQUJQQVF5RWxwVXFucXphY2lTb1ZrWFZVTUZhRlN3bHBPQ2NNWWxFckFhdmhPTW5OTE5vOEtzWnNNWkl0SkVJRElGU2tMR1FvUVROaElzRmVoUnd3MkNRTEtGMHRZR0tZU2creWdzWkl1TnFKa3NLZ2JmZ0lHZXBObzJjSVVCM1YxQjNJdk5pQllOUWFEU1R0ZmhoeDBDd1ZQSTBVSmUwK2JtNGc1VmdjR29xT2Nuam1qcURTZG5oZ0VvYW1jc1p1WE8xYVdReThLQXdPQXVUWVlHd2k3dzVoK0tyMFNKOE1GaWhwTmJ4KzRFcnE3QllCdXpzZGlIMWpDQXpvU2ZsMHJWaXJOYlJYbEJCbExYK0JQMFhKTEFQR3pUa0F1QU9xYjBXVDVBSDdPY2RDbTVCOFRnUndTUktJSFF0YUxDd2cxUkFBQU93QUFBQUFBQUFBQUFBPT0/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJqcXVlcnlcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogZXh0ZXJuYWwgXCJqcXVlcnlcIiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pxdWVyeV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJyZWFjdFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIFwicmVhY3RcIiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG4vKioqKioqLyBcdFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG4vKioqKioqLyBcdFx0XHRcdCgpID0+IChtb2R1bGUpO1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmcgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmIgPSBkb2N1bWVudC5iYXNlVVJJIHx8IHNlbGYubG9jYXRpb24uaHJlZjtcbi8qKioqKiovIFx0XHRcbi8qKioqKiovIFx0XHQvLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLyoqKioqKi8gXHRcdC8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLyoqKioqKi8gXHRcdC8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxuLyoqKioqKi8gXHRcdHZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG4vKioqKioqLyBcdFx0XHRcIm1haW5cIjogMFxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFx0XG4vKioqKioqLyBcdFx0Ly8gbm8gY2h1bmsgb24gZGVtYW5kIGxvYWRpbmdcbi8qKioqKiovIFx0XHRcbi8qKioqKiovIFx0XHQvLyBubyBwcmVmZXRjaGluZ1xuLyoqKioqKi8gXHRcdFxuLyoqKioqKi8gXHRcdC8vIG5vIHByZWxvYWRlZFxuLyoqKioqKi8gXHRcdFxuLyoqKioqKi8gXHRcdC8vIG5vIEhNUlxuLyoqKioqKi8gXHRcdFxuLyoqKioqKi8gXHRcdC8vIG5vIEhNUiBtYW5pZmVzdFxuLyoqKioqKi8gXHRcdFxuLyoqKioqKi8gXHRcdC8vIG5vIG9uIGNodW5rcyBsb2FkZWRcbi8qKioqKiovIFx0XHRcbi8qKioqKiovIFx0XHQvLyBubyBqc29ucCBmdW5jdGlvblxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBjYW4ndCBiZSBpbmxpbmVkIGJlY2F1c2UgdGhlIGV2YWwgZGV2dG9vbCBpcyB1c2VkLlxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsImEiLCJpIiwic2VsZiIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanF1ZXJ5X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JlYWN0X18iLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsImV2YWwiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsInVuZGVmaW5lZCIsImlkIiwibSIsIm4iLCJnZXR0ZXIiLCJfX2VzTW9kdWxlIiwiZCIsImRlZmluaXRpb24iLCJrZXkiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwib2JqIiwicHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwiYiIsImRvY3VtZW50IiwiYmFzZVVSSSIsImxvY2F0aW9uIiwiaHJlZiIsImluc3RhbGxlZENodW5rcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-jvectormap+core@1.0.4_jquery@3.7.1_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/@react-jvectormap/core/dist/index.js\n");

/***/ })

};
;